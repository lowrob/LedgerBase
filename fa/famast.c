/******************************************************************************
		Sourcename    : famast.c
		System        : Budgetary Financial System.
		Subsystem     : Fixed Assets System 
		Module        : Fixed Assets maintenance 
		Created on    : 89-10-9
		Created  By   : K HARISH.
		Cobol sources : 

HISTORY:
 Date           Programmer     Description of modification
____/__/__      __________     ___________________________
1990/11/19       J. Cormier    added OBSOLETE condition 
1990/11/20       J. Cormier    default quantity to one (s_qty) 
1990/11/20       J. Cormier    default value (s_value) to quantity * cost/item
1990/12/18	J. Prescott    Added D_Roundoff to take care of 
			       precision problem.
1990/12/21	F.Tao 	       Change to prohabit enter 0 for item id.
1991/01/01	F.Tao 	       Add codes to protect users from file locked
			       system message.
******************************************************************************/
#include <stdio.h>

#define MAIN
#define MAINFL	FAMAST

#include <bfs_defs.h>
#include <bfs_recs.h>
#include <cfomstrc.h>
#include <bfs_fa.h>

#define SYSTEM		"FIXED ASSETS"
#define MOD_DATE	"23-JAN-90"
#define SCREEN_NAME	"famast"
#define ESCAPE		12	/* flag indicates discontinuation of entries */
#define RANDOM  	18
#define SEQUENTIAL	19
#define	DELTA_DIFF	0.001
#define LOW 		-1
#define HIGH 		 1
#define HL_CHAR(VAL)	(VAL==HIGH) ? HV_CHAR : LV_CHAR
#define ESC_F		(sr.retcode==RET_USER_ESC && \
			(sr.escchar[0]=='F'||sr.escchar[0]=='f'))
#define ESC_H		(sr.retcode==RET_USER_ESC && \
			(sr.escchar[0]=='H'||sr.escchar[0]=='h'))
#define NO_HLP_WIN	(sr.curfld!=500 && sr.curfld!=600 && sr.curfld!=1000\
			 && sr.curfld!=1300)

#define END_FLD		2400

#ifdef ENGLISH
#define ADDREC		'A'
#define CHANGE 		'C'
#define DELETE		'D'
#define NEXT		'N'
#define PREV		'P'
#define INQUIRE		'I'
#define EXITOPT		'E'

#define EDIT		'E'
#define CANCEL		'C'
#define YES		'Y'
#define NO		'N'
#else	/* FRENCH */
#define ADDREC 		'R'
#define CHANGE 		'C'
#define DELETE		'E'
#define NEXT		'S'
#define PREV		'P'
#define INQUIRE		'I'
#define EXITOPT		'F'

#define EDIT		'M'
#define CANCEL		'A'
#define YES		'O'
#define NO		'N'
#endif

/* fa_maint.sth - header for C structure generated by PROFOM EDITOR */

struct	fa_struct	{
	char	s_progname[11];	/* 100 program name */
	long	s_rundt;	/* 300 system date */
	char	s_fn[2];	/* 400 function */
	short	s_costcen;	/* 500 cost centre# */
	long	s_itemid;	/* 600 item id */
	short	s_fld_no;	/* 700 field# field for editing */
	char	s_desc[36];	/* 900 description of the item */
	char	s_type[5];	/* 1000 fixed asset item type code */
	char	s_typname[16];	/* 1100 fixed asset item type name */
	char	s_sno[13];	/* 1200 model or s# under the type */
	char	s_dept[5];	/* 1300 department number */
	char	s_roomno[6];	/* 1400 room number */
	char	s_cond[2];	/* 1500 condition code */
	char	s_condexp[10];	/* 1600 condition explanation */
	char	s_suppname[21];	/* 1700 supplier name */
	char	s_invc[11];	/* 1800 invoice number */
	short	s_curcostcen;	/* 1850 current location of fixed asset */
	long	s_rectdate;	/* 1900 date of receipt */
	long	s_qty;		/* 2000 quantity */
	double	s_rate;		/* 2100 rate */
	double	s_value;	/* 2200 value of the stock */
	char	s_mesg[77];	/* 2300 message field */
	char	s_resp[2];	/* 2400 response field */
};
struct fa_struct	s_rec;		/* screen record */
struct stat_rec 	sr;		/* profom status record */

Sch_rec		sch_rec;	/* School record */
Fa_type		fa_type;	/* Fixed Asset types file */
Fa_dept		fa_dept;	/* Dept Codes file */
Fa_rec		fa_mast, oldfamast;	/* Fixed Asset Item master file */
Pa_rec		pa_rec;		/* Parameter file */

static	int err, retval;	/* Global variable to store function values */
char e_mesg[80]; /* to store error messages */

double D_Roundoff();

/* Initialize profom fields, call entry procedures */
main( argc, argv )
int argc;
char *argv[];
{
	strncpy( SYS_NAME, SYSTEM, 50 ); /* Module name */
	strncpy( CHNG_DATE, MOD_DATE, 10 );/* Last date of change */
	
	proc_switch( argc,argv,MAINFL );/* process the switches */

	if( Initialize()<0 )	/* Initialize profom enviroment */
		exit(-1);
	if( get_param(&pa_rec,BROWSE,1,e_mesg)<1 ){
		fomen(e_mesg);
		get();
		exit(-1);
	}
	if( pa_rec.pa_fa[0]!=YES ){
#ifdef ENGLISH
		fomen("FA system absent. See Parameter Maintenance");
#else
		fomen("Systeme AI absent. Voir l'entretien des parametres");
#endif
		get();
		exit(0);
	}
	retval = Process();	/* Interact with the user */
	CleanExit();
}

CleanExit()
{
	/* clear and exit the screen , close files & exit program */
	free_audit();	/* free memory allocated for writing audit rec */
	fomcs();
	fomrt();
	close_dbh();
	exit(retval);
}

Initialize()
{
	/* initialize the profom status variables */
	STRCPY( sr.scrnam, NFM_PATH );
	strcat( sr.scrnam, SCREEN_NAME );
	STRCPY( sr.termnm, terminal );

	/* initialize the fields and the profom screen */
	if( FillScrHdg()<0 ) 			return(-1);
	if( FillKeyFields( HIGH )<0 ) 		return(-1);
	if( FillField( HIGH )<0 ) 		return(-1);
	if( FillNonKeyFlds( HIGH )<0 ) 		return(-1);
	if( FillMesgRespFlds( HIGH )<0 ) 	return(-1);
	if( InitProfom()<0 ){
		fomcs();
		fomrt();
		return(-1);
	}
	return(0);
}
/* initialize the profom and the screen */
InitProfom()
{
	fomin( &sr );			/* initialize profom */
	ret( err_chk(&sr) );		/* if profom error return */
	if( WriteFields(1,0)<0 )	/* Write all fields once */
		return(-1);
	fomcf(1,1);			/* Enable snap-screen option */
	return(0);
}
/* Fill the screen heading fields: the program name and the date */
FillScrHdg()
{
	STRCPY( s_rec.s_progname, PROG_NAME );
	s_rec.s_rundt = get_date();
	return(0);
}
/* Fill the keyfields with high or low values */
FillKeyFields( value )
short value;
{
	s_rec.s_costcen = value * HV_SHORT;
	s_rec.s_itemid = value * HV_LONG;

	return(0);
}
/* Fill the field# field with high/low values */
FillField( value )
short value;
{
	s_rec.s_fld_no = value * HV_SHORT;
	return(0);
}
/* Fill the non key fields with high/low values */
FillNonKeyFlds( value )
short value;
{
	s_rec.s_desc[0] 	= HL_CHAR(value);
	s_rec.s_type[0] 	= HL_CHAR(value);
	s_rec.s_typname[0] 	= HL_CHAR(value);
	s_rec.s_sno[0] 		= HL_CHAR(value);
	s_rec.s_dept[0] 	= HL_CHAR(value);
	s_rec.s_roomno[0]	= HL_CHAR(value);
	s_rec.s_cond[0] 	= HL_CHAR(value);
	s_rec.s_condexp[0] 	= HL_CHAR(value);
	s_rec.s_suppname[0] 	= HL_CHAR(value);
	s_rec.s_invc[0] 	= HL_CHAR(value);
	s_rec.s_curcostcen	= value * HV_SHORT;
	s_rec.s_rectdate	= value * HV_LONG;
	s_rec.s_qty		= value * HV_LONG;
	s_rec.s_rate 		= value * HV_DOUBLE;
	s_rec.s_value 		= value * HV_DOUBLE;

	return(0);
}
/* Fill the message and response fields with high or low values */
FillMesgRespFlds( value )
short value;
{
	s_rec.s_mesg[0] = HL_CHAR(value);
	s_rec.s_resp[0] = HL_CHAR(value);
	return(0);
}
/* Accept user's option and call the corresponding routine in a loop */
Process()
{
	/* Initialize the key fields to zeros. Used if seq. search is made */
	s_rec.s_costcen = 0;
	s_rec.s_itemid = 0;

	for( ; ; ){
		if( ReadFunction()<0 ) return(-1);
		switch( s_rec.s_fn[0] ){
			case ADDREC:	/* add a record */
				CHKACC(retval,ADD,e_mesg);
				retval = AddRecord();
				roll_back(e_mesg);
				if( retval<0 )
					return(-1);
				break;
			case CHANGE:	/* Change a record */
				CHKACC(retval,UPDATE,e_mesg);
				retval = ChangeRecord();
				roll_back(e_mesg);
				if( retval<0 )
					return(-1);
				break;
			case DELETE:	/* Delete a record */
				CHKACC(retval,P_DEL,e_mesg);
				retval = DeleteRecord();
				roll_back(e_mesg);
				if( retval<0 )
					return(-1);
				break;
			case NEXT:	/* show next record in sequence */
				CHKACC(retval,BROWSE,e_mesg);
				if( Inquiry(SEQUENTIAL,FORWARD)<0 ) return(-1);
				break;
			case PREV:	/* show prev record in sequence */
				CHKACC(retval,BROWSE,e_mesg);
				if( Inquiry(SEQUENTIAL,BACKWARD)<0 ) return(-1);
				break;
			case INQUIRE:	/* show selected record */
				CHKACC(retval,BROWSE,e_mesg);
				if( Inquiry(RANDOM,0)<0 ) return(-1);
				break;
			case EXITOPT:	/* exit */
				return(0);
			default:
				break;
		}
		if( retval<0 ){
			fomen(e_mesg);
			get();
		}
		if( retval==DBH_ERR )
			return(retval);
	}
}
SetDupBuffers( firstfld, lastfld, value )
int	firstfld, lastfld;	/* field numbers range */
int	value;			/* ENABLE or DISABLE */
{
	int i;

	for( i=firstfld; i<=lastfld; i+=100 )
		fomca1( i, 19, value);
	if( value==0 )
		return(0);
	sr.nextfld = firstfld;
	sr.endfld = lastfld;
	fomud( (char *)&s_rec );
	ret( err_chk(&sr) );

	return( 0 );
}
ReadFunction()	/* Display options at the bottom, and read entry */
{
#ifdef ENGLISH
	fomer("A(dd), C(hange), D(elete), N(ext), P(rev), I(nquire), E(xit)");
#else
	fomer("R(ajouter), C(hanger), E(liminer), S(uivant), P(recedent), I(nterroger), F(in)");
#endif
	sr.nextfld = 400;	/* Fn field number */
	fomrf( (char *)&s_rec );
	ret( err_chk(&sr) );
	return(0);
}
/* Add a stock master record */
AddRecord()
{
	if( SetDupBuffers(500,2200,0)<0 )
		return(-1);
	if( ClearScreen()<0 )	return(-1);
	if( (retval=RdKeyFlds())<0 )	/* Read key fields */
		return(retval);
	if(retval==ESCAPE){
		if(ClearScreen()<0)	
			return(-1);
		return(retval);
	}
	
	if( FillNonKeyFlds(LOW)<0 ) 	/* Prepare to read other fields */
		return(-1);
	s_rec.s_curcostcen = s_rec.s_costcen;

	/* Read the non key fields now */
	if( (retval=ReadFields(900,2200))<0 )
		return(retval);
	if(retval==ESCAPE){
		if(ClearScreen()<0)	return(-1);
		return(retval);
	}

	if( (retval=EditFlds(ADD))<0 )	return(retval);
	if( retval==ESCAPE ){
		if(ClearScreen()<0)	return(-1);
		return(retval);
	}

	for( ; ; ) {
		err = WriteSession( ADD );
		if(err==NOERROR) break;
		if(err==LOCKED) {
			roll_back(e_mesg);
			if( (retval=EditFlds(LOCKED))<0 )	return(retval);
			if( retval==ESCAPE ){
				if(ClearScreen()<0)	return(-1);
				return(retval);
			}
			continue;
		}
		if(err<0) return(err);
	}

	return(0);
}
/* Read stock master key fields, the fund and stock item code */
RdKeyFlds()
{
	if( FillKeyFields(LOW)<0 ) return(-1);
	return ( ReadFields(500,600) );
}
static
ReadFields( start,end )	/* Read the given range of fields */
{
	sr.nextfld = start;
	sr.endfld = end;
	for( ; ; ){	/* Do in a loop */
		fomrd( (char *)&s_rec );	/* Profom call */
		ret(err_chk(&sr));		/* Check for profom error */
		if( sr.retcode==RET_USER_ESC || sr.retcode==RET_VAL_CHK ){
		    if( sr.retcode==RET_USER_ESC ){
			if( sr.escchar[0]=='F' || sr.escchar[0]=='f' )
				return( ESCAPE );
			else if( sr.escchar[0]=='H' || sr.escchar[0]=='h' ){
				if( NO_HLP_WIN )
					continue;
			}
			else
				continue;
		    }
		    retval=Validate();
		    if(retval<0 || retval==ESCAPE)
			return(retval);
		    else
			continue;
		}
		break;
	}
	return(0);
}
static
WriteFields( start,end )	/* write the given range of fields */
int start, end;			/* start & end profom field numbers */
{
	sr.nextfld = start;
	sr.endfld = end;
	fomwr( (char *)&s_rec );
	ret( err_chk(&sr) );
	return(0);
}
ClearScreen()	/* clear the screen except fn field key flds & screen heading */
{
	if(FillField(HIGH)<0 ) return(-1);
	if(FillNonKeyFlds(HIGH)<0 ) return(-1);
	if(FillMesgRespFlds(HIGH)<0 ) return(-1);

	if( WriteFields(700,2400)<0 ) return(-1);
	
	return(0);
}
Validate()	/* Validate the values entered by the user */
{
	int index;

	switch( sr.curfld ){
		case 500:	/* cost centre/ school number */
			if( ESC_H ){
				retval = sch_hlp( &s_rec.s_costcen, 7,13 );
				if( retval==DBH_ERR )
					return( retval );
				else if( retval>=0 )
					redraw();
				if( retval==0 )
					break;
			}
			sch_rec.sc_numb = s_rec.s_costcen;
			index = get_sch( &sch_rec, BROWSE, 0, e_mesg );
			if( index==ERROR ){
				fomen(e_mesg); get();
				return(-1);
			}
			if( index!=NOERROR ){	/* record doesn't exist */
				fomer(e_mesg);
				s_rec.s_costcen = LV_SHORT; 
				break;
			}
			fomer( sch_rec.sc_name );

			if(s_rec.s_fn[0] != ADDREC) break;

			/* ADDREC Getting the next item no for the specified 
			  Cost Center */
			fa_mast.fa_costcen = s_rec.s_costcen;
			fa_mast.fa_itemid = HV_LONG;
			flg_reset(FAMAST);
			retval = get_n_famast( &fa_mast, BROWSE, 0, BACKWARD, e_mesg );
			if(retval==EFL)
				s_rec.s_itemid = 1;
			else 
				s_rec.s_itemid = fa_mast.fa_itemid + 1 ;
			if( WriteFields(500,600)<0 )
				return(-1);
			break;
		case 600:	/* fixedasset itemid: check by reading master */
			if (s_rec.s_itemid == 0) {
				fomer("must be greater than 0");
				s_rec.s_itemid = LV_LONG; 
			}
			if( ESC_H ){
				retval = faitem_hlp( 
					s_rec.s_costcen,&s_rec.s_itemid, 7,13 );
				if( retval==DBH_ERR )
					return( retval );
				else if( retval>=0 )
					redraw();
				if( retval==0 )
					break;
			}
			fa_mast.fa_costcen = s_rec.s_costcen;
			fa_mast.fa_itemid = s_rec.s_itemid;
			retval = get_famast( &fa_mast, BROWSE, 0, e_mesg );
			if( retval==ERROR ){
				fomen(e_mesg);get();
				return(retval);
			}
			if( s_rec.s_fn[0]==ADDREC ){	/* add mode */
				if( retval!=UNDEF ){
#ifdef ENGLISH
					fomer("Record already exists");
#else
					fomer("Fiche existe deja");
#endif
					s_rec.s_itemid = LV_LONG; 
				}
			}
			else{
				if( retval!=NOERROR ){ /* no record exists */
					fomer(e_mesg);
					s_rec.s_itemid = LV_LONG; 
				} 
			}
			break; 
		case 700:	/* field # for editing */
			if( sr.fillcode==FIL_OMITTED )	/* Nothing entered */
				return(ESCAPE);
			break;
		case 1000:	/* FA item type */
			if( ESC_H ){
				retval = fatype_hlp( s_rec.s_type, 7,13 );
				if( retval==DBH_ERR )
					return( retval );
				else if( retval>=0 )
					redraw();
				if( retval==0 )
					break;
			}
			STRCPY( fa_type.code, s_rec.s_type );
			if( get_fatype(&fa_type,BROWSE,0,e_mesg)<0 ){
				fomer(e_mesg);
				s_rec.s_type[0] = LV_CHAR; 
			}
			else
				strncpy( s_rec.s_typname, fa_type.desc, 15 );
			break;
		case 1300:	/* Dept Code */
			if( ESC_H ){
				retval = fadept_hlp( s_rec.s_dept, 7,13 );
				if( retval==DBH_ERR )
					return( retval );
				else if( retval>=0 )
					redraw();
				if( retval==0 )
					break;
			}
			STRCPY( fa_dept.code, s_rec.s_dept );
			if( get_fadept(&fa_dept,BROWSE,0,e_mesg)<0 ){
				fomer(e_mesg);
				s_rec.s_dept[0] = LV_CHAR; 
			}
			else
				fomer( fa_dept.desc );
			break;
		case 1500:	/* fa item condition */
			if( s_rec.s_cond[0] != CD_EXCELLENT &&
			    s_rec.s_cond[0] != CD_GOOD &&
			    s_rec.s_cond[0] != CD_FAIR &&
			    s_rec.s_cond[0] != CD_POOR &&
			    s_rec.s_cond[0] != CD_OBSOLETE ){
#ifdef ENGLISH
			fomer(" E(xcellent), G(ood), F(air), P(oor), O(bsolete)");
#else
			fomer(" E(xcellent), B(on), P(assable), M(auvais), O(bsolete)");
#endif
				s_rec.s_cond[0] = LV_CHAR;
			}
			else{
				switch( s_rec.s_cond[0] ){
					case CD_EXCELLENT:
						STRCPY(s_rec.s_condexp,
							EXCELLENT);
						break;
					case CD_GOOD:
						STRCPY(s_rec.s_condexp,
							GOOD);
						break;
					case CD_FAIR:
						STRCPY(s_rec.s_condexp,
							FAIR);
						break;
					case CD_POOR:
						STRCPY(s_rec.s_condexp,
							POOR);
						break;
					case CD_OBSOLETE:
						STRCPY(s_rec.s_condexp,
							OBSOLETE);
						break;
				}
			}
			break;
		case 1900:	/* date of receipt */
			if( s_rec.s_rectdate> s_rec.s_rundt ){
#ifdef ENGLISH
				fomer("Date can't exceed current date");
#else
				fomer("Date ne peut pas etre plus tard que la date courante");
#endif
				s_rec.s_rectdate = LV_LONG;
			}
			if(s_rec.s_fn[0] == ADDREC) {
	                        s_rec.s_qty = 1;
        	                SetDupBuffers(2000,2000,2);
                	        s_rec.s_qty = LV_LONG;
			}
			break;
                case 2100:
                        s_rec.s_value = s_rec.s_qty * s_rec.s_rate;
                        SetDupBuffers(2200,2200,2);
                        s_rec.s_value = LV_DOUBLE;
			break;
		default:
			break;
	}
	sr.nextfld = sr.curfld;
	return(0);
}
EditFlds(mode)	/* Ask if user wants to edit fields before saving */
int	mode;
{
	/* Go to field changing directly if Change mode */
	if( s_rec.s_fn[0]==CHANGE && mode != LOCKED)
		if( FldEdit()<0 )
			return(-1);
	for( ; ; ){
#ifdef ENGLISH
		if(DisplayMessage( "Y(es), E(dit), C(ancel)")<0 ) 
#else
		if(DisplayMessage( "O(ui), M(odifier), A(nnuler)")<0 ) 
#endif
			return(-1);
		sr.nextfld = 2400;
		fomrf( (char *)&s_rec );
		ret( err_chk(&sr) );
		switch( s_rec.s_resp[0] ){
			case EDIT:	/* Edit the fields */
				if( (retval=FldEdit())<0 )
					return(retval);
				break;
			case CANCEL:	/* Cancel the session */
#ifdef ENGLISH
				if( DisplayMessage("Confirm the Cancel (Y/N)?")<0 )
#else
				if( DisplayMessage("Confirmer l'annulation (O/N)?")<0 )
#endif
					return(-1);
				sr.nextfld = 2400;	/* response field */
				fomrf( (char *)&s_rec );
				ret( err_chk(&sr) );
				if( s_rec.s_resp[0]==YES ){
					if( HideMessage()<0 ) return(-1);
					return(ESCAPE);
				}
				break;
			case YES:
				if( HideMessage()<0 ) return(-1);
				return(0);
		}
	}
}
DisplayMessage(mesg)	/* Display the given message in the message field */
char *mesg;
{
	STRCPY( s_rec.s_mesg, mesg );
	if( WriteFields(2300,2300)<0 )	return(-1);
	return(0);
}
HideMessage()	/* Hide the message & response fields */
{
	if( FillMesgRespFlds(HIGH)<0 )	return(-1);
	if( WriteFields(2300,2400)<0 ) return(-1);
	return(0);
}
HideFldNo()	/* Hide the 'Field#' field */
{
	if( FillField(HIGH)<0 )	return(-1);
	if( (WriteFields(700,700))<0 )
		return(-1);
	return(0);
}
FldEdit()	/* Read the field number and read corresponding field */
{
	int firstfld,lastfld;

	for( ; ; ){
#ifdef	ENGLISH
		STRCPY(s_rec.s_mesg,"Enter RETURN to terminate Edit");
#else
		STRCPY(s_rec.s_mesg,"Appuyer sur RETURN pour terminer l'ajustement");
#endif
		ShowMesg();
		/* Read number of field to be changed */
		if( FillField(LOW)<0 )	return(-1);
		if( (retval = ReadFields(700,700))<0 ) return(-1);
		if( retval==ESCAPE ){
			if( HideFldNo()<0 ) return(-1);
			break;
		}
		switch(s_rec.s_fld_no){
			case 1: 	/* description */
				firstfld = lastfld=900;
				break;
			case 2: 	/* type */
				firstfld = 1000;
				lastfld = 1100;
				break;
			case 3: 	/* serial no  */
				firstfld =lastfld=1200;
				break;
			case 4: 	/* Department # */
				firstfld = lastfld = 1300;
				break;
			case 5: 	/* Room # */
				firstfld = lastfld = 1400;
				break;
			case 6: 	/* condition */
				firstfld = 1500;
				lastfld = 1600;
				break;
			case 7: 	/* Supplier code */
				firstfld = lastfld = 1700;
				break;
			case 8: 	/* Invoice number */
				firstfld = lastfld = 1800;
				break;
			case 10: 	/* Date of Receipt */
				firstfld = lastfld = 1900;
				break;
			case 11: 	/* Quantity */
				firstfld = 2000;
				lastfld = 2100;
				break;
			case 12: 	/* Rate */
				firstfld = lastfld = 2100;
				break;
			case 13: 	/* Value */
				firstfld = lastfld = 2200;
				break;
#ifdef ENGLISH
			default: fomer("Can't change specified field");
#else
			default: fomer("Ne peut pas changer le champ specifie");
#endif
				continue;
		}
		retval = ModifyField(firstfld, lastfld);
		if( retval<0 )	return(retval);
		if( retval==ESCAPE ){
			if( HideFldNo()<0 ) return(-1);
			break;
		}
	}
	return(0);
}
ModifyField( firstfld, lastfld )	/* Read & change the specified fields */
int firstfld,lastfld;
{
	int i;

	for( i=firstfld; i<=lastfld; i+=100 ){
		fomca1( i,19,2);	/* enable dup buffers */
		fomca1( i,10,0);	/* disable escape flag */
	}
	sr.nextfld = firstfld;
	sr.endfld = lastfld;
	fomud( (char *)&s_rec);		/* Update dup buffers */
	switch(firstfld){
		case 900:	/* description */
			s_rec.s_desc[0] = LV_CHAR;
			break;
		case 1000:	/* type */
			s_rec.s_type[0] = LV_CHAR;
			break;
		case 1200:	/* Serial # */
			s_rec.s_sno[0] = LV_CHAR;
			break;
		case 1300:	/* department# */
			s_rec.s_dept[0] = LV_CHAR;
			break;
		case 1400:	/* room# */
			s_rec.s_roomno[0] = LV_CHAR;
			break;
		case 1500:	/* condition # */
			s_rec.s_cond[0] = LV_CHAR;
			break;
		case 1700:	/* Supplier code */
			s_rec.s_suppname[0] = LV_CHAR;
			break;
		case 1800:	/* Invoice */
			s_rec.s_invc[0] = LV_CHAR;
			break;
		case 1900:	/* Date of receipt */
			s_rec.s_rectdate = LV_LONG;
			break;
		case 2000:	/* Quantity and Rate */
			s_rec.s_qty = LV_LONG;
			s_rec.s_rate = LV_DOUBLE; 
			break;
                case 2100:      /*  Rate  */
			s_rec.s_rate = LV_DOUBLE; 
			break;
		case 2200:	/* Value */
			s_rec.s_value = LV_DOUBLE;
			break;
		default:
			break;
	}
	retval = ReadFields( firstfld, lastfld );
	if( retval<0 || retval==ESCAPE )	return(retval);
	for( i=firstfld; i<=lastfld; i+=100 ){
		fomca1( i,19,0);	/* disable dup buffers */
		fomca1( i,10,1);	/* enable escape flag */
	}
	return(0);
}
WriteSession(mode)	/* Write the stock master record */
int	mode;		/* ADD, UPDATE */
{
	fa_mast.fa_costcen = s_rec.s_costcen;
	fa_mast.fa_itemid = s_rec.s_itemid;
	STRCPY( fa_mast.fa_desc, s_rec.s_desc );
	STRCPY( fa_mast.fa_type, s_rec.s_type );
	STRCPY( fa_mast.fa_sno, s_rec.s_sno );
	STRCPY( fa_mast.fa_dept, s_rec.s_dept );
	STRCPY( fa_mast.fa_roomno, s_rec.s_roomno );
	STRCPY( fa_mast.fa_cond, s_rec.s_cond );
	STRCPY( fa_mast.fa_suppname, s_rec.s_suppname );
	STRCPY( fa_mast.fa_invc, s_rec.s_invc );
	fa_mast.fa_curcostcen = s_rec.s_curcostcen;
	fa_mast.fa_rectdate = s_rec.s_rectdate;
	fa_mast.fa_qty = s_rec.s_qty;
	fa_mast.fa_rate = s_rec.s_rate;
	fa_mast.fa_value = s_rec.s_value;
	
	fa_mast.fa_value = D_Roundoff(fa_mast.fa_value);
	
	retval = put_famast( &fa_mast, mode, e_mesg );
	if( retval!=NOERROR ){
		fomen(e_mesg);get();
		roll_back(e_mesg);
		return(retval);
	}
	err=rite_audit((char*)&s_rec, FAMAST,mode,(char *)&fa_mast,
				(char *)&oldfamast,e_mesg);
	if(err==LOCKED) {
		DispError(e_mesg);
		roll_back(e_mesg);
		return(LOCKED);
	}

	if(err != NOERROR){
#ifdef ENGLISH
		DispError("ERROR in Saving Records"); 
#else
		DispError("ERREUR en conservant les fiches");
#endif
		DispError(e_mesg);
		roll_back(e_mesg);
		MoveHighs() ;
		return(DBH_ERR);
	}
	if(commit(e_mesg) < 0) {
#ifdef ENGLISH
		DispError("ERROR in Saving Records"); 
#else
		DispError("ERREUR en conservant les fiches");
#endif
		DispError(e_mesg);
		MoveHighs() ;
		return(DBH_ERR);
	}
	return(0);
}
Inquiry( access, direction )	/* Screen inquiry, random/sequential */
int access, direction;		/* RANDOM, SEQUENTIAL accesses */
{
	if( access==RANDOM ){
		if( SetDupBuffers(500,600,2)<0 )
			return(-1);
		retval = GetRecord();	/* Read the key values */
		if( retval==UNDEF || retval==ESCAPE || retval==LOCKED )
			return( retval=ESCAPE );
	}
	else{	/* access is sequential, so get next record from file */
		retval = GetNextRec( direction );	/* Get next rec */
		if(retval==EFL)
			return(retval=0);
	}
	if( retval<0 ){	/* errors in reading */
		fomen(e_mesg);get();
		return(-1);
	}
	
	retval = DisplayRecord();	/* Display the header & item records */
	if( retval<0 ) return(retval);

	return(0);
}
DisplayRecord()	/* Get and display the header and item records */
{
	s_rec.s_costcen = fa_mast.fa_costcen ; 
	s_rec.s_itemid = fa_mast.fa_itemid ; 
	STRCPY( s_rec.s_desc, fa_mast.fa_desc );
	STRCPY( s_rec.s_type, fa_mast.fa_type );

	STRCPY( fa_type.code, fa_mast.fa_type );
	retval = get_fatype( &fa_type, BROWSE, 0, e_mesg );
	if( retval<0 ){
		fomen(e_mesg); get();
		return(-1);
	}
	strncpy( s_rec.s_typname, fa_type.desc, 15 );

	STRCPY( s_rec.s_sno, fa_mast.fa_sno );
	STRCPY( s_rec.s_dept, fa_mast.fa_dept );
	STRCPY( s_rec.s_roomno, fa_mast.fa_roomno );
	STRCPY( s_rec.s_cond, fa_mast.fa_cond );
	switch( s_rec.s_cond[0] ){
		case CD_EXCELLENT:
				STRCPY( s_rec.s_condexp,EXCELLENT );
				break;
		case CD_GOOD:
				STRCPY( s_rec.s_condexp,GOOD );
				break;
		case CD_FAIR:
				STRCPY( s_rec.s_condexp,FAIR );
				break;
		case CD_POOR:
				STRCPY( s_rec.s_condexp,POOR );
				break;
		case CD_OBSOLETE:
				STRCPY( s_rec.s_condexp,OBSOLETE );
				break;
		default:	
				s_rec.s_condexp[0] = HV_CHAR;
				break;
	}
	STRCPY( s_rec.s_suppname, fa_mast.fa_suppname );
	STRCPY( s_rec.s_invc, fa_mast.fa_invc );
	s_rec.s_curcostcen = fa_mast.fa_curcostcen;
	s_rec.s_rectdate = fa_mast.fa_rectdate ; 
	s_rec.s_qty = fa_mast.fa_qty ; 
	s_rec.s_rate = fa_mast.fa_rate ; 
	s_rec.s_value = fa_mast.fa_value ; 

	if( WriteFields(900,2200) < 0 )
		return(-1);
	return(0);
}
GetNextRec(direction)	/* Read the next record in the specified direction */
int	direction;
{
	if( flg_start(FAMAST)!=direction ){ 	/* file access mode changed */
		fa_mast.fa_costcen = s_rec.s_costcen;
		fa_mast.fa_itemid = s_rec.s_itemid;
		if( direction==FORWARD )
			fa_mast.fa_itemid++;
		else
			fa_mast.fa_itemid--;
		flg_reset(FAMAST);
	}
	/* Read the next record from stmast file */
	retval = get_n_famast( &fa_mast, BROWSE, 0, direction, e_mesg );
#ifndef ORACLE
	seq_over( FAMAST );
#endif
	if( retval==EFL ){
#ifdef ENGLISH
		fomen("No More Records....");
#else
		fomen("Plus de fiches....");
#endif
		get();
		flg_reset(FAMAST);
		return(EFL);
	}
	if( retval!=NOERROR ){
		fomen(e_mesg);	get();
		return(retval);
	}
	/* Write the key fields on to the screen */
	s_rec.s_costcen = fa_mast.fa_costcen;
	s_rec.s_itemid = fa_mast.fa_itemid;
	if( WriteFields(500,600)<0 )
		return(-1);
	return(0);
}
GetRecord()	/* Read the header key values, get terminal info ,read rec */
{
	int	mode;

	if( s_rec.s_fn[0]==CHANGE||s_rec.s_fn[0]==DELETE )	
		mode = UPDATE;
	else
		mode = BROWSE;
	s_rec.s_costcen = LV_SHORT;
	s_rec.s_itemid = LV_LONG;
	if( (retval=ReadFields(500,600))<0 || retval==ESCAPE ){ 
		return( retval );
	}
	fa_mast.fa_costcen = s_rec.s_costcen;
	fa_mast.fa_itemid = s_rec.s_itemid;
	retval = get_famast( &fa_mast, mode, 0, e_mesg );
	if( retval!=NOERROR ){
		fomer(e_mesg);
		get();
		return(retval);
	}

	return(0);
}
ChangeRecord()	/* Change an existing record */
{
	/* Get the record & display it */
	retval = Inquiry( RANDOM, 0 );
	if( retval<0 )	return(retval);
	if( retval==ESCAPE )  return(0);

	/* Copy the record to another buffer, for writing audit */
	scpy( (char *)&oldfamast, (char *)&fa_mast, sizeof( Fa_rec ) );

	/* Allow changes on the record fields */
	retval = EditFlds(UPDATE);
	if( retval<0 )	return(retval);
	if( retval==ESCAPE ){	/* Cancellation of changes */
		roll_back(e_mesg);	/* release locked record */
		return(0);
	}

	for( ; ; ) {
		err= WriteSession( UPDATE );

		if(err==NOERROR) break;
		if(err==LOCKED) {
			roll_back(e_mesg);
			fa_mast.fa_costcen = s_rec.s_costcen;
			fa_mast.fa_itemid = s_rec.s_itemid;
			retval = get_famast( &fa_mast, UPDATE, 0, e_mesg );
			if(retval < 0){
				fomen(e_mesg);
				get() ;
				if(retval== UNDEF || retval== LOCKED) continue;
				return(DBH_ERR);
			}
			retval = EditFlds(LOCKED);
			if( retval<0 )	return(retval);
			if( retval==ESCAPE ){	/* Cancellation of changes */
				roll_back(e_mesg);  /* release locked record */
				return(0);
			}
			continue;
		}
		if(err<0) return(err);
	}
	return(0);
}
DeleteRecord()	/* delete an existing record */
{
	int retval;

	/* Get the record & display it */
	retval = Inquiry( RANDOM, 0 );
	if( retval<0 )	return(retval);
	if( retval==ESCAPE )
		return(0);
	for( ; ;){
		for( ; ; ){
#ifdef ENGLISH
			if( DisplayMessage("Confirm (Y/N)?")<0 ) return(-1);
#else	
			if( DisplayMessage("Confirmer (O/N)?")<0 ) return(-1);
#endif
			s_rec.s_resp[0] = LV_CHAR;
			if( ReadFields(2400,2400)<0 ) return(-1);
			if( s_rec.s_resp[0]!=YES && s_rec.s_resp[0]!=NO )
				continue;
			else
				break;
		}
		if( s_rec.s_resp[0]==NO ){ /* Cancellation of deletion */
			roll_back(e_mesg);	/* release locked record */
			return( HideMessage() );
		}

	/* Write the updated record */

		err= WriteSession( P_DEL );

		if(err==NOERROR) break;
		if(err==LOCKED) {
			roll_back(e_mesg);
			fa_mast.fa_costcen = s_rec.s_costcen;
			fa_mast.fa_itemid = s_rec.s_itemid;
			retval = get_famast( &fa_mast, UPDATE, 0, e_mesg );
			if(retval < 0){
				fomen(e_mesg);
				get() ;
				if(retval== UNDEF || retval== LOCKED) continue;
				return(DBH_ERR);
			}
			continue;
		}
	}
	return( ClearScreen() );
}

/*----------------------------------------------------------------------*/
/* Initialize screen data fields with High values and display the screen*/
/*----------------------------------------------------------------------*/
static
MoveHighs()
{
	if( FillKeyFields( HIGH )<0 ) 		return(-1);
	if( FillField( HIGH )<0 ) 		return(-1);
	if( FillNonKeyFlds( HIGH )<0 ) 		return(-1);
	return(NOERROR);
}	/* MoveHighs() */
/*----------------------------------------------------------------------*/
/* show ERROR and wait 							*/
/*----------------------------------------------------------------------*/
static
DispError(s)    /* show ERROR and wait */
char *s;
{
	STRCPY(s_rec.s_mesg,s);
	ShowMesg();
#ifdef	ENGLISH
	fomen("Press any key to continue");
#else
	fomen("Appuyer sur une touche pour continuer");
#endif
	get();
	s_rec.s_mesg[0] = HV_CHAR;
	ShowMesg();
	return(ERROR);
}
/*----------------------------------------------------------------------*/
/* shows or clears message field 					*/
/*----------------------------------------------------------------------*/
static
ShowMesg()  /* shows or clears message field */
{
	sr.nextfld = END_FLD - 100;
	fomwf((char*)&s_rec) ;
}
/*-------------------- E n d   O f   P r o g r a m ---------------------*/
