/*-----------------------------------------------------------------------------
Sourcename    : arsinv.c
System        : Budgetary Financial system.
Module        : ARS  :  Invoice/Db Memo/Cr Memo
Created on    : 89-10-26
Created  By   : K HARISH.
Cobol sources : 

-------------------------------------------------------------------------------
About the program:

	This program allows the user to Add or Inquire about Sales
Invoices, Debit memos and Credit memos raised by the ARS. Change or
Deletion of previously raised bills is not allowed. 
	The Debit/Credit memos are linked to a prior invoice. Apart from
the invoice number, the invoice always bears serial number 1 and any 
further Debit/Credit Memos related to this invoice bear serial numbers 
2,3,4.... so on.
	Each Invoice amount can be distributed across a user 
specified set of customer accounts. The amount for any DM/CM related to
this invoice can be distributed across only that set of accounts.

For Invoice and DM:
	The ARS general account is credited and the user account(s) is
(are) debited.

For CM:
	The ARS general account is debited and the user account(s) is
(are) credited.

HISTORY:
 Date           Programmer     Description of modification
____/__/__      __________     ___________________________
1990/11/21	peter ralph	Use param_rec.pa_due_days as default due date
1990/12/05	Frank Tao	Changed Screen for GST calculation.
1990/12/18	Frank Tao	Round Up amounts before write to file.
1990/12/20	Frank Tao	Fix editing screen.
1990/12/27	Frank Tao	Round off Tax calculation;
				Fix gross amount formula in the file. 
1990/12/28	Frank Tao	Increment Sequential number if needed.
1991/01/24	Frank Tao	When updating "curcr" in GL, should post
				negative amount.
1991/02/08	peter ralph	right justify numeric customer codes 
1992/07/23	Jamie McLean	Changed screen, line by line account and
				description.  Running totals added for 
				all options.  Changed customer code from 6 
				to 10 characters.
1992/08/11	Jamie McLean	Changed code to allow user to enter zero for 
				both invoice amount and item amounts.
1992/10/06	Louis Robichaud Changed to allow the account number to be 
				entered by the use of the help window or to
				be entered in directly.
1992/10/08	Louis Robichaud Fix help window not to allow account numbers
				without the code type of 99.
-----------------------------------------------------------------------------*/
#define MAIN
#define MAINFL		ARSHDR		/* main file used */

#include <bfs_defs.h>
#include <bfs_recs.h>
#include <cfomstrc.h>
#include <stdio.h>

#define SYSTEM		"ACCOUNTS RECEIVABLE"
#define MOD_DATE	"22-JUL-92"
#define SCREEN_NAME	"arsinv"
#define ITEMSPERPAGE 	3
#define EXIT		12
#define ALLOC_ERROR	13
#define ADD_MODE	16
#define INQ_MODE	17
#define RANDOM  	18
#define SEQUENTIAL	19
/* #define DELTA_AMT	0.0001   */
#define DELTA_AMT	0.01     
#define LOW 		-1
#define HIGH 		 1
#define IN 		1	/* Type flag for INVOICE */
#define DM 		2	/* Type flag for DEBIT MEMO */
#define CM 		3	/* Type flag for CREDIT MEMO */

#define	INVCNBR		1	/* generate invoice # */
#define	MEMONBR		2	/* generate DM/CM # */
#define	SEQNO		3	/* generate seq no # */

#define HL_CHAR(VAL)	VAL==HIGH ? HV_CHAR : LV_CHAR

#define ESC_F		sr.retcode==RET_USER_ESC && \
			(sr.escchar[0]=='F'||sr.escchar[0]=='f')
#define ESC_H		sr.retcode==RET_USER_ESC && \
			(sr.escchar[0]=='H'||sr.escchar[0]=='h')

#define NO_HLP_WIN	(sr.curfld != CUST_FLD && (sr.curfld-STEP)%STEP != 100 )

#define	DEBIT		0		/* Add to Gl master */
#define	CREDIT		1		/* Subtract from GL master */

#ifdef ENGLISH

#define T_INVOICE	"IN"
#define T_CRMEMO	"CM"
#define T_DBMEMO	"DM"

#define ADDREC		'A'
#define CHANGE 		'C'
#define DELETE		'D'
#define REVIVE		'R'
#define NEXT		'N'
#define PREV		'P'
#define INQUIRE		'I'
#define EXITOPT		'E'

#define EDIT		'E'
#define CANCEL		'C'
#define TOTAL		'T'

#define YES		'Y'
#define NO		'N'

#define ACTIVE		'A'

#else	/* French */

#define T_INVOICE	"FC"
#define T_CRMEMO	"NC"
#define T_DBMEMO	"ND"

#define ADDREC		'R'
#define CHANGE 		'C'
#define DELETE		'E'
#define REVIVE		'V'
#define NEXT		'S'
#define PREV		'P'
#define INQUIRE		'I'
#define EXITOPT		'F'

#define EDIT		'M'
#define CANCEL		'A'
#define TOTAL		'T'

#define YES		'O'
#define NO		'N'

#define ACTIVE		'A'
#endif

typedef struct scr_item{	/* one line of fields for each entry item */
	char	s_accno[19];	/* account number */
	double	s_amount;	/* amount */
	char	s_status[4];	/* description of the entry */
	char	s_desc[61];	/* account description */
	short 	s_dummy;	/* dummy to align structure */
} Scr_item;

/* arsinv.sth - header for C structure generated by PROFOM EDITOR */
struct	ai_struct{
	char	s_progname[11];	/* Program name field 100 */
	long	s_rundt;	/* Date field  for display only 300 */

	char	s_fn[2];	/* Function field 400 */
	char	s_type[3];	/* Invoice/DM/CM type 500 */
	short	s_fund;		/* fund code field 600 */
	long	s_invoice;	/* Invoice number 700 */
	short	s_sno;		/* Serial no. under invoice 800 */
	short	s_fld_no;	/* To read field# for editing field 900 */
	char	s_cucode[11];	/* Customer code field 1100 */
	long	s_trandt;	/* Transaction Date field for storage 1200 */
	long	s_duedt;	/* Due date for invoice payment 1300 */
	double	s_oriamt;	/* Amount for which invoice was raised 1400 */
	double	s_gramt;	/* Gross amount including DM/CMs 1500 */
	double	s_GSTpercent;	/* %age tax 1600 */
	double	s_GSTtaxamt;	/* Tax amount 1700 */
	double	s_PSTpercent;	/* %age tax 1800 */
	double	s_PSTtaxamt;	/* Tax amount 1900 */
	double	s_netamt;	/* Net amount 2000 */
	double	s_balance;	/* Outstanding amount 2100 */
	short	s_period;	/* Period field 2200 */
	char	s_remarks[21];	/* Remarks field 2300 */
	char	s_seperator[2];	/* To hide a demarcating line 2400 */

	short	s_page;		/* Page # of items field 2500 */
	Scr_item s_entries[ITEMSPERPAGE]; /* fields 2600-3900 array */

	double	s_tot_invoice;	/* Total sum of invoice amounts 4100 */
	double	s_tot_gst;	/* Total sum of GST 4200 */
	double	s_tot_pst;	/* Total sum of PST 4300 */
	double	s_grand_tot;	/* Grand Total of Invoice & Tax 4400 */

	char	s_mesg[78];	/* Message field 4500*/
	char	s_resp[2];	/* Response field 4600 */
};

static struct ai_struct	s_rec;		/* screen record */

#define	FN_FLD		400
#define	TYPE_FLD	500
#define	FUND_FLD	600
#define	INVOICE_FLD	700
#define SNO_FLD		800
#define	EDIT_FLD	900
#define CUST_FLD	1100
#define TRANDT_FLD	1200
#define DUEDT_FLD	1300
#define ORIAMT_FLD	1400
#define GRAMT_FLD	1500
#define GSTPERC_FLD	1600
#define GSTAMT_FLD	1700
#define PSTPERC_FLD	1800
#define PSTAMT_FLD	1900
#define NETAMT_FLD	2000
#define BALANCE_FLD	2100
#define PERIOD_FLD	2200
#define REMARKS_FLD	2300
#define SEPARATOR_FLD	2400

#define PAGE_FLD	2500
#define ACCOUNT1_FLD	2600
#define AMOUNT1_FLD	2700
#define STATUS1_FLD	2800
#define DESC1_FLD	2900

#define ACCOUNT2_FLD	3100
#define AMOUNT2_FLD	3200
#define STATUS2_FLD	3300
#define DESC2_FLD	3400

#define ACCOUNT3_FLD	3600
#define AMOUNT3_FLD	3700
#define STATUS3_FLD	3800
#define DESC3_FLD	3900

#define	TOT_INV_FLD	4100
#define	TOT_GST_FLD	4200
#define	TOT_PST_FLD	4300
#define	GRANDTOT_FLD	4400

#define MESG_FLD	4500
#define RESP_FLD	4600

#define STEP		500

/*  Line Edit numbers  */
#define CUST_NO		1
#define TRANSDATE_NO	2
#define	DUEDATE_NO	3
#define NETAMT_NO	4
#define GROSSAMT_NO	5
#define	GST_NO		6
#define PST_NO		7
#define TOTAL_NO	8
#define OUTSTANDING_NO	9
#define PERIOD_NO	10
#define REMARKS_NO	11

typedef struct{		/* structure to record current page & line of entry */
	short	page;	
	short	line;
}	Counter;

/* linked list node for holding one page of entries */
typedef	struct pgofitems{
	struct 	pgofitems *prevptr;	/* pointer to previous entry */
	int	lines_entered;		/* no of lines entered */
	Scr_item fields[ITEMSPERPAGE];	/* array of lines per page */
	struct 	pgofitems *nextptr;	/* pointer to next entry */
}	Page;

long	date_plus();

static Page	*headptr,*tempptr,*tailptr;	/* to maintain list */
static Counter	current; /* For current line & page of journal item entry */
struct stat_rec 	sr;		/* profom status record */

int	Argc;		/* Store the argc, argv here, to call execute */
char	**Argv;

static Gl_rec 		gl_rec;		/* GL master record */
static Tr_hdr 		tr_hdr;		/* GL transaction header rec */
static Tr_item 		tr_item;	/* GL transaction item rec */
static Ar_hdr 		ar_hdr,		/* Invoice/Memo header rec */
	 		in_hdr;		/* Invoice header rec referred to 
					   when DM / CM is added */
static Ar_item 		ar_item;	/* Invoice/Memo item rec */
static Pa_rec		param_rec;	/* parameter file record */
static Ctl_rec		ctl_rec;	/* control file record */
static Cu_rec		cu_rec;		/* customer file record */

static	long	dm_cm_duedt;	/* applied DM/CM due date */
static	long	g_invnbr;	/* generated invoice number */
static  int	cnt;		/* used to see if GST && PST amount entered */
static	short	memotype;	/* Memo type IN or DM or CM */
static 	int totalitemsadded;	/* total items added in any add session */
static 	int retval;	/* Global variable to store function values */
static 	char e_mesg[80]; /* to store error messages */

double D_Roundoff();

/* Initialize profom fields, call entry procedures */
main( argc, argv )
int argc;
char *argv[];
{
	strncpy( SYS_NAME, SYSTEM, 50 ); 	/* Module name */
	strncpy( CHNG_DATE, MOD_DATE, 10 );	/* Last date of change */
	proc_switch( argc,argv, MAINFL ); 	/* process the switches */
	Argc = argc;
	Argv = argv;

	if( Initialize(terminal) <0 )	/* initialize profom and screen */
		exit(-1);
	retval = Process();		/* process the user's options */
	CleanExit();		/* Wind up the show */
}
CleanExit()/* clear and exit the screen , close files & exit program */
{
	fomcs();
	fomrt();
	close_dbh();
	exit(retval);
}
Initialize( terminal )	/* initialize profom and screen */
char *terminal;
{
	if( InitProfom(terminal)<0 ){	/* initialize profom */
		fomcs();
		fomrt();
		return( -1 );
	}
	if( InitScreen()<0 ){		/* initialize screen */
		fomcs();
		fomrt();
		return(-1);
	}
	return(0);
}	
InitProfom(terminal)	/* initialize profom */
char *terminal;
{
	strcpy( sr.termnm, terminal );
	fomin( &sr );
	ret( err_chk(&sr) );	/* if profom error return */
	fomcf(1,1);
	return(0);
}
InitScreen()		/* initialize the screen */
{
	/* initialize the profom screen variables */
	strcpy( sr.scrnam, NFM_PATH );
	strcat( sr.scrnam, SCREEN_NAME );

	/* initialize the fields of the profom screen */
	if( FillScrHdg()<0 ) 				return(-1);

	if( FillKeyFields( LOW )<0 ) 			return(-1);

	if( FillFieldNum( HIGH )<0 ) 			return(-1);
	if( FillHeaderFields( HIGH )<0 ) 		return(-1);

	if( FillSeperatorLine(HIGH)<0 ) 		return(-1);
	if( FillItemLines( HIGH,1,ITEMSPERPAGE )<0 )	return(-1);

	if( FillMsgRespFields( HIGH )<0 ) 		return(-1);

	if( WriteFields(1,0)<0 )			return(-1);

	return(0);
}
/* Fill the screen heading fields, the program name and the date */
FillScrHdg()
{
	strcpy( s_rec.s_progname, PROG_NAME );

	s_rec.s_rundt = get_date();
	return(0);
}
/* Fill the keyfields with high or low values */
FillKeyFields( value )
short value;
{
	s_rec.s_type[0] = HL_CHAR( value );
	s_rec.s_fund    = value * HV_SHORT;
	s_rec.s_invoice = value * HV_LONG;
	s_rec.s_sno     = value * HV_SHORT;

	return(0);
}
/* Fill the field# field with high/low values */
FillFieldNum( value )
short value;
{
	s_rec.s_fld_no = value * HV_SHORT;
	return(0);
}
/* Fill the transaction header part with high/low values */
FillHeaderFields( value )
short value;
{
	/* The following fields are used by IN or CM or DM types */
	s_rec.s_cucode[0]	= HL_CHAR( value );
	s_rec.s_trandt 		= value * HV_LONG;
	s_rec.s_oriamt 		= value * HV_DOUBLE;
	s_rec.s_period 		= value * HV_SHORT;
	s_rec.s_remarks[0]	= HL_CHAR( value );

	/* The following fields are to be displayed only if type is IN */
	if( memotype!=IN && s_rec.s_invoice!=g_invnbr)
		value = HIGH; /* force High values */

	s_rec.s_duedt 		= value * HV_LONG;
	s_rec.s_gramt 		= value * HV_DOUBLE;
	s_rec.s_PSTpercent 	= value * HV_DOUBLE;
	s_rec.s_PSTtaxamt 	= value * HV_DOUBLE;
	s_rec.s_GSTpercent 	= value * HV_DOUBLE;
	s_rec.s_GSTtaxamt	= value * HV_DOUBLE;
	s_rec.s_netamt 		= value * HV_DOUBLE;
	s_rec.s_balance 	= value * HV_DOUBLE;

	return(0);
}
/* Fill the message and response fields with high or low values */
FillMsgRespFields( value )
short value;
{
	s_rec.s_tot_invoice = value * HV_DOUBLE;
	s_rec.s_tot_gst = value * HV_DOUBLE;
	s_rec.s_tot_pst = value * HV_DOUBLE;
	s_rec.s_grand_tot = value * HV_DOUBLE;
	s_rec.s_mesg[0] = HL_CHAR( value );
	s_rec.s_resp[0] = HL_CHAR( value );

	return(0);
}
/* Fill the Xaction item array with high or low values */
FillItemLines( value,firstline,lastline )
int value;
short firstline, lastline;
{
	short i;

	s_rec.s_page = value * HV_SHORT;
	for( i=firstline-1; i<lastline; i++ ){
		s_rec.s_entries[i].s_accno[0] = HL_CHAR(value);
		s_rec.s_entries[i].s_amount = value * HV_DOUBLE;
		s_rec.s_entries[i].s_status[0] = HL_CHAR(value);
		s_rec.s_entries[i].s_desc[0] = HL_CHAR(value);
		s_rec.s_entries[i].s_dummy = HV_SHORT;
	}
	return(0);
}
/* Accept user's option and call the corresponding routine in a loop */
Process()
{
	/* get the parameter record */
	retval = get_param( &param_rec, BROWSE, 1, e_mesg );
	if( retval < 0 ){
		fomen(e_mesg);
		get();
		return(retval);
	}
	s_rec.s_fund = 1;
	s_rec.s_invoice = 0;	/* initializing the key fields */
	s_rec.s_sno = 0;	/* useful if N(ext) option is selected first */
	for( ; ; ){
		if( ReadFunction()<0 ) return(-1);
		switch( s_rec.s_fn[0] ){
			case ADDREC:	/* add a transaction list */
				if( param_rec.pa_cur_period==0 ){
#ifdef ENGLISH
				   fomen("Addition invalid in period 0");
#else
				   fomen("Ajout invalide dans la periode 0");
#endif
				   get();
				   break;
				}
				CHKACC(retval,ADD,e_mesg);
				retval = AddRecords();
				if( retval<0 ){
					roll_back(e_mesg);
					return(-1);
				}
				break;
			case NEXT:	/* show next Xaction list in sequence */
				if(s_rec.s_tot_invoice != HV_DOUBLE) {
					s_rec.s_tot_invoice = HV_DOUBLE;
					s_rec.s_tot_gst = HV_DOUBLE;
					s_rec.s_tot_pst = HV_DOUBLE;
					s_rec.s_grand_tot = HV_DOUBLE;
				}
				if(WriteFields(TOT_INV_FLD,GRANDTOT_FLD) <0)
					return(-1);
				CHKACC(retval,BROWSE,e_mesg);
				if( Inquire(SEQUENTIAL,FORWARD)<0 ) return(-1);
				break;
			case PREV:	/* show prev Xaction list in sequence */
				if(s_rec.s_tot_invoice != HV_DOUBLE) {
					s_rec.s_tot_invoice = HV_DOUBLE;
					s_rec.s_tot_gst = HV_DOUBLE;
					s_rec.s_tot_pst = HV_DOUBLE;
					s_rec.s_grand_tot = HV_DOUBLE;
				}
				if(WriteFields(TOT_INV_FLD,GRANDTOT_FLD) <0)
					return(-1);
				CHKACC(retval,BROWSE,e_mesg);
				if( Inquire(SEQUENTIAL,BACKWARD)<0 ) return(-1);
				break;
			case INQUIRE:	/* show selected Xaction list */
				if(s_rec.s_tot_invoice != HV_DOUBLE) {
					s_rec.s_tot_invoice = HV_DOUBLE;
					s_rec.s_tot_gst = HV_DOUBLE;
					s_rec.s_tot_pst = HV_DOUBLE;
					s_rec.s_grand_tot = HV_DOUBLE;
				}
				if(WriteFields(TOT_INV_FLD,GRANDTOT_FLD) <0)
					return(-1);
				CHKACC(retval,BROWSE,e_mesg);
				if( Inquire(RANDOM,0)<0 ) return(-1);
				break;
			case EXITOPT:	/* exit */
				return(0);
			default:
				break;
		}
		if( retval<0 ){
			fomen(e_mesg);
			get();
		}
		if( retval==DBH_ERR )
			return(retval);
	}
}
SetDupBuffers( firstfld, lastfld, value )
int	firstfld, lastfld;	/* field numbers range */
int	value;			/* ENABLE or DISABLE */
{
	int i;

	for( i=firstfld; i<=lastfld; i+=100 )
		fomca1( i, 19, value);
	if( value==0 )		/* if disabling dup buffers */
		return(0);

	sr.nextfld = firstfld;
	sr.endfld = lastfld;
	fomud( (char *)&s_rec );
	ret( err_chk(&sr) );

	return( 0 );
}
ReadFunction()	/* Display options at the bottom and read entry */
{
#ifdef ENGLISH
	fomer("A(dd), N(ext), P(rev), I(nquire), E(xit)");
#else
	fomer("R(ajouter), S(uivant), P(recedent), I(nterroger), F(in)");
#endif
	sr.nextfld = FN_FLD;	/* Fn field number */
	fomrf( (char *)&s_rec );
	ret( err_chk(&sr) );
	return(0);
}
/* Add a complete Xaction, with 1 header & a no. of item records */
AddRecords()
{
	int index; 

	if( ClearScreen() < 0 )	return(-1);
	if( SetDupBuffers(FUND_FLD,SNO_FLD,0)<0 )
		return(-1);
	if( (retval=ReadKeyFields())<0 ) return(retval);
	if(retval==EXIT){
		if(ClearScreen()<0) return(-1);
		roll_back(e_mesg);
		return(retval);
	}

	/* show current system date as default transaction date */
	s_rec.s_trandt = s_rec.s_rundt;	/* system date */
	s_rec.s_duedt = date_plus( s_rec.s_rundt, param_rec.pa_due_days_ar);
	if( SetDupBuffers(TRANDT_FLD,DUEDT_FLD,1)<0 )
		return(-1);
	s_rec.s_period = param_rec.pa_cur_period;
	if( SetDupBuffers(PERIOD_FLD,PERIOD_FLD,1)<0 )
		return(-1);

	ctl_rec.fund = (short)s_rec.s_fund;
	index = get_ctl( &ctl_rec, BROWSE, 0, e_mesg );
	if( index==ERROR ){
		fomen(e_mesg); get();
		return(-1);
	}

	s_rec.s_GSTpercent = ctl_rec.gst_tax/1.00;
	if( SetDupBuffers(GSTPERC_FLD,GSTPERC_FLD,1)<0 )
		return(-1);
	s_rec.s_PSTpercent = ctl_rec.pst_tax/1.00;	
	if( SetDupBuffers(PSTPERC_FLD,PSTPERC_FLD,1)<0 )
		return(-1);

	if( FillHeaderFields(LOW)<0 ) return(-1);

	if( s_rec.s_fn[0]==ADDREC && memotype!=IN && s_rec.s_invoice!=g_invnbr){
		retval = RdCustomer();
		if(retval < 0)
			return(retval);
	}

	if(retval==EXIT){
		if(ClearScreen()<0)
			return(-1);
		roll_back(e_mesg);
		return(retval);
	}

	if( (retval=ReadFields(CUST_FLD,REMARKS_FLD))<0 )
		return(retval);/* read header fields */

	if( SetDupBuffers(TRANDT_FLD,DUEDT_FLD,0)<0 )
		return(-1);
	if( SetDupBuffers(GSTPERC_FLD,GSTPERC_FLD,0)<0 )
		return(-1);
	if( SetDupBuffers(PSTPERC_FLD,PSTPERC_FLD,0)<0 )
		return(-1);
	if( SetDupBuffers(PERIOD_FLD,PERIOD_FLD,0)<0 )
		return(-1);

	if(retval==EXIT){
		if(ClearScreen()<0)	return(-1);
		roll_back(e_mesg);
		return(retval);
	}
	if( (retval=ConfirmHeader())<0 )	return(retval);
	if( retval==EXIT ){
		if(ClearScreen()<0)	return(-1);
		roll_back(e_mesg);
		return(retval);
	}
	s_rec.s_seperator[0] = '-';
	if( WriteFields(SEPARATOR_FLD,SEPARATOR_FLD)<0 )	return(-1);
	if( (retval=ReadItemFields())<0 )
		return(retval);
	
	for( ; ; ) {
		retval = ConfirmItems(ADD_MODE);/* Allow changing of entered values */
		if( retval<0 )	return(retval);
		if( retval==EXIT ){
			roll_back(e_mesg);
			if(ClearScreen()<0)		/* Clear the screen */
				return(-1);	
			return(EXIT);
		}
		retval=WriteSession();
		unlock_file(GLTRHDR);
		close_file(GLTRHDR);
		if(retval < 0) {
			if (retval == LOCKED) continue;
			roll_back(e_mesg);
			return(-1);
		}
		break;
	}
	return( FreeList() );
}
RdCustomer()
{
	strcpy( s_rec.s_cucode, in_hdr.ah_cu_code );
	strcpy( cu_rec.cu_code, s_rec.s_cucode );
	retval = get_cust( &cu_rec,UPDATE,0,e_mesg );
	if( retval==ERROR ){
		fomen(e_mesg);
		get();
		return( retval );
	}	
	else if( retval!=NOERROR ){
		fomen(e_mesg);
		get();
		return( EXIT );
	}
	return(0);
}
ReadKeyFields()	/* Read fund, show invoice# and s# under invoice */
{
	int retval;

	if( FillKeyFields(LOW)<0 )
		return(-1);
#ifdef ENGLISH
	fomer("Valid types are IN, CM, DM");
#else
	fomer("Genres valables sont FC, NC, ND");
#endif
	fund_default();
	retval = ReadFields(TYPE_FLD,FUND_FLD);
	if( retval<0 || retval==EXIT )
		return(retval);

	if( strcmp( s_rec.s_type,T_INVOICE )==0 )
		memotype = IN;
	else if( strcmp( s_rec.s_type,T_DBMEMO )==0 )
		memotype = DM;
	else if( strcmp( s_rec.s_type,T_CRMEMO )==0 )
		memotype = CM;

/**
	if( memotype!=IN ){	* Read invoice# also *
		retval = ReadFields(INVOICE_FLD,INVOICE_FLD);
		if( retval<0 || retval==EXIT )
			return(retval);
	}
**/
	if(memotype==IN) {
		if( GetNextSerialNo(INVCNBR)<0 )
			return(-1);
		if( WriteFields(INVOICE_FLD,SNO_FLD)<0 )
			return(-1);
	}
	else {
		if( GetNextSerialNo(MEMONBR)<0 )
			return(-1);
		if( WriteFields(INVOICE_FLD,SNO_FLD)<0 )
			return(-1);
	}

	if(memotype!=IN) {
		if(SetDupBuffers(INVOICE_FLD,INVOICE_FLD,1)<0)
			return(-1);
		s_rec.s_invoice=LV_LONG;
		retval=ReadFields(INVOICE_FLD,INVOICE_FLD);
		if(retval<0 || retval==EXIT)
			return(retval);
	}
	return(0);
}
GetNextSerialNo(generate) /* Generate the next serial no. (part of the key) */
int	generate;	  /* 1-Generate Invoice Nbr, 2-generate DM/CM Nbr. */
			  /* 3-Generate Seq No. */
{
#ifdef	ORACLE
	long	sno, get_maxsno() ;
#endif

	if( generate==IN || generate == MEMONBR){ /* Invoice is being added */
		/* If invoice, generate next invoice# and set serial# to 1 */
		/* Move highs to invoice no & access previous rec in sequence */

		ar_hdr.ah_fund = s_rec.s_fund;
#ifndef	ORACLE
		if(generate==MEMONBR)
			ar_hdr.ah_inv_no = HV_LONG;
		else
			ar_hdr.ah_inv_no = 89999999;

		flg_reset(ARSHDR);
		retval = get_n_arhdr( &ar_hdr,BROWSE,0,BACKWARD,e_mesg );
		seq_over(ARSHDR);
		if( retval==ERROR ){
			fomen(e_mesg); get();
			return(retval);
		}
	
		if( ar_hdr.ah_fund!=s_rec.s_fund || retval==EFL ){
			ar_hdr.ah_fund = s_rec.s_fund;
			s_rec.s_invoice = 1;
		}
		else
			s_rec.s_invoice = ar_hdr.ah_inv_no+1;

		if(generate==MEMONBR && s_rec.s_invoice < 90000000)
			s_rec.s_invoice=90000000;

		g_invnbr=s_rec.s_invoice;
#else
		/* Get maximum invoice number(i.e on 2nd part of key) */
		sno = get_maxsno(ARSHDR, (char*)&ar_hdr, 0, 1, e_mesg) ;
		if( sno < 0 ){
			fomen(e_mesg); get();
			return(sno);
		}
		s_rec.s_invoice = sno + 1;

		g_invnbr=s_rec.s_invoice;
#endif

		s_rec.s_sno = 1;
	}
	else{	/* Debit memo or credit memo */
		/* generate next serial# by reading fund & invoice# */
		/* Move highs to serial# & access previous rec in sequence */

		ar_hdr.ah_fund = s_rec.s_fund;
		ar_hdr.ah_inv_no = s_rec.s_invoice;
#ifndef	ORACLE
		ar_hdr.ah_sno = HV_SHORT;
		flg_reset(ARSHDR);
		retval = get_n_arhdr( &ar_hdr,BROWSE,0,BACKWARD,e_mesg );
		seq_over(ARSHDR);
		if( retval==ERROR ){
			fomen(e_mesg); get();
			return(-1);
		}
		if( ar_hdr.ah_fund!=s_rec.s_fund ||
		    ar_hdr.ah_inv_no!=s_rec.s_invoice ||
		    retval==EFL ){
#ifdef ENGLISH
			fomen("No prior invoice exists for this memo. Press any key");
#else
			fomen("Facture anterieure n'existe pas pour cette note. Appuyer sur une touche");
#endif
			get();
			return(EXIT);
		}
		else
			s_rec.s_sno = ar_hdr.ah_sno + 1;
#else
		/* Get maximum sno under invoice (i.e on last part of key) */
		sno = get_maxsno(ARSHDR, (char*)&ar_hdr, 0, -1, e_mesg) ;
		if( sno < 0 ){
			fomen(e_mesg); get();
			return(sno);
		}
		if( sno == 0 ){		/* Invoice not exists */
#ifdef ENGLISH
			fomen("No prior invoice exists for this memo. Press any key");
#else
			fomen("Facture anterieure n'existe pas pour cette note. Appuyer sur une touche");
#endif
			get();
			return(EXIT);
		}
		s_rec.s_sno = sno + 1;
#endif
	}

	/*** set due_date for Applied DM/CM to same as invoice ***/
	dm_cm_duedt = ar_hdr.ah_duedt;
	return(0);
}
ReadFields(start,end)	/* read the given range of fields */
int start, end;		/* start and end profom field numbers */
{
	int retval;
	static	int tmp_fld;

	sr.nextfld = start;
	sr.endfld = end;
	for( ; ; ){	/* Do in a loop */
		tmp_fld = sr.endfld;
		fomrd( (char *)&s_rec );
		sr.endfld = tmp_fld;
		ret(err_chk(&sr));		/* Check for profom error */
		if( sr.retcode==RET_USER_ESC || sr.retcode==RET_VAL_CHK ){
		    if( sr.retcode==RET_USER_ESC ){
			if( (sr.escchar[0]=='F' || sr.escchar[0]=='f') && 
				s_rec.s_resp[0]!=EDIT &&
				s_rec.s_resp[0]!=DELETE &&
				s_rec.s_resp[0]!=REVIVE &&
				s_rec.s_resp[0]!=TOTAL )
				return( EXIT );
			else if( sr.escchar[0]=='H' || sr.escchar[0]=='h' ){
				if( NO_HLP_WIN )
					continue;
			}
			else
				continue;
		    }
		    retval = Validate();
		    if(retval < 0 || retval == EXIT)
			return(retval);
		    else
			continue;
		}
		break;
	}
	return(0);
}
WriteFields( start,end )/* write fields whose numbers range from start to end */
int start, end;
{
	sr.nextfld = start;
	sr.endfld = end;
	fomwr( (char *)&s_rec );
	ret( err_chk(&sr) );
	return(0);
}
ClearScreen()	/* clear the screen except fn field and screen heading */
{
	if(FillFieldNum(HIGH)<0 ) return(-1);
	if(FillHeaderFields(HIGH)<0 ) return(-1);
	if(FillSeperatorLine(HIGH)<0 ) return(-1);
	if(FillItemLines(HIGH,1,ITEMSPERPAGE)<0 ) return(-1);
	if(FillMsgRespFields(HIGH)<0 ) return(-1);

	if( WriteFields(EDIT_FLD,RESP_FLD)<0 ) return(-1);
	
	return(0);
}
Validate()	/* Validate the values entered by the user */
{
	Gl_rec temp_rec;
	int index, mode;
	int	temp_fld;
	short	reccod;
	double 	amount;
	Ar_hdr	*ptr;
        double  GST_Temp;

	switch( sr.curfld ){
		case TYPE_FLD:	/* Memo type */
			if( strcmp(s_rec.s_type,T_INVOICE) &&
			    strcmp(s_rec.s_type,T_CRMEMO) &&
			    strcmp(s_rec.s_type,T_DBMEMO) ){
				s_rec.s_type[0] = LV_CHAR;
			}
			break;
		case FUND_FLD:	/* fund code */
			ctl_rec.fund = (short)s_rec.s_fund;
/*  Sept 26, 1990.  Not necessary to lock file
			mode = strcmp(s_rec.s_type,T_INVOICE) ? BROWSE : UPDATE;
*/
			index = get_ctl( &ctl_rec, BROWSE, 0, e_mesg );
			if( index==ERROR ){
				fomen(e_mesg); get();
				return(-1);
			}
			if( index!=NOERROR ){
				fomer(e_mesg);
				s_rec.s_fund = LV_SHORT;
			}
			break;
		case INVOICE_FLD:	/* Invoice number */
			/*  This field is read if a DM/CM is added or  */
			/*  inquiry is done on a key  */
			if( s_rec.s_fn[0]==ADDREC && s_rec.s_invoice!=g_invnbr){
				ptr = &in_hdr;
				index = UPDATE;
			}
			else{
				ptr = &ar_hdr;
				index = BROWSE;
			}

			if(s_rec.s_fn[0]==ADDREC &&
				s_rec.s_invoice==g_invnbr) break;

			ptr->ah_fund = s_rec.s_fund;
			ptr->ah_inv_no = s_rec.s_invoice;
			ptr->ah_sno = 1;	
			retval = get_arhdr( ptr,index,0,e_mesg );
			if( retval==ERROR ){
				fomen( e_mesg );
				get();
				return( retval );
			}
			if( retval!=NOERROR ){
#ifdef ENGLISH
				fomer("Invoice with given number not found");
#else
				fomer("Facture avec le numero donne pas retrouvee");
#endif
				s_rec.s_invoice = LV_LONG;
				break;
			}
			if( s_rec.s_fn[0]==ADDREC && ptr->ah_status[0]!=OPEN ){
#ifdef ENGLISH
				fomer("Invoice with given number not open");
#else
				fomer("Facture avec le numero donne pas ouverte");
#endif
				s_rec.s_invoice = LV_LONG;
				break;
			}
			if(s_rec.s_fn[0]==ADDREC) {
				if(GetNextSerialNo(SEQNO)<0)
					return(-1);
				if(WriteFields(SNO_FLD,SNO_FLD)<0)
					return(-1);
			}
			break;
		case SNO_FLD:	/* serial number under the invoice */
			/* This field is read only in inquire mode */
			ar_hdr.ah_fund = s_rec.s_fund;
			ar_hdr.ah_inv_no = s_rec.s_invoice;
			ar_hdr.ah_sno = s_rec.s_sno;	
			retval = get_arhdr( &ar_hdr,BROWSE,0,e_mesg );
			if( retval==ERROR ){
				fomen( e_mesg );
				get();
				return( retval );
			}
			else if( retval!=NOERROR ){
				fomer(e_mesg);
				s_rec.s_sno = LV_SHORT;
			}
			break;
		case EDIT_FLD:	/* field # for editing */
			if( sr.fillcode==FIL_OMITTED )	return(EXIT);
			break;
		case CUST_FLD:	/* Customer code */
			Right_Justify_Numeric(s_rec.s_cucode,
					sizeof(s_rec.s_cucode)-1);
			if( ESC_H ){
			   retval = cust_hlp(s_rec.s_cucode, 7, 15 );
			   if( retval<0 )	/* error */
					return( retval );
			   if( retval>=0 )
					redraw(); /* remove hlp window*/
			   if( retval==0 ) 	/* nothing selected */
				break;
			}
			strcpy( cu_rec.cu_code, s_rec.s_cucode );
			retval = get_cust( &cu_rec,UPDATE,0,e_mesg );
			if( retval==ERROR ){
				fomen(e_mesg);
				get();
				return( retval );
			}	
			else if( retval==UNDEF ){
			 retval = GetOpt(
#ifdef ENGLISH
			 "Customer not found. Want to add one (Y/N)?","YN");
#else
			 "Client pas retrouve. Desirez-vous en ajouter un (O/N)?","ON");
#endif
				if( retval<0 )	return(retval);
				if( retval==YES ){
				   retval=execute( "customer", Argc, Argv );
				   if( retval<0 )
					return( retval );
				   redraw();
				}
				s_rec.s_cucode[0] = LV_CHAR;
			}
			else if( retval!=NOERROR ){
				fomer( e_mesg );
				s_rec.s_cucode[0] = LV_CHAR;
			}
			else
				fomer(cu_rec.cu_name);
			break;
		case TRANDT_FLD:	/* date of transaction */
			if( s_rec.s_trandt>s_rec.s_rundt ){
#ifdef ENGLISH
				fomer("Invalid transaction date");
#else
				fomer("Date de transaction invalide");
#endif
				s_rec.s_trandt = LV_LONG;
				break;
			}
			if( memotype!=IN && s_rec.s_trandt<in_hdr.ah_trandt ){
#ifdef ENGLISH
				fomer("Memo date can't precede invoice date");
#else
				fomer("Date de la note ne peut pas preceder la date de la facture");
#endif
				s_rec.s_trandt = LV_LONG;
				break;
			}
			if( s_rec.s_resp[0]==EDIT && memotype==IN &&
			    s_rec.s_trandt>s_rec.s_duedt){
				retval = ModifyField(DUEDT_FLD);
				if( retval<0 )	return(retval);
				if( retval==EXIT ){
					if( HideFldNo()<0 ) return(-1);
						break;
				}
			}
			break;
		case DUEDT_FLD:	/* due date */
			if( s_rec.s_duedt<s_rec.s_trandt ){
#ifdef ENGLISH
				fomer("Date can't precede transaction date");
#else
				fomer("Date ne peut pas preceder la date de la transaction");
#endif
				s_rec.s_duedt = LV_LONG;
			}
			break;
		case ORIAMT_FLD:	/*(original invoice amount) or (DM/CM)amount  */
/*
			if( s_rec.s_oriamt<DELTA_AMT ){
*/
			if( s_rec.s_oriamt < 0.00 ){
#ifdef ENGLISH
				fomer("Invalid amount");
#else
				fomer("Montant invalide");
#endif
				s_rec.s_oriamt = LV_DOUBLE;
				break;
			}
			if( memotype==IN || s_rec.s_invoice==g_invnbr ){
				s_rec.s_gramt = s_rec.s_oriamt; 
				s_rec.s_netamt = s_rec.s_oriamt;
				s_rec.s_balance = s_rec.s_netamt;
			}
			else if( memotype==CM && s_rec.s_sno!=1 ){
			  if( in_hdr.ah_gramt-s_rec.s_oriamt < (-DELTA_AMT) ){
#ifdef ENGLISH
			   sprintf(e_mesg,
				"Credit can't exceed Gross amount: %.2lf !",
				in_hdr.ah_gramt );
#else
			   sprintf(e_mesg,
				"Credit ne peut pas depasser le montant brut: %.2lf !",
				in_hdr.ah_gramt );
#endif
			   fomer( e_mesg );
			   s_rec.s_oriamt = LV_DOUBLE;
			  }
			  s_rec.s_balance = s_rec.s_netamt;
			}
			break;
		case GSTPERC_FLD:	/* GST tax percent */
			if( s_rec.s_GSTpercent>=100.0 ){
#ifdef ENGLISH
				fomer("GST must be less than 100%");
#else
				fomer("TPS doit etre moins que 100%");
#endif
				s_rec.s_GSTpercent = LV_DOUBLE;
				break;
			}
			if( s_rec.s_GSTpercent>= 0.0 ){
				GST_Temp = s_rec.s_oriamt*(1 +
						 ( s_rec.s_GSTpercent/100.00));
				s_rec.s_GSTtaxamt =  s_rec.s_oriamt*
						 ( s_rec.s_GSTpercent/100.00);
				s_rec.s_GSTtaxamt=D_Roundoff(s_rec.s_GSTtaxamt);
                                s_rec.s_balance = D_Roundoff(GST_Temp);
			        s_rec.s_netamt=s_rec.s_oriamt+s_rec.s_GSTtaxamt;
				s_rec.s_netamt=D_Roundoff(s_rec.s_netamt);
				s_rec.s_gramt = s_rec.s_netamt;
				s_rec.s_gramt=D_Roundoff(s_rec.s_gramt);
				temp_fld = sr.endfld;
				if(WriteFields(GRAMT_FLD,GRAMT_FLD) <0)
					return(-1);
				if(WriteFields(NETAMT_FLD,NETAMT_FLD) <0)
					return(-1);
				if(WriteFields(BALANCE_FLD,BALANCE_FLD) <0)
					return(-1);
				sr.endfld = temp_fld;
				sr.curfld = GSTPERC_FLD;
                                GST_Temp = 0;
			}
			break;

		case GSTAMT_FLD:	
			if( s_rec.s_GSTtaxamt > s_rec.s_netamt/2 ){
#ifdef ENGLISH
			   fomer("Tax amount can't exceed half of Total Amount");
#else
			   fomer("Montant de la taxe ne peut pas depasser la moitie du montant total");
#endif
				s_rec.s_GSTtaxamt = LV_DOUBLE ;
				break;
			}
			break;

		case PSTPERC_FLD:	/* PST tax percent */
			if( s_rec.s_PSTpercent>=100.0 ){
#ifdef ENGLISH
				fomer("PST must be less than 100%");
#else
				fomer("TVP doit etre moins que 100%");
#endif
				s_rec.s_PSTpercent = LV_DOUBLE;
				break;
			}
			if( s_rec.s_PSTpercent>=0.0 ){
				s_rec.s_netamt = s_rec.s_netamt*(1 +
						 ( s_rec.s_PSTpercent/100));
				s_rec.s_netamt = D_Roundoff(s_rec.s_netamt);
				s_rec.s_PSTtaxamt = 
					s_rec.s_netamt - s_rec.s_oriamt - s_rec.s_GSTtaxamt;
				s_rec.s_PSTtaxamt=D_Roundoff(s_rec.s_PSTtaxamt);
                                s_rec.s_balance = s_rec.s_netamt;
				s_rec.s_balance = D_Roundoff(s_rec.s_balance);
				s_rec.s_gramt = s_rec.s_netamt;
				s_rec.s_gramt = D_Roundoff(s_rec.s_gramt);
				temp_fld = sr.endfld;
				if(WriteFields(GRAMT_FLD,GRAMT_FLD) <0 )
					return (-1);
				if(WriteFields(NETAMT_FLD,NETAMT_FLD) <0)
					return(-1);
				if(WriteFields(BALANCE_FLD,BALANCE_FLD) <0)
					return(-1);
				sr.endfld = temp_fld;
				sr.curfld = PSTPERC_FLD;
			}
			break;
		case PSTAMT_FLD:	
			if( s_rec.s_PSTtaxamt>s_rec.s_oriamt/2 ){
#ifdef ENGLISH
			   fomer("PST amount can't exceed half of Total Amount");
#else
			   fomer("Montant de la TVP ne peut pas depasser la moitie du montant total");
#endif
				s_rec.s_PSTtaxamt = LV_DOUBLE ;
				break;
			}
			break;
		case PERIOD_FLD:	/* period */
			if( s_rec.s_period<
			    param_rec.pa_cur_period-param_rec.pa_open_per || 
			    s_rec.s_period> param_rec.pa_cur_period ||
			    s_rec.s_period<1 ){
#ifdef ENGLISH
				fomer("Period invalid or not open");
#else
				fomer("Periode invalide ou pas ouverte");
#endif
				s_rec.s_period = LV_SHORT;
			}
			break;
		case ACCOUNT1_FLD:	/* account number fields */
		case ACCOUNT2_FLD:
		case ACCOUNT3_FLD:
			index = (sr.curfld - ACCOUNT1_FLD) / STEP;
			if( ESC_H ){
/* removed to allow help   if( memotype==IN || s_rec.s_invoice==g_invnbr){ */
			  
				retval = gl_hlp(s_rec.s_fund,
					s_rec.s_entries[index].s_accno,
					&reccod,
					7, 15 );
                          /***** }
			   else
				retval = dm_cm_hlp(s_rec.s_fund,s_rec.s_invoice,
removed to always allow help         s_rec.s_entries[index].s_accno,
						7,15 );
			   *****/
			   if( retval<0 ){
#ifdef ENGLISH
				fomen("Error in help window");
#else
				fomen("Erreur dans la fenetre d'assistance");
#endif
				get();
				return( retval );
			   }
			   if( retval>=0 ){	/* nothing selected */
				redraw(); 	/* remove hlp window */
			   }
			   if( retval==1 ){/* selected */
					/* check for reccod compatibility */
				if( reccod!=99 ){
#ifdef ENGLISH
				   fomer("Valid record code is 99. Try again");
#else
				   fomer("Code de fiche valable est 99. Reessayer");
#endif
				   s_rec.s_entries[index].s_accno[0]=LV_CHAR;
				   sr.nextfld = sr.curfld;
				   break;
				}
			   }
			   else if( retval==2 ){/* Only one account in list */
#ifdef ENGLISH
				  fomer("Only one account in the distribution");
#else
				  fomer("Seulement un compte dans la distribution");
#endif
				  break;
			   }
			}
			else {	/* user entered an account number */
			   	if(acnt_chk(s_rec.s_entries[index].s_accno)==
					ERROR){
#ifdef ENGLISH
					fomer("Invalid Account number");
#else
					fomer("Numero de compte invalide");
#endif
					s_rec.s_entries[index].s_accno[0]=
						LV_CHAR;
					break;
			   }
				retval = VerifyAccount(index,&temp_rec); 
				if( retval==ERROR )	return(-1);
				if( retval!=NOERROR ){
					s_rec.s_entries[index].s_accno[0]=
						LV_CHAR;
#ifdef ENGLISH
					fomer("Invalid Account number");
#else
					fomer("Numero de compte invalide");
#endif
				}
				else{
					fomer(temp_rec.desc);
				/*	fomer("2 Valid Account number");*/
				}

			}
			break; 
		case AMOUNT1_FLD:	/* amount fields */
		case AMOUNT2_FLD:
		case AMOUNT3_FLD:
			index = (sr.curfld - ACCOUNT1_FLD) / STEP;
			amount = s_rec.s_entries[index].s_amount ;
/*
			if( amount < DELTA_AMT ){
*/
			if( amount < 0.00 ){
#ifdef ENGLISH
				fomer("Amount too small for transaction");
#else
				fomer("Montant trop petit pour transaction");
#endif
				s_rec.s_entries[index].s_amount = LV_DOUBLE;
			}
			break;
	}
	sr.nextfld = sr.curfld;
	return(0);
}
VerifyAccount(index,temp_rec) /* Check if a record exists in the GL master */
int index;
Gl_rec *temp_rec;
{
	int ret_val;

	temp_rec->funds = (short)s_rec.s_fund;
	strcpy( temp_rec->accno,s_rec.s_entries[index].s_accno );
/*	Right_Justify_Numeric(temp_rec->accno,
		sizeof(temp_rec->accno)-1); */
	temp_rec->reccod = 99;
	ret_val = get_gl( temp_rec,UPDATE,0,e_mesg );
	if(ret_val!=NOERROR ){
		fomen(e_mesg);
		get();
		return(ret_val);
	}
	return(0);
}
ConfirmHeader()	/* Ask if user wants to edit hdr items before going to items */
{
	for( ; ; ){
#ifdef ENGLISH
		if(DisplayMessage( "A(dd items), E(dit), C(ancel)")<0 ) 
#else
		if(DisplayMessage( "R(ajouter articles), M(odifier), A(nnuler)")<0 )
#endif
			return(-1);
		sr.nextfld = RESP_FLD;
		fomrf( (char *)&s_rec );
		ret( err_chk(&sr) );
		switch( s_rec.s_resp[0] ){
			case ADDREC:	/* Go to addition of items */
				if( HideMessage()<0 ) return(-1);
				return(0);
			case EDIT:	/* Edit the fields in header */
				if( (retval=EditHeaderFields())<0 )
					return(retval);
				break;
			case CANCEL:	/* Cancel the session */
				retval = DisplayMessage(
#ifdef ENGLISH
					"Confirm the Cancel (Y/N)?" );
#else
					"Confirmer l'annulation (O/N)?" );
#endif
				if( retval<0 ) return( retval );
				sr.nextfld = RESP_FLD;
				fomrf( (char *)&s_rec );
				ret( err_chk(&sr) );
				if( s_rec.s_resp[0]!=YES )
					continue;
				if( HideMessage()<0 ) return(-1);
				return(EXIT);
		}
	}
}
DisplayMessage(mesg)	/* Display the given message in the message field */
char *mesg;
{
	strcpy( s_rec.s_mesg, mesg );
	if( WriteFields(MESG_FLD,MESG_FLD)<0 )	return(-1);
	return(0);
}
HideMessage()	/* Hide the message field */
{
	if( FillMsgRespFields(HIGH)<0 )	return(-1);
	if( WriteFields(MESG_FLD,RESP_FLD)<0 ) return(-1);
	return(0);
}
HideFldNo()	/* Hide the 'Field#' field */
{
	if( FillFieldNum(HIGH)<0 )	return(-1);
	if( (WriteFields(EDIT_FLD,EDIT_FLD))<0 )
		return(-1);
	return(0);
}
EditHeaderFields()	/* Read header field# and read corresponding field */
{
	int fld;

	for( ; ; ){
		if( FillFieldNum(LOW)<0 )	return(-1);
		if( (retval = ReadFields(EDIT_FLD,EDIT_FLD))<0 ) return(-1);
		if( retval == EXIT ){
			if( HideFldNo()<0 ) return(-1);
			break;
		}
		if( s_rec.s_fld_no < CUST_NO || s_rec.s_fld_no > REMARKS_NO ){
#ifdef ENGLISH
			fomer("Invalid field number");
#else
			fomer("Numero de champ invalide");
#endif
			continue;
		}
		if( memotype == IN || s_rec.s_invoice == g_invnbr ){ /*Invoice*/
			if( s_rec.s_fld_no == GROSSAMT_NO || 
			    s_rec.s_fld_no == TOTAL_NO ||
			    s_rec.s_fld_no == OUTSTANDING_NO ){
#ifdef ENGLISH
				fomer("Can't change specified field");
#else
				fomer("Ne peut pas changer le champ specifie");
#endif
				continue;
			}
		}
		else{		/* Editing a DM/CM */
			if(s_rec.s_sno != 1) {
				if( s_rec.s_fld_no != NETAMT_NO && 
				    s_rec.s_fld_no != TRANSDATE_NO &&
				    s_rec.s_fld_no != PERIOD_NO && 
				    s_rec.s_fld_no != REMARKS_NO){
#ifdef ENGLISH
					fomer("Can't change specified field");
#else
					fomer("Ne peut pas changer le champ specifie");
#endif
					continue;
				}
			}
			else {
				if( s_rec.s_fld_no == GROSSAMT_NO || 
			 	    s_rec.s_fld_no == TOTAL_NO ||
				    s_rec.s_fld_no == OUTSTANDING_NO ){
#ifdef ENGLISH
					fomer("Can't change specified field");
#else
					fomer("Ne peut pas changer le champ specifie");
#endif
					continue;
				}
			}
		}
		fld = (s_rec.s_fld_no * 100) + (CUST_FLD - 100);
		if( fld > ORIAMT_FLD && fld < PSTAMT_FLD ){
#ifdef ENGLISH
			fomer("Edit Original Amount First");
#else
			fomer("Modifier le montant original premierement");
#endif
			continue;
		}
	        if( fld > GSTAMT_FLD )
			fld = fld + 200;	
                retval = ModifyField(fld);
		if( retval<0 )
			return(retval);
		if( retval==EXIT ){
			if( HideFldNo()<0 ) return(-1);
			break;
		}
	}
	return(0);
}
ModifyField( fld )		/* Read & change the specified field */
int fld;
{
	int	i, j;
	char	buf[sizeof(s_rec.s_cucode)];

	sr.nextfld = sr.endfld = i = fld;
	if((memotype==IN || s_rec.s_invoice==g_invnbr) && 
	    fld > DUEDT_FLD && fld < NETAMT_FLD)
		sr.endfld = i = BALANCE_FLD;			
	for( j=fld; j<=i; j+=100 ){
		fomca1( j, 19, 1 );
	}
	fomud( (char *)&s_rec);
	sr.nextfld = fld;
	sr.endfld = i;
	switch(fld){
		case CUST_FLD:	/* customer code */
			strcpy( buf, s_rec.s_cucode );
			s_rec.s_cucode[0] = LV_CHAR;
			break;
		case TRANDT_FLD:	/* transaction date */
			s_rec.s_trandt = LV_LONG;
			break;
		case DUEDT_FLD:	/* due date */
			s_rec.s_duedt = LV_LONG;
			break;
		case ORIAMT_FLD:	/* invoice/DM/CM amount */
			s_rec.s_oriamt = LV_DOUBLE;
			s_rec.s_PSTpercent = LV_DOUBLE;
			s_rec.s_PSTtaxamt = LV_DOUBLE;
			s_rec.s_GSTpercent = LV_DOUBLE;
			s_rec.s_GSTtaxamt = LV_DOUBLE;
			break;
		case GSTPERC_FLD:	/* GST tax percent */
			s_rec.s_GSTpercent = LV_DOUBLE;
			s_rec.s_GSTtaxamt = LV_DOUBLE;
			break;
		case GSTAMT_FLD:	/* GST tax amount */
			s_rec.s_GSTtaxamt = LV_DOUBLE;
			break;
		case PSTPERC_FLD:	/* PST tax percent */
			s_rec.s_PSTpercent = LV_DOUBLE;
			s_rec.s_PSTtaxamt = LV_DOUBLE;
			break;
		case PSTAMT_FLD:	/* PST tax amount */
			s_rec.s_PSTtaxamt = LV_DOUBLE;
			break;
		case PERIOD_FLD:	/* period */
			s_rec.s_period = LV_SHORT;
			break;
		case REMARKS_FLD:	/* remarks */
			s_rec.s_remarks[0] = LV_CHAR;
			break;
	}
	retval = ReadFields( fld,i );
	for( j=fld; j<=i; j+=100 ){
		fomca1( j, 19, 0 );
	}
	if( retval == EXIT && fld == CUST_FLD )
		strcpy( s_rec.s_cucode, buf );
	return( retval );
}
Page *PageAllocated()	/* Allocate memory for 1 page of items on screen */
{
	return( (Page *)(malloc((unsigned)sizeof( Page ))) );
}
ReadItemFields()		/* Read the journal entry items */
{
	if(InitTotals() < 0)
		return(-1);

	headptr = tailptr = tempptr = NULL; 
	current.page = 0;
	current.line = ITEMSPERPAGE;	/* Initialize list & counter values */ 
	totalitemsadded = 0;

	if( AddItemsInLoop()<0 )	/* Read all the transactions */
		return(-1);
	return(0);
}
InitTotals()
{
	/*  Initialize totals  */
	s_rec.s_tot_invoice = 0.00;
	s_rec.s_tot_gst = 0.00;
	s_rec.s_tot_pst = 0.00;
	s_rec.s_grand_tot = 0.00;

/**	if(s_rec.s_sno > 1 && (s_rec.s_fn[0] == NEXT || 
				s_rec.s_fn[0] == PREV || 
				s_rec.s_fn[0] == INQUIRE)) {
**/
	if(s_rec.s_sno > 1) { 
		s_rec.s_PSTpercent = 0;
		s_rec.s_GSTpercent = 0;
	}

	return(NOERROR);
}
AddItemsInLoop()
{
	for( ; ; ){
		/* read one transaction- account#,amount */
		retval=ReadOneItem();   
		if( retval<0 ){
			FreeList();
			return(-1);
		}
		if (tailptr)
			tailptr->lines_entered = current.line;
		if( retval==EXIT || retval==ALLOC_ERROR )
			break;
	}
	return(0);
}
ReadOneItem()	/* read one transaction (one line on screen) */
{
	if( current.line == ITEMSPERPAGE ){ 
		retval = MakeFreshPage(); /* add new page to list */
		if( retval<0 || retval==ALLOC_ERROR )
			return( retval );
		current.page++;
		current.line = 1;
		if( PutPageNumber(current.page)<0 )
			return(-1);
	}
	else
		current.line++;

	if( FillItemLines(LOW,current.line,current.line)<0 )
		return(-1);
	if( memotype==IN || s_rec.s_invoice==g_invnbr ) /* Invoice */
#ifdef ENGLISH
		fomer("Press ESC-F to Quit");
#else
		fomer("Appuyer sur ESC-F pour retourner");
#endif
	else
#ifdef ENGLISH
		fomer("Press ESC-F to quit");
		strcpy(s_rec.s_entries[current.line-1].s_status, "ACT");
#else
		fomer("Appuyer sur ESC-F pour retourner");
		strcpy(s_rec.s_entries[current.line-1].s_status, "ACT");
#endif
	retval = ReadFields( ACCOUNT1_FLD+(current.line-1)*STEP,
			     DESC1_FLD+(current.line-1)*STEP );
	if(retval==EXIT || retval<0 ){
		if( FillItemLines(HIGH,current.line,current.line)<0 )
			return(-1);
		if( WriteFields( ACCOUNT1_FLD+(current.line-1)*STEP,
		                DESC1_FLD+(current.line-1)*STEP )<0 )
			return(-1);
		tempptr->fields[current.line-1].s_accno[0] = HV_CHAR;
		tempptr->fields[current.line-1].s_amount = HV_DOUBLE;
		tempptr->fields[current.line-1].s_status[0] = HV_CHAR;
		tempptr->fields[current.line-1].s_desc[0] = HV_CHAR;
		tempptr->fields[current.line-1].s_dummy = HV_SHORT;
		current.line--;
		if(current.line<1){
			if( headptr==tailptr )
				headptr=tailptr=NULL;
			else{
				tailptr = tailptr->prevptr;
				tailptr->nextptr = NULL;
			}
			free( (char *)tempptr );
			tempptr = tailptr;
			current.page--;
			if( PutPageNumber(current.page)<0 )
				return(-1);
			current.line =  ITEMSPERPAGE;
			if( tempptr )
				if( ShowPage()<0 )
					return(-1);
		}
		return(retval);
	}
	else{
		strcpy(tempptr->fields[current.line-1].s_accno,
		       s_rec.s_entries[current.line-1].s_accno);
		tempptr->fields[current.line-1].s_amount
			= s_rec.s_entries[current.line-1].s_amount;
		strncpy(tempptr->fields[current.line-1].s_status,
			 s_rec.s_entries[current.line-1].s_status, 3);
		strncpy(tempptr->fields[current.line-1].s_desc,
			 s_rec.s_entries[current.line-1].s_desc, 60);
		tempptr->fields[current.line-1].s_dummy = HV_SHORT;
		tempptr->lines_entered = current.line;
		totalitemsadded++;

		/*  Keep Totals at Bottom of Screen.  1 is   */
		/*  passed to signal accumulate invoice and  */
		/*  recalculate totals.  */
		if(DisplayTotals(1) < 0)
			return(-1);
	}
	return(0);
}
DisplayTotals(accum) 
short	accum;		/*  0 - Just recalculate GST and PST        */
			/*  1 - Accumulate invoice and recalculate  */
{
	static	double	temp_gst;

	/*  Keep totals at the bottom of the screen.  Get the    */
	/*  first value, do the calculation.  Get the second     */
	/*  value, add it to the first, and then do the entire   */
	/*  calculation again, etc.  If you try to do individual */
	/*  calculations and add them together you may lose or   */
	/*  gain a cent here and there because of the rounding.  */

	if(accum == 1) {
		s_rec.s_tot_invoice += 
			s_rec.s_entries[current.line-1].s_amount;
	}
	s_rec.s_tot_gst = ((s_rec.s_GSTpercent / 100.00) * 
		s_rec.s_tot_invoice);
	s_rec.s_tot_gst = D_Roundoff(s_rec.s_tot_gst);
	temp_gst = ((s_rec.s_GSTpercent / 100.00) * 
		s_rec.s_tot_invoice);
	temp_gst = D_Roundoff(temp_gst);
	s_rec.s_tot_pst = ((s_rec.s_PSTpercent / 100.00) * 
		(s_rec.s_tot_invoice + temp_gst));
	s_rec.s_tot_pst = D_Roundoff(s_rec.s_tot_pst);
	s_rec.s_grand_tot = (s_rec.s_tot_invoice + 
		s_rec.s_tot_gst + s_rec.s_tot_pst);
	s_rec.s_grand_tot = D_Roundoff(s_rec.s_grand_tot);

	/*  Display totals on screen  */
	if( WriteFields( TOT_INV_FLD,GRANDTOT_FLD )<0 ) 
		return(-1); 

	return(0);
}
ShowPage()	/* Dump contents of node pointed to by tempptr onto screen */
{
	if( ListToScreen()<0 ) return(-1);	/* transfer data */
	if( WriteFields( ACCOUNT1_FLD,DESC3_FLD )<0 ) 
		return(-1); /* display on screen */
	if( PutPageNumber( current.page )<0 )return(-1); /* Paginate properly */
	return(0);
}
ListToScreen()	/* copy contents of *tempptr to screen (items part) */
{
	short i;

	if( tempptr==NULL )
		return(-1);
	for( i=0; i<tempptr->lines_entered; i++){ /* for entries already made */
		strcpy( s_rec.s_entries[i].s_accno,tempptr->fields[i].s_accno );
		s_rec.s_entries[i].s_amount = tempptr->fields[i].s_amount ;
		strncpy(s_rec.s_entries[i].s_status,tempptr->fields[i].s_status ,4);
		strncpy(s_rec.s_entries[i].s_desc,tempptr->fields[i].s_desc,60);
		s_rec.s_entries[i].s_dummy = HV_SHORT;
	}
	for(i=tempptr->lines_entered; i<ITEMSPERPAGE; i++){/* for other lines */
		s_rec.s_entries[i].s_accno[0] = HV_CHAR;
		s_rec.s_entries[i].s_amount = HV_DOUBLE;
		s_rec.s_entries[i].s_status[0] = HV_CHAR;
		s_rec.s_entries[i].s_desc[0] = HV_CHAR;
		s_rec.s_entries[i].s_dummy = HV_SHORT;
	}
	return(0);
}
MakeFreshPage()	/* Add a new node to the linked list */
{
	tempptr=PageAllocated();
	if( tempptr==NULL ){
#ifdef ENGLISH
	  fomen("MEMORY ALLOCATION ERROR...");
#else
	  fomen("ERREUR D'ALLOCATION A LA MEMOIRE...");
#endif
	  get();
	  return(ALLOC_ERROR);
	}
	if( tailptr == NULL ){	/* If not a single node in the list yet */
		headptr=tailptr=tempptr;
		tempptr->prevptr = NULL;
		tempptr->nextptr = NULL;
	}
	else{			/* if at least one node exists */
		tailptr->lines_entered = current.line;
		tailptr->nextptr = tempptr;
		tempptr->prevptr = tailptr;
		tempptr->nextptr = NULL;
		tailptr = tempptr;
	}
	tempptr->lines_entered = 0;
	if( FillItemLines(HIGH,1,ITEMSPERPAGE)<0 ) 
		return(-1);
	if( WriteFields(ACCOUNT1_FLD,DESC3_FLD)<0 )
		return(-1);
	return(0);
}
PutPageNumber(pgno)		/* Display the given number as Page No */
short pgno;
{
	s_rec.s_page = pgno;
	return(WriteFields(PAGE_FLD,PAGE_FLD));
}
ConfirmItems( mode )	/* Allow user to change entered data in ADD_MODE only */
int mode;		/* ADD_MODE, INQ_MODE */
{
	double diff, total, tran_amt;
	int	i;

    for( ; ; ){
	if( mode==ADD_MODE )
#ifdef ENGLISH
	    DisplayMessage("A(dd), E(dit), D(el), C(ancel), N(ext), P(rev), R(eactivate), T(otal), Y(es)");
#else
	    DisplayMessage("R(ajouter), M(odif), E(lim), A(nnul), S(uiv), P(rec), V(ivif), T(otal), O(ui)");
#endif
	else if( mode==INQ_MODE ){
		if( headptr->nextptr )
#ifdef ENGLISH
			DisplayMessage("N(ext), P(rev), Y(es)");
#else
			DisplayMessage("S(uivant), P(recedent), O(ui)");
#endif
		else
			break;
	}

	sr.nextfld = RESP_FLD;
	fomrf( (char *)&s_rec );	/* Read user's option */
	ret( err_chk(&sr) );
	switch(s_rec.s_resp[0]){
		case ADDREC:	/* Add items allowed in ADD MODE only */
			if( mode==INQ_MODE )
				break;
			while( tempptr && tempptr->nextptr ){
				tempptr = tempptr->nextptr;
				current.page ++;
			}
			if( tempptr ){
				current.line = tempptr->lines_entered;
				if( current.line<1 )
					current.line = ITEMSPERPAGE;
				if( ShowPage()<0 ) return(-1);
			}
			if( AddItemsInLoop()<0 ) return(-1);
			break;
		case EDIT:	/* Edit entered data in ADD MODE only */
			if( mode==INQ_MODE )
				break;	
			if( !tempptr )	/* if no page is being pointed to */
				break;
			retval = EditItemFields();
			if( retval<0 )
				return(-1);
			if( HideFldNo()<0 )
				return(-1);
			break;
		case DELETE:	/* Delete an item entered in ADD MODE only*/
		case REVIVE:	/* Revive an item deleted in ADD MODE only*/
			if( !tempptr )	/* if no page is being pointed to */
				break;
			if( mode==INQ_MODE )
				break;
			if( ChangeItemStatus()<0 )
				return(-1);
			if( HideFldNo()<0 )
				return(-1);
			break;
		case NEXT:	/* Display the next page of items */
			if(tempptr && tempptr->nextptr){
				tempptr = tempptr->nextptr;
				current.page ++;
				if(ShowPage()<0 ) return(-1);
			}
			else
#ifdef ENGLISH
				fomer("Last Page Displayed");
#else
				fomer("Derniere page affichee");
#endif
			break;
		case PREV:	/* Display the prev page of items */
			if(tempptr && tempptr->prevptr){
				tempptr = tempptr->prevptr;
				current.page --;
				if(ShowPage()<0 ) return(-1);
			}
			else
#ifdef ENGLISH
				fomer("First Page Displayed");
#else
				fomer("Premiere page affichee");
#endif
			break;
		case CANCEL:    /* Cancel the entire session in ADD MODE only*/
			if( mode==INQ_MODE )
				break;
#ifdef ENGLISH
			DisplayMessage("Confirm the Cancel (Y/N)?"); 
#else
			DisplayMessage("Confirmer l'annulation (O/N)?"); 
#endif
			for( ; ; ){
				sr.nextfld = RESP_FLD;
				fomrf( (char *)&s_rec);
				if(s_rec.s_resp[0]!=YES &&
				   s_rec.s_resp[0]!=NO)
					continue;
				if( s_rec.s_resp[0]==YES ){
					FreeList();
					if(HideMessage()<0 )
						return(-1);
					return(EXIT);
				}
				else
					break;
			}
			break;
		case TOTAL:
			if( mode==INQ_MODE )
				break;

			if( SetDupBuffers(ORIAMT_FLD,PSTAMT_FLD,1)<0 )
				return(-1);

			for( i=ORIAMT_FLD; i<=PSTAMT_FLD; i+=100 )
				fomca1( i, 10, 0 );  /* Disable user escape */

			strcpy(s_rec.s_seperator,"-");
			s_rec.s_oriamt = LV_DOUBLE;
			if( memotype==IN || s_rec.s_invoice==g_invnbr ){
				s_rec.s_GSTpercent = LV_DOUBLE;
				s_rec.s_PSTpercent = LV_DOUBLE;
			}

	 		retval = ReadFields(ORIAMT_FLD,PSTAMT_FLD);
			if(retval < 0)
				return( retval );
	
			/*  Update totals on screen.  0 is passed to signal  */
			/*  that the GST and PST calculations are all that's */
			/*  needed.  */
			if(DisplayTotals(0) < 0)
				return(-1);

			for( i=ORIAMT_FLD; i<=PSTAMT_FLD; i+=100 )
				fomca1( i, 10, 1 ); /* Enable user escape */

			if( SetDupBuffers(ORIAMT_FLD,PSTAMT_FLD,0)<0 )
				return(-1);

			if (WriteFields(SEPARATOR_FLD,SEPARATOR_FLD) <0) return(-1);
			sr.nextfld = RESP_FLD;
			break;
		case YES:	/* Save & Exit in ADD MODE,Exit in INQ MODE */
			if( mode==INQ_MODE )
				return( HideMessage() );
			if( totalitemsadded<1 ){
#ifdef ENGLISH
				fomer("No items to save. Cancel to Quit");
#else
				fomer("Pas d'articles a conserver. Annuler pour retourner");
#endif
				break;
			}
			if( TotalAmount( &total )<0 )
				return(-1);

/*
			if( memotype==IN || s_rec.s_invoice==g_invnbr )
				tran_amt = s_rec.s_netamt ;
			else
*/
				tran_amt = s_rec.s_oriamt ;

			diff = total -  tran_amt;  

			if( diff>DELTA_AMT || diff<(-DELTA_AMT) ){
#ifdef ENGLISH
		    sprintf(e_mesg,
				"Unbalanced: IN/DM/CM amount: %.2lf, Items total: %.2lf, Diff : %.2lf", tran_amt, total, diff);
#else
			    sprintf(e_mesg,
				"Non-solde: FC/ND/NC montant: %.2lf, Total d'articles: %.2lf, Diff : %.2lf", tran_amt, total, diff);
#endif
				    fomer( e_mesg );
			}
			else
				return(HideMessage());
			break;
	}
	continue;
   }
	return(0);
}
EditItemFields()	/* Read the field# and allow changes on that field(s) */
{
	int retval;

	for( ; ; ){
		s_rec.s_fld_no = LV_SHORT;
		if( (retval=ReadFields(EDIT_FLD,EDIT_FLD)) < 0 )
			return(-1);
		if( retval==EXIT )
			return(retval);
		if( s_rec.s_fld_no<1 || s_rec.s_fld_no>ITEMSPERPAGE*10+3 )
			continue;
		if( s_rec.s_fld_no>0 && s_rec.s_fld_no<=ITEMSPERPAGE ){
						/* Chg a line */ 

			/*  Subtract amount from screen totals  */
			s_rec.s_tot_invoice -= 
			   	s_rec.s_entries[s_rec.s_fld_no-1].s_amount;

			if( (retval=LineChange(s_rec.s_fld_no)) < 0 )
				return(retval);

			/*  Recalculate totals with new amount  */
			s_rec.s_tot_invoice += 
				s_rec.s_entries[s_rec.s_fld_no-1].s_amount;
			if(DisplayTotals(0) < 0)
				return(-1);

		}
		else {		/* Change a field - account# or amount */
			if( (retval=FieldChange(s_rec.s_fld_no/10,
					      s_rec.s_fld_no%10))< 0)
				return(retval); 

		} 
	}
}
LineChange( line_no )	/* Read new values: account# & amount at given line */
int line_no;
{
	int i, firstfld, lastfld;
	char	buf_acnt[19];
	double	buf_amnt;
	char	buf_desc[61];

	/* Don't allow changes/access if item not active or not entered yet */
	if( !tempptr )	return(0);	/* if no pages, return */
	if( tempptr->fields[line_no-1].s_status[0]!=ACTIVE ){
#ifdef ENGLISH
		fomer( "Record not active. Revive first" );
#else
		fomer( "Fiche n'est pas active. Vivifier premierement" );
#endif
		get();
		return(0);
	}
	if( line_no>tempptr->lines_entered )
		return(0);

	firstfld = ACCOUNT1_FLD+(line_no-1)*STEP;     /* account number field */
	lastfld = DESC1_FLD+(line_no-1)*STEP;	      /* amount field */
	for( i = firstfld; i <= lastfld; i+=100 )
		fomca1( i, 19, 1 );	              /* enable dup buffers */
	sr.nextfld = firstfld;
	sr.endfld = lastfld;
	fomud( (char *)&s_rec );		/* update dup buffers */
	strcpy( buf_acnt, s_rec.s_entries[line_no-1].s_accno );
	buf_amnt = s_rec.s_entries[line_no-1].s_amount;

	s_rec.s_entries[line_no-1].s_accno[0] = LV_CHAR;
	s_rec.s_entries[line_no-1].s_amount = LV_DOUBLE;
	s_rec.s_entries[line_no-1].s_desc[0] = LV_CHAR;
	i= ReadFields( firstfld, lastfld );
	if( i<0 )	return(i);
	if( i==EXIT ){
		if( sr.curfld==firstfld ){
			strcpy( s_rec.s_entries[line_no-1].s_accno, buf_acnt );
			s_rec.s_entries[line_no-1].s_amount = buf_amnt;
		}
		else
			s_rec.s_entries[line_no-1].s_amount = buf_amnt;
	}
	for( i=firstfld; i<=lastfld; i+=100 )
		fomca1( i, 19, 0 );		/* disable dup buffers */
	scpy( (char *)(tempptr->fields+line_no-1), 
		(char *)(s_rec.s_entries+line_no-1), 
		sizeof( Scr_item ) );
	return(0);
}
FieldChange( line_no, col_no )	/* Allow change on specified field */
int line_no, col_no;
{
	int fld_no;
	char	buf_acnt[19];
	double	buf_amnt;
	char	buf_desc[61];

	if( !tempptr )	return(0);	/* if no pages, return */
	if( tempptr->fields[line_no-1].s_status[0]!=ACTIVE ){
#ifdef ENGLISH
		fomer( "Record not active. Revive first" );
#else
		fomer( "Fiche n'est pas active. Vivifier premierement" );
#endif
		get();
		return(0);
	}
	if( line_no>tempptr->lines_entered )
		return(0);
	if( col_no<1 || col_no>2 )
		return(0);

	fld_no = SEPARATOR_FLD+(col_no-1)*100 + (line_no-1)*STEP;/*kyle hanson*/

	fomca1( fld_no, 19, 1 );
	sr.nextfld = sr.endfld = fld_no;
	fomud( (char *)&s_rec );
	switch( col_no ){
		case 1:
			strcpy( buf_acnt, s_rec.s_entries[line_no-1].s_accno );
			s_rec.s_entries[line_no-1].s_accno[0]=LV_CHAR;
			break;
		case 2:
			buf_amnt = s_rec.s_entries[line_no-1].s_amount;
			s_rec.s_entries[line_no-1].s_amount=LV_DOUBLE;
			break;
		case 3:
			strcpy( buf_desc, s_rec.s_entries[line_no-1].s_desc );
			s_rec.s_entries[line_no-1].s_desc[0]=LV_CHAR;
			break;
		default:
			break;
	}
	if( (retval=ReadFields( fld_no, fld_no )) < 0 )
		return(-1);
	if( retval==EXIT )
	switch( col_no ){
		case 1:
			strcpy( s_rec.s_entries[line_no-1].s_accno, buf_acnt );
			break;
		case 2:
			s_rec.s_entries[line_no-1].s_amount = buf_amnt;
			break;
		case 3:
			strcpy( s_rec.s_entries[line_no-1].s_desc, buf_desc );
			break;
	}
	switch( col_no ){
		case 1:
			strcpy(tempptr->fields[line_no-1].s_accno,
			       s_rec.s_entries[line_no-1].s_accno);
			break;
		case 2:
			tempptr->fields[line_no-1].s_amount
			= s_rec.s_entries[line_no-1].s_amount;
			break;
		case 3:
			strcpy(tempptr->fields[line_no-1].s_desc,
			       s_rec.s_entries[line_no-1].s_desc);
			break;
		default:
			break;
	}
	fomca1( fld_no, 19, 0 );
	return(0);
}
ChangeItemStatus()	/* Allow deletion or revival of an item */
{
	int fld_no;

	for( ; ; ){
		s_rec.s_fld_no = LV_SHORT;
		if( (retval=ReadFields(EDIT_FLD,EDIT_FLD)) < 0 )
			return(-1);
		if( retval==EXIT )
			return(retval);
		if( s_rec.s_fld_no<1 || s_rec.s_fld_no>tempptr->lines_entered )
			continue;
		switch( s_rec.s_resp[0] ){
			case DELETE:
#ifdef ENGLISH
			   if( !strcmp(s_rec.s_entries[s_rec.s_fld_no-1].s_status,"DEL"))
#else
			   if( !strcmp(s_rec.s_entries[s_rec.s_fld_no-1].s_status,"ELI"))
#endif
				break;
#ifdef ENGLISH
			   strcpy(s_rec.s_entries[s_rec.s_fld_no-1].s_status,
									"DEL");
#else
			   strcpy(s_rec.s_entries[s_rec.s_fld_no-1].s_status,
								       "ELI");
#endif
			   totalitemsadded--;
			   /*  Subtract amount from screen totals  */
			   s_rec.s_tot_invoice -= 
			   	s_rec.s_entries[s_rec.s_fld_no-1].s_amount;
			   if(DisplayTotals(0) < 0)
				return(-1);

			   break;
			case REVIVE:
#ifdef ENGLISH
			   if( !strcmp(s_rec.s_entries[s_rec.s_fld_no-1].s_status,"ACT"))
				break;
#else
			   if( !strcmp(s_rec.s_entries[s_rec.s_fld_no-1].s_status,"ACT"))
				break;
#endif
#ifdef ENGLISH
			   strcpy(s_rec.s_entries[s_rec.s_fld_no-1].s_status,
									"ACT");
#else
			   strcpy(s_rec.s_entries[s_rec.s_fld_no-1].s_status,
								        "ACT");
#endif
			   totalitemsadded++;
			   /*  Add amount to screen totals  */
			   s_rec.s_tot_invoice += 
			   	s_rec.s_entries[s_rec.s_fld_no-1].s_amount;
			   if(DisplayTotals(0) < 0)
				return(-1);

			   break;
			default:
				return(0);
		}
		strcpy(tempptr->fields[s_rec.s_fld_no-1].s_status ,
			 s_rec.s_entries[s_rec.s_fld_no-1].s_status);
		fld_no = STATUS1_FLD + (s_rec.s_fld_no-1)*STEP;
		if( WriteFields(fld_no,fld_no)<0 )
			return(-1);
		break;
	}
	return(0);
}
WriteSession()	/* Write header, list of items and update GL master */
{
	int i, item_no;
	int err;

	/* J. Prescott Sept. 29/92 Try to Lock GL Trans file until successful */
	for( ; ; ) {
		if((err = lock_file(GLTRHDR)) < 0) {
			if(err == LOCKED) { 
				continue;
			}
			fomen(e_mesg);get();
			roll_back(e_mesg);	/* Unlock the locked Records */
			return(err);
		}
		else break;
	}
	/***********************************************/

	if( WriteHeader()<0 ){	/* Write the header record in arhdr file */
		roll_back(e_mesg) ;
		return(-1);
	}
	/* CHANGE from 3 to 0 XXXXXX */
	item_no = 0;		/* useful for generating the item serial no */
	tempptr = headptr;	/* initialize tempptr to beginning of list */
	for( ; ; ){	/* to write the items in gltran file */
		if(tempptr==NULL)
			break;
		for( i=1; i<=ITEMSPERPAGE; i++){ /* for each line on page */
			if(tempptr->fields[i-1].s_amount==HV_DOUBLE)
				break;
			if(tempptr->fields[i-1].s_status[0]==DELETE)
				continue;
			item_no++;
			if( WriteItem(i,item_no)<0 ){
				roll_back(e_mesg) ;
				return(-1);
			}
		}
		if(tempptr->fields[i-1].s_amount==HV_DOUBLE)
			break;	/* terminate when High values are found */
		tempptr=tempptr->nextptr;
	}

	if (commit(e_mesg) < 0 ){
		fomen(e_mesg) ;
		get() ;
		roll_back(e_mesg);
		return(-1);
	}
	return(0);
}
TotalAmount( total )	/* Calculate the total of line items */
double *total;
{
	int i;
	double amount;
	Page *ptr;

	amount = 0.0;
	ptr = headptr;
	for( ; ; ){	/* for each page in the list */
		if(ptr==NULL)
			break;
		for(i=1;i<=ITEMSPERPAGE;i++){	/* for each line in the page */
			if(ptr->fields[i-1].s_amount==HV_DOUBLE)
				break;
			if(ptr->fields[i-1].s_status[0]==DELETE)
				continue;
			amount += ptr->fields[i-1].s_amount;
		}
		ptr=ptr->nextptr;
	}
	*total = amount;
	return(0);
}
WriteHeader()	/* Write the header of the Sales Invoice file */
		/* Update the invoice if DM or CM is being added */
		/* Update the customer file */
		/* Update the AR general GL master account */
		/* Update the GST GL master account	*/
		/* Write the journal entry header */
		/* Write the journal entry item for AR general acct */
{
	short	flag;

	if( memotype!=IN && s_rec.s_sno!=1 ){
		s_rec.s_netamt     = s_rec.s_oriamt;
 		s_rec.s_GSTpercent = 0;
 		s_rec.s_PSTpercent = 0;
		s_rec.s_GSTtaxamt  = 0;	
		s_rec.s_PSTtaxamt  = 0;	
	}
		

	ar_hdr.ah_fund = s_rec.s_fund;
	ar_hdr.ah_inv_no = s_rec.s_invoice;
	ar_hdr.ah_sno = s_rec.s_sno;
	retval = get_arhdr( &ar_hdr, UPDATE, 0, e_mesg );
 	if( retval==NOERROR ){
 		s_rec.s_invoice ++; 
 		if( WriteFields(INVOICE_FLD,SNO_FLD)<0 )
 			return(-1);
 	}
	/* Write the new header record */

	ar_hdr.ah_fund = s_rec.s_fund;
	ar_hdr.ah_inv_no = s_rec.s_invoice;
	ar_hdr.ah_sno = s_rec.s_sno;
	strcpy( ar_hdr.ah_type, s_rec.s_type );
	strcpy( ar_hdr.ah_cu_code, s_rec.s_cucode );
	ar_hdr.ah_trandt = s_rec.s_trandt;
	ar_hdr.ah_oriamt = s_rec.s_oriamt;
	ar_hdr.ah_period = s_rec.s_period;
	strcpy( ar_hdr.ah_remarks, s_rec.s_remarks );

	if( memotype==IN || s_rec.s_invoice==g_invnbr ){ /* Invoice */
		flag = 1;
		ar_hdr.ah_status[0] = OPEN;		/* Invoice Open */
	}
	else{			/* DM/CM */
		flag = 0;
		ar_hdr.ah_status[0] = '\0';	/* null character */
	}
	
	if(memotype==IN || s_rec.s_invoice==g_invnbr) 
		ar_hdr.ah_duedt = s_rec.s_duedt;
	else
		ar_hdr.ah_duedt = dm_cm_duedt; /* same as invoice due date */

	ar_hdr.ah_gramt = s_rec.s_gramt * flag;
	ar_hdr.ah_gramt = D_Roundoff(ar_hdr.ah_gramt); 
	ar_hdr.ah_gstpercent = s_rec.s_GSTpercent * flag;
	ar_hdr.ah_gstamt = s_rec.s_GSTtaxamt * flag;
	ar_hdr.ah_gstamt = D_Roundoff(ar_hdr.ah_gstamt);
	ar_hdr.ah_txpercent = s_rec.s_PSTpercent * flag;
	ar_hdr.ah_txamt = s_rec.s_PSTtaxamt * flag;
	ar_hdr.ah_txamt = D_Roundoff(ar_hdr.ah_txamt);
	ar_hdr.ah_netamt = s_rec.s_netamt * flag;
	ar_hdr.ah_netamt = D_Roundoff(ar_hdr.ah_netamt);
	ar_hdr.ah_balance = s_rec.s_balance * flag;
	ar_hdr.ah_balance = D_Roundoff(ar_hdr.ah_balance);
	retval = put_arhdr( &ar_hdr, ADD, e_mesg );
	if( retval!=NOERROR ){
		fomen(e_mesg);get();
		roll_back(e_mesg);
		return(retval);
	}

	if( memotype==CM )	flag = -1;
	else 			flag = 1;

	/* If DM or CM is being added update the invoice record */
	if( memotype!=IN && s_rec.s_invoice!=g_invnbr){
		if((strcmp(in_hdr.ah_type, T_CRMEMO) == 0) && memotype == DM)
			in_hdr.ah_gramt -= s_rec.s_oriamt * flag;
		else
			in_hdr.ah_gramt += s_rec.s_oriamt * flag;
		in_hdr.ah_gramt = D_Roundoff(in_hdr.ah_gramt);
	
		if((strcmp(in_hdr.ah_type, T_CRMEMO) == 0) && memotype == DM)
		 	in_hdr.ah_balance -= s_rec.s_oriamt * flag;
		else
		 	in_hdr.ah_balance += s_rec.s_oriamt * flag;
		 in_hdr.ah_balance =D_Roundoff( in_hdr.ah_balance );

/************************
		in_hdr.ah_gramt += s_rec.s_oriamt * flag;
		in_hdr.ah_gramt = D_Roundoff(in_hdr.ah_gramt);
	
		in_hdr.ah_gramt += in_hdr.ah_gramt;
		in_hdr.ah_gramt = D_Roundoff(in_hdr.ah_gramt); 

		in_hdr.ah_balance += s_rec.s_oriamt * flag;
		in_hdr.ah_balance =D_Roundoff( in_hdr.ah_balance );
*******************************/
		if( in_hdr.ah_balance<=0.0 )
			in_hdr.ah_status[0] = CHANGE;
		retval = put_arhdr( &in_hdr, UPDATE, e_mesg );
		if( retval!=NOERROR ){
			fomen(e_mesg);get();
			roll_back(e_mesg);
			return(retval);
		}
	}

	/* Update the customer master file */
	cu_rec.cu_cur_bal += s_rec.s_netamt * flag; 
	/* cu_rec.cu_cur_bal += s_rec.s_oriamt * flag; */
	cu_rec.cu_cur_bal = D_Roundoff( cu_rec.cu_cur_bal);
	/* cu_rec.cu_ytd_sales += s_rec.s_oriamt * flag; */
	cu_rec.cu_ytd_sales += s_rec.s_netamt * flag; 
	cu_rec.cu_ytd_sales = D_Roundoff( cu_rec.cu_ytd_sales); 
	if( memotype==IN && s_rec.s_trandt>cu_rec.cu_sale_dt )
		cu_rec.cu_sale_dt = s_rec.s_trandt;
	retval = put_cust( &cu_rec, UPDATE, e_mesg );
	if( retval!=NOERROR ){
		fomen(e_mesg);get();
		roll_back(e_mesg);
		return(retval);
	}

	if(memotype != CM) 
		retval = UpdateGlmast(s_rec.s_netamt, DEBIT, ctl_rec.ar_acnt);
	else
		retval = UpdateGlmast(s_rec.s_netamt, CREDIT, ctl_rec.ar_acnt);

	if( retval!=NOERROR ){
		fomen(e_mesg);get();
		roll_back(e_mesg);
		return(retval);
	} 

	/* Write journal entry header*/
	if( WriteTrhdr()<0 )
		return(retval);

	cnt = 1;	/* First gl transaction */
	/*  Write one item( s#=1 ) for AR general */
	tr_item.ti_fund = (short)s_rec.s_fund;
	tr_item.ti_reccod = tr_hdr.th_reccod;
	tr_item.ti_create[0] = 'G';
	tr_item.ti_seq_no = tr_hdr.th_seq_no;
	tr_item.ti_sys_dt = tr_hdr.th_sys_dt;
	tr_item.ti_period = tr_hdr.th_period;
	tr_item.ti_item_no = cnt;
	strcpy( tr_item.ti_accno, ctl_rec.ar_acnt );
	tr_item.ti_section = gl_rec.sect;/* From corr. recently updated Glmast*/

	if( memotype!=CM )	flag = 1;
	else			flag = -1;
	tr_item.ti_amount = s_rec.s_netamt * flag;
	tr_item.ti_amount = D_Roundoff(tr_item.ti_amount);
	tr_item.ti_status = 0;
	retval = put_tritem( &tr_item, ADD, e_mesg );
	if( retval!=NOERROR ){
		fomen(e_mesg);get();
		roll_back(e_mesg);
		return(retval);
	} 
	
	cnt++;

	if(memotype == IN || s_rec.s_invoice==g_invnbr) {

		if(memotype==CM ) flag = 1;
		else		  flag = -1;	

		if(s_rec.s_GSTtaxamt!=0.00) {
			/* Adds to ytd,period info in GL master record */
			if (memotype != CM)  
				retval = UpdateGlmast(s_rec.s_GSTtaxamt,CREDIT,ctl_rec.ap_gst_acnt);
			else
				retval = UpdateGlmast(s_rec.s_GSTtaxamt,DEBIT,ctl_rec.ap_gst_acnt);

			if( retval!=NOERROR ){
				fomen(e_mesg);get();
				roll_back(e_mesg);
				return(retval);
			} 

			/*  Write one item( s#=2 ) for GST general */
			tr_item.ti_fund = (short)s_rec.s_fund;
			tr_item.ti_reccod = tr_hdr.th_reccod;
			tr_item.ti_create[0] = 'G';
			tr_item.ti_seq_no = tr_hdr.th_seq_no;
			tr_item.ti_sys_dt = tr_hdr.th_sys_dt;
			tr_item.ti_period = tr_hdr.th_period;
			tr_item.ti_item_no = cnt;
			strcpy( tr_item.ti_accno, ctl_rec.ap_gst_acnt );
			tr_item.ti_section = gl_rec.sect;
			tr_item.ti_amount = s_rec.s_GSTtaxamt*flag;
			tr_item.ti_amount = D_Roundoff(tr_item.ti_amount);
			tr_item.ti_status = 0;
			retval = put_tritem( &tr_item, ADD, e_mesg );
			if( retval!=NOERROR ){
				fomen(e_mesg);get();
				roll_back(e_mesg);
				return(retval);
			}
			cnt++;
		}

		if(s_rec.s_PSTtaxamt!=0.00) {
			/* Adds to ytd,period info in GL master record */
			if (memotype != CM)  
				retval = UpdateGlmast(s_rec.s_PSTtaxamt,CREDIT,ctl_rec.pst_tax_acnt);
			else
				retval = UpdateGlmast(s_rec.s_PSTtaxamt,DEBIT,ctl_rec.pst_tax_acnt);

			if( retval!=NOERROR ){
				fomen(e_mesg);get();
				roll_back(e_mesg);
				return(retval);
			} 

			/*  Write one item( s#=3 ) for PST general */
			tr_item.ti_fund = (short)s_rec.s_fund;
			tr_item.ti_reccod = tr_hdr.th_reccod;
			tr_item.ti_create[0] = 'G';
			tr_item.ti_seq_no = tr_hdr.th_seq_no;
			tr_item.ti_sys_dt = tr_hdr.th_sys_dt;
			tr_item.ti_period = tr_hdr.th_period;
			tr_item.ti_item_no = cnt;
			strcpy( tr_item.ti_accno, ctl_rec.pst_tax_acnt );
			tr_item.ti_section = gl_rec.sect;
			tr_item.ti_amount = s_rec.s_PSTtaxamt*flag;
			tr_item.ti_amount = D_Roundoff(tr_item.ti_amount);
			tr_item.ti_status = 0;
			retval = put_tritem( &tr_item, ADD, e_mesg );
			if( retval!=NOERROR ){
				fomen(e_mesg);get();
				roll_back(e_mesg);
				return(retval);
			}
		}
	}
	return(0);
}

UpdateGlmast(amount,transtype,accno)
double 	amount;
short	transtype;
char	*accno;
{

	/* Update the AR General account */
	gl_rec.funds = s_rec.s_fund;
	strcpy( gl_rec.accno, accno );
	gl_rec.reccod = 99;
	retval = get_gl( &gl_rec,UPDATE,0,e_mesg );
	if( retval!=NOERROR ){
		fomen(e_mesg);get();
		if( retval == LOCKED) return(LOCKED);
		return(DBH_ERR); 
	}

	if( transtype==DEBIT ){
		gl_rec.curdb += amount;
		gl_rec.curdb = D_Roundoff( gl_rec.curdb);
		gl_rec.ytd += amount;
		gl_rec.currel[s_rec.s_period-1] += amount;
	}
	else{
		gl_rec.curcr -= amount;
		gl_rec.curcr = D_Roundoff( gl_rec.curcr);
		gl_rec.ytd -= amount;
		gl_rec.currel[s_rec.s_period-1] -= amount;
	}
	gl_rec.ytd = D_Roundoff( gl_rec.ytd);
	gl_rec.currel[s_rec.s_period-1] 
			= D_Roundoff(gl_rec.currel[s_rec.s_period-1]);

	retval = put_gl( &gl_rec, UPDATE, e_mesg );
	if( retval!=NOERROR ){
		fomen(e_mesg);get();
		return(retval);
	}
	return(NOERROR);
}

WriteTrhdr()
{
#ifdef	ORACLE
	long	get_maxsno(), sno ;
#endif
	long	sysdt ;

	tr_hdr.th_fund = s_rec.s_fund;
	tr_hdr.th_reccod = 99;
	tr_hdr.th_create[0] = 'G';
#ifndef	ORACLE
	tr_hdr.th_seq_no = HV_SHORT;
	retval = get_n_trhdr( &tr_hdr, BROWSE, 0, BACKWARD, e_mesg );
	seq_over( GLTRHDR );
	if( retval==ERROR ){
		fomen(e_mesg);
		get();
		roll_back(e_mesg);
		return(-1);
	}
	if( retval==EFL || 
	    tr_hdr.th_fund != s_rec.s_fund ||	
	    tr_hdr.th_reccod != 99 || 
	    tr_hdr.th_create[0] != 'G' ){
		tr_hdr.th_fund = s_rec.s_fund;
		tr_hdr.th_reccod = 99;
		tr_hdr.th_create[0] = 'G';
		tr_hdr.th_seq_no = 1;
	}
	else
		tr_hdr.th_seq_no++;
#else
	sno = get_maxsno(GLTRHDR, (char*)&tr_hdr, 0, -1, e_mesg) ;
	if( sno < 0 ){
		fomen(e_mesg);
		get();
		return(-1);
	}
	tr_hdr.th_seq_no = sno + 1 ;
#endif
	strcpy( tr_hdr.th_userid, User_Id );
	tr_hdr.th_sys_dt = sysdt = get_date();
	tr_hdr.th_period = s_rec.s_period;
	tr_hdr.th_date = s_rec.s_trandt;
	tr_hdr.th_debits = tr_hdr.th_credits = s_rec.s_oriamt;
	tr_hdr.th_debits = D_Roundoff(tr_hdr.th_debits);
	tr_hdr.th_credits = D_Roundoff(tr_hdr.th_credits);
	sprintf(tr_hdr.th_reference, "%d-%ld", s_rec.s_fund, s_rec.s_invoice );
	tr_hdr.th_type[0] = '9';

	strcpy(tr_hdr.th_descr, s_rec.s_remarks);
	strcpy(tr_hdr.th_supp_cd, s_rec.s_cucode);

	if( put_trhdr( &tr_hdr, ADD, e_mesg )<0 ){
		fomen(e_mesg);
		get();
		roll_back(e_mesg);
		return(-1);
	}
	return(0);
}
WriteItem(line_no,item_no)/* Write one item in gltran file from *tempptr */
int line_no,item_no;
{
	short flag;
	double amt;

	gl_rec.funds = s_rec.s_fund;
	strcpy( gl_rec.accno, tempptr->fields[line_no-1].s_accno );
	gl_rec.reccod = 99;
	retval = get_gl( &gl_rec,UPDATE,0,e_mesg );
	if( retval!=NOERROR ){
		fomen(e_mesg);get();
		if (retval == LOCKED) return(LOCKED);
		return(DBH_ERR); 
	}

	amt = tempptr->fields[line_no-1].s_amount;
	if( memotype!=CM ){
		gl_rec.curcr -= amt;
		gl_rec.curcr = D_Roundoff(gl_rec.curcr);
		gl_rec.ytd -= amt;
		gl_rec.currel[s_rec.s_period-1] -= amt;
	}
	else{
		gl_rec.curdb += amt;
		gl_rec.curdb = D_Roundoff(gl_rec.curdb);
		gl_rec.ytd += amt;
		gl_rec.currel[s_rec.s_period-1] += amt;
	}
	gl_rec.ytd = D_Roundoff( gl_rec.ytd );
	gl_rec.currel[s_rec.s_period-1] =
				D_Roundoff(gl_rec.currel[s_rec.s_period-1]);
	retval = put_gl( &gl_rec, UPDATE, e_mesg );
	if( retval!=NOERROR ){
		fomen(e_mesg);get();
		if(retval == LOCKED) return(LOCKED);
		return(retval);
	}

	tr_item.ti_sys_dt = tr_hdr.th_sys_dt;
	tr_item.ti_seq_no = tr_hdr.th_seq_no;
	tr_item.ti_period = tr_hdr.th_period;
	/* for item number, count one for AR acnt already written */
	/* ADDED +3 XXXXXX */
	tr_item.ti_item_no = item_no+cnt; /* cnt = 3 if GST && PST amounts */
					  /* Not equal Zero */
	tr_item.ti_fund = (short)s_rec.s_fund;
	strcpy( tr_item.ti_accno, tempptr->fields[line_no-1].s_accno );
	tr_item.ti_reccod = tr_hdr.th_reccod;
	tr_item.ti_section = gl_rec.sect;/* From corr. recently updated Glmast*/

	if( memotype!=CM )	flag = -1;
	else			flag = 1;
	tr_item.ti_amount=tempptr->fields[line_no-1].s_amount*flag;
	tr_item.ti_amount=D_Roundoff(tr_item.ti_amount);
	tr_item.ti_status = 0;
	retval = put_tritem( &tr_item, ADD, e_mesg );
	if( retval!=NOERROR ){
		fomen(e_mesg);get();
		roll_back(e_mesg);
		return(retval);
	}

	/* Write a sale item */

	ar_item.ai_fund = ar_hdr.ah_fund;
	ar_item.ai_inv_no = ar_hdr.ah_inv_no;
	ar_item.ai_hno = ar_hdr.ah_sno;
	/* REMOVE -3 XXXXXX */
	ar_item.ai_sno = item_no;
	strcpy( ar_item.ai_accno, tempptr->fields[line_no-1].s_accno );
	ar_item.ai_amount = tempptr->fields[line_no-1].s_amount;
	strcpy( ar_item.ai_desc, tempptr->fields[line_no-1].s_desc );

	retval = put_aritem( &ar_item, ADD, e_mesg );
	if( retval!=NOERROR ){
		fomen(e_mesg);get();
		roll_back(e_mesg);
		return(retval);
	}

	return(0);
}

/***********************************************************************
     NOT BEING USED BECAUSE ctl_rec.last_invc is used by PO SUB-SYSTEM 
UpdateControl()
{
	ctl_rec.fund = ar_hdr.ah_fund ;

	retval = get_ctl(&ctl_rec,UPDATE,0,e_mesg );
	if( retval != NOERROR) {
		fomen(e_mesg); get();
		if (retval == LOCKED) return(LOCKED);
		roll_back(e_mesg);
		return(retval);
	}

	ctl_rec.last_invc = ar_hdr.ah_inv_no ;

	retval = put_ctl(&ctl_rec, UPDATE, e_mesg );
	if( retval!=NOERROR ){
		fomen(e_mesg);get();
		if(retval == LOCKED) return(LOCKED);
		roll_back(e_mesg);
		return(retval);
	}
	return(0);
}
**************************************************************************/

FreeList()	/* Free the linked list */
{
	for( tempptr=headptr; tempptr; tempptr=headptr ){
		headptr=headptr->nextptr;
		free( (char *)tempptr );
	}
	tailptr = NULL;
	return(0);
}
Inquire( access, direction )	/* Screen inquiry, random/sequential */
int access, direction;		/* RANDOM, SEQUENTIAL accesses */
{
	int retval;

	if( access==RANDOM ){
		/* enable & update dup buffers */
		if( SetDupBuffers(FUND_FLD,SNO_FLD,1)<0 )
			return(-1);
		retval = GetHeaderKey();	/* Read the key values */
		if(retval==UNDEF)
			return(0);
		if( retval==EXIT ){
			if(ClearScreen()<0)	return(-1);
			return(retval);
		}
	}
	else{
		retval = GetNextHeader( direction );	/* Get next rec */
		if(retval==EFL)
			return(0);
	}
	if( retval<0 ){
		fomen(e_mesg);get();
		return(-1);
	}
	retval = DisplayRecord();	/* Display the header & item records */
	if( retval<0 ) return(retval);

	return( FreeList() );
}
DisplayRecord()	/* Get and display the header and item records */
{
	int retval;

	retval = ShowHeaderFields();	/* Display header information */
	if( retval<0 || retval==EXIT ) return(retval);

	retval = ShowItems();	/* Display first pageful of items */
	if( retval<0 || retval==EXIT ) {
		if( ClearScreen()<0 )	return(-1);
		return(retval);
	}

	retval = ConfirmItems( INQ_MODE );	/* Allow scanning of pages */
	if( retval<0 || retval==EXIT ) return(retval);

	return(0);
}
GetNextHeader(direction)	/* Read the next rec in specified direction */
int	direction ;
{
	int retval;
	
	if( flg_start(ARSHDR) != direction ){ 	/* file not in seq read mode */
		/* Set the least part of the key to next possible key and set
		   the file to start */
		ar_hdr.ah_fund = s_rec.s_fund;
		ar_hdr.ah_inv_no = s_rec.s_invoice;
		if(direction == FORWARD)
			ar_hdr.ah_sno = s_rec.s_sno + 1;
		else
			ar_hdr.ah_sno = s_rec.s_sno - 1;
		flg_reset(ARSHDR) ;
	}
	/* Read the next record from arshdr file */
	retval = get_n_arhdr( &ar_hdr, BROWSE, 0, direction, e_mesg );
#ifndef ORCALE
	seq_over(ARSHDR) ;
#endif
	if( retval==EFL ){
#ifdef ENGLISH
		fomen("No More Records....");
#else
		fomen("Plus de fiches....");
#endif
		get();
		flg_reset(ARSHDR);
		return(retval);
	}
	if( retval!=NOERROR ){
		fomen(e_mesg);	get();
		return(retval);
	}
	strcpy( s_rec.s_type, ar_hdr.ah_type );
	s_rec.s_fund = ar_hdr.ah_fund;
	s_rec.s_invoice = ar_hdr.ah_inv_no;
	s_rec.s_sno = ar_hdr.ah_sno;
	if( WriteFields(TYPE_FLD,SNO_FLD)<0 )
		return(-1);
	return(0);
}
GetHeaderKey()	/* Read the header key values, get terminal info ,read rec */
{
	int retval;

	s_rec.s_fund = LV_SHORT;
	s_rec.s_invoice = LV_LONG;
	s_rec.s_sno = LV_SHORT;
	fund_default();
	if( (retval = ReadFields(FUND_FLD,SNO_FLD))<0   || (retval==EXIT)  )  
		return(retval);
	ar_hdr.ah_fund = s_rec.s_fund;
	ar_hdr.ah_inv_no = s_rec.s_invoice;
	ar_hdr.ah_sno = s_rec.s_sno;
	retval = get_arhdr( &ar_hdr, BROWSE, 0, e_mesg );
	if( retval!=NOERROR ){
		fomer(e_mesg);
		get();
		return(retval);
	}
	strcpy( s_rec.s_type, ar_hdr.ah_type );
	if( WriteFields(TYPE_FLD,TYPE_FLD)<0 )
		return(-1);
	return(0);
}
ShowHeaderFields()	/* Display header info */
{
	if( !strcmp(ar_hdr.ah_type,T_INVOICE) )
		memotype = IN;
	else if( !strcmp(ar_hdr.ah_type,T_DBMEMO) )
		memotype = DM;
	else if( !strcmp(ar_hdr.ah_type,T_CRMEMO) )
		memotype = CM;

	strcpy(s_rec.s_cucode, ar_hdr.ah_cu_code );
	s_rec.s_trandt = ar_hdr.ah_trandt;
	s_rec.s_oriamt = ar_hdr.ah_oriamt;
	s_rec.s_period = ar_hdr.ah_period;
	strcpy(s_rec.s_remarks, ar_hdr.ah_remarks );

	if( memotype==IN || ar_hdr.ah_sno==1 ){
		s_rec.s_duedt = ar_hdr.ah_duedt;
		s_rec.s_gramt = ar_hdr.ah_gramt;
		s_rec.s_GSTpercent = ar_hdr.ah_gstpercent; 
		s_rec.s_GSTtaxamt  = ar_hdr.ah_gstamt;
		s_rec.s_PSTpercent = ar_hdr.ah_txpercent;
		s_rec.s_PSTtaxamt = ar_hdr.ah_txamt;
		s_rec.s_netamt = ar_hdr.ah_netamt;
		s_rec.s_balance = ar_hdr.ah_balance;
	}
	else{
		s_rec.s_duedt = HV_LONG;
		s_rec.s_gramt = HV_DOUBLE;
		s_rec.s_GSTpercent = HV_DOUBLE;
		s_rec.s_GSTtaxamt  = HV_DOUBLE;
		s_rec.s_PSTpercent = HV_DOUBLE;
		s_rec.s_PSTtaxamt = HV_DOUBLE;
		s_rec.s_netamt = HV_DOUBLE;
		s_rec.s_balance = HV_DOUBLE;
	}
	if( WriteFields(CUST_FLD,REMARKS_FLD)<0 ) return(-1);
	return(0);
}
ShowItems()	/* Display first pageful of items */
{
	/* Build linked list of pages in memory */
	if( (retval=BuildList())<0 || retval==EXIT)  
		return(retval);
	tempptr = headptr ;	/* Seek to first node/page of list */
	current.page = 1;
	s_rec.s_seperator[0] = '-';
	if( WriteFields(SEPARATOR_FLD,SEPARATOR_FLD)<0 )	return(-1);
	if( ShowPage()<0 ) return(-1);	/* Display contents of page sought */ 
	return(0);
}
BuildList()	/* Read item by item from file and build list */
{
	int retval;

	headptr = tailptr = tempptr = NULL;

/*	ar_item.ai_fund = ar_hdr.ah_fund;
	ar_item.ai_inv_no = ar_hdr.ah_inv_no;
	ar_item.ai_hno = ar_hdr.ah_sno;
*/
	ar_item.ai_fund 	= s_rec.s_fund;   
	ar_item.ai_inv_no 	= s_rec.s_invoice;
	ar_item.ai_hno 		= s_rec.s_sno;  
	ar_item.ai_sno 		= 0;
	flg_reset(ARSITEM);	/* Initialize to get first rec under givenkey */

	for( ; ; ){
#ifndef ORACLE
		retval = get_n_aritem( &ar_item, BROWSE, 0, FORWARD, e_mesg);
#else
		retval = get_n_aritem( &ar_item, BROWSE, 0, EQUAL, e_mesg);
#endif		
		if( retval==ERROR ){
			fomen(e_mesg);
			get();
			return(retval);
		}
		if( retval==EFL )
			break;
#ifndef ORACLE
		if( ar_item.ai_fund != s_rec.s_fund ||
		    ar_item.ai_inv_no != s_rec.s_invoice ||
		    ar_item.ai_hno != s_rec.s_sno || ar_item.ai_sno < 1 )
			break;	/* No more records with specified key */
#endif		
		current.line = ar_item.ai_sno % ITEMSPERPAGE;
		if( current.line==0 ) current.line = ITEMSPERPAGE;
		if( current.line==1 ){	/* New page to be formed */
		    tempptr = PageAllocated();	/* Allocate memory for page */
		    if( tempptr==NULL ){
#ifdef ENGLISH
	  		fomen("MEMORY ALLOCATION ERROR...");
#else
	  		fomen("ERREUR D'ALLOCATION A LA MEMOIRE...");
#endif
			get();
			return(-1);
		    }
		    tempptr->lines_entered = 0;
		    if( ar_item.ai_sno==1 ){	/* First item */
			headptr = tailptr = tempptr;
			tempptr->nextptr = tempptr->prevptr = NULL;
		    }
		    else{
			tailptr->nextptr = tempptr;
			tempptr->prevptr = tailptr;
			tempptr->nextptr = NULL;
			tailptr = tempptr;
		    }
		}

		/*  Only initialize totals once  */
		if(s_rec.s_tot_invoice == HV_DOUBLE) {
			if(InitTotals() < 0)
				return(-1);
		}

		strcpy(tempptr->fields[current.line-1].s_accno,ar_item.ai_accno);
		tempptr->fields[current.line-1].s_amount = ar_item.ai_amount;
		tempptr->fields[current.line-1].s_status[0] = HV_CHAR; 
		strcpy(tempptr->fields[current.line-1].s_desc,ar_item.ai_desc);
		tempptr->fields[current.line-1].s_dummy = HV_SHORT;
		tempptr->lines_entered++;

		strcpy(s_rec.s_entries[current.line-1].s_accno,
							ar_item.ai_accno);
		s_rec.s_entries[current.line-1].s_amount = ar_item.ai_amount;

		/*  Keep Totals at Bottom of Screen.  1 is   */
		/*  passed to signal accumulate invoice and  */
		/*  recalculate totals.  */
		if(DisplayTotals(1) < 0)
			return(-1);
	} 
	seq_over( ARSITEM );
	if( headptr==NULL ){
#ifdef ENGLISH
		fomen("Can't find items list"); 
#else
		fomen("Ne trouve pas la liste des articles");
#endif
		get();
		return(-1);
	}
	return(0);
}
/* Fill the demarkating line field with high/low values */
FillSeperatorLine( value )
short value;
{
	s_rec.s_seperator[0] = HL_CHAR(value);
	return(0);
}
/* Display message and get the option */
GetOpt(msg,options)
char	*msg ;
char	*options ;
{
	int	i, j ;

	if( DisplayMessage(msg)<0 )
		return(-1); ;

	for( ; ; ) {
		s_rec.s_resp[0] = LV_CHAR;
		if( (retval=ReadFields(RESP_FLD,RESP_FLD))<0 )
			return(retval);
		j = strlen(options) ;
		for( i = 0 ; i < j ; i++)
			if(s_rec.s_resp[0] == options[i]) break ;
		if(i != j) break ;	/* Valid Option Selected */
#ifdef ENGLISH
		fomer("Invalid Option..");
#else
		fomer("Option invalide..");
#endif
	}
	s_rec.s_mesg[0] = HV_CHAR ;
	s_rec.s_resp[0] = HV_CHAR ;
	if( (retval=WriteFields(MESG_FLD,RESP_FLD))<0 )
		return(retval);

	return((int)(options[i])) ;
}	/* GetOpt() */

fund_default()
{
	fomca1(FUND_FLD,19,1);
	s_rec.s_fund = 1;
	WriteFields(FUND_FLD,FUND_FLD);
	s_rec.s_fund = LV_SHORT;
}
