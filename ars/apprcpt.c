/*-----------------------------------------------------------------------
Source Name: apprcpt.c
System     : Accounts Receivable.
Created  On: 25-FEB-91.
Created  By: J.Prescott.

DESCRIPTION:
	Program to Apply Unapplied Receipts.

MODIFICATIONS:        

Programmer     YY/MM/DD      	Description of modification
J McLean       92/07/27		Changed customer code from 6 to 10 characters.

------------------------------------------------------------------------*/
#define	MAIN		/* Main program. This is to declare Switches */
#define MAINFL		RCPTHDR		/* main file used */

#define	SYSTEM		"ACCOUNTS RECEIVABLE"	/* Sub System Name */
#define	MOD_DATE	"25-FEB-91"		/* Progran Last Modified */

#include <stdio.h>
#include <cfomstrc.h>
#include <bfs_defs.h>
#include <bfs_recs.h>

#define	DELTA_AMT  0.005	/* To Check double values for zero */
#define	DELTA_QTY  0.00005	/* To Check double values for zero */

/* User Interface define constants */
#ifdef ENGLISH
#define ADDREC		'A'
#define INQUIRE		'I'
#define NEXT		'N'
#define PREV		'P'
#define EXITOPT		'E'

#define	YES		'Y'
#define NO		'N'
#define APPLY		'A'
#define UNAPPLY		'U'
#define	NEXTPAGE	'N'
#define	PREVPAGE	'P'
#define	CANCEL		'C'

#define	T_INVOICE	"IN"
#define	T_CRMEMO	"CM"
#define	T_DBMEMO	"DM"

#define APPLY_STAT	"APP"
#define UNAPP_STAT	"UAP"
#else
#define ADDREC		'R'
#define INQUIRE		'I'
#define NEXT		'S'
#define PREV		'P'
#define EXITOPT		'F'

#define	YES		'O'
#define NO		'N'
/* XXXXXX translate */
#define APPLY		'R'
#define UNAPPLY		'N'
#define	NEXTPAGE	'S'
#define	PREVPAGE	'P'
#define	CANCEL		'A'

#define	T_INVOICE	"FC"
#define	T_CRMEMO	"NC"
#define	T_DBMEMO	"ND"

/* XXXXXX translate */
#define APPLY_STAT	"APP"
#define UNAPP_STAT	"NAP"
#endif

/* PROFOM Releted declarations */

#define	SCR_NAME	"apprcpt"	/* PROFOM screen Name */

#define	PAGESIZE	8		/* No of Items */

/* PROFOM Screen STH file */

/* Field PROFOM numbers */

#define	HDR_ST_FLD	800	/* Header Start Field */
#define	HDR_END_FLD	1100	/* Header End Field */
#define	ITEM_ST_FLD	1600	/* Item 1 Start Field */
#define	END_FLD		6000	/* Last Field of the screen */
#define	STEP		500	/* NO of fields diff. between 2 items */

#define TOTAL_ST_FLD	5600	/* Totals Start Field */
#define TOTAL_END_FLD	5800	/* Totals End Field */

/* HDR Fields */
#define	FN_FLD		400	/* Fn: */
#define	KEY_START	500	/* Reference Number */
#define	KEY_END		500	/* Reference Number */
#define	CHG_FLD		600	/* Field: */

#define	CUST_FLD	800	/* Customer Code: */
#define CUSTNAME_FLD	900	/* Customer Name: */
#define RCPTAMT_FLD	1000 	/* Receipt Amount: */
#define	TRTYPE_FLD	1100	/* Trans Type: */
#define	PAGENO_FLD	1200	/* Page#: */
#define COLHDG1_FLD	1300
#define COLHDG2_FLD	1400
#define COLHDG3_FLD	1500
	
/* Item Fields. These numbers are difference between that field
   and the 1st fld within the item */
#define	TYPE_FLD	  0
#define	INVNBR_FLD	100
#define TRDATE_FLD	200
#define	INVAMT_FLD	300
#define	STATUS_FLD	400

/* Total Fields */
#define RECEAMT_FLD	5600
#define APPLAMT_FLD	5700
#define UNAPAMT_FLD	5800

/* Message/Response Fields */
#define MESSAGE_FLD	5900
#define RESP_FLD	6000

/* po.sth - header for C structure generated by PROFOM EDITOR */

typedef	struct	{	/* Start Fld 1600, Endfld 5500 and Step 500 */

	char	s_type[3];	/* STRING XXX          Field 1600 */
	long	s_invcnbr;	/* NUMERIC ########    Field 1700 */
	long	s_trdate;	/* DATE ####/##/##     Field 1800 */
	double	s_invcamt;	/* NUMERIC 99999999.99 Field 1900 */
	char	s_status[4];	/* STRING XXX          Field 2000 */
}	S_item ;

typedef struct	{

	char	s_pgm[11];	/* STRING XXXXXXXXXX   Field 100 */
	long	s_rundate;	/* DATE YYYYFMMFDD     Field 300 */

	char	s_fn[2];	/* STRING X            Field 400 */
	long	s_refnbr;	/* NUMERIC 99999999    Field 500 */
	short	s_field;	/* NUMERIC 999         Field 600 */

	char	s_cust_cd[11];	/* STRING XXXXXXXXXX   Field 800 */
	char	s_cust_nm[27];  /* STRING X(26)        Field 900 */
	double  s_rcpt_amt;	/* NUMERIC 99999999.99 Field 1000 */
	char	s_tr_type[3];   /* STRING XX           Field 1100 */
	short	s_page_no;	/* NUMERIC 99          Field 1200 */
	char	s_dummy1[2];	/* STRING XX           Field 1300 */
	char	s_dummy2[2];	/* STRING XX           Field 1400 */
	char	s_dummy3[2];	/* STRING XX           Field 1500 */

	S_item	s_items[PAGESIZE] ;	/* Start Fld 2500, End Fld 5400 and
					   Step 1500 */
	double	s_rcptamt;	/* NUMERIC 99999999.99 Field 5600 */
	double	s_applamt;	/* NUMERIC 99999999.99 Field 5700 */
	double	s_unapamt;	/* NUMERIC 99999999.99 Field 5800 */

	char	s_mesg[78];	/* STRING X[77] Field 5900 */
	char	s_resp[2];	/* STRING X Field 6000 */
} s_struct;


double	D_Roundoff();

static	s_struct  s_sth;	/* PROFOM Screen Structure */
static	struct  stat_rec  sr;		/* PROFOM status rec */

static	Cu_rec		cu_rec ;	/* Customer Record */
static	Rcpt_hdr	rcpt_hdr ;	/* Receipts Header Record */
static	Rcpt_item	rcpt_item ;	/* Receipts Item Record */
static	Ar_hdr		ar_hdr ;	/* Sales Invoice Header Record */
static  Pa_rec		pa_rec ;	/* Parameter Record */

static	char 	e_mesg[100];  		/* dbh will return err msg in this */

/*
*	Doubly linked list to maintain po items. Each node in this list
*	conatins one page full of po items. This list is freed only at the
*	time of exiting program. 
*/

typedef	struct Page {

	S_item	Items[PAGESIZE] ;	/* Items information */
	struct	Page	*PrevPage ;	/* Ptr to Previous Page */
	struct	Page	*NextPage ;	/* Ptr to Next Page */
	short	NoItems ;		/* No of Items in this page */
	short	Pageno ;		/* Page Number */

}	Page ;

static	Page	*FirstPage,		/* Address of the First Page */
		*CurPage,		/* Address of the Active Page */
		*InvcLast,		/* Address of Cur. PO Last page */
		*LastPage ;		/* Address of the Last page Memory
					   allocated */
int	KeyAndHdrValidation() ;
int	HdrAndKeyWindowHelp() ;

void	free() ;
char	*malloc() ;

static	double	rcpt_item_total;
static	int	items_written;		/* number of items written to file */

main(argc,argv)
int argc;
char *argv[];
{
	int 	retval;

	retval = Initialize(argc,argv);	/* Initialization routine */

	if (retval == NOERROR) retval = Process();

	CloseRtn();			/* return to menu */
	if (retval != NOERROR) exit(-1);
	exit(0);
}

/*-------------------------------------------------------------------*/
/* Initialize PROFOM */

Initialize(argc, argv)
int	argc ;
char	*argv[] ;
{
	int	err ;

	/*
	*	Initialize DBH Environment
	*/
	strncpy(SYS_NAME,SYSTEM,50);	/* Sub system name */
	strncpy(CHNG_DATE,MOD_DATE,10);	/* Modification Date */

	proc_switch(argc, argv, MAINFL) ; 	/* Process Switches */

	/*
	*	Initialize PROFOM & Screen
	*/
	strcpy(sr.termnm,terminal);	/* Copy Terminal Name */
	fomin(&sr);
	ret(err_chk(&sr)) ;		/* Check for PROFOM Error */
	fomcf(1,1);			/* Enable Snap screen option */

	err = InitScreen() ;		/* Initialize Screen */
	if(NOERROR != err) return(err) ;

	/*
	*	Get The Parameter Record
	*/
	err = get_param(&pa_rec, BROWSE, 1, e_mesg) ;
	if(err == ERROR) {
		DispError(e_mesg);
		return(ERROR) ;
	}
	else if(err == UNDEF) {
#ifdef ENGLISH
		DispError("Parameters Are Not Set Up ...");
#else
		DispError("Parametres ne sont pas etablis... ");
#endif
		return(ERROR) ;
	}

	/*
	*	Initialize Variables
	*/

	FirstPage = NULL ;
	LastPage  = NULL ;

	return(NOERROR) ;
}	/* Initialize() */

/*--------------------------------------------------------------------------*/
/* Close nessary files and environment before exiting program               */

CloseRtn() 
{
	/* Free the linked list from the end */

	/* Free all the pages except the first page */
	for( ; LastPage != FirstPage ; ) {
		LastPage = LastPage->PrevPage ;
		free((char*)LastPage->NextPage) ;
		LastPage->NextPage = NULL ;
	}
	if(FirstPage != NULL)
		free((char*)FirstPage) ;
		
	FirstPage = LastPage = NULL ;

	/* Set terminal back to normal mode from PROFOM */
	fomcs();
	fomrt();

	close_dbh();	/* Close files */

	return(NOERROR);
}	/* CloseRtn() */
/*----------------------------------------------------------------*/
/* Initialize screen before going to process options */

InitScreen()
{
	int	err ;

	/* move screen name to Profom status structure */
	strcpy(sr.scrnam,NFM_PATH);
	strcat(sr.scrnam,SCR_NAME) ;

	strcpy(s_sth.s_pgm,PROG_NAME);

	s_sth.s_rundate = get_date();	/* get Today's Date in YYYYMMDD format*/
	s_sth.s_field = HV_SHORT ;
	s_sth.s_mesg[0] = HV_CHAR ;
	s_sth.s_resp[0] = HV_CHAR ;

	/* Initialize Reference number Field */
	/* So that if user selects 'N' as the first option */
	/* the first record in the file will be retrieved */
	s_sth.s_refnbr = 0;

	/* Move High Values to data fields and Display the screen */
	err = ClearScreen() ;
	if(NOERROR != err) return(err) ;

	return(NOERROR) ;
}	/* InitScreen() */

/*-------------------------------------------------------------------*/
/* Get Option from user and call corresponding function */

Process()
{
	int err;

	for( ; ; ){

		/* Get the Fn: option from the user */
		if((err = ReadFunction()) != NOERROR) return(err) ;

		err = ProcFunction() ;	/* Process Function */

		if(QUIT == err)		return(NOERROR) ;    /* Exit */
		if(NOACCESS == err)	fomen(e_mesg);	     /* security */
		if(PROFOM_ERR == err)	return(PROFOM_ERR);  /* PROFOM ERROR */
		if(DBH_ERR == err) {
			DispError(e_mesg);
#ifdef ENGLISH
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"System Error... Iserror:",
				iserror, dberror, errno);
#else
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"Erreur du systeme... Iserror:",
				iserror, dberror, errno);
#endif
			DispError(e_mesg);
			return(DBH_ERR); /* DBH ERROR */
		}
	}      /*   end of the for( ; ; )       */
}	/* Process() */
/*----------------------------------------------------------------*/
/* Display the Function (Fn:) options and get the option from the user */

ReadFunction()
{
	/* Display Fn: options */
#ifdef ENGLISH
	fomer("A(dd), I(nquire), N(ext), P(rev), E(xit)");
#else
	fomer("R(ajouter), I(nterroger), S(uivant), P(recedent), F(in)");
#endif
	/* Read Fn: field to get the option */
	sr.nextfld = FN_FLD ;
	fomrf( (char *)&s_sth );
	ret(err_chk(&sr));	/* Check for PROFOM error */

	return(NOERROR) ;
}	/* ReadFunction() */
/*----------------------------------------------------------------*/
/* Process the user selected Fn: option */

ProcFunction()
{
	int retval;

	switch (s_sth.s_fn[0]) {
	case ADDREC  :			/* ADD */
		CHKACC(retval,ADD,e_mesg);
		return( AddApply() ) ;
	case INQUIRE  :		
		CHKACC(retval,BROWSE,e_mesg);
		return( Inquire() ) ;
	case NEXT  :			
		CHKACC(retval,BROWSE,e_mesg);
		return( NextRcpt(FORWARD) ) ;
	case PREV  :		
		CHKACC(retval,BROWSE,e_mesg);
		return( NextRcpt(BACKWARD) ) ;
	case EXITOPT  :			/* Exit */
		return( QUIT ) ;
	}  /*   end of the switch statement */

	return(retval);
}	/* ProcFunction() */
/*----------------------------------------------------------------------*/
/* Get receipt to Apply to invoices */

AddApply()
{
	int	err, i ;

	SetDupBuffers( KEY_START, KEY_END, 2 );
	s_sth.s_refnbr = LV_LONG;

	InitHdr(LV_CHAR,LV_DOUBLE);

	/* Get reference number */
	i = ReadFields(KEY_START, KEY_END,
		KeyAndHdrValidation, HdrAndKeyWindowHelp, 0) ;
	if(PROFOM_ERR == i || DBH_ERR == i) return(i) ;
	if(RET_USER_ESC == i) {	/* ESC-F */
		InitHdr(HV_CHAR,HV_DOUBLE) ;

		ret( WriteFields(HDR_ST_FLD, HDR_END_FLD) ) ;

		s_sth.s_mesg[0] = HV_CHAR ;
		ShowMesg() ;

		return(ERROR) ;
	}

	CurPage = NULL ;
	InvcLast  = NULL ;

	/* Get trans type */
	i = ReadFields(HDR_ST_FLD, HDR_END_FLD,
		KeyAndHdrValidation, HdrAndKeyWindowHelp, 0) ;
	if(PROFOM_ERR == i || DBH_ERR == i) return(i) ;
	if(RET_USER_ESC == i) {	/* ESC-F */
		InitHdr(HV_CHAR,HV_DOUBLE) ;

		ret( WriteFields(HDR_ST_FLD, HDR_END_FLD) ) ;

		s_sth.s_mesg[0] = HV_CHAR ;
		ShowMesg() ;

		return(ERROR) ;
	}

	err = GetDetails() ;
	if(PROFOM_ERR == err || DBH_ERR == err) return(err) ;
	if(err < 0 || CANCEL == err) {
		roll_back(e_mesg) ;	/* Unlock the locked Records */
		return(ClearScreen()) ;	/* Clear the Screen */
	}

	if(CurPage == NULL) return(NOERROR);	

	for( ; ; ) {
		err = ConfirmItems() ;
		if(err != YES) break;

		err = WriteRecords();
		if(err < 0) {
			if(err == LOCKED) continue;
			break;
		}
		break;
	}

	return(NOERROR);
}	/* AddApply() */
/*-----------------------------------------------------------------------*/
WriteRecords()
{

	int 	i, err;
	Page	*temppage;

	/* initialze to no items written */
	items_written = 0;

	/* Copy Items and write to the file */
	if(InvcLast != NULL) {
		for(temppage = FirstPage ; temppage != NULL ;
					temppage = temppage->NextPage) {
			for(i = 0; i < temppage->NoItems ; i++) {
				err = ProcItemUpdates(temppage, i) ;
				if(err==LOCKED) {
					DispError(e_mesg);
					roll_back(e_mesg) ;
					return(LOCKED) ;
				}
				if(err != NOERROR) break ;
			}
			/* IF the process is done upto Current Po Last Page,
			   then break */
			if(temppage == InvcLast) break ;
		    }
	}

	if(err == NOERROR)
		err = commit(e_mesg) ;
	if(err < 0) {
#ifdef ENGLISH
		DispError("ERROR in Saving Records"); 
#else
		DispError("ERREUR en conservant les fiches");
#endif
		DispError(e_mesg);
		return(err);
	}
	return(NOERROR);
}
/*-----------------------------------------------------------------------*/
ProcItemUpdates(temppage, item_no)
Page	*temppage ;
int	item_no;
{
	int	err;

	if(strcmp(temppage->Items[item_no].s_status,APPLY_STAT) == 0) {
		/* UPDATE ARS HEADER RECORD */
		ar_hdr.ah_fund = rcpt_hdr.rhdr_fund;
		ar_hdr.ah_inv_no = temppage->Items[item_no].s_invcnbr;
		ar_hdr.ah_sno = 1;
		err = get_arhdr(&ar_hdr,UPDATE,0,e_mesg);
		if(err < 0) {
			if(err==LOCKED) return(LOCKED);
			fomer(e_mesg); get();
			roll_back(e_mesg);
			return(DBH_ERR);
		}
		ar_hdr.ah_balance -= temppage->Items[item_no].s_invcamt;
		ar_hdr.ah_balance = D_Roundoff(ar_hdr.ah_balance);
		if(ar_hdr.ah_balance == 0.00)
			ar_hdr.ah_status[0] = COMPLETE;
		err = put_arhdr(&ar_hdr,UPDATE,e_mesg);
		if(err < 0) {
			fomer(e_mesg); get();
			roll_back(e_mesg);
			return(DBH_ERR);
		}

		if(items_written == 0) {
			/* ADD RECEIPT ITEMS RECORDS */
			err = GetNextSerialNo();
			if(err < 0) {
				fomer(e_mesg); get();
				roll_back(e_mesg);
				return(DBH_ERR);
			}
		}
		else {
			rcpt_item.ritm_seqno++;
		}
		
		/* refno & seqno set in above function */
		rcpt_item.ritm_invnumb =  temppage->Items[item_no].s_invcnbr;
		strcpy(rcpt_item.ritm_cust,s_sth.s_cust_cd);
		rcpt_item.ritm_amount =  temppage->Items[item_no].s_invcamt;

		err = put_rcptitem(&rcpt_item,ADD,e_mesg);
		if(err < 0) {
			fomer(e_mesg); get();
			roll_back(e_mesg);
			return(DBH_ERR);
		}

		/* Add 1 to items written */
		items_written++;

		if(s_sth.s_unapamt == 0.00) {
			/* Keys already set */
			err = get_rcpthdr(&rcpt_hdr,UPDATE,0,e_mesg);
			if(err < 0) {
				if(err==LOCKED) return(LOCKED);
				fomer(e_mesg); get();
				roll_back(e_mesg);
				return(DBH_ERR);
			}
			rcpt_hdr.rhdr_applied[0] = APPLY;
			err = put_rcpthdr(&rcpt_hdr,UPDATE,e_mesg);
			if(err < 0) {
				fomer(e_mesg); get();
				roll_back(e_mesg);
				return(DBH_ERR);
			}
		}
	}

	return(NOERROR);
}	/* ProcItemUpdates() */
/*-----------------------------------------------------------------------*/
GetNextSerialNo() /* Generate the next serial no. (part of the key) */
{
	int	retval;

#ifdef	ORACLE
	long	sno, get_maxsno() ;
#endif

		rcpt_item.ritm_refno = rcpt_hdr.rhdr_refno;
#ifndef	ORACLE
		rcpt_item.ritm_seqno = HV_LONG;

		flg_reset(RCPTITEM);
		retval = get_n_rcptitem( &rcpt_item,BROWSE,0,BACKWARD,e_mesg );
		seq_over(RCPTITEM);
		if( retval==ERROR ){
			fomen(e_mesg); get();
			return(retval);
		}
	
		if( rcpt_item.ritm_refno!=s_sth.s_refnbr || retval==EFL ){
			rcpt_item.ritm_refno = s_sth.s_refnbr;
			rcpt_item.ritm_seqno = 1;
		}
		else
			rcpt_item.ritm_seqno++ ;
#else
		/* Get maximum invoice number(i.e on 2nd part of key) */
		sno = get_maxsno(RCPTITEM, (char*)&rcpt_item, 0, 1, e_mesg) ;
		if( sno < 0 ){
			fomen(e_mesg); get();
			return(sno);
		}
		rcpt_item.ritm_seqno = sno + 1;

#endif

	return(NOERROR);
}	/* GetNextSerialNo() */
/*-----------------------------------------------------------------------*/
Inquire()
{
	int	err, i ;

	s_sth.s_refnbr = LV_LONG;

	InitHdr(HV_CHAR,HV_DOUBLE);

	/* Get reference number */
	i = ReadFields(KEY_START, KEY_END,
		KeyAndHdrValidation, HdrAndKeyWindowHelp, 0) ;
	if(PROFOM_ERR == i || DBH_ERR == i) return(i) ;
	if(RET_USER_ESC == i) {	/* ESC-F */
		InitHdr(HV_CHAR,HV_DOUBLE) ;

		ret( WriteFields(HDR_ST_FLD, HDR_END_FLD) ) ;

		s_sth.s_mesg[0] = HV_CHAR ;
		ShowMesg() ;

		return(ERROR) ;
	}

	CurPage = NULL ;
	InvcLast  = NULL ;

	/* Initialize tr_type so all IN/DM and CM transactions will be */
	/* Displayed. */
	strcpy(s_sth.s_tr_type,"  ");

	err = GetDetails() ;
	if(PROFOM_ERR == err || DBH_ERR == err) return(err) ;
	if(err < 0 || CANCEL == err) {
		roll_back(e_mesg) ;	/* Unlock the locked Records */
		return(ClearScreen()) ;	/* Clear the Screen */
	}

	if(CurPage == NULL) return(NOERROR);

	err = ConfirmItems() ;
	if(err < 0) return(err) ;

	return(NOERROR) ;
}	/* Inquire() */
/*----------------------------------------------------------*/
/* Show the next or previous receipt */

NextRcpt(direction)
int	direction ;
{
	int err;

	/* Check whether file is in seq. read mode */
	if(flg_start(RCPTHDR) != direction) {
		rcpt_hdr.rhdr_refno = s_sth.s_refnbr ;
		if (direction == FORWARD)
			rcpt_hdr.rhdr_refno++ ;
		else	rcpt_hdr.rhdr_refno-- ;
		flg_reset(RCPTHDR);
	}

	err = get_n_rcpthdr(&rcpt_hdr, BROWSE, 0, direction, e_mesg);
#ifndef ORACLE
	seq_over(RCPTHDR);
#endif
	if(ERROR == err)return(DBH_ERR) ;
	if(EFL == err) {
#ifdef	ENGLISH
		fomen("No More Records....");
#else
		fomen("Plus de fiches....");
#endif
		get();
		flg_reset(RCPTHDR);
		return(NOERROR) ;
	}

	CurPage = NULL ;
	InvcLast  = NULL ;

	s_sth.s_refnbr = rcpt_hdr.rhdr_refno;

	if(GetRcptItems()<0) return(DBH_ERR);
	if(GetCustomer()<0) return(DBH_ERR);
	strcpy(s_sth.s_cust_cd,rcpt_hdr.rhdr_cust);
	strcpy(s_sth.s_cust_nm,cu_rec.cu_name);
	s_sth.s_rcpt_amt = rcpt_hdr.rhdr_amount - rcpt_item_total;

	/* Initialize tr_type so all IN/DM and CM transactions will be */
	/* Displayed. */
	strcpy(s_sth.s_tr_type,"  ");

	/* Initialize Totals */
	s_sth.s_rcptamt = s_sth.s_rcpt_amt;
	s_sth.s_applamt = 0.00;
	s_sth.s_unapamt = s_sth.s_rcptamt - s_sth.s_applamt;
	ret( WriteFields(KEY_START, HDR_END_FLD) );

	
	return( GetDetails() ) ;
}	/* NextRcpt() */
/*-----------------------------------------------------------------------*/
/* Get Item Details.							 */
GetDetails()
{
	int err, i;

	/* Make Invoice Linked list to apply the receipt to */
	if((err = MakeInvcItemList())<0) return(err);

	if(CurPage == NULL) {
		/* if no items to display clear items and totals */
		for(i=0 ; i < PAGESIZE ; i++ )
			InitItem(i, HV_CHAR, HV_LONG, HV_DOUBLE) ;

		InitTotals(HV_DOUBLE);
		ret( WriteFields(ITEM_ST_FLD,TOTAL_END_FLD) ) ;

		if(strcmp(s_sth.s_tr_type,"  ") == 0) 
#ifdef ENGLISH
			fomer("No Items to be Displayed");
#else
			fomer("Pas d'articles a afficher");
#endif
		else
#ifdef ENGLISH
			fomer("No Items of that Type to be Displayed");
#else
			fomer("Pas d'articles de ce genre a afficher");
#endif
		get();
		return(NOERROR);
	}

	if((err = ShowItems(CurPage)) < 0) return(err);

	if((err = ShowTotals()) <0) return(err);

	return(NOERROR);
}	/* GetDetails() */
/*-----------------------------------------------------------------------*/
/* Make invoice items list depending on s_tr_type. 			 */
MakeInvcItemList()
{
	int err, i;
	int rcptexist = 0;
	long	prev_invc;

	strcpy(ar_hdr.ah_cu_code,s_sth.s_cust_cd);
	ar_hdr.ah_fund = 0;
	ar_hdr.ah_inv_no = 0;
	ar_hdr.ah_sno = 0;
	flg_reset(ARSHDR);

	InvcLast = CurPage = NULL;
	i = 0;
	
	prev_invc = 0;
	for( ; ; ) {
#ifndef ORACLE
		err = get_n_arhdr( &ar_hdr, BROWSE, 1, FORWARD, e_mesg);
#else
		err = get_n_arhdr( &ar_hdr, BROWSE, 1, EQUAL, e_mesg);
#endif
		if(ERROR == err) return(DBH_ERR) ;
		if(EFL == err) break ;
		if(strcmp(ar_hdr.ah_cu_code,s_sth.s_cust_cd)!=0) break;

		if(s_sth.s_fn[0] == ADDREC) {
			if(ar_hdr.ah_sno == 1 && ar_hdr.ah_balance == 0.00)
				 continue;
		}
		else {
			/* skip if not and invoice and the invoice number
			   on the screen does not match the current rec. */
			if(ar_hdr.ah_sno != 1 && prev_invc != ar_hdr.ah_inv_no)
				continue;

			if(CheckRcptExist(&rcptexist)<0) return(DBH_ERR);
			/* skip if no receipt and balance of zero */
			if(rcptexist==0 && ar_hdr.ah_sno == 1 && 
						ar_hdr.ah_balance == 0.00)
				continue;
		}
		if(strcmp(s_sth.s_tr_type,"  ")!=0) {
			if(strcmp(s_sth.s_tr_type,ar_hdr.ah_type) != 0) 
				continue;
		} 

		if(PAGESIZE == i) i = 0 ;
		if(0 == i)		/* 1st Item in the Page */
			if((err = MakeFreshPage()) < 0) return(err) ;

		strcpy(CurPage->Items[i].s_type,ar_hdr.ah_type);
		CurPage->Items[i].s_invcnbr = ar_hdr.ah_inv_no;
		CurPage->Items[i].s_trdate = ar_hdr.ah_trandt;
		if(ar_hdr.ah_sno == 1) 
			CurPage->Items[i].s_invcamt = ar_hdr.ah_balance;
		else
			CurPage->Items[i].s_invcamt = ar_hdr.ah_oriamt;

		if(rcptexist == 0) 
			strcpy(CurPage->Items[i].s_status, UNAPP_STAT) ;
		else
			strcpy(CurPage->Items[i].s_status, APPLY_STAT) ;

		prev_invc = ar_hdr.ah_inv_no;
		CurPage->NoItems++ ;
		i++ ;
	} 
	seq_over(ARSHDR) ;

	if(InvcLast != NULL)
		CurPage = FirstPage ;

	return(NOERROR) ;
}	/* MakeInvcItemsList() */
/*-----------------------------------------------------------------------*/
/*	Get the next node in linked list to add invoice items. If the
*	(Cur. invc last page) = (Last Page in linked List) or no
*	nodes in list, allocate node and add to linked list
*/

MakeFreshPage()
{
	Page	*tempptr ;

	/* If, no node is allocated yet or Current invoice used all the nodes,
	   then allocate new node */

	if( LastPage == NULL || InvcLast == LastPage ){
		tempptr= (Page *)malloc((unsigned)sizeof(Page)) ;

		if( tempptr == NULL ){
#ifdef ENGLISH
			DispError("MEMORY ALLOCATION ERROR...");
#else
			DispError("ERREUR D'ALLOCATION A LA MEMOIRE...");
#endif
			return(ERROR);
		}
		tempptr->NextPage = NULL ;

		if( LastPage == NULL ){	/* No node is allocated Yet */
			tempptr->PrevPage = NULL ;
			tempptr->Pageno = 1 ;
			FirstPage = tempptr ;
		}
		else {				/* Not a first node in list */
			tempptr->Pageno = LastPage->Pageno + 1 ;
			LastPage->NextPage = tempptr ;
			tempptr->PrevPage = LastPage ;
		}
		LastPage = tempptr ;
	}

	if(InvcLast == NULL)
		InvcLast = FirstPage ;
	else
		InvcLast = InvcLast->NextPage ;

	InvcLast->NoItems = 0 ;
	CurPage = InvcLast ;

	return(NOERROR);
}	/* MakeFreshPage() */
/*------------------------------------------------------------*/
CheckRcptExist(exists)
int	*exists;
{
	int	err;

	/* Assume receipt does not exist until it finds it */
	*exists = 0;

	strcpy(rcpt_item.ritm_cust,s_sth.s_cust_cd);
	rcpt_item.ritm_invnumb = ar_hdr.ah_inv_no;
	rcpt_item.ritm_refno = s_sth.s_refnbr;
	rcpt_item.ritm_seqno = 0;
	flg_reset(RCPTITEM);
	for( ; ; ) {
		err = get_n_rcptitem(&rcpt_item,BROWSE,1,FORWARD,e_mesg);
		if(err == EFL) break;
		if(err < 0) {
			fomer(e_mesg); get();
			return(DBH_ERR);
		}

		if(strcmp(rcpt_item.ritm_cust,s_sth.s_cust_cd) != 0 ||
		   rcpt_item.ritm_invnumb != ar_hdr.ah_inv_no ||
		   rcpt_item.ritm_refno != rcpt_hdr.rhdr_refno) break;

		if(rcpt_item.ritm_invnumb == ar_hdr.ah_inv_no) {
			*exists = 1;
			break;
		}
	}
	seq_over(RCPTITEM);
	return(NOERROR);
}
/*------------------------------------------------------------*/
/* Show all the items on the current page 		      */
ShowItems(pageptr)
Page	*pageptr ;
{
	int	i ;

	if(pageptr != NULL) {
		/* Copy the items to screen */
		scpy((char*)s_sth.s_items, (char*)pageptr->Items,
			(pageptr->NoItems * sizeof(S_item)) );

		s_sth.s_page_no   = pageptr->Pageno ;

		s_sth.s_dummy1[0] = ' ' ;
		s_sth.s_dummy2[0] = ' ' ;
		s_sth.s_dummy3[0] = ' ' ;

		i = pageptr->NoItems ;
	}
	else {
		s_sth.s_page_no   = HV_SHORT ;
		s_sth.s_dummy1[0] = HV_CHAR ;
		s_sth.s_dummy2[0] = HV_CHAR ;
		s_sth.s_dummy3[0] = HV_CHAR ;
		i = 0 ;
	}

	/* Move High Values to remaining Items */
	for( ; i < PAGESIZE ; i++ )
		InitItem(i, HV_CHAR, HV_LONG, HV_DOUBLE) ;

	ret( WriteFields( PAGENO_FLD, (END_FLD - 200)) );

	return(NOERROR) ;
}	/* ShowItems() */
/*------------------------------------------------------------*/
ConfirmItems()
{
	int	err ;
	char	chg_status[4];

	/* Options:
	   Add      - YAENPC
	   Change   - YAEHSTNPC
	   Inquiry  - YNPH
	*/

	for( ; ; ) {
	    switch(s_sth.s_fn[0]) {
	    case  ADDREC :		/* Add Apply */
#ifdef ENGLISH
		err = GetOption(
		"Y(es), A(pply), U(napply), N(ext), P(rev), C(ancel)"
		,"YAUNPC");
#else
		err = GetOption(
		"O(ui), R(ecu s'applique), N(on-applique), S(uiv), P(rec), A(nnul)"
		,"ORNSPA");
#endif
		break ;
	    case INQUIRE :
#ifdef ENGLISH
		err = GetOption("Y(es), N(ext Page), P(rev Page)","YNP");
#else
		err = GetOption("O(ui), S(uivant), P(recedent)","OSP");
#endif
		break ;
	    }
	    if(err == PROFOM_ERR) return(err) ;

	    switch(err) {
	    case  YES  :
		return(YES);
	    case  APPLY :
	    case  UNAPPLY :
		if(err == APPLY)
			strcpy(chg_status,APPLY_STAT);
		else
			strcpy(chg_status,UNAPP_STAT);

		ChangeStatus(chg_status);
		break ;
	    case  NEXTPAGE :
		if(CurPage == InvcLast || InvcLast == NULL) {
#ifdef ENGLISH
			fomer("No More Pages....") ;
#else
			fomer("Plus de pages....") ;
#endif
			continue ;
		}
		CurPage = CurPage->NextPage ;
		err = ShowItems(CurPage) ;
		break ;
	    case  PREVPAGE :
		if(InvcLast == NULL || CurPage == FirstPage ) {
#ifdef ENGLISH
			fomer("No More Pages....") ;
#else
			fomer("Plus de pages....") ;
#endif
			continue ;
		}
		CurPage = CurPage->PrevPage ;
		err = ShowItems(CurPage) ;
		break ;
	    case  CANCEL :
#ifdef ENGLISH
		err = GetOption("Confirm the Cancel (Y/N)?", "YN") ;
#else
		err = GetOption("Confirmer l'annulation (O/N)?", "ON") ;
#endif
		if(err == YES) return(CANCEL) ;
		break ;
	    }	/* switch err */

	    if(err == PROFOM_ERR) return(err) ;
	    if(err == DBH_ERR) return(err) ;
	}	/* for(; ; ) */
}	/* ConfirmItems() */
/*------------------------------------------------------------*/
/* Change Status. 					      */
ChangeStatus(status)
char	*status;
{
	int	flag, err ;

	/* Get The Item to Be Modified */

	for( ; ; ) {
#ifdef ENGLISH
		strcpy(s_sth.s_mesg,"Press RETURN to terminate Edit");
#else
		strcpy(s_sth.s_mesg,"Appuyer sur RETURN pour terminer l'ajustement");
#endif
		ShowMesg() ;
		sr.nextfld = CHG_FLD ;
		fomrf( (char *)&s_sth );
		ret(err_chk(&sr));

		if(s_sth.s_field == 0) break ;
		if( s_sth.s_field < 1 || CurPage == NULL ||
				s_sth.s_field > CurPage->NoItems)
			continue ;

		if(s_sth.s_items[s_sth.s_field-1].s_invcnbr == 
		   s_sth.s_items[s_sth.s_field-2].s_invcnbr) {
#ifdef ENGLISH
			fomer("Cannot apply receipt to applied DM or CM");
#else
			fomer("Ne peut pas appliquer le recu a la ND ou a la NC appliquee");
#endif
			continue;
		} 
		if(strcmp(s_sth.s_items[s_sth.s_field-1].s_type,T_CRMEMO)==0) {
#ifdef ENGLISH
			fomer("The status of a credit memo cannot be changed");
#else
			fomer("L'etat de la note de credit ne peut etre change");
#endif
			continue;
		}
		if(strcmp(status,APPLY_STAT) == 0 && s_sth.s_unapamt < 
				s_sth.s_items[s_sth.s_field-1].s_invcamt) {
#ifdef ENGLISH
			fomer("Applied Amount must complete invoice");
#else
			fomer("Le montant applique doit complete la facture");
#endif
			continue;
		}		

		if(strcmp(s_sth.s_items[s_sth.s_field-1].s_status,status)==0) {
			if(strcmp(status,APPLY_STAT)==0) 
#ifdef ENGLISH
				fomer("Invoice is already applied");
#else
				fomer("Facture est deja appliquee");
#endif
			else
#ifdef ENGLISH
				fomer("Invoice is already unapplied");
#else
				fomer("Facture est deja non-appliquee");
#endif
		}
		else {
			/* Change status on screen and in linked list */
			strcpy(s_sth.s_items[s_sth.s_field-1].s_status,status);
			strcpy(CurPage->Items[s_sth.s_field-1].s_status,status);
			sr.nextfld = ((s_sth.s_field-1)*STEP) + 
						ITEM_ST_FLD + STATUS_FLD;
			fomwf( (char *)&s_sth );
			ret(err_chk(&sr));

			/* Calculate Totals and Display */
			if(strcmp(status,APPLY_STAT) == 0) 
				flag = 1;
			else
				flag = -1;

			s_sth.s_applamt += 
				s_sth.s_items[s_sth.s_field-1].s_invcamt * flag;

			s_sth.s_unapamt = s_sth.s_rcptamt - s_sth.s_applamt;

			if((err = ShowTotals()) <0) return(err);
			
		}
	}

	sr.nextfld = CHG_FLD ;
	s_sth.s_field = HV_SHORT ;
	fomwf( (char *)&s_sth );
	ret(err_chk(&sr));

	s_sth.s_mesg[0] = HV_CHAR;
	ShowMesg();
	return(NOERROR);
}
/*------------------------------------------------------------*/
/* Show totals at bottom of screen.			      */
ShowTotals()
{
	ret(WriteFields(TOTAL_ST_FLD,TOTAL_END_FLD));
	return(NOERROR);
}
/*------------------------------------------------------------*/
/* Read the PROFOM Screen for a given Range of fields */

ReadFields(st_fld, end_fld, Validate, WindowHelp, mode)
int	st_fld ;
int	end_fld;
int	(*Validate)() ;
int	(*WindowHelp)() ;
int	mode ;	/* ADD or UPDATE. This is required only when reading item */
{
	int	err ;

	sr.nextfld = st_fld ;
	sr.endfld  = end_fld;
	for( ; ;){
		fomrd( (char *)&s_sth );
		ret(err_chk(&sr));

		if(sr.retcode == RET_VAL_CHK){
			err = (*Validate)(mode) ;
			if(DBH_ERR == err || PROFOM_ERR == err) return(err);
			sr.nextfld = sr.curfld ;
			continue;
		}
		if(sr.retcode == RET_USER_ESC){
			if(sr.escchar[0] == 'f' || sr.escchar[0] == 'F')
				return(RET_USER_ESC) ;
			if(sr.escchar[0] == 'h' || sr.escchar[0] == 'H'){
				err = (*WindowHelp)() ;
				if(DBH_ERR == err || PROFOM_ERR == err)
					return(err) ;
				sr.nextfld = sr.curfld ;
				continue;
			}
			continue;
		}
		/* else RET_NO_ERROR */
		break;
	}

	return(NOERROR) ;
}	/* ReadFields() */
/*------------------------------------------------------------*/
/* Write fields on Screen for a given Range */

WriteFields(st_fld, end_fld)
int	st_fld ;
int	end_fld ;
{
	sr.nextfld = st_fld ;
	sr.endfld  = end_fld ;

	fomwr( (char *)&s_sth );
	ret(err_chk(&sr));

	return(NOERROR) ;
}	/* WriteFields() */
/*----------------------------------------------------------------*/
/* Set Duplication buffers for fields 				  */
SetDupBuffers( firstfld, lastfld, value )
int	firstfld, lastfld;	/* field numbers range */
int	value;			/* ENABLE or DISABLE */
{
	int i;

	for( i=firstfld; i<=lastfld; i+=100 )
		fomca1( i, 19, value);
	if( value==0 )
		return(0);
	sr.nextfld = firstfld;
	sr.endfld = lastfld;
	fomud( (char *)&s_sth );
	ret( err_chk(&sr) );

	return( 0 );
}
/*----------------------------------------------------------------*/
/* Validation function() for Key and Header fields when PROFOM returns
  RET_VAL_CHK */

KeyAndHdrValidation()
{
	int	err ;

	switch(sr.curfld){
	case	KEY_START	:	/* receipt number */
		if(s_sth.s_fn[0] == ADDREC || s_sth.s_fn[0]==INQUIRE) {
			rcpt_hdr.rhdr_refno = s_sth.s_refnbr;
			err = get_rcpthdr(&rcpt_hdr,BROWSE,0,e_mesg);
			if(err < 0) {
			      fomer(e_mesg);
			      s_sth.s_refnbr = LV_LONG;
			      break;
			}
			if(rcpt_hdr.rhdr_applied[0] == APPLY && 
						s_sth.s_fn[0] == ADDREC) {
#ifdef ENGLISH
				fomer("Receipt already fully applied");
#else
				fomer("Le recu est deja pleinement applique");
#endif
				s_sth.s_refnbr = LV_LONG;
				break;
			}
		}
		if(GetRcptItems()<0) return(DBH_ERR);
		if(GetCustomer()<0) return(DBH_ERR);
		strcpy(s_sth.s_cust_cd,rcpt_hdr.rhdr_cust);
		strcpy(s_sth.s_cust_nm,cu_rec.cu_name);
		s_sth.s_rcpt_amt = rcpt_hdr.rhdr_amount - rcpt_item_total;
		/* Initialize Totals */
		s_sth.s_rcptamt = s_sth.s_rcpt_amt;
		s_sth.s_applamt = 0.00;
		s_sth.s_unapamt = s_sth.s_rcptamt - s_sth.s_applamt;
		ret( WriteFields(HDR_ST_FLD, HDR_END_FLD) );
		break;
	case	TRTYPE_FLD	:	/* trans type */
		if(strcmp(s_sth.s_tr_type,"\0") == 0) {
			strcpy(s_sth.s_tr_type,"  ");
		}
		if(strcmp(s_sth.s_tr_type,T_INVOICE) && 
		   strcmp(s_sth.s_tr_type,T_DBMEMO) && 
		   strcmp(s_sth.s_tr_type,T_CRMEMO) &&
		   strcmp(s_sth.s_tr_type,"  ") ) {
			fomer("Valid types are IN, DM, and CM");  get();
			s_sth.s_tr_type[0] = LV_CHAR;
		}
		break;
	default :
#ifdef ENGLISH
		sprintf(e_mesg,"No Validity Check For Field#  %d",sr.curfld);
#else
		sprintf(e_mesg,"Pas de controle de validite pour le Champ#  %d",sr.curfld);
#endif
		fomen(e_mesg);
		get();
		return(ERROR) ;
	}	/* Switch sr.curfld */

	return(NOERROR) ;
}	/* KeyAndHdrValidation() */
/*----------------------------------------------------------------*/
/* read receipts item file. */
GetRcptItems()
{
	int	err;

	rcpt_item_total = 0.00;
	
	rcpt_item.ritm_refno = rcpt_hdr.rhdr_refno;
	rcpt_item.ritm_seqno = 0;
	flg_reset(RCPTITEM);
	for( ; ; ) {
		err = get_n_rcptitem(&rcpt_item,BROWSE,0,FORWARD,e_mesg);
		if(err == EFL) break;
		if(err < 0) {
			fomer(e_mesg); get();
			return(DBH_ERR);
		}
		if(rcpt_item.ritm_refno != rcpt_hdr.rhdr_refno) break;
		rcpt_item_total += rcpt_item.ritm_amount;
	}
	seq_over(RCPTITEM);
	return(NOERROR);
}	/* GetRcptItem() */
/*----------------------------------------------------------------*/
/* read customer file. */
GetCustomer()
{
	int	err;
	
	strcpy(cu_rec.cu_code,rcpt_hdr.rhdr_cust);
	err = get_cust(&cu_rec,BROWSE,0,e_mesg);
	if(err < 0) {
		fomer(e_mesg); get();
		return(DBH_ERR);
	}
	return(NOERROR);
}	/* GetCustomer() */
/*----------------------------------------------------------------*/
/* Show Help Windows, if applicable, when user gives ESC-H in key
   and header fields */

HdrAndKeyWindowHelp()
{
#ifdef ENGLISH
	fomer("No Help Window For This Field");
#else
	fomer("Pas de fenetre d'assistance pour ce champ");
#endif

	return(NOERROR) ;
}	/* HdrAndKeyWindowHelp() */
/*-----------------------------------------------------------------------*/
/* Display message and get the option */

GetOption(msg,options)
char	*msg ;
char	*options ;
{
	int	i, j ;

	strcpy(s_sth.s_mesg,msg);
	ShowMesg() ;

	sr.nextfld = END_FLD ;
	for( ; ; ) {
		fomrf( (char *)&s_sth ) ;
		ret(err_chk(&sr)) ;

		j = strlen(options) ;
		for( i = 0 ; i < j ; i++)
			if(s_sth.s_resp[0] == options[i]) break ;
		if(i != j) break ;	/* Valid Option Selected */
#ifdef ENGLISH
		fomer("Invalid Option..");
#else
		fomer("Option invalide..");
#endif
	}

	s_sth.s_mesg[0] = HV_CHAR ;
	s_sth.s_resp[0] = HV_CHAR ;
	
	ret( WriteFields(END_FLD -100, END_FLD) );

	return((int)(options[i])) ;
}	/* GetOption() */
/*-----------------------------------------------------------*/
/* Move High values to all data fields and clear the screen */

ClearScreen()
{
	int	i;

	/* Move High Values to Hedaer part */
	InitHdr(HV_CHAR, HV_DOUBLE) ;

	s_sth.s_page_no    = HV_SHORT ;
	s_sth.s_dummy1[0] = HV_CHAR ;
	s_sth.s_dummy2[0] = HV_CHAR ;
	s_sth.s_dummy3[0] = HV_CHAR ;

	/* Move High Values to All items */
	for(i = 0 ; i < PAGESIZE ; i++)
		InitItem(i, HV_CHAR, HV_LONG, HV_DOUBLE) ;

	InitTotals(HV_DOUBLE);

	ret( WriteFields(HDR_ST_FLD, (END_FLD - 200)) );

	return(NOERROR);
}	/* ClearScreen() */
/*-------------------------------------------------------------------------*/
/* Initialize Screen Header with either Low or High Values */

InitHdr( t_char, t_double )
char	t_char ;
double	t_double ;
{
	s_sth.s_cust_cd[0] = t_char;
	s_sth.s_cust_nm[0] = t_char;
	s_sth.s_rcpt_amt   = t_double;
	s_sth.s_tr_type[0] = t_char;

	return(NOERROR) ;
}	/* InitHdr() */
/*-------------------------------------------------------------------------*/
/* Initialize Given screen item with either Low values or High values */

InitItem(item_no, t_char, t_long, t_double)
int	item_no ;
char	t_char ;
long	t_long ;
double	t_double ;
{
	s_sth.s_items[item_no].s_type[0]   = t_char;
	s_sth.s_items[item_no].s_invcnbr   = t_long;
	s_sth.s_items[item_no].s_trdate    = t_long;
	s_sth.s_items[item_no].s_invcamt   = t_double;
	s_sth.s_items[item_no].s_status[0] = t_char;

	return(NOERROR) ;
}	/* Inititem() */
/*-------------------------------------------------------------------------*/
/* Initialize Given screen item with either Low values or High values */
InitTotals(t_double)
double t_double;
{
	
	s_sth.s_rcptamt = t_double;
	s_sth.s_applamt = t_double;
	s_sth.s_unapamt = t_double;

	return(NOERROR);
}	/* InitTotals() */
/*-------------------------------------------------------------------------*/

DispError(s)    /* show ERROR and wait */
char	*s;
{
	strncpy(s_sth.s_mesg,s, (sizeof(s_sth.s_mesg) - 1));
	ShowMesg();
#ifdef ENGLISH
	fomen("Press any key to continue");
#else
	fomen("Appuyer sur une touche pour continuer");
#endif
	get();
	s_sth.s_mesg[0] = HV_CHAR;
	ShowMesg();
	return(NOERROR);
}
/*-------------------------------------------------------------------------*/

ShowMesg()  /* shows or clears message field */
{
	sr.nextfld = END_FLD - 100;
	fomwf( (char *)&s_sth ) ;
}
/*-------------------- E n d   O f   P r o g r a m ---------------------*/
