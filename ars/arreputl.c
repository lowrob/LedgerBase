/******************************************************************************
		Sourcename    : arreputl.c
		System        : Budgetary Financial system.
		Module        : ARS reports
		Created on    : 89-11-23
		Created  By   : K HARISH.
		Cobol sources : 

HISTORY:
 Date           Programmer     Description of modification
____/__/__      __________     ___________________________
1991/02/08	p.ralph		Right justify numeric customer codes
1992/07/28      Jamie McLean    Summary or Detail Report Option,
				Changed Customer code from 6 to 10 characters.

Calls for the user:	( Check for the value returned: -1 on error )

int	AddMenuItem( char *name, int (* fnptr)() );
int	Initialize( char *terminalname , char *heading );
int	Process();
int	GetCNbrRange( char *, char * );
int	GetCNameRange( char *, char * );
int	GetReportType( char * );
int	GetTransDateRange( long *, long * );
int	GetDate( long * );
int	GetFundRange( short *, short * );
long	GetInvcRange( long *, long * );
long	GetRcptRange( long *, long * );
int	DisplayMessage( char * );
int	GetResponse( char * char * );
int	HideMessage();
int	GetOutputon( char * );
int	GetFilename( char * );
int	GetPrinter( short * );
int	GetNbrCopies( short * );
int	Confirm();		returns 1 for Yes, and 0 for anyother input

The programmer should make calls for appending menuitems in the following order.
		AddMenuItem( menuname, functionpointer );( max. 9 options )
		Initialize( screenheading );
		Process();	 for menu item selection
		{	Any "Get...." calls }
		Confirm();	It clears the screen and resets terminal
A maximum of 9 menuitems can be added, excluding one for Quitting the screen
which is automatically appended by the system.

For all the calls starting with "Get", user can pass any default values by 
initialising the corresponding variables before passing their address(es)
as parameters. The program does not do any validation except that it disallows
user's entry of end value ( range limit ) if it is smaller than starting value.

The last call should be "Confirm()",  which clears the profom screen and resets
the terminal characteristics

******************************************************************************/
#include <stdio.h>

#include <bfs_defs.h>
#include <cfomstrc.h>

#define SCREEN_NAME	"arrep"
#define EXIT		12
#define PATH_FILE_SIZE	50
#define STARTLINENUM	18
#define LOW 		-1
#define HIGH 		 1
#define HL_CHAR(VAL)	VAL==HIGH ? HV_CHAR : LV_CHAR
#define ESC_F		sr.retcode==RET_USER_ESC && \
			(sr.escchar[0]=='F'||sr.escchar[0]=='f')
#define	OPTIONLEN	34
#define MAXOPTIONS	20
#define MAXQUERYLINES	6	
#define	CNBR		0
#define RTYPE		1
#define	CNAME		1
#define TRDATE		2
#define FUNDNO		3
#define INVCNBR		4
#define RCPTNBR		5

#define CU_NBR1		3000
#define CU_NBR2		3100
#define RPT_TYPE	3200
#define CU_NAM1		3300
#define CU_NAM2		3400
#define TRDATE1		3500
#define TRDATE2		3600
#define FUND1		3700
#define FUND2		3800
#define INVCNO1		3900
#define INVCNO2		4000
#define RCPTNO1		4100
#define RCPTNO2		4200
#define MESSAGE		4300
#define RESPONSE	4400

#ifdef ENGLISH
#define PRINTER		'P'
#define DISPLAY 	'D'
#define FILE_IO		'F'

#define YES		'Y'
#else
#define PRINTER		'I'
#define DISPLAY		'A'
#define FILE_IO		'D'

#define YES		'O'
#endif

/* arrep.sth - header for C structure generated by PROFOM EDITOR */

static struct	s_struct	{
	char	s_progname[11];	/* 100 program name */
	char	s_scrhdg[16];	/* 200 */
	long	s_rundt;	/* 300 DATE YYYYFMMFDD */
	char	s_item[MAXOPTIONS][OPTIONLEN];	/* 400 - 2300 options */
	short	s_option;	/* 2400 user's input */
	char	s_outputon[2];	/* 2600 report output on D / F / P */
	char	s_filename[16];	/* 2700 name of file if option is F */
	short	s_printer;	/* 2800 printer# if option is P */
	short	s_nbrcopies;	/* 2900 number of copies to be printed */

	short	s_no_up;	/* 2950 number of labels across */
	char	s_ccode1[11];	/* 3000 starting dept no. */
	char	s_ccode2[11];	/* 3100 ending dept no. */
	char	s_rpt_type[2];	/* 3200 report type - Detail or Summary  */
	char	s_cname1[21];	/* 3300 starting dept no. */
	char	s_cname2[21];	/* 3400 ending dept no. */
	long	s_trandt1;	/* 3500 starting trans. date */
	long	s_trandt2;	/* 3600 ending trans. date */
	short	s_fund1;	/* 3700 starting fund */
	short	s_fund2;	/* 3800 ending fund */
	long	s_invcno1;	/* 3900 starting invoice number */
	long	s_invcno2;	/* 4000 ending invoice number */
	long	s_rcptno1;	/* 4100 starting invoice number */
	long	s_rcptno2;	/* 4200 ending invoice number */

	char	s_mesg[77];	/* 4300 message field */
	char	s_resp[2];	/* 4400 response field */
}	s_rec;

typedef struct{
	char	name[OPTIONLEN];
	int	(* fnptr)();
	int	mainflno;
}Menu;

struct stat_rec 	sr;		/* profom status record */

static int		line[MAXQUERYLINES];/* for positioning key queries */
static short		call_no;
static short		totaloptions;
static int retval;	/* Global variable to store function values */
static Menu	menu[MAXOPTIONS];
static	int	initialised ;
extern	e_mesg[80];

static
CleanExit()/* clear and exit the screen , close files & exit program */
{
	fomcs();
	fomrt();
	exit(0);
}
Initialize( terminal,heading )	/* initialize profom and screen */
char *terminal;
char *heading;	
{
	if( (retval=InitProfom(terminal))<0 ){	/* initialize profom */
		fomcs();
		fomrt();
		return( retval );
	}
	if( (retval=InitScreen(heading))<0 ){		/* initialize screen */
		fomcs();
		fomrt();
		return( retval );
	}
	initialised = 1 ;
	return(0);
}	
static
InitProfom(terminal)	/* initialize profom */
char *terminal;
{
	if ( initialised )
		return(0) ;
	STRCPY( sr.termnm, terminal );
	fomin( &sr );		/* initialize the screen */
	ret( err_chk(&sr) );	/* if profom error return */

	return(0);
}
static
InitScreen(heading)		/* initialize the screen */
char 	*heading;
{
	/* initialize the profom screen variables */
	STRCPY( sr.scrnam, NFM_PATH );
	strcat( sr.scrnam, SCREEN_NAME );

	/* initialize the fields of the profom screen */
	if( initialised==0 ){
		if( FillScrHdg(heading)<0 ) 		return(-1);
		if( FillMenu()<0 ) 			return(-1);
		if( FillOption(HIGH)<0 )		return(-1);
	}

	/* Move Highs to inquiry area and write the entire screen */
	if( (retval=ClearInquiryArea())<0 )	
		return(retval);

	fomcf( 1,1 ) ;		/* Enable snap screen */
	return(0);
}

/* Fill the screen heading fields, the program name and the date */
static
FillScrHdg(heading)
char *heading;
{
	STRCPY( s_rec.s_progname, PROG_NAME );
	STRCPY( s_rec.s_scrhdg, heading );
	s_rec.s_rundt = get_date();
	return(0);
}

/* Add a menu item to the array of report menu items */
AddMenuItem( menuname, fnptr, mainflno )
char	*menuname;
int	(* fnptr)();
int	mainflno;
{
	if( totaloptions==0 ){ /* no options added to array yet */
#ifdef ENGLISH
		STRCPY( menu[totaloptions].name, "RETURN TO PREVIOUS MENU" );
#else
		STRCPY( menu[totaloptions].name, "RETOURNER AU MENU PRECEDENT");
#endif
		menu[totaloptions].fnptr = NULL;
		totaloptions++;
	}

	if( totaloptions>=MAXOPTIONS )	/* array can't accomodate any more */ 
		return(-1);
	if( menuname==NULL )		/* menu name can't be null */
		return(-1);
	STRCPY( menu[totaloptions].name, menuname );
	menu[totaloptions].fnptr = fnptr;	/* copy function pointer */
	menu[totaloptions].mainflno = mainflno; /* copy main file used */

	totaloptions++;

	return(totaloptions-1);
}
/* Fill Menu Options with the proper names */
static
FillMenu()
{
	short	i;

	for( i=0; i<totaloptions; i++ )
		STRCPY( s_rec.s_item[i], menu[i].name );
	for( i=totaloptions; i<MAXOPTIONS; i++ )
		s_rec.s_item[i][0] = HV_CHAR;
	return(0);
}
static
FillOption( value )
short value;
{
	s_rec.s_option = value * HV_SHORT;
	return(0);
}
/* Fill output details with high or low values */
static
FillOutputDetails( value )
short value;
{
	s_rec.s_outputon[0] = HL_CHAR(value);
	s_rec.s_filename[0] = HL_CHAR(value);
	s_rec.s_printer = HV_SHORT * value;
	s_rec.s_nbrcopies = HV_SHORT * value;
	s_rec.s_no_up = HV_SHORT * value;
	return(0);
}
static
FillCNbr( val1, val2 )
short	val1, val2;
{
	s_rec.s_ccode1[0] = HL_CHAR(val1);
	s_rec.s_ccode2[0] = HL_CHAR(val2);
	return(0);
}
static
FillRType( val1 )
short	val1;
{
	s_rec.s_rpt_type[0] = HL_CHAR(val1);
	return(0);
}
FillCName( val1, val2 )
short	val1, val2;
{
	s_rec.s_cname1[0] = HL_CHAR(val1);
	s_rec.s_cname2[0] = HL_CHAR(val2);
	return(0);
}
FillTrDate( val1, val2 )
short	val1, val2;
{
	s_rec.s_trandt1 = HV_LONG * val1;
	s_rec.s_trandt2 = HV_LONG * val2;
	return(0);
}
FillFund( val1, val2 )
short	val1, val2;
{
	s_rec.s_fund1 = HV_SHORT * val1;
	s_rec.s_fund2 = HV_SHORT * val2;
	return(0);
}
FillInvcno( val1, val2 )
short	val1, val2;
{
	s_rec.s_invcno1 = HV_LONG * val1;
	s_rec.s_invcno2 = HV_LONG * val2;
	return(0);
}
FillRcptno( val1, val2 )
short	val1, val2;
{
	s_rec.s_rcptno1 = HV_LONG * val1;
	s_rec.s_rcptno2 = HV_LONG * val2;
	return(0);
}
/* Fill the message and response fields with high or low values */
static
FillMsgRespFields( value )
short value;
{
	s_rec.s_mesg[0] = HL_CHAR( value );
	s_rec.s_resp[0] = HL_CHAR( value );

	return(0);
}
/* Accept user's option and call the corresponding routine in a loop */
Process(terminal, heading)
char	*terminal ;
char	*heading  ;
{
	int	field;
	short	prev_option;

	if((retval = Initialize(terminal, heading))<0 )
		return(retval);
	call_no = 0;	/* No get calls made yet */
	prev_option = -1;
	for( ; ; ){
		mainfileno = -1 ;
		for( ; ; ) {
			fomca1(2400,19,2); /* enable dup control */

			sr.nextfld = sr.endfld = 2400;
			fomud( (char *)&s_rec);
			ret(err_chk(&sr));	/* Check for PROFOM error */
			s_rec.s_option=LV_SHORT;

			retval = ReadOption();
			if( retval<0 )
				return(retval);

			if(prev_option != -1) {
				/* Turn off Highlight option. */
				field = 400+(prev_option*100);
				fomca1( field, 9, 5 );
			}

			if( s_rec.s_option>=totaloptions ){
#ifdef ENGLISH
				fomer("Invalid option");
#else
				fomer("Option invalide");
#endif
				continue;
			}

			/* Highlight option. Dehighlight in Confirm() */
			field = 400+(s_rec.s_option*100);
			fomca1( field, 9, 3 );

			if(prev_option != s_rec.s_option) {
#ifdef ENGLISH
				fomer("Enter RETURN to confirm");
#else
				fomer("Appuyer sur RETURN pour confirmer");
#endif
				prev_option = s_rec.s_option;
			}
			else if(sr.fillcode == FIL_DUP) {
					break;
			}
			else {
#ifdef ENGLISH
				fomer("Enter RETURN to confirm");
#else
				fomer("Appuyer sur RETURN pour confirmer");
#endif
				prev_option = s_rec.s_option;
			}
		}
		if( s_rec.s_option==0 ){   /* option 0 is reserved to quit */
			fomcs();
			fomrt();
			return(0);
		}

		if((retval=CheckAccess( menu[s_rec.s_option].mainflno,
				    BROWSE,e_mesg))<0)
			return(retval);

		mainfileno = menu[s_rec.s_option].mainflno ;

		/* if a corresponding function exists, call it  */
		if( menu[s_rec.s_option].fnptr ){
			if( (retval=(*menu[s_rec.s_option].fnptr)())<0 )
				return(retval);
			fomst();
			s_rec.s_option=LV_SHORT;
			sr.nextfld = sr.endfld = 2400;
			fomud( (char *)&s_rec);
			ret(err_chk(&sr));	/* Check for PROFOM error */
		}
		else {	/* there isn't corr. function,  return value */
			s_rec.s_option=LV_SHORT;
			sr.nextfld = sr.endfld = 2400;
			fomud( (char *)&s_rec);
			ret(err_chk(&sr));	/* Check for PROFOM error */
			return (s_rec.s_option);
		}
		if( (retval=ClearInquiryArea())<0 )
			return(retval);
	}
}

/*	The following Get....() calls display default values given as parameter 
*	and fill up the variable with the value entered by the user 
*	The fields for accepting input are positioned in the order in which
*	they are called. For this, they make use of variable 'call_no'
*/

GetCNbrRange( ccode1, ccode2 )
char *ccode1, *ccode2;
{
	int	retval=0;

	if( line[CNBR]==0 )	/* no customer code call made yet */
		line[CNBR] = STARTLINENUM + call_no++;
	fomca2( CU_NBR1,1, line[CNBR], 1 );
	fomca2( CU_NBR1,2, line[CNBR], 19 );
	fomca2( CU_NBR2,1, line[CNBR], 40 );
	fomca2( CU_NBR2,2, line[CNBR], 45 );

	STRCPY( s_rec.s_ccode1, ccode1 );
	STRCPY( s_rec.s_ccode2, ccode2 );
	fomca1( CU_NBR1, 19, 2 );
	fomca1( CU_NBR2, 19, 2 );
	sr.nextfld = CU_NBR1;
	sr.endfld = CU_NBR2;
	fomud( (char *)&s_rec );
	s_rec.s_ccode1[0] = LV_CHAR;
	s_rec.s_ccode2[0] = LV_CHAR;
	retval = ReadFields( CU_NBR1, CU_NBR2 );
	if( retval!=EXIT && retval>=0 ){
		strcpy( ccode1, s_rec.s_ccode1 );
		strcpy( ccode2, s_rec.s_ccode2 );
	}
	fomca1( CU_NBR1, 19, 0 );
	fomca1( CU_NBR2, 19, 0 );

	return(retval);
}
GetReportType( type )	/*  Summary or Detail  */
char	*type;
{
	int	retval=0;

	if( line[RTYPE]==0 )	/* no customer name call made yet */
		line[RTYPE] = STARTLINENUM + call_no++;
	fomca2( RPT_TYPE,1, line[RTYPE], 1 );
	fomca2( RPT_TYPE,2, line[RTYPE], 32 );

	STRCPY( s_rec.s_rpt_type, type );
	fomca1( RPT_TYPE, 19, 2 );
	sr.nextfld = RPT_TYPE;
	sr.endfld = RPT_TYPE;
	fomud( (char *)&s_rec );
	s_rec.s_rpt_type[0] = LV_CHAR;
	retval = ReadFields( RPT_TYPE, RPT_TYPE );
	if( retval!=EXIT && retval>=0 ){
		strcpy( type, s_rec.s_rpt_type );
	}
	fomca1( RPT_TYPE, 19, 0 );

	return(retval);
}
GetCNameRange( cname1,cname2 )
char *cname1, *cname2;
{
	int	retval=0;

	if( line[CNAME]==0 )	/* no customer name call made yet */
		line[CNAME] = STARTLINENUM + call_no++;
	fomca2( CU_NAM1,1, line[CNAME], 1 );
	fomca2( CU_NAM1,2, line[CNAME], 19 );
	fomca2( CU_NAM2,1, line[CNAME], 40 );
	fomca2( CU_NAM2,2, line[CNAME], 45 );

	STRCPY( s_rec.s_cname1, cname1 );
	STRCPY( s_rec.s_cname2, cname2 );
	fomca1( CU_NAM1, 19, 2 );
	fomca1( CU_NAM2, 19, 2 );
	sr.nextfld = CU_NAM1;
	sr.endfld = CU_NAM2;
	fomud( (char *)&s_rec );
	s_rec.s_cname1[0] = LV_CHAR;
	s_rec.s_cname2[0] = LV_CHAR;
	retval = ReadFields( CU_NAM1, CU_NAM2 );
	if( retval!=EXIT && retval>=0 ){
		strcpy( cname1, s_rec.s_cname1 );
		strcpy( cname2, s_rec.s_cname2 );
	}
	fomca1( CU_NAM1, 19, 0 );
	fomca1( CU_NAM2, 19, 0 );

	return(retval);
}
GetTransDateRange( trandt1,trandt2 )
long *trandt1, *trandt2;
{
	int	retval=0;

	if( line[TRDATE]==0 )	/* no trans date call made yet */
		line[TRDATE] = STARTLINENUM + call_no++;
	fomca2( TRDATE1,1, line[TRDATE], 1 );
	fomca2( TRDATE1,2, line[TRDATE], 19 );
	fomca2( TRDATE2,1, line[TRDATE], 40 );
	fomca2( TRDATE2,2, line[TRDATE], 45 );

	s_rec.s_trandt1 = *trandt1;
	s_rec.s_trandt2 = *trandt2;
	fomca1( TRDATE1, 19, 2 );
	fomca1( TRDATE2, 19, 2 );
	sr.nextfld = TRDATE1;
	sr.endfld = TRDATE2;
	fomud( (char *)&s_rec );
	s_rec.s_trandt1 = LV_LONG;
	s_rec.s_trandt2 = LV_LONG;
	retval = ReadFields( TRDATE1, TRDATE2 );
	if( retval!=EXIT && retval>=0 ){
		*trandt1 = s_rec.s_trandt1;
		*trandt2 = s_rec.s_trandt2;
	}
	fomca1( TRDATE1, 19, 0 );
	fomca1( TRDATE2, 19, 0 );

	return(retval);
}
GetDate( trandt1 )
long *trandt1;
{
	int	retval=0;

	if( line[TRDATE]==0 )	/* no trans date call made yet */
		line[TRDATE] = STARTLINENUM + call_no++;
	fomca2( TRDATE1,1, line[TRDATE], 1 );
	fomca2( TRDATE1,2, line[TRDATE], 19 );
	fomca2( TRDATE2,1, line[TRDATE], 40 );
	fomca2( TRDATE2,2, line[TRDATE], 45 );

	s_rec.s_trandt1 = *trandt1;
	fomca1( TRDATE1, 19, 2 );
	sr.nextfld = TRDATE1;
	sr.endfld = TRDATE1;
	fomud( (char *)&s_rec );
	s_rec.s_trandt1 = LV_LONG;
	retval = ReadFields( TRDATE1, TRDATE1 );
	if( retval!=EXIT && retval>=0 ){
		*trandt1 = s_rec.s_trandt1;
	}
	fomca1( TRDATE1, 19, 0 );

	return(retval);
}
GetFundRange( fund1,fund2 )
short *fund1, *fund2;
{
	int	retval=0;

	if( line[FUNDNO]==0 )	/* no trans date call made yet */
		line[FUNDNO] = STARTLINENUM + call_no++;
	fomca2( FUND1,1, line[FUNDNO], 1 );
	fomca2( FUND1,2, line[FUNDNO], 19 );
	fomca2( FUND2,1, line[FUNDNO], 40 );
	fomca2( FUND2,2, line[FUNDNO], 45 );

	s_rec.s_fund1 = *fund1;
	s_rec.s_fund2 = *fund2;
	fomca1( FUND1, 19, 2 );
	fomca1( FUND2, 19, 2 );
	sr.nextfld = FUND1;
	sr.endfld = FUND2;
	fomud( (char *)&s_rec );
	s_rec.s_fund1 = LV_SHORT;
	s_rec.s_fund2 = LV_SHORT;
	retval = ReadFields( FUND1, FUND2 );
	if( retval!=EXIT && retval>=0 ){
		*fund1 = s_rec.s_fund1;
		*fund2 = s_rec.s_fund2;
	}
	fomca1( FUND1, 19, 0 );
	fomca1( FUND2, 19, 0 );

	return(retval);
}
GetInvcRange( invcno1,invcno2 )
long *invcno1, *invcno2;
{
	int	retval=0;

	if( line[INVCNBR]==0 )	/* no trans date call made yet */
		line[INVCNBR] = STARTLINENUM + call_no++;
	fomca2( INVCNO1,1, line[INVCNBR], 1 );
	fomca2( INVCNO1,2, line[INVCNBR], 19 );
	fomca2( INVCNO2,1, line[INVCNBR], 40 );
	fomca2( INVCNO2,2, line[INVCNBR], 45 );

	s_rec.s_invcno1 = *invcno1;
	s_rec.s_invcno2 = *invcno2;
	fomca1( INVCNO1, 19, 2 );
	fomca1( INVCNO2, 19, 2 );
	sr.nextfld = INVCNO1;
	sr.endfld = INVCNO2;
	fomud( (char *)&s_rec );
	s_rec.s_invcno1 = LV_LONG;
	s_rec.s_invcno2 = LV_LONG;
	retval = ReadFields( INVCNO1, INVCNO2 );
	if( retval!=EXIT && retval>=0 ){
		*invcno1 = s_rec.s_invcno1;
		*invcno2 = s_rec.s_invcno2;
	}
	fomca1( INVCNO1, 19, 0 );
	fomca1( INVCNO2, 19, 0 );

	return(retval);
}
GetRcptRange( rcptno1,rcptno2 )
long *rcptno1, *rcptno2;
{
	int	retval=0;

	if( line[RCPTNBR]==0 )	/* no trans date call made yet */
		line[RCPTNBR] = STARTLINENUM + call_no++;
	fomca2( RCPTNO1,1, line[RCPTNBR], 1 );
	fomca2( RCPTNO1,2, line[RCPTNBR], 19 );
	fomca2( RCPTNO2,1, line[RCPTNBR], 40 );
	fomca2( RCPTNO2,2, line[RCPTNBR], 45 );

	s_rec.s_rcptno1 = *rcptno1;
	s_rec.s_rcptno2 = *rcptno2;
	fomca1( RCPTNO1, 19, 2 );
	fomca1( RCPTNO2, 19, 2 );
	sr.nextfld = RCPTNO1;
	sr.endfld = RCPTNO2;
	fomud( (char *)&s_rec );
	s_rec.s_rcptno1 = LV_LONG;
	s_rec.s_rcptno2 = LV_LONG;
	retval = ReadFields( RCPTNO1, RCPTNO2 );
	if( retval!=EXIT && retval>=0 ){
		*rcptno1 = s_rec.s_rcptno1;
		*rcptno2 = s_rec.s_rcptno2;
	}
	fomca1( RCPTNO1, 19, 0 );
	fomca1( RCPTNO2, 19, 0 );

	return(retval);
}
Confirm()	/* returns 1 for yes, 0 for no, -1 for error */
{		/* Clears the profom screen when user's response is 'Y' */
	int	field;

#ifdef ENGLISH
	if( (retval=DisplayMessage("Confirm (Y/N)?"))<0 )
		return(retval);
	if( (retval=GetResponse(s_rec.s_resp, "YN"))<0 )
		return(retval);
#else
	if( (retval=DisplayMessage("Confirmer (O/N)?"))<0 )
		return(retval);
	if( (retval=GetResponse(s_rec.s_resp, "ON"))<0 )
		return(retval);
#endif
	field = s_rec.s_option*100 + 400;

	if( s_rec.s_resp[0]==YES ){
		fflush( stdout );
		fomcs();
		fomrt();
		return(1);
	}
	/* Dehighlight the option which is highlighted in Process() */
	fomca1( field, 9, 5 );

	return( HideMessage() );
}

static
ClearInquiryArea()
{
	short i;

	call_no = 0;	/* Reset the call_no */
	for( i=0; i<MAXQUERYLINES; i++ )/* so that next time fields can be */
		line[i] = 0;	/* repositioned for next routine calls */
	if(FillOutputDetails(HIGH)<0 )
		return(-1);
	if(FillCNbr(HIGH,HIGH)<0 )
		return(-1);
	if(FillRType(HIGH) < 0)
		return(-1);
	if(FillCName(HIGH,HIGH)<0 )
		return(-1);
	if(FillTrDate(HIGH,HIGH)<0 )
		return(-1);
	if(FillFund(HIGH,HIGH)<0 )
		return(-1);
	if(FillInvcno(HIGH,HIGH)<0 )
		return(-1);
	if(FillRcptno(HIGH,HIGH)<0 )
		return(-1);
	if(FillMsgRespFields(HIGH)<0 )
		return(-1);
	return(WriteFields(1,0));
}
static
ReadOption()
{
	s_rec.s_option = LV_SHORT;
	return( ReadFields(2400,2400) );
}
static
ReadFields(start,end)	/* read fields whose numbers range from start to end */
int start, end;		/* start and end fields */
{
	int retval;

	sr.nextfld = start;
	sr.endfld = end;
	for( ; ; ){
		fomrd( (char *)&s_rec );
		ret(err_chk(&sr));
		if( sr.retcode==RET_USER_ESC || sr.retcode==RET_VAL_CHK ){
			if( ESC_F ) return(EXIT);
			retval=Validate();
			if( retval<0 || retval==EXIT)	return(retval);
			continue;
		}
		break;
	}
	return(0);
}
static
WriteFields( start,end )/* write fields whose numbers range from start to end */
int start, end;
{
	sr.nextfld = start;
	sr.endfld = end;
	fomwr( (char *)&s_rec );
	ret( err_chk(&sr) );
	return(0);
}
static
Validate()	/* Validate the values entered by the user */
{
	switch( sr.curfld ){
		case 2400:	/* menu option */
/**** Don't Validate Here 
			if( s_rec.s_option<0 || s_rec.s_option>=totaloptions ){
#ifdef ENGLISH
				fomer("Invalid option");
#else
				fomer("Option invalide");
#endif
				s_rec.s_option = LV_SHORT;
			}
******/
			break;
		case 2600:	/* output on */
			if( s_rec.s_outputon[0]!= DISPLAY &&
			    s_rec.s_outputon[0]!= PRINTER &&
			    s_rec.s_outputon[0]!= FILE_IO ){
#ifdef ENGLISH
				fomer("D(isplay), P(rinter), F(ile)");
#else
				fomer("A(fficher), I(mprimante), D(ossier)");
#endif
				s_rec.s_outputon[0] = LV_CHAR;
			}
			break;
		case 2700:	/* Filename */
			break;
		case 2800:	/* Printer */
			break;
		case 2900:	/* Page Size */
			break;
		case CU_NBR1:	/* end customer code */
			if(Right_Justify_Numeric(s_rec.s_ccode1,
					sizeof(s_rec.s_ccode1)-1)){
				sr.nextfld = CU_NBR1;
				fomwf((char *)&s_rec);
			}
			break;
		case CU_NBR2:	/* end customer code */
			if(Right_Justify_Numeric(s_rec.s_ccode2,
					sizeof(s_rec.s_ccode2)-1)){
				sr.nextfld = CU_NBR2;
				fomwf((char *)&s_rec);
			}

			if(strcmp(s_rec.s_ccode2,s_rec.s_ccode1)<0){
#ifdef ENGLISH
				fomer("Ending code smaller than starting code");
#else
				fomer("Code finissant plus petit que le code debutant");
#endif
				s_rec.s_ccode2[0] = LV_CHAR;
			}
			break;
		case CU_NAM2:	/* end customer name */
			if(strcmp(s_rec.s_cname2,s_rec.s_cname1)<0){
#ifdef ENGLISH
				fomer("Ending name is before starting name");
#else
				fomer("Nom finissant avant le nom debutant");
#endif
				s_rec.s_cname2[0] = LV_CHAR; 
			} 
			break;
		case TRDATE2:	/* end transaction date */
			if(s_rec.s_trandt2 < s_rec.s_trandt1){
#ifdef ENGLISH
				fomer("Ending date earlier than starting date");
#else
				fomer("Date finissante plus tot que date debutante");
#endif
				s_rec.s_trandt2 = LV_LONG; 
			} 
			break;
		case FUND1:	/* start fund */
			break;
		case FUND2:	/* end fund */
			if(s_rec.s_fund2 < s_rec.s_fund1){
#ifdef ENGLISH
				fomer("Ending fund less than starting fund");
#else
				fomer("Fond finissant moins que fond debutant");
#endif
				s_rec.s_fund2 = LV_SHORT; 
			} 
			break;
		case INVCNO1:	/* start invcno */
			break;
		case INVCNO2:	/* end invcno */
			if(s_rec.s_invcno2 < s_rec.s_invcno1){
#ifdef ENGLISH
				fomer("Ending invcno less than starting invcno");
#else
				fomer("#de facture finissant est plus petit que le #de facture debutant");
#endif
				s_rec.s_invcno2 = LV_LONG; 
			} 
			break;
		case RCPTNO1:	/* start invcno */
			break;
		case RCPTNO2:	/* end invcno */
			if(s_rec.s_rcptno2 < s_rec.s_rcptno1){
#ifdef ENGLISH
				fomer("Ending rcptno less than starting rcptno");
#else
				fomer("#de recu finissant est plus petit que le #de recu debutant");
#endif
				s_rec.s_rcptno2 = LV_LONG; 
			} 
			break;
	}
	sr.nextfld = sr.curfld;
	return(0);
}
DisplayMessage(mesg)	/* Display the given message in the message field */
char *mesg;
{
	STRCPY( s_rec.s_mesg, mesg );
	return(WriteFields(MESSAGE,MESSAGE));
}
HideMessage()	/* Hide the message field */
{
	if( FillMsgRespFields(HIGH)<0 )	return(-1);
	return(WriteFields(MESSAGE,RESPONSE));
}
GetResponse( respchar, answers )
char *respchar;
char *answers;
{
	int	retval;
	int	i;

	for(;;){
		s_rec.s_resp[0] = LV_CHAR;
		retval = ReadFields( RESPONSE, RESPONSE );
		if( retval==EXIT || retval<0 )
			break;
		for(i=0;i<(strlen(answers));i++){
			if(s_rec.s_resp[0] == answers[i]){
				respchar[0] = s_rec.s_resp[0];
				return(NOERROR);
			}
		}
#ifdef ENGLISH
		fomer("Invalid option");
#else
		fomer("Option invalide");
#endif
	}
	return( retval );
}
GetOutputon( outputon )
char	*outputon;
{
	int	retval;

#ifdef ENGLISH
	fomer("D(isplay), P(rinter), F(ile)");
#else
	fomer("A(fficher), I(mprimante), D(ossier)");
#endif
	STRCPY( s_rec.s_outputon, outputon );
	fomca1( 2600, 19, 2 );
	sr.nextfld = 2600;
	sr.endfld = 2600;
	fomud( (char *)&s_rec );
	s_rec.s_outputon[0] = LV_CHAR;
	retval = ReadFields(2600,2600);
	if( retval!=EXIT && retval>=0 )
		*outputon = s_rec.s_outputon[0];
	fomca1( 2600, 19, 0 );
	return( retval );
}
GetFilename( filename )
char	*filename;
{
	int	retval;

	STRCPY( s_rec.s_filename, filename );
	fomca1( 2700, 19, 2 );
	sr.nextfld = 2700;
	sr.endfld = 2700;
	fomud( (char *)&s_rec );
	s_rec.s_filename[0] = LV_CHAR;
	retval = ReadFields(2700,2700);
	if( retval!=EXIT && retval>=0 )
		strcpy( filename , s_rec.s_filename ) ;
	fomca1( 2700, 19, 0 );
	return( retval );
}
GetPrinter( printer )
short	*printer;
{
	int	retval;

	s_rec.s_printer = *printer ;
	fomca1( 2800, 19, 2 );
	sr.nextfld = 2800;
	sr.endfld = 2800;
	fomud( (char *)&s_rec );
	s_rec.s_printer = LV_SHORT;
	retval = ReadFields(2800,2800);
	if( retval!=EXIT && retval>=0 )
		*printer = s_rec.s_printer;
	fomca1( 2800, 19, 0 );
	return( retval );
}
GetNbrCopies( nbrcopies )
short	*nbrcopies;
{
	int	retval;

	s_rec.s_nbrcopies = *nbrcopies ;
	fomca1( 2900, 19, 2 );
	sr.nextfld = 2900;
	sr.endfld = 2900;
	fomud( (char *)&s_rec );
	s_rec.s_nbrcopies = LV_SHORT;
	retval = ReadFields(2900,2900);
	if( retval!=EXIT && retval>=0 )
		*nbrcopies = s_rec.s_nbrcopies;
	fomca1( 2900, 19, 0 );
	return( retval );
}
GetNbrup( nbrlabels )
short	*nbrlabels;
{
	int	retval;

	s_rec.s_no_up = *nbrlabels;
	fomca1( 2950, 19, 2);
	sr.nextfld = 2950;
	sr.endfld = 2950;
	fomud( (char *)&s_rec);
	s_rec.s_no_up = LV_SHORT;
	retval = ReadFields(2950,2950);
	if( retval != EXIT && retval>=0 )
		*nbrlabels = s_rec.s_no_up;
	fomca1( 2950, 19, 0);
	return( retval );
}

