/*-----------------------------------------------------------------------
Source Name: customer.c
System     : Budgetary Financial system.
Module     : Accounts Receivables system.
Created  On: 1st July 89.
Created  By: T AMARENDRA.

COBOL Source(s): ??????. This sub-system is totally redesigned. No program
		 is taken form existing COBOL A/R system.

DESCRIPTION:
	Program to Maintain Customer File. This program provides
	Add, Change, Inquiry & Delete options on Customer File.

Usage of SWITCHES when they are ON :
	SW1 :
	SW2 :
	SW3 :
	SW4 :
	SW5 :
	SW6 :
	SW7 :
	SW8 :
		Not Used.


MODIFICATIONS:        

Programmer     YY/MM/DD       Description of modification
~~~~~~~~~     ~~~~~~~~       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
p. ralph       91/02/07		Right justify numeric customer codes
m. galvin      30-jun-92     The customer master file was modified to allow the
			     postal code field to hold 10 characters instead of
			     only 7 and a sort name field was added.
J. McLean      23-Jul-92     Changed the Customer Code from 6 to 10 characters.

------------------------------------------------------------------------*/

#define	MAIN		/* Main program. This is to declare Switches */
#define MAINFL		CUSTOMER		/* main file used */

#define	SYSTEM		"ACCOUNTS RECEIVABLE"	/* Sub System Name */
#define	MOD_DATE	"30-JUN-92"			/* Prog Last Modified */

#include <stdio.h>
#include <ctype.h>
#include <cfomstrc.h>
#include <bfs_defs.h>
#include <bfs_recs.h>

#ifdef ENGLISH
#define ADDREC		'A'
#define CHANGE 		'C'
#define DELETE		'D'
#define NEXT		'N'
#define PREV		'P'
#define INQUIRE		'I'
#define EXITOPT		'E'

#define EDIT		'E'
#define CANCEL		'C'
#define YES		'Y'
#define NO		'N'
#else	/* FRENCH */
#define ADDREC 		'R'
#define CHANGE 		'C'
#define DELETE		'E'
#define NEXT		'S'
#define PREV		'P'
#define INQUIRE		'I'
#define EXITOPT		'F'

#define EDIT		'M'
#define CANCEL		'A'
#define YES		'O'
#define NO		'N'
#endif

#define	SCR_NAME	"customer"	/* PROFOM screen name */

/* PROFOM Field Numbers */

#define	ST_FLD		800	/* Data entry starting field */
#define	END_FLD		2600	/* screen end field */

#define	FN_FLD		400	/* Fn: */
#define	KEY_FLD		500	/* Cust Code#: */
#define	CUST_CD		500	/* Cust Code#: */
#define	CHG_FLD		600	/* Field: */

#define	NAME_FLD	800	/* Customer Name Field# */
#define ABREV_FLD	900     /* Customer Sort Field */ 
#define PC_FLD		1300	/* Postal Code Field */
#define PHONE_FLD	1400	/* Phone Number Field */
#define FAX_FLD		1500	/* Fax Number Field */
#define OPENDT		1700	/* Open date */
#define	PRNTCD_FLD	2000	/* Print Code Field# */

/* Field Numbers on Screen */

#define	LAST_SNO	17	/* Last Field Number on Screen */

/* customer.sth - header for C structure generated by PROFOM EDITOR */

struct	s_struct	{
	char	s_pgm[11];	/* STRING XXXXXXXXXX Field 100 */
	long	s_rundate;	/* DATE YYYYFMMFDD Field 300 */
	char	s_fn[2];	/* STRING X Field 400 */

	/* Key Field */
	char	s_code[11];	/* STRING X[10] Field 500 */

	short	s_field;	/* NUMERIC 99 Field 600 */

	/* Data entry Fields */
	char	s_name[31];	/* STRING X[30] Field 800 */
        char    s_abrev[31];    /* STRING X[30] Field 900 */	
        char	s_adr1[31];	/* STRING X[30] Field 1000 */
	char	s_adr2[31];	/* STRING X[30] Field 1100 */
	char	s_adr3[31];	/* STRING X[30] Field 1200 */
	char	s_pc[11];	/* STRING XXXXXXXXXX Field 1300 */
	char	s_phone[11];	/* STRING Field 1400 */
	char	s_fax[11];	/* STRING Field 1500 */
	char	s_contper[26];	/* STRING X[20] Field 1600 */
	long	s_open_dt;	/* DATE YYYYFMMFDD Field 1700 */
	long	s_sale_dt;	/* DATE YYYYFMMFDD Field 1800 */
	long	s_rcpt_dt;	/* DATE YYYYFMMFDD Field 1900 */
	char	s_prnt_cd[2];	/* STRING X Field 2000 */
	double	s_mon_op;	/* NUMERIC 99F999F999.99 Field 2100 */
	double	s_cur_bal;	/* NUMERIC 99F999F999.99 Field 2200 */
	double	s_ytd_sales;	/* NUMERIC 99F999F999.99 Field 2300 */
	double	s_ytd_rcpts;	/* NUMERIC 99F999F999.99 Field 2400 */

	char	s_mesg[78];	/* STRING X[77] Field 2500 */
	char	s_resp[2];	/* STRING X Field 2600 */
};

static	struct	s_struct  s_sth;	/* Screen Structure */

static	struct  stat_rec sr;		/* PROFOM status rec */

static	Cu_rec	cu_rec ,		/* Customer Record */
		pre_rec ;		/* Previous Customer Rec to write audit
					   info */
static	Pa_rec	pa_rec;			/* Parameter Record */
static	char 	e_mesg[80];  		/* dbh will return err msg in this */


main(argc,argv)
int argc;
char *argv[];
{
	int	err;

	if(argc < 2){
#ifdef  DEVELOP
		printf("MAIN ARGUMENTS ARE NOT PROPER\n");
		printf("Usage : %s {terminal name}\n", argv[0]);
#endif
		exit(1);
	}

	strncpy(SYS_NAME,SYSTEM,50);	/* Sub system name */
	strncpy(CHNG_DATE,MOD_DATE,10);	/* Modification Date */

	proc_switch(argc, argv, MAINFL) ; 	/* Process Switches */

	strcpy(sr.termnm,terminal);	/* Copy Terminal Name */

	InitProfom() ;			/* Initialize PROFOM */

	if( get_param(&pa_rec,BROWSE,1,e_mesg)<1 ){
		fomen(e_mesg);
		get();
		exit(-1);
	}
	if( pa_rec.pa_ars[0]!=YES ){
#ifdef ENGLISH
		fomen("ARS not present. See parameter Maintenance");
#else
		fomen("Systeme C/R pas present. Voir l'entretien des parametres");
#endif
		get();
		exit(0);
	}
	err = Process(); 	/* Initiate Process */

	/* Set terminal back to normal mode from PROFOM */
	fomcs();
	fomrt();

	free_audit() ;	/* Free the space allocated in rite_audit() */
	close_dbh();	/* Close files */

	if(err != NOERROR)exit(1);
	exit(0);
} /* END OF MAIN */
/*-------------------------------------------------------------------*/
/* Initialize PROFOM & Screen before going to process options */
InitProfom()
{
	fomin(&sr);
	/* Check for Error */
	if(err_chk(&sr) == PROFOM_ERR){
		fomcs();
		fomrt();
		exit(1);
	}
	fomcf(1,1);	/* Enable Snap screen option */

	/* move screen name to Profom status structure */
	strcpy(sr.scrnam,NFM_PATH);
	strcat(sr.scrnam,SCR_NAME) ;

	strcpy(s_sth.s_pgm,PROG_NAME);
	s_sth.s_rundate = get_date();	/* get Today's Dt in YYYYMMDD format */
	s_sth.s_field = HV_SHORT ;
	s_sth.s_mesg[0] = HV_CHAR ;
	s_sth.s_resp[0] = HV_CHAR ;

	/* Initialize key field. This gets 1st record from the file
	   if user selects 'N' option immediatly after invoking */
	s_sth.s_code[0] = LV_CHAR ;

	/* Move High Values to screen data fields & Display */
	InitScreen(HV_CHAR, HV_LONG, HV_DOUBLE) ;

	return(NOERROR) ;
}	/* InitProfom() */
/*-------------------------------------------------------------------*/
/* Get Option from user and call corresponding function */
Process()
{
	int err;

	for( ; ; ){
		/* Display Fn: options */
#ifdef	ENGLISH
		fomer("A(dd), C(hange), D(elete), N(ext), P(rev), I(nquire), E(xit)");
#else
		fomer("R(ajouter), C(hanger), E(liminer), S(uivant), P(recedent), I(nterroger), F(in)");
#endif
		/* Read Fn: field to get the option */
		sr.nextfld = FN_FLD ;
		fomrf((char*)&s_sth);
		ret(err_chk(&sr));	/* Check for PROFOM error */

		switch(s_sth.s_fn[0]){
		case ADDREC  :	/* Add */
			CHKACC(err,ADD,e_mesg);
			err = AddNewRec();
			break;
		case CHANGE  :	/* Change */
			CHKACC(err,UPDATE,e_mesg);
			err = ChangeRec();
			break;
		case DELETE  :	/* Delete */
			CHKACC(err,P_DEL,e_mesg);
			err = DeleteRec();
			break;
		case NEXT  : 	/* Next */
			CHKACC(err,BROWSE,e_mesg);
			err = NextRec() ; 
			break ;
		case PREV  :	/* Previous */
			CHKACC(err,BROWSE,e_mesg);
			err = PrevRec() ; 
			break ;
		case INQUIRE  : 	/* Inquiry */
			CHKACC(err,BROWSE,e_mesg);
			err = InquiryRec();
			break ;
		case EXITOPT  :
			return(NOERROR);
		default   : 
			continue; 
		}  /*   end of the switch statement */

		if(err == NOACCESS) {
			fomen(e_mesg);
			get();
		}
		if(err == PROFOM_ERR)return(PROFOM_ERR); /* PROFOM ERROR */
		if(err == DBH_ERR) {
			DispError(e_mesg);
#ifdef	ENGLISH
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"System Error... Iserror:",
				iserror, dberror, errno);
#else
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"Erreur du systeme... Iserror:",
				iserror, dberror, errno);
#endif
			DispError(e_mesg);
			return(DBH_ERR); /* DBH ERROR */
		}
	}      /*   end of the for( ; ; )       */
}	/* Process() */
/*----------------------------------------------------------------------*/
/* Read the full screen and add the record to data base */
AddNewRec()
{
	int	i ;

	for( ; ;){
		i = ReadKey();
		if(i != NOERROR)return(i);

		/* check whether given key is already existing */
		i = BringRecord(BROWSE);
		if(i == ERROR) return(DBH_ERR) ;
		if(i == NOERROR){
#ifdef	ENGLISH
			fomer("Given Key already in File - Please Enter again") ;
#else
			fomer("Cle donnee deja dans le dossier - Reessayer");
#endif
			continue;
		}
		/* UNDEF */
		break;
	}

	/* Change PROFOM logical field attributes */

	for(i = ST_FLD ; i <= END_FLD - 200  ; i += 100)
		fomca1(i,19,0); /* Disable Dup control */
	s_sth.s_open_dt = s_sth.s_rundate;
	for(i = OPENDT ; i <= OPENDT ; i += 100)
		fomca1(i,19,1); /* enable Dup control for open date */
	/* Set Dup Buffers for open date*/
	sr.nextfld = OPENDT;
	sr.endfld = OPENDT;
	fomud((char*)&s_sth);  /* Updating dup buffer */
	ret(err_chk(&sr));
	fomwr((char*)&s_sth);

	i = ReadScreen() ;	/* Read fields */
	if(i != NOERROR) return(i) ;

	for( ; ; ) {
		i = ReadOption() ;
		if(i < 0) return(i) ;

		if(i == CANCEL)
			return(InitScreen(HV_CHAR, HV_LONG, HV_DOUBLE)) ;

		CopyToRecord(ADD) ;

		i =   RiteRecord(ADD);
		if(i==NOERROR) break;
		if(i==LOCKED)  {
			roll_back(e_mesg);
			if(i <0) {
				if(i == UNDEF || i == LOCKED) continue;
				return(DBH_ERR);
			}
			continue;
		}
		if(i<0) return(i);
	}
	return(NOERROR);
}	/* AddNewRec() */
/*-----------------------------------------------------------------------*/
/* Accepts the changes to selected record and update the database */
ChangeRec()
{
	int	err ;

	err = SelectRecord(UPDATE) ;
	if(err != NOERROR) return(err) ;

	err = ChangeFields();
	if(err != NOERROR) return(err);

	for(; ; )  {
		err = ReadOption() ;
		if(err < 0) return(err) ;

		if(err == CANCEL) {
			CopyToScreen() ;    /* Display the original record */
			roll_back(e_mesg); /* Unlocking if recs not modified */
			return(NOERROR) ;
		}

		CopyToRecord(UPDATE) ;

		err =   RiteRecord(UPDATE) ;
		if(err==NOERROR) break;
		if(err==LOCKED) {
			roll_back(e_mesg);
			err = BringRecord(UPDATE);
			if(err < 0) {
				fomen(e_mesg);
				get();
				if(err== UNDEF || err==LOCKED) continue ;
				return(DBH_ERR);
			}
			continue;
		}
		if(err<0) return(err);
	}
	return(NOERROR);
}	/* ChangeRec() */
/*-----------------------------------------------------------------------*/
/* Select the record to be deleted and delete from database afetr
   confirmation */
DeleteRec()
{
	int	err;

	err = SelectRecord(UPDATE) ;
	if(err != NOERROR) return(err) ;

	if(cu_rec.cu_cur_bal != 0){
#ifdef ENGLISH
		DispError("You Can Not Delete A Customer With a Non Zero Balance");
#else
		DispError("On ne peut eliminer un client qui n'a pas un solde de zero ");
#endif
		return(NOERROR);
	}

	for( ; ; ) {
		err = ReadOption() ;
		if(err < 0) return(err) ;

		if(err == CANCEL) {
			roll_back(e_mesg);  /* Unlocking if recs not modified */
			return(NOERROR) ;
		}

		err =   RiteRecord(P_DEL) ;
		if(err==NOERROR) break;
		if(err==LOCKED) {
			roll_back(e_mesg);
			err = BringRecord(UPDATE);
			if(err < 0) {
				fomen(e_mesg);
				get();
				if(err== UNDEF || err==LOCKED) continue ;
				return(DBH_ERR);
			}
			continue;
		}
		if(err<0) return(err);
	}
	return(NOERROR);

}	/* DeleteRec() */
/*-----------------------------------------------------------------------*/
/* Get next rec from file & Display when user selected 'N' in function */
NextRec()
{
	int	err;

	err = BringNext(FORWARD) ;
	if(err != NOERROR) return(err) ;

	return(NOERROR) ;
}	/* NextRec() */
/*-----------------------------------------------------------------------*/
/* Get Previous record from file & Display when user selected 'P' in function */
PrevRec()
{
	int	err;

	err = BringNext(BACKWARD) ;
	if(err != NOERROR) return(err) ;

	return(NOERROR) ;
}	/* PrevRec() */
/*-----------------------------------------------------------------------*/
/* Select the Key, get the record & display */
InquiryRec()
{
	int	err ;

	err = SelectRecord(BROWSE) ;
	if(err != NOERROR) return(err) ;

	return(NOERROR) ;
}	/* InquiryRec() */
/*----------------------------------------------------------*/
/* Read the key fields, get the record with LOCK and display
   the Record */
SelectRecord(md)
int	md ;	/* BROWSE for Inquiry, UPDATE for Others */
{
	int	err ;

	for(; ;){
		err = ReadKey();
		if(err != NOERROR) return(err) ;

		/* Get the record from database */

		err = BringRecord(md);
		if(err < 0){
			fomen(e_mesg);
			get() ;
			if(err == UNDEF || err == LOCKED) continue ;
			return(DBH_ERR);
		}
		CopyToScreen() ;
		return(NOERROR) ;
	}
}	/* SelectRecord() */
/*----------------------------------------------------------------------*/
/* Read Key Fields */
ReadKey()
{
	char 	key_code[sizeof(s_sth.s_code)] ;
	int	err ;

#ifdef	ENGLISH
	strcpy(s_sth.s_mesg,"Press ESC-F to Go Back to Fn:");
#else
	strcpy(s_sth.s_mesg,"Appuyer sur ESC-F pour retourner a Fn:");
#endif
	ShowMesg();

	/* In Add mode turn off dup control for key field. Other modes
	   invert it */
	if(s_sth.s_fn[0] == ADDREC)	/* ADD */
		fomca1(KEY_FLD,19,0) ;	/* Off Dup Control */
	else {
		fomca1(KEY_FLD,19,2) ;	/* ON Dup Control */

		/* Update Dup Buffer */
		sr.nextfld = KEY_FLD ;
		sr.endfld = KEY_FLD ;
		fomud((char*)&s_sth);
	}

	/* Store key field to copy back when user gives ESC-F */
	strcpy(key_code,s_sth.s_code) ;

	sr.nextfld = KEY_FLD ;
	for(; ;) {
		fomrf((char*)&s_sth);
		ret(err_chk(&sr));

		if(sr.retcode == RET_USER_ESC){
			if(sr.escchar[0] == 'F' || sr.escchar[0] == 'f') {
				/* copy back key fields */
				strcpy(s_sth.s_code, key_code) ;

				sr.nextfld = KEY_FLD ;
				fomwf((char*)&s_sth);

				s_sth.s_mesg[0] = HV_CHAR;
				ShowMesg();
				return(ERROR) ;
			}
			if(sr.escchar[0] == 'h' || sr.escchar[0] == 'H'){
				err = WindowHelp() ;
				if(err == DBH_ERR) return(err) ;
				if(err == NOERROR) break ;	/* single fld */
				continue;
			}
			continue;
		}
		if( s_sth.s_code[0] == '\0' ){
#ifdef ENGLISH
			fomer("Invalid Code");
#else
			fomer("Code invalide");
#endif
			continue;
		}else{
			if(Right_Justify_Numeric(s_sth.s_code,
						sizeof(s_sth.s_code)-1)){
				sr.nextfld = KEY_FLD ;
				fomwf((char*)&s_sth);
			}
				
		}
		/* else RET_NO_ERROR */
		break;
	}
	
	s_sth.s_mesg[0] = HV_CHAR;
	ShowMesg();

	return(NOERROR);
}	/*  ReadKey() */
/*------------------------------------------------------------*/
/* Get all fields from user on screen */
ReadScreen()
{

	/* Initialize screen with Low values */
	InitScreen(LV_CHAR, LV_LONG, LV_DOUBLE) ;
	sr.nextfld = ST_FLD;
	sr.endfld = END_FLD-200;
	for( ; ;){
		fomrd((char*)&s_sth);
		ret(err_chk(&sr));
		if(sr.retcode == RET_VAL_CHK){
			Validate() ;
			sr.nextfld = sr.curfld ;
			continue;
		}
		if(sr.retcode == RET_USER_ESC){
			if(sr.escchar[0] == 'f' || sr.escchar[0] == 'F') {
				roll_back(e_mesg);
				InitScreen(HV_CHAR, HV_LONG, HV_DOUBLE) ;
				return(ERROR);
			}
			continue;
		}
		/* else RET_NO_ERROR */
		break;
	}

	return(NOERROR) ;
}	/* ReadScreen() */
/*----------------------------------------------------------------*/
Validate()	/* validate flds when PROFOM returns RET_VAL_CHK */
{
	int valid_flag, i;
	switch(sr.curfld) {
	case	NAME_FLD:	/* Customer Name */
		if(s_sth.s_name[0]=='\0'){
#ifdef ENGLISH
			fomer("Invalid Name");
#else
			fomer("Nom invalide");
#endif
			s_sth.s_name[0] = LV_CHAR;
			return(ERROR) ;
		}
		fomca1(ABREV_FLD,19,2);
		sr.nextfld = ABREV_FLD;
		sr.endfld = ABREV_FLD;
		strcpy(s_sth.s_abrev,s_sth.s_name);
		fomud((char*)&s_sth);  /* Updating dup buffer */
		ret(err_chk(&sr));
		s_sth.s_abrev[0] = LV_CHAR;
		break;
	case	ABREV_FLD:	/* Customer Abreviated Name */   
		if(s_sth.s_abrev[0]=='\0'){
#ifdef ENGLISH
			fomer("Invalid Sort Name");
#else
			fomer("Nom de triage invalide");
#endif
			s_sth.s_abrev[0] = LV_CHAR;
			return(ERROR) ;
		}
		break;
	case	PRNTCD_FLD :
		/*
		* Valid print Codes are
		*	A - Print Always
		*	B - Don't print if balance is 0
		*	C - Don't print if balance < 0
		*	D - Don't print if balance <= 0
		*/

		if(s_sth.s_prnt_cd[0] < 'A' || s_sth.s_prnt_cd[0] > 'D'){
#ifdef ENGLISH
			fomer("Valid Codes - A(Always), B(Balance not 0), C(Balance >= 0) or D(Balance > 0)"); 
#else
			fomer("Codes valables - A(Toujours), B(Solde pas 0), C(Solde >= 0), ou D(Solde > 0)"); 
#endif
			s_sth.s_prnt_cd[0] = LV_CHAR ;
			return(ERROR) ;
		}
		break;
	case PHONE_FLD:
		if(s_sth.s_phone[0] == '\0'){
			sr.curfld += 100;
			return(NOERROR);
		}

		valid_flag = 0;
		for (i=0; i<10 && !valid_flag; i++) {
			if ((isdigit((int)s_sth.s_phone[i]))==0)
				valid_flag = 1;
		}
		if (valid_flag) {
#ifdef	ENGLISH
			fomen("Must be All Digits");
#else
			fomen("Doit etre des chiffres");
#endif
			s_sth.s_phone[0] = LV_CHAR;
			sr.nextfld = PHONE_FLD;
			return (ERROR);
		}
		break;
	case FAX_FLD:
		if(s_sth.s_fax[0] == '\0'){
			sr.curfld += 100;
			return(NOERROR);
		}

		valid_flag = 0;
		for (i=0; i<10 && !valid_flag; i++) {
			if ((isdigit((int)s_sth.s_fax[i]))==0)
				valid_flag = 1;
		}
		if (valid_flag) {
#ifdef	ENGLISH
			fomen("Must be All Digits");
#else
			fomen("Doit etre des chiffres");
#endif
			s_sth.s_fax[0] = LV_CHAR;
			sr.nextfld = FAX_FLD;
			return (ERROR);
		}
		break;
	case PC_FLD:
		if(s_sth.s_pc[0] == '\0'){
			sr.curfld += 100;
			return(NOERROR);
		}

		valid_flag = 0;
		if ((isalpha((int)s_sth.s_pc[0]))==0) valid_flag = 1;
		if ((isdigit((int)s_sth.s_pc[1]))==0) valid_flag = 1;
		if ((isalpha((int)s_sth.s_pc[2]))==0) valid_flag = 1;
		if ((isdigit((int)s_sth.s_pc[3]))==0) valid_flag = 1;
		if ((isalpha((int)s_sth.s_pc[4]))==0) valid_flag = 1;
		if ((isdigit((int)s_sth.s_pc[5]))==0) valid_flag = 1;

		if (valid_flag) {
#ifdef	ENGLISH
			fomen("Must be in LNLNLN Format");
#else
			fomen("Doit avoir le format LNLNLN");
#endif
			s_sth.s_pc[0] = LV_CHAR;
			sr.nextfld = PC_FLD;
			return (ERROR);
		}
		break;
	default:
#ifdef ENGLISH
		sprintf(e_mesg,"No Validity Check For Field#  %d",sr.curfld);
#else
		sprintf(e_mesg,"Pas de controle de validite pour le champ#  %d",sr.curfld);
#endif
		fomen(e_mesg);
		get();
		return(ERROR) ;
	}

	return(NOERROR) ;
}	/* Validate() */
/*----------------------------------------------------------------*/
WindowHelp()	/* Display help window for applicable fields */
{
	int	err ;

	switch(sr.curfld){
	case	CUST_CD  :	/* Customer Code */
		/* ADD mode need not give help because user going to
		   add new key */
		if(s_sth.s_fn[0] == ADDREC) return(ERROR) ;

		err = cust_hlp(s_sth.s_code, 7, 13 );
		if(err == DBH_ERR) return(err) ;
		if(err >= 0 ) redraw();
		if(err < 1 ) return(ERROR);
		break ;
	default :
#ifdef ENGLISH
		fomer("No Help Window For This Field");
#else
		fomer("Pas de fenetre d'assistance pour ce champ");
#endif
		return(ERROR) ;
	}	/* Switch fld_no */

	sr.nextfld = sr.curfld ;
	return(NOERROR) ;
}	/* WindowHelp() */
/*----------------------------------------------------------------------*/
/* Changing fields. Accept fld to be changed and read that fld */
ChangeFields()
{
	int	i;

	/* Change PROFOM logical field attributes */

	for(i = ST_FLD ; i <= END_FLD - 200  ; i += 100)
		fomca1(i,19,2); /* enabling Dup control */

	/* Set Dup Buffers */
	sr.nextfld = ST_FLD;
	sr.endfld = END_FLD-200;
	fomud((char*)&s_sth);  /* Updating dup buffer */
	ret(err_chk(&sr));

	/* Get The Field to Be Modified */
#ifdef	ENGLISH
	strcpy(s_sth.s_mesg,"Enter RETURN to Terminate Edit");
#else
	strcpy(s_sth.s_mesg,"Appuyer sur RETURN pour terminer l'ajustement");
#endif
	ShowMesg() ;

	for( ; ; ) {
		sr.nextfld = CHG_FLD ;
		fomrf((char*)&s_sth);
		ret(err_chk(&sr));

		if(s_sth.s_field == 0) break ;

		i = ReadFld() ;	/* Read Field */
		if(i == PROFOM_ERR) return(i) ;
		if(i == DBH_ERR) return(i) ;
	}	/* for( ; ; ) */

	s_sth.s_field = HV_SHORT ;
	fomwf((char*)&s_sth);
	ret(err_chk(&sr));

	s_sth.s_mesg[0] = HV_CHAR;
	ShowMesg();

	return(NOERROR);
}	/* ChangeFields() */
/*-----------------------------------------------------------------------*/
/* Read the user selected field in change mode */
ReadFld()
{
	int	err ;

	/* Validate  Field Number */

	if( s_sth.s_field < 1 || s_sth.s_field > LAST_SNO) return (ERROR) ;

	/* Set PROFOM nextfld */
	sr.nextfld = ST_FLD + (s_sth.s_field - 1) * 100 ;

	for( ; ; ) {
		fomrf((char*)&s_sth);
		ret(err_chk(&sr));

		if(sr.retcode == RET_VAL_CHK) {
			err = Validate() ;
			if(err == NOERROR) break;
			continue ;
		}
		if(sr.retcode != RET_NO_ERROR) continue;
		break ;
	}

	return(NOERROR) ;
}	/* ReadFld() */
/*-----------------------------------------------------------------------*/
/* Display the confirmation message at the bottom of the screen, take the
   option from user and call necessary functions */
ReadOption()
{
	int	err ;

	/* Options:
	   Add      - YEC
	   Change   - YEC
	   Delete   - YC
	*/

	for( ; ; ) {
	    switch(s_sth.s_fn[0]) {
	    case	ADDREC :	/* Add */
	    case	CHANGE :	/* Change */
#ifdef	ENGLISH
		    err = GetOpt("Y(es), E(dit), C(ancel)", "YEC");
#else
		    err = GetOpt("O(ui), M(odifier), A(nnuler)", "OMA");
#endif
		break ;
	    case	DELETE :	/* Delete */
#ifdef	ENGLISH
		err = GetOpt("Y(es), C(ancel)", "YC");
#else
		err = GetOpt("O(ui), A(nnuler)", "OA");
#endif
		break ;
	    }	/* switch fn[] */

	    if(err == PROFOM_ERR) return(err) ;

	    switch(err) {
	    case  YES :
		return(YES) ;
	    case  EDIT  :
		err = ChangeFields();
		break ;
	    case  CANCEL :
#ifdef	ENGLISH
		err = GetOpt("Confirm the Cancel (Y/N)?", "YN") ;
#else
		err = GetOpt("Confirmer l'annulation (O/N)?", "ON") ;
#endif
		if(err == YES) return(CANCEL) ;
		break ;
	    }	/* switch err */

	    if(err == PROFOM_ERR) return(err) ;
	    if(err == DBH_ERR) return(err) ;
	}	/* for(; ; ) */
}	/* ReadOption() */
/*-----------------------------------------------------------------------*/
/* Display message and get the option */
GetOpt(msg,options)
char	*msg ;
char	*options ;
{
	int	i, j ;

	strcpy(s_sth.s_mesg,msg);

	sr.nextfld = END_FLD - 100 ;
	sr.endfld = END_FLD ;
	for( ; ; ) {
		s_sth.s_resp[0] = LV_CHAR ;
		fomrd((char*)&s_sth) ;
		ret(err_chk(&sr)) ;

		j = strlen(options) ;
		for( i = 0 ; i < j ; i++)
			if(s_sth.s_resp[0] == options[i]) break ;
		if(i != j) break ;	/* Valid Option Selected */
#ifdef	ENGLISH
		fomer("Invalid Option..");
#else
		fomer("Option invalide..");
#endif
	}
	s_sth.s_mesg[0] = HV_CHAR ;
	s_sth.s_resp[0] = HV_CHAR ;
	sr.nextfld = END_FLD - 100 ;
	sr.endfld = END_FLD ;
	fomwr((char*)&s_sth) ;
	ret(err_chk(&sr)) ;

	return((int)(options[i])) ;
}	/* GetOpt() */
/*-----------------------------------------------------------------------*/
/* Write record in data base */
RiteRecord(md)
int	md ;
{
	int	err;

	err = put_cust(&cu_rec,md,e_mesg);
	if(err != NOERROR){
		DispError(e_mesg) ;
#ifdef ENGLISH
		DispError("ERROR in Saving Records"); 
#else
		DispError("ERREUR en conservant les fiches");
#endif
		roll_back(e_mesg);
		InitScreen(HV_CHAR, HV_LONG, HV_DOUBLE) ;
		return(DBH_ERR);
	}

	err = rite_audit((char*)&s_sth, CUSTOMER, md, (char*)&cu_rec, 
				(char*)&pre_rec, e_mesg);
	if(err==LOCKED)  {
		DispError(e_mesg);
		roll_back(e_mesg);
		return(LOCKED);
	}

	if(err != NOERROR){
		DispError(e_mesg) ;
#ifdef ENGLISH
		DispError("ERROR in Saving Records"); 
#else
		DispError("ERREUR en conservant les fiches");
#endif
		roll_back(e_mesg);
		InitScreen(HV_CHAR, HV_LONG, HV_DOUBLE) ;
		return(DBH_ERR);
	}
	if(commit(e_mesg) < 0) {
		DispError(e_mesg) ;
#ifdef ENGLISH
		DispError("ERROR in Saving Records"); 
#else
		DispError("ERREUR en conservant les fiches");
#endif
		InitScreen(HV_CHAR, HV_LONG, HV_DOUBLE) ;
		return(DBH_ERR);
	}

	return(NOERROR);
}	/* RiteRecord() */
/*-----------------------------------------------------------------------*/ 
/* Copy the key fields from screen to data record and get the record from
   data base */
BringRecord(md)
int md; /* BROWSE or UPDATE */
{
	strcpy(cu_rec.cu_code, s_sth.s_code) ;

	return(get_cust(&cu_rec, md, 0, e_mesg));
}
/*-----------------------------------------------------------------------*/ 
/* Read the next record from data base */
BringNext(direction)
int	direction;
{
	int err;

	/* Check whether file is in seq. read mode */
	if(flg_start(CUSTOMER) != direction) {
		/* Set the key to next possible key and set file to start */
		strcpy(cu_rec.cu_code, s_sth.s_code) ;
		inc_str( cu_rec.cu_code, sizeof(cu_rec.cu_code)-1, direction );

		flg_reset(CUSTOMER);
	}

	err = get_n_cust(&cu_rec, BROWSE, 0, direction, e_mesg);

#ifndef ORCALE
	seq_over(CUSTOMER);
#endif

	if(ERROR == err)return(DBH_ERR) ;
	if(EFL == err) {
#ifdef	ENGLISH
		fomen("No More Records....");
#else
		fomen("Plus de fiches....");
#endif
		get();
		flg_reset(CUSTOMER);
		return(ERROR) ;
	}

	CopyToScreen() ;

	return(NOERROR);
}
/*-----------------------------------------------------------------------*/
/* Copy the data record fields to Screen and display the screen */
CopyToScreen()
{
	strcpy(s_sth.s_code, cu_rec.cu_code) ;

	strcpy(s_sth.s_name, cu_rec.cu_name) ;
	strcpy(s_sth.s_abrev, cu_rec.cu_abrev) ;
	strcpy(s_sth.s_adr1, cu_rec.cu_adr1) ;
	strcpy(s_sth.s_adr2, cu_rec.cu_adr2) ;
	strcpy(s_sth.s_adr3, cu_rec.cu_adr3) ;
	strcpy(s_sth.s_pc, cu_rec.cu_pc) ;
	strcpy(s_sth.s_phone, cu_rec.cu_phone) ;
	strcpy(s_sth.s_fax, cu_rec.cu_fax) ;
	strcpy(s_sth.s_contper, cu_rec.cu_contper) ;
	s_sth.s_open_dt = cu_rec.cu_open_dt ;
	s_sth.s_sale_dt = cu_rec.cu_sale_dt ;
	s_sth.s_rcpt_dt = cu_rec.cu_rcpt_dt ;
	s_sth.s_prnt_cd[0]  = cu_rec.cu_prnt_cd[0] ;
	s_sth.s_mon_op = cu_rec.cu_mon_op ;
	s_sth.s_cur_bal = cu_rec.cu_cur_bal ;
	s_sth.s_ytd_sales  = cu_rec.cu_ytd_sales ;
	s_sth.s_ytd_rcpts = cu_rec.cu_ytd_rcpts ;

	/* display screen */
	sr.nextfld = KEY_FLD ;
	sr.endfld = END_FLD - 200;
	fomwr((char*)&s_sth);
	return(NOERROR) ; 
}
/*-----------------------------------------------------------------------*/
/* Copy the Screen fields to data record */
CopyToRecord(md)
int md;
{
	/* Save the cu_rec in pre_rec to write audit records for changed
	   fields */
	if(md != ADD)
		scpy((char*)&pre_rec, (char*)&cu_rec, sizeof(Cu_rec)) ;

	strcpy(cu_rec.cu_code, s_sth.s_code) ;

	strcpy(cu_rec.cu_name, s_sth.s_name) ;
	strcpy(cu_rec.cu_abrev, s_sth.s_abrev) ;
	strcpy(cu_rec.cu_adr1, s_sth.s_adr1) ;
	strcpy(cu_rec.cu_adr2, s_sth.s_adr2) ;
	strcpy(cu_rec.cu_adr3, s_sth.s_adr3) ;
	strcpy(cu_rec.cu_pc, s_sth.s_pc) ;
	strcpy(cu_rec.cu_phone, s_sth.s_phone) ;
	strcpy(cu_rec.cu_fax, s_sth.s_fax) ;
	strcpy(cu_rec.cu_contper, s_sth.s_contper) ;
	cu_rec.cu_open_dt = s_sth.s_open_dt ;
	cu_rec.cu_sale_dt = s_sth.s_sale_dt ;
	cu_rec.cu_rcpt_dt = s_sth.s_rcpt_dt ;
	cu_rec.cu_prnt_cd[0] = s_sth.s_prnt_cd[0] ;
	cu_rec.cu_mon_op = s_sth.s_mon_op ;
	cu_rec.cu_cur_bal = s_sth.s_cur_bal ;
	cu_rec.cu_ytd_sales = s_sth.s_ytd_sales ;
	cu_rec.cu_ytd_rcpts = s_sth.s_ytd_rcpts ;

}
/*------------------------------------------------------------------------*/
/* Initialize screen data fields with the passed parameters. They are
   either High Values or Low Values */
InitScreen(t_char, t_long, t_double)
char	t_char ;
long	t_long ;
double	t_double ;
{
	s_sth.s_name[0] = t_char ;
        s_sth.s_abrev[0] = t_char ;	
	s_sth.s_adr1[0] = t_char ;
	s_sth.s_adr2[0] = t_char ;
	s_sth.s_adr3[0] = t_char ;
	s_sth.s_pc[0] = t_char ;
	s_sth.s_phone[0] = t_char ;
	s_sth.s_fax[0] = t_char ;
	s_sth.s_contper[0] = t_char ;
	s_sth.s_open_dt = t_long ;
	s_sth.s_sale_dt = t_long ;
	s_sth.s_rcpt_dt = t_long ;
	s_sth.s_prnt_cd[0] = t_char ;
	s_sth.s_mon_op = t_double ;
	s_sth.s_cur_bal = t_double ;
	s_sth.s_ytd_sales = t_double ;
	s_sth.s_ytd_rcpts = t_double ;

	if(t_long == HV_LONG) {
		sr.nextfld = ST_FLD ;
		sr.endfld = END_FLD - 200 ;
		fomwr((char*)&s_sth);
		ret(err_chk(&sr));
	}

	return(NOERROR);
}	/* InitScreen() */
/*-------------------------------------------------------------------------*/
static 
DispError(s)    /* show ERROR and wait */
char *s;
{
	strcpy(s_sth.s_mesg,s);
	ShowMesg();
#ifdef	ENGLISH
	fomen("Press any key to continue");
#else
	fomen("Appuyer sur une touche pour continuer");
#endif
	get();
	s_sth.s_mesg[0] = HV_CHAR;
	ShowMesg();
	return(ERROR);
}
/*------------------------------------------------------------------------*/
ShowMesg()  /* shows or clears message field */
{
	sr.nextfld = END_FLD - 100;
	fomwf((char*)&s_sth) ;
}
/*-------------------- E n d   O f   P r o g r a m ---------------------*/

