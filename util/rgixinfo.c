/*-----------------------------------------------------------------------
Source Name: rgixinfo.c
System     : General Utility.
Created  On: 5th July 89.
Created  By: T AMARENDRA.

DESCRIPTION:
	Program to Maintain temporay index information. Takes source file name,
	target file name, index keys information, constraints on source file
	from user and writes it as 'target'.KEY. This .KEY file will be used in
	rgmain.c to create temporary index and print reports.

MODIFICATIONS:        

Programmer     YY/MM/DD       Description of modification
~~~~~~~~~~     ~~~~~~~~       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

------------------------------------------------------------------------*/

#include <stdio.h>
#include <ctype.h>
#include <cfomstrc.h>
#include <bfs_defs.h>
#include <indxbld.h>
#include <fld_defs.h>

#ifdef ENGLISH
#define ADDREC		'A'
#define CHANGE		'C'
#define DELETE		'D'
#define INQUIRE		'I'
#define EXITOPT		'E'

#define	YES		'Y'
#define	ADDITEM		'A'
#define	EDIT		'E'
#define	CANCEL		'C'
#define	FIRST_SCR	'1'
#define	SECOND_SCR	'2'

#define ASCEND		'A'
#define DESEND		'D'
#else
#define ADDREC		'R'
#define CHANGE		'C'
#define DELETE		'E'
#define INQUIRE		'I'
#define EXITOPT		'F'

#define	YES		'O'
#define	ADDITEM		'R'
#define	EDIT		'M'
#define	CANCEL		'A'
#define	FIRST_SCR	'1'
#define	SECOND_SCR	'2'

#define ASCEND		'C'
#define DESEND		'D'
#endif

#define	SCR_NAME1	"rgixinf1"	/* First screen */
#define	SCR_NAME2	"rgixinf2"	/* Second screen */

#define	PAGESIZE	IXSIZE	/* No of Items */

#define	S1_ST_FLD	1200	/* Item 1 Start Field */
#define	S1_END_FLD	4300	/* Last Field of the screen */
#define	S1_STEP		300	/* NO of fields difference between 2 items */
#define	S2_ST_FLD	1100	/* Item 1 Start Field */
#define	S2_END_FLD	13200	/* Last Field of the screen */
#define	S2_STEP		1200	/* NO of fields difference between 2 items */

#define	FN_FLD		500	/* Fn: */
#define	KEY_START	600	/* Index Info File: */
#define	KEY_END		700	/* From(DBH) File: */
#define	IX_FILE		600	/* Index Info File: */
#define	IN_FILE		700	/* From File: */
#define	CHG_FLD		800	/* Field: */
#define	CRT_DATE	1000	/* Date of Creation */

/* Screen 1 STH file */

/* Field Numbers on Screen */

/* rgixbld1.sth - header for C structure generated by PROFOM EDITOR */

typedef	struct	{	/* Start Field 1200. End Field 4100 */

	short	fld_no;		/* NUMERIC 999 Field 1200. Step 300 */
	char	fld_name[16];	/* STRING X[15] Field 1300. Step 300 */
	char	fld_order[2];	/* STRING X Field 1400. Step 300 */

} S1_item;

struct	s1_struct	{

	char	s1_pgm[11];	/* STRING XXXXXXXXXX Field 100 */
	long	s1_rundate;		/* DATE YYYYFMMFDD Field 300 */
	char	s1_fn[2];	/* STRING X Field 500 */
	char	s1_ix_file[11];	/* STRING XXXXXXXXX Field 600 */
	char	s1_in_file[11];	/* STRING XXXXXXXXX Field 700 */
	short	s1_itm_no;		/* NUMERIC 99 Field 800 */
	long	s1_crt_dt;		/* DATE YYYYFMMFDD Field 1000 */

	S1_item	s1_items[PAGESIZE] ;	/* Start Fld 1200. End Fld 4100.
					   Step 300 */

	char	s1_mesg[78];	/* STRING X[77] Field 4200 */
	char	s1_resp[2];	/* STRING X Field 4300 */
};

/* Screen 2 STH file */

/* rgixbld2.sth - header for C structure generated by PROFOM EDITOR */

typedef	struct	{	/* Start Field 1100. End fld 13000 */

	short	fld_no;	/* NUMERIC 999 Field 1100 */
	char	fld_name[16];	/* STRING XXXXXXXXXXXXXXX Field 1200 */
	char	min_char[21];	/* STRING XXXXXXXXXXXXXXXXXXXX Field 1300 */
	char	max_char[21];	/* STRING XXXXXXXXXXXXXXXXXXXX Field 1400 */
	long	min_long;	/* NUMERIC S99999999 Field 1500 */
	long	max_long;	/* NUMERIC S99999999 Field 1600 */
	short	min_short;	/* NUMERIC S9999 Field 1700 */
	short	max_short;	/* NUMERIC S9999 Field 1800 */
	double	min_double;	/* NUMERIC S99999999.9999 Field 1900 */
	double	max_double;	/* NUMERIC S99999999.9999 Field 2000 */
	float	min_float;	/* NUMERIC S9999999.99 Field 2100 */
	float	max_float;	/* NUMERIC S9999999.99 Field 2200 */

} S2_item ;

struct	s2_struct	{

	char	s2_pgm[11];	/* STRING XXXXXXXXXX Field 100 */
	long	s2_rundate;		/* DATE YYYYFMMFDD Field 300 */
	char	s2_fn[2];	/* STRING X Field 500 */
	char	s2_ix_file[11];	/* STRING XXXXXXXXX Field 600 */
	char	s2_in_file[11];	/* STRING XXXXXXXXX Field 700 */
	short	s2_itm_no;		/* NUMERIC 99 Field 800 */
	short	s2_dummy ;	/* NUMERIC 9 Field 850.. For alignment */

	S2_item	s2_items[PAGESIZE] ;	/* Start Fld 1100. End Fld 13000.
					   Step 1200 */

	char	s2_mesg[78];	/* STRING X[77] Field 13100 */
	char	s2_resp[2];	/* STRING X Field 13200 */
	};

static	struct	s1_struct  s1_sth;	/* Screen-1 Structure */
static	struct	s2_struct  s2_sth;	/* Screen-2 Structure */

static	short	No_keys ;	/* NO of Keys */
static	short	No_cons ;	/* No Of Constraints */

/* Screens Control Variables */
static	int	ST_FLD;		/* Data entry starting field */
static	int	END_FLD;	/* screen end field */
static	int	STEP;		/* Step size in fld numbers between each item */
static	short	*Item;		/* Ptr to Change Item number */
static	short	*No_Items ;	/* No of Items active in Current Screen */
static	char	*Mesg;		/* Message fld */
static	char	*Resp;		/* Response fld to user response */
static	char	*CurrentScreen;	/* Ptr to active screen */
static	short	ActiveScr ;	/* Current screen in working */
static	int	(*Validate)() ;	/* Ptr to Validation function of Cur. Screen */
static	int	(*WindowHelp)();/* Ptr to Help Windows dispaly function of
				   Cur. Screen */
static	int	(*InitItem)() ;	/* Ptr to Low/High Moving function of a given
				   item */

/* Common varibales between all modules */

/* Field definitions */
extern	Fld_hdr	hdr ;
extern	Field	*fields ;

extern	Ix_info	ix_info ;		/* Index Information */
extern	struct	stat_rec sr;		/* PROFOM status rec */
extern	char 	e_mesg[];  		/* dbh will return err msg in this */
extern	char	key_file[];		/* Current Index Key File name */
extern	char	ix_file[];		/* Temporay Index File name */


/*----------------------------------------------------------------*/

IndexSetup()
{
	int	err;

	InitScreens() ;

	for( ; ; ){
		/* Display Fn: options */
#ifdef ENGLISH
		fomer("A(dd), C(hange), D(elete), I(nquiry), E(xit)");
#else
		fomer("R(ajouter), C(hanger), E(liminer), I(nterrogation), F(in)");
#endif

		/* Read Fn: field to get the option */
		sr.nextfld = FN_FLD ;
		fomrf(CurrentScreen);
		ret(err_chk(&sr));	/* Check for PROFOM error */

		switch(s1_sth.s1_fn[0]){
		case ADDREC  :	/* ADD */
			err = AddIndx();
			break;
		case CHANGE  :	/* Change */
			err = ChangeIndx() ;
			break ;
		case DELETE  :	/* Delete */
			err = DeleteIndx() ;
			break ;
		case INQUIRE  :	/* Inquire */
			err = InquireIndx() ;
			break ;
		case EXITOPT  :	/* Exit */
			return(NOERROR);
		default   : 
			continue; 
		}  /*   end of the switch statement */

		if(err == PROFOM_ERR)return(PROFOM_ERR); /* PROFOM ERROR */
		if(err == DBH_ERR)return(DBH_ERR); /* Index Creation ERROR */
	}      /*   end of the for( ; ; )       */
}	/* IndexSetup() */
/*----------------------------------------------------------------*/
/* Initialize screens before going to process options */
InitScreens()
{
	/* set 1st screen as a active screen */
	Set1stScreen(0);

	/* Screen 1 */

	strcpy(s1_sth.s1_pgm,PROG_NAME);
	s1_sth.s1_rundate = get_date();	/* get Today's Date in YYYYMMDD format*/
	s1_sth.s1_ix_file[0] = LV_CHAR ;
	s1_sth.s1_itm_no = HV_SHORT ;
	s1_sth.s1_mesg[0] = HV_CHAR ;
	s1_sth.s1_resp[0] = HV_CHAR ;

	/* Screen 2 */

	strcpy(s2_sth.s2_pgm,PROG_NAME);
	s2_sth.s2_rundate = s1_sth.s1_rundate ;
	s2_sth.s2_itm_no = HV_SHORT ;
	s2_sth.s2_dummy  = HV_SHORT ;
	s2_sth.s2_mesg[0] = HV_CHAR ;
	s2_sth.s2_resp[0] = HV_CHAR ;

	/* Move HIgh Values to Both screen data fields & Display the 1st scr */
	MoveHighs() ;

}	/* InitScreens() */
/*---------------------------------------------------------------------*/
/* Set 1st screen as active screen */
Set1stScreen(flg)
int	flg ;	/* If Yes display the screen */
{
	int	Init1_Item(), Scr1Validation(), Scr1Help() ;

	/* move 1st screen name to Profom status structure */
	strcpy(sr.scrnam,NFM_PATH);
	strcat(sr.scrnam,SCR_NAME1) ;

	/* Initialize Ptrs to 1st screen */
	No_Items = &No_keys ;
	InitItem = Init1_Item ;
	Validate = Scr1Validation ;
	WindowHelp = Scr1Help ;
	Item = &s1_sth.s1_itm_no ;
	Mesg = s1_sth.s1_mesg;
	Resp = s1_sth.s1_resp;
	CurrentScreen = (char*)&s1_sth ;
	ActiveScr = 1 ;
	ST_FLD  = S1_ST_FLD ;
	END_FLD = S1_END_FLD ;
	STEP    = S1_STEP ;

	if(flg) {
		sr.nextfld = 1;
		sr.endfld = 0;
		fomwr(CurrentScreen);
		ret(err_chk(&sr));
	}
	return(NOERROR) ;
}	/* Set1stScreen() */
/*---------------------------------------------------------------------*/
/* Set 2nd screen as active screen */
Set2ndScreen()
{
	int	Init2_Item(), Scr2Validation(), Scr2Help() ;

	/* move 2nd screen name to Profom status structure */
	strcpy(sr.scrnam,NFM_PATH);
	strcat(sr.scrnam,SCR_NAME2) ;

	/* Copy Key fields from 1st screen */
	strcpy(s2_sth.s2_fn,s1_sth.s1_fn) ;
	strcpy(s2_sth.s2_in_file,s1_sth.s1_in_file) ;
	strcpy(s2_sth.s2_ix_file,s1_sth.s1_ix_file) ;

	/* Initialize Ptrs to 2nd screen */
	No_Items = &No_cons ;
	InitItem = Init2_Item ;
	Validate = Scr2Validation ;
	WindowHelp = Scr2Help ;
	Item = &s2_sth.s2_itm_no ;
	Mesg = s2_sth.s2_mesg;
	Resp = s2_sth.s2_resp;
	CurrentScreen = (char*)&s2_sth ;
	ActiveScr = 2 ;
	ST_FLD  = S2_ST_FLD ;
	END_FLD = S2_END_FLD ;
	STEP    = S2_STEP ;

	sr.nextfld = 1;
	sr.endfld = 0;
	fomwr(CurrentScreen);
	ret(err_chk(&sr));

	return(NOERROR) ;
}	/* Set2ndScreen() */
/*----------------------------------------------------------------------*/
/* Read the File, Keys and constraints information and create 'target.KEY'
   File */
AddIndx()
{
	int	err ;

	MoveHighs() ;

	err = ReadKey();
	if(err != NOERROR) return(err) ;

	No_keys = 0 ;
	No_cons = 0 ;

	/* Read 1st Screen (Index Keys) */

	err = ReadScreen() ;
	if(err == PROFOM_ERR) return(err) ;

	/* Read 2nd Screen (Constraints) */

	err = Set2ndScreen() ;
	if(err == PROFOM_ERR) return(err) ;

	err = ReadScreen() ;
	if(err == PROFOM_ERR) return(err) ;

	err = ReadOption() ;
	if(err < 0) return(err) ;

	if(err == CANCEL)
		return(MoveHighs()) ;

	CopyToRecord() ;

	return( RiteDetails(ADD) );
}	/* AddIndx() */
/*-----------------------------------------------------------------------*/
/* Accepts the changes to selected record and update the database */
ChangeIndx()
{
	int	err ;

	err = SelectIndx() ;
	if(err != NOERROR) return(err) ;

	err = ChangeItems();
	if(err != NOERROR) return(err);

	err = ReadOption() ;
	if(err < 0) return(err) ;

	if(err == CANCEL)
		return(CopyToScreen());	/* Display the original record */

	UnlinkIxFile(ix_file) ;		/* Delete temporay index file */

	CopyToRecord() ;

	return( RiteDetails(UPDATE) );
}	/* ChangeIndx() */
/*-----------------------------------------------------------------------*/
/* Select the Index Info to be deleted and delete the file afetr confirmation */
DeleteIndx()
{
	int	err;
	char	t_file[50] ;

	err = SelectIndx() ;
	if(err != NOERROR) return(err) ;

	err = ReadOption() ;
	if(err < 0) return(err) ;

	if(err == CANCEL)
		return(NOERROR) ;

	form_f_name(s1_sth.s1_ix_file, t_file) ;
	strcat(t_file, INDX_SUFFIX) ;
	unlink(t_file) ;

	MoveHighs();

	return(NOERROR) ;
}	/* DeleteIndx() */
/*-----------------------------------------------------------------------*/
/* Select the Indx File, get the record & display */
InquireIndx()
{
	int	err ;

	err = SelectIndx() ;
	if(err != NOERROR) return(err) ;

	err = ReadOption() ;
	if(err < 0) return(err) ;

	return(NOERROR) ;
}	/* InquireIndx() */
/*----------------------------------------------------------*/
/* Read the Index file name, get the record and display */
SelectIndx()
{
	int	err ;
	char	filename[20] ;

	for(; ;){
		err = ReadKey();
		if(err != NOERROR) return(err) ;

		/* Get the record from database */

		err = GetInfo();
		if(err == DBH_ERR) return(err) ;
		if(err < 0) continue ;

		getflnm(ix_info.t_source, filename) ;

		if(fields != NULL) {
			free((char*)fields);
			fields = NULL ;
		}
		if( GetFields(filename, &hdr, &fields, e_mesg) == ERROR) {
			fomen(e_mesg) ;
			get() ;
			return(DBH_ERR) ;
		}
		return(CopyToScreen()) ;
	}
}	/* SelectIndx() */
/*----------------------------------------------------------------------*/
/* Read Index and Source files form user */
ReadKey()
{
	int	err, i;
	char	in_file[sizeof(s1_sth.s1_in_file)];
	char	ky_file[sizeof(s1_sth.s1_ix_file)];

#ifdef ENGLISH
	strcpy(Mesg,"Key ESC-F to Go Back to Fn:");
#else
	strcpy(Mesg,"Appuyer sur ESC-F pour retourner a Fn:");
#endif
	ShowMesg();

	/* In Add mode turn off dup control for key fields.
	   Other modes reverse it */
	if(s1_sth.s1_fn[0] == ADDREC){	/* ADD */
		for(i = KEY_START ; i <= KEY_END ; i += 100)
			fomca1(i,19,0) ;	/* Off Dup Control */
	}
	else {
		for(i = KEY_START ; i <= KEY_END ; i += 100)
			fomca1(i,19,2) ;

		sr.nextfld = KEY_START;
		sr.endfld = KEY_END;
		fomud((char*)&s1_sth);
	}

	/* Store fields to copy back when user gives ESC-F */
	strcpy(ky_file,s1_sth.s1_ix_file) ;
	strcpy(in_file,s1_sth.s1_in_file) ;

	sr.nextfld = KEY_START;
	sr.endfld = KEY_END;
	s1_sth.s1_ix_file[0] = LV_CHAR ;
	if(s1_sth.s1_fn[0] == ADDREC)
		s1_sth.s1_in_file[0] = LV_CHAR ;

	for(; ;) {
		fomrd(CurrentScreen);
		ret(err_chk(&sr));

		if(sr.retcode == RET_VAL_CHK){
			err = (*Validate)() ;
			if(err == DBH_ERR) return(err) ;
			continue;
		}
		if(sr.retcode == RET_USER_ESC){
			if(sr.escchar[0] == 'F' || sr.escchar[0] == 'f') {
				/* copy back key fields */
				strcpy(s1_sth.s1_in_file,in_file) ;
				strcpy(s1_sth.s1_ix_file,ky_file) ;

				sr.nextfld = KEY_START;
				sr.endfld = KEY_END;
				fomwr(CurrentScreen);

				Mesg[0] = HV_CHAR;
				ShowMesg();
				return(ERROR) ;
			}
			continue;
		}
		/* else RET_NO_ERROR */
		break;
	}			/* end of for loop */

	/* If New index is selected then delete the current Index file */
	if(strcmp(key_file, s1_sth.s1_ix_file) )
		UnlinkIxFile(ix_file);

	strcpy(key_file, s1_sth.s1_ix_file) ;

	Mesg[0] = HV_CHAR;
	ShowMesg();

	return(NOERROR);
}	/*  ReadKey() */
/*------------------------------------------------------------*/
/* Get all fields from user on current screen */
ReadScreen()
{
	int	i ;

	if(*No_Items == PAGESIZE) {
#ifdef ENGLISH
		fomer("No More Additions possible");
#else
		fomer("Aucune autre addition possible");
#endif
		return(NOERROR) ;
	}

	/* Change PROFOM logical field attributes */

	i = ST_FLD + (STEP * (*No_Items)) ;

	for( ; i <= END_FLD - 200  ; i += 100)
		fomca1(i,19,0); /* Disable Dup control */

	for( ; *No_Items < PAGESIZE ; (*No_Items)++) {

#ifdef ENGLISH
		strcpy(Mesg,"Press RETURN in the 1st field or Press ESC-F to Terminate");
#else
		strcpy(Mesg,"Appuyer RETURN dans le premier champ ou appuyer sur ESC-F pour terminer");
#endif
		ShowMesg();

		i = ReadItem((int)(*No_Items)) ;
				   /* Read Each Item Line */
		if(i == PROFOM_ERR) return(i) ;
		if(i == DBH_ERR) return(i) ;
		if(i != NOERROR) break ;
	}

	/* If the user terminated at some item, then move High values to that */
	if(*No_Items != PAGESIZE) {
		(*InitItem)((int)(*No_Items), HV_SHORT, HV_CHAR) ;

		sr.nextfld = ST_FLD + (STEP * (*No_Items)) ;
		sr.endfld = sr.nextfld + STEP - 100 ;

		fomwr(CurrentScreen) ;
		ret(err_chk(&sr));
	}

	Mesg[0] = HV_CHAR ;
	ShowMesg() ;

	return(NOERROR) ;
}	/* ReadScreen() */
/*------------------------------------------------------------*/
/* Get all fields from user on current screen */
ReadItem(item_no)
int	item_no ;
{
	int	err ;

	/* Initialize Reading Item with Low values */
	(*InitItem)(item_no, LV_SHORT, LV_CHAR) ;

	sr.nextfld = ST_FLD + (STEP * item_no) ;
	sr.endfld = sr.nextfld + STEP - 100 ;

	for( ; ;){
		fomrd(CurrentScreen);
		ret(err_chk(&sr));
		if(sr.retcode == RET_VAL_CHK){
			err = (*Validate)() ;
			if(err != NOERROR) return(err);
			continue;
		}
		if(sr.retcode == RET_USER_ESC){
			if(sr.escchar[0] == 'f' || sr.escchar[0] == 'F')
				return(RET_USER_ESC) ;
			if(sr.escchar[0] == 'h' || sr.escchar[0] == 'H'){
				err = (*WindowHelp)() ;
				if(err == DBH_ERR) return(err) ;
				continue;
			}
			continue;
		}
		/* else RET_NO_ERROR */
		break;
	}

	return(NOERROR) ;
}	/* ReadItem() */
/*----------------------------------------------------------------*/
/* validate 1st Screen flds when PROFOM returns RET_VAL_CHK */
Scr1Validation()
{
	int	i ;
	char	file_nm[50] ;

	switch(sr.curfld){
	case	IX_FILE  :			/* Index File */
		if(s1_sth.s1_ix_file[0] != '\0') {
		    if(getfileno(s1_sth.s1_ix_file) >= 0) {
#ifdef ENGLISH
			fomer("Index File Can't Be One of the Data Files");
#else
			fomer("Dossier d'indexe ne peut etre une des dossier de donnees");
#endif
			s1_sth.s1_ix_file[0] = LV_CHAR ;
			break ;
		    }
		    form_f_name(s1_sth.s1_ix_file, file_nm) ;
		    strcat(file_nm, INDX_SUFFIX) ;
		    if(access(file_nm,0) >=  0 && s1_sth.s1_fn[0] == ADDREC) {
#ifdef ENGLISH
			fomer("File Exists with this name.. Enter again..") ;
#else
			fomer("Dossier existe deja avec ce nom.. Entrer de nouveau..") ;
#endif
			s1_sth.s1_ix_file[0] = LV_CHAR ;
		    }
		}
		/* Else read the field againg */
		break ;
	case	IN_FILE  :			/* From File */
		/* Check whether user has read permission on this file */
		i = CheckAccess(getfileno(s1_sth.s1_in_file), BROWSE, e_mesg) ;
		if(i == DBH_ERR) return(i) ;
		if( i < 0) {
			fomer(e_mesg) ;
			s1_sth.s1_in_file[0] = LV_CHAR ;
			break ;
		}
		if(fields != NULL) {
			free((char*)fields);
			fields = NULL ;
		}
		if( GetFields(s1_sth.s1_in_file, &hdr, &fields, e_mesg) ==
								ERROR) {
			fomer(e_mesg) ;
			s1_sth.s1_in_file[0] = LV_CHAR ;
		}
		break ;

	/*
	*	FLd# fields
	*/

	case	(S1_ST_FLD + (0 * S1_STEP)) :		/* Item 1 */
	case	(S1_ST_FLD + (1 * S1_STEP)) :		/* Item 2 */
	case	(S1_ST_FLD + (2 * S1_STEP)) :		/* Item 3 */
	case	(S1_ST_FLD + (3 * S1_STEP)) :		/* Item 4 */
	case	(S1_ST_FLD + (4 * S1_STEP)) :		/* Item 5 */
	case	(S1_ST_FLD + (5 * S1_STEP)) :		/* Item 6 */
	case	(S1_ST_FLD + (6 * S1_STEP)) :		/* Item 7 */
	case	(S1_ST_FLD + (7 * S1_STEP)) :		/* Item 8 */
	case	(S1_ST_FLD + (8 * S1_STEP)) :		/* Item 9 */
	case	(S1_ST_FLD + (9 * S1_STEP)) :		/* Item 10 */

		/* Caluculate item# */
		i = (sr.curfld - S1_ST_FLD) / S1_STEP ;

		/* Return ERROR When the fld# == 0, i.e user doesn't want
		   that item */
		if(s1_sth.s1_items[i].fld_no == 0) return(ERROR) ;
		
		if(s1_sth.s1_items[i].fld_no < 1 ||
				s1_sth.s1_items[i].fld_no > hdr.no_fields) {
#ifdef ENGLISH
			fomer("Invalid Field#");
#else
			fomer("Numero de champ invalide");
#endif
			s1_sth.s1_items[i].fld_no = LV_SHORT ;
			break ;
		}
		/* Copy Name */
		strcpy(s1_sth.s1_items[i].fld_name,
			(fields+(s1_sth.s1_items[i].fld_no-1))->name);

		/* Display help message for Order Field(Next input Field) */
#ifdef ENGLISH
		fomer("A(scnd), D(escnd)");
#else
		fomer("C(roissante), D(ecroissante)");
#endif
		break ;
	/*
	*	Order fields
	*/

	case	(S1_ST_FLD + (0 * S1_STEP) + 200) :		/* Item 1 */
	case	(S1_ST_FLD + (1 * S1_STEP) + 200) :		/* Item 2 */
	case	(S1_ST_FLD + (2 * S1_STEP) + 200) :		/* Item 3 */
	case	(S1_ST_FLD + (3 * S1_STEP) + 200) :		/* Item 4 */
	case	(S1_ST_FLD + (4 * S1_STEP) + 200) :		/* Item 5 */
	case	(S1_ST_FLD + (5 * S1_STEP) + 200) :		/* Item 6 */
	case	(S1_ST_FLD + (6 * S1_STEP) + 200) :		/* Item 7 */
	case	(S1_ST_FLD + (7 * S1_STEP) + 200) :		/* Item 8 */
	case	(S1_ST_FLD + (8 * S1_STEP) + 200) :		/* Item 9 */
	case	(S1_ST_FLD + (9 * S1_STEP) + 200) :		/* Item 10 */

		/* Caluculate item# */
		i = (sr.curfld - S1_ST_FLD) / S1_STEP ;

		if(s1_sth.s1_items[i].fld_order[0] != ASCEND &&
				s1_sth.s1_items[i].fld_order[0] != DESEND) {
#ifdef ENGLISH
			fomer("A(scnd), D(escnd)");
#else
			fomer("C(roissante), D(ecroissante)");
#endif
			s1_sth.s1_items[i].fld_order[0] = LV_CHAR ;
		}
		break ;
	default :
#ifdef ENGLISH
		sprintf(e_mesg,"No Validity Check For Field#  %d",sr.curfld);
#else
		sprintf(e_mesg,"Pas de controle de validite pour le Champ# %d",sr.curfld);
#endif
		fomen(e_mesg);
		get();
		return(ERROR) ;
	}	/* Switch fld_no */

	sr.nextfld = sr.curfld ;
	return(NOERROR) ;
}	/* Scr1Validation() */
/*----------------------------------------------------------------*/
/* validate 2nd Screen flds when PROFOM returns RET_VAL_CHK */
Scr2Validation()
{
	int	i ;

	switch(sr.curfld){

	/*
	*	FLd# fields
	*/

	case	(S2_ST_FLD + (0 * S2_STEP)) :		/* Item 1 */
	case	(S2_ST_FLD + (1 * S2_STEP)) :		/* Item 2 */
	case	(S2_ST_FLD + (2 * S2_STEP)) :		/* Item 3 */
	case	(S2_ST_FLD + (3 * S2_STEP)) :		/* Item 4 */
	case	(S2_ST_FLD + (4 * S2_STEP)) :		/* Item 5 */
	case	(S2_ST_FLD + (5 * S2_STEP)) :		/* Item 6 */
	case	(S2_ST_FLD + (6 * S2_STEP)) :		/* Item 7 */
	case	(S2_ST_FLD + (7 * S2_STEP)) :		/* Item 8 */
	case	(S2_ST_FLD + (8 * S2_STEP)) :		/* Item 9 */
	case	(S2_ST_FLD + (9 * S2_STEP)) :		/* Item 10 */

		/* Caluculate item# */
		i = (sr.curfld - S2_ST_FLD) / S2_STEP ;

		/* Return ERROR When the fld# == 0, i.e user doesn't want
		   that item */
		if(s2_sth.s2_items[i].fld_no == 0) return(ERROR) ;
		
		if(s2_sth.s2_items[i].fld_no < 1 ||
				s2_sth.s2_items[i].fld_no > hdr.no_fields) {
#ifdef ENGLISH
			fomer("Invalid Field#");
#else
			fomer("Numero de champ invalide");
#endif
			s2_sth.s2_items[i].fld_no = LV_SHORT ;
			break ;
		}
		/* Copy Name */
		strcpy(s2_sth.s2_items[i].fld_name,
			(fields+(s2_sth.s2_items[i].fld_no-1))->name);

		LV_cons(i, (fields+(s2_sth.s2_items[i].fld_no-1))->type);
		break ;

	/*
	*	Maximum Constraint - Character Fields
	*/

	case	(S2_ST_FLD + (0 * S2_STEP)) + 300 :		/* Item 1 */
	case	(S2_ST_FLD + (1 * S2_STEP)) + 300 :		/* Item 2 */
	case	(S2_ST_FLD + (2 * S2_STEP)) + 300 :		/* Item 3 */
	case	(S2_ST_FLD + (3 * S2_STEP)) + 300 :		/* Item 4 */
	case	(S2_ST_FLD + (4 * S2_STEP)) + 300 :		/* Item 5 */
	case	(S2_ST_FLD + (5 * S2_STEP)) + 300 :		/* Item 6 */
	case	(S2_ST_FLD + (6 * S2_STEP)) + 300 :		/* Item 7 */
	case	(S2_ST_FLD + (7 * S2_STEP)) + 300 :		/* Item 8 */
	case	(S2_ST_FLD + (8 * S2_STEP)) + 300 :		/* Item 9 */
	case	(S2_ST_FLD + (9 * S2_STEP)) + 300 :		/* Item 10 */

		/* Caluculate item# */
		i = (sr.curfld - S2_ST_FLD) / S2_STEP ;

		if(strcmp(s2_sth.s2_items[i].min_char,
				s2_sth.s2_items[i].max_char) > 0){
#ifdef ENGLISH
			fomer("Invalid Range");
#else
			fomer("Limite invalide");
#endif
			s2_sth.s2_items[i].max_char[0] = LV_CHAR ;
			break ;
		}
		/* When user is not given any input in Char filds, and that
		   is valid input set the sr.nextfld to next field. Otherwise
		   next fomrd() reads same field again */
		if(s2_sth.s2_items[i].max_char[0] == '\0') 
			sr.curfld += 100 ;
		break ;

	/*
	*	Maximum Constraint - Long Fields
	*/

	case	(S2_ST_FLD + (0 * S2_STEP)) + 500 :		/* Item 1 */
	case	(S2_ST_FLD + (1 * S2_STEP)) + 500 :		/* Item 2 */
	case	(S2_ST_FLD + (2 * S2_STEP)) + 500 :		/* Item 3 */
	case	(S2_ST_FLD + (3 * S2_STEP)) + 500 :		/* Item 4 */
	case	(S2_ST_FLD + (4 * S2_STEP)) + 500 :		/* Item 5 */
	case	(S2_ST_FLD + (5 * S2_STEP)) + 500 :		/* Item 6 */
	case	(S2_ST_FLD + (6 * S2_STEP)) + 500 :		/* Item 7 */
	case	(S2_ST_FLD + (7 * S2_STEP)) + 500 :		/* Item 8 */
	case	(S2_ST_FLD + (8 * S2_STEP)) + 500 :		/* Item 9 */
	case	(S2_ST_FLD + (9 * S2_STEP)) + 500 :		/* Item 10 */

		/* Caluculate item# */
		i = (sr.curfld - S2_ST_FLD) / S2_STEP ;

		if(s2_sth.s2_items[i].min_long > s2_sth.s2_items[i].max_long){
#ifdef ENGLISH
			fomer("Invalid Range");
#else
			fomer("Limite invalide");
#endif
			s2_sth.s2_items[i].max_long = LV_LONG ;
		}
		break ;

	/*
	*	Maximum Constraint - Short Fields
	*/

	case	(S2_ST_FLD + (0 * S2_STEP)) + 700 :		/* Item 1 */
	case	(S2_ST_FLD + (1 * S2_STEP)) + 700 :		/* Item 2 */
	case	(S2_ST_FLD + (2 * S2_STEP)) + 700 :		/* Item 3 */
	case	(S2_ST_FLD + (3 * S2_STEP)) + 700 :		/* Item 4 */
	case	(S2_ST_FLD + (4 * S2_STEP)) + 700 :		/* Item 5 */
	case	(S2_ST_FLD + (5 * S2_STEP)) + 700 :		/* Item 6 */
	case	(S2_ST_FLD + (6 * S2_STEP)) + 700 :		/* Item 7 */
	case	(S2_ST_FLD + (7 * S2_STEP)) + 700 :		/* Item 8 */
	case	(S2_ST_FLD + (8 * S2_STEP)) + 700 :		/* Item 9 */
	case	(S2_ST_FLD + (9 * S2_STEP)) + 700 :		/* Item 10 */

		/* Caluculate item# */
		i = (sr.curfld - S2_ST_FLD) / S2_STEP ;

		if(s2_sth.s2_items[i].min_short > s2_sth.s2_items[i].max_short){
#ifdef ENGLISH
			fomer("Invalid Range");
#else
			fomer("Limite invalide");
#endif
			s2_sth.s2_items[i].max_short = LV_SHORT ;
		}
		break ;

	/*
	*	Maximum Constraint - Double Fields
	*/

	case	(S2_ST_FLD + (0 * S2_STEP)) + 900 :		/* Item 1 */
	case	(S2_ST_FLD + (1 * S2_STEP)) + 900 :		/* Item 2 */
	case	(S2_ST_FLD + (2 * S2_STEP)) + 900 :		/* Item 3 */
	case	(S2_ST_FLD + (3 * S2_STEP)) + 900 :		/* Item 4 */
	case	(S2_ST_FLD + (4 * S2_STEP)) + 900 :		/* Item 5 */
	case	(S2_ST_FLD + (5 * S2_STEP)) + 900 :		/* Item 6 */
	case	(S2_ST_FLD + (6 * S2_STEP)) + 900 :		/* Item 7 */
	case	(S2_ST_FLD + (7 * S2_STEP)) + 900 :		/* Item 8 */
	case	(S2_ST_FLD + (8 * S2_STEP)) + 900 :		/* Item 9 */
	case	(S2_ST_FLD + (9 * S2_STEP)) + 900 :		/* Item 10 */

		/* Caluculate item# */
		i = (sr.curfld - S2_ST_FLD) / S2_STEP ;

		if(s2_sth.s2_items[i].min_double >
					s2_sth.s2_items[i].max_double){
#ifdef ENGLISH
			fomer("Invalid Range");
#else
			fomer("Limite invalide");
#endif
			s2_sth.s2_items[i].max_double = LV_DOUBLE ;
		}
		break ;
	/*
	*	Maximum Constraint - Double Fields
	*/

	case	(S2_ST_FLD + (0 * S2_STEP)) + 1100 :		/* Item 1 */
	case	(S2_ST_FLD + (1 * S2_STEP)) + 1100 :		/* Item 2 */
	case	(S2_ST_FLD + (2 * S2_STEP)) + 1100 :		/* Item 3 */
	case	(S2_ST_FLD + (3 * S2_STEP)) + 1100 :		/* Item 4 */
	case	(S2_ST_FLD + (4 * S2_STEP)) + 1100 :		/* Item 5 */
	case	(S2_ST_FLD + (5 * S2_STEP)) + 1100 :		/* Item 6 */
	case	(S2_ST_FLD + (6 * S2_STEP)) + 1100 :		/* Item 7 */
	case	(S2_ST_FLD + (7 * S2_STEP)) + 1100 :		/* Item 8 */
	case	(S2_ST_FLD + (8 * S2_STEP)) + 1100 :		/* Item 9 */
	case	(S2_ST_FLD + (9 * S2_STEP)) + 1100 :		/* Item 10 */

		/* Caluculate item# */
		i = (sr.curfld - S2_ST_FLD) / S2_STEP ;

		if(s2_sth.s2_items[i].min_float >
					s2_sth.s2_items[i].max_float){
#ifdef ENGLISH
			fomer("Invalid Range");
#else
			fomer("Limite invalide");
#endif
			s2_sth.s2_items[i].max_float = LV_FLOAT ;
		}
		break ;
	default :
#ifdef ENGLISH
		sprintf(e_mesg,"No Validity Check For Field#  %d",sr.curfld);
#else
		sprintf(e_mesg,"Pas de controle de validite pour le Champ# %d",sr.curfld);
#endif
		fomen(e_mesg);
		get();
		return(ERROR) ;
	}	/* Switch fld_no */

	sr.nextfld = sr.curfld ;
	return(NOERROR) ;
}	/* Scr2Validation() */
/*----------------------------------------------------------------*/
/* Move Low Values to 2nd screen item based on fld type */
static	int
LV_cons(item_no, type)
int	item_no ;	/* Item no */
char	type ;		/* Type of the field */
{
	HV_cons(item_no) ;	/* Move High Values to all Constraints */

	switch(type) {
	case	T_CHAR :
		s2_sth.s2_items[item_no].min_char[0] = LV_CHAR ;
		s2_sth.s2_items[item_no].max_char[0] = LV_CHAR ;
		break ;
	case	T_SHORT :
		s2_sth.s2_items[item_no].min_short = LV_SHORT ;
		s2_sth.s2_items[item_no].max_short = LV_SHORT ;
		break ;
	case	T_INT :
		if(sizeof(int) == sizeof(short)) {
			s2_sth.s2_items[item_no].min_short = LV_SHORT ;
			s2_sth.s2_items[item_no].max_short = LV_SHORT ;
			break ;
		}
		/* else fall thru to next case */
	case	T_LONG :
		s2_sth.s2_items[item_no].min_long = LV_LONG ;
		s2_sth.s2_items[item_no].max_long = LV_LONG ;
		break ;
	case	T_FLOAT :
		s2_sth.s2_items[item_no].min_float = LV_FLOAT ;
		s2_sth.s2_items[item_no].max_float = LV_FLOAT ;
		break ;
	case	T_DOUBLE :
		s2_sth.s2_items[item_no].min_double = LV_DOUBLE ;
		s2_sth.s2_items[item_no].max_double = LV_DOUBLE ;
		break ;
	}
}
/*----------------------------------------------------------------*/
Scr1Help()	/* Display help window for applicable fields of 1st Screen */
{
	int	i ;
	int	fld_no ;

	switch(sr.curfld){
	/*
	*	FLd# fields
	*/

	case	(S1_ST_FLD + (0 * S1_STEP)) :		/* Item 1 */
	case	(S1_ST_FLD + (1 * S1_STEP)) :		/* Item 2 */
	case	(S1_ST_FLD + (2 * S1_STEP)) :		/* Item 3 */
	case	(S1_ST_FLD + (3 * S1_STEP)) :		/* Item 4 */
	case	(S1_ST_FLD + (4 * S1_STEP)) :		/* Item 5 */
	case	(S1_ST_FLD + (5 * S1_STEP)) :		/* Item 6 */
	case	(S1_ST_FLD + (6 * S1_STEP)) :		/* Item 7 */
	case	(S1_ST_FLD + (7 * S1_STEP)) :		/* Item 8 */
	case	(S1_ST_FLD + (8 * S1_STEP)) :		/* Item 9 */
	case	(S1_ST_FLD + (9 * S1_STEP)) :		/* Item 10 */

		i = fld_hlp(hdr, fields, &fld_no, 10, 20);
		if(i >= 0) redraw() ;

		if(i > 0) {	/* Fld Selected */
			/* Caluculate item# */
			i = (sr.curfld - S1_ST_FLD) / S1_STEP ;

			s1_sth.s1_items[i].fld_no = fld_no ;
			strcpy(s1_sth.s1_items[i].fld_name,
					(fields+(fld_no-1))->name);
		}
		break ;
	default :
#ifdef ENGLISH
		fomer("No Help Window For This Field");
#else
		fomer("Pas de fenetre d'assistance pour ce champ");
#endif
	}	/* Switch sr.curfld */

	sr.nextfld = sr.curfld ;
	return(NOERROR) ;
}	/* Scr1Help() */
/*----------------------------------------------------------------*/
Scr2Help()	/* Display help window for applicable fields of 2nd Screen */
{
	int	i ;
	int	fld_no ;

	switch(sr.curfld){
	/*
	*	FLd# fields
	*/

	case	(S2_ST_FLD + (0 * S2_STEP)) :		/* Item 1 */
	case	(S2_ST_FLD + (1 * S2_STEP)) :		/* Item 2 */
	case	(S2_ST_FLD + (2 * S2_STEP)) :		/* Item 3 */
	case	(S2_ST_FLD + (3 * S2_STEP)) :		/* Item 4 */
	case	(S2_ST_FLD + (4 * S2_STEP)) :		/* Item 5 */
	case	(S2_ST_FLD + (5 * S2_STEP)) :		/* Item 6 */
	case	(S2_ST_FLD + (6 * S2_STEP)) :		/* Item 7 */
	case	(S2_ST_FLD + (7 * S2_STEP)) :		/* Item 8 */
	case	(S2_ST_FLD + (8 * S2_STEP)) :		/* Item 9 */
	case	(S2_ST_FLD + (9 * S2_STEP)) :		/* Item 10 */

		i = fld_hlp(hdr, fields, &fld_no, 10, 20);
		if(i >= 0) redraw() ;

		if(i > 0) {	/* Fld Selected */
			/* Caluculate item# */
			i = (sr.curfld - S2_ST_FLD) / S2_STEP ;

			s2_sth.s2_items[i].fld_no = fld_no ;
			strcpy(s2_sth.s2_items[i].fld_name,
					(fields+(fld_no-1))->name);

			LV_cons(i, (fields+(fld_no-1))->type);
		}
		break ;
	default :
#ifdef ENGLISH
		fomer("No Help Window For This Field");
#else
		fomer("Pas de fenetre d'assistance pour ce champ");
#endif
	}	/* Switch sr.curfld */

	sr.nextfld = sr.curfld ;
	return(NOERROR) ;
}	/* Scr2Help() */
/*----------------------------------------------------------------------*/
/* Changing Items. Accept Item to be changed and read that Item */
/* This function is common function for both the screens */
ChangeItems()
{
	int	i, j, k;
	char	image[sizeof(S2_item)] ;	/* Bigger Items size */

	/* Change PROFOM logical field attributes upto last entered items */

	j = ST_FLD + (STEP * (*No_Items)) - 100 ;

	for(i = ST_FLD ; i <= j ; i += 100)
		fomca1(i,19,2); /* enabling Dup control */

	/* Set Dup Buffers */
	sr.nextfld = ST_FLD;
	sr.endfld = j ;
	fomud(CurrentScreen);	/* Updating dup buffer */
	ret(err_chk(&sr));

	for( ; ; ) {
		/* Get The Item to Be Modified */
#ifdef ENGLISH
		strcpy(Mesg,"Enter RETURN to terminate Edit");
#else
		strcpy(Mesg,"Appuyer sur RETURN pour terminer l'ajustement");
#endif
		ShowMesg() ;

		sr.nextfld = CHG_FLD ;
		fomrf(CurrentScreen);
		ret(err_chk(&sr));

		if(*Item == 0) break ;

		/* Valid Number is within existing items */
		if( *Item < 1 || *Item > *No_Items ) continue ;

		/* Save The image */
		if(ActiveScr == 1)
			scpy(image, (char*)&s1_sth.s1_items[*Item - 1],
				sizeof(S1_item));
		else
			scpy(image, (char*)&s2_sth.s2_items[*Item - 1],
				sizeof(S2_item));

#ifdef ENGLISH
		strcpy(Mesg,"ENTER 0 in the 1st field to Delete It");
#else
		strcpy(Mesg,"ENTRER 0 dans le premier champ a eliminer");
#endif
		ShowMesg();

		i = ReadItem((int)(*Item - 1)) ;	/* Read Item */
		if(i == PROFOM_ERR) return(i) ;
		if(i == DBH_ERR) return(i) ;

		if(i == NOERROR) {	/* Successful read */
			j = ST_FLD + (STEP * (*No_Items -1)) ;
			k = ST_FLD + (STEP * (*No_Items)) - 100 ;

			for(i = j ; i <= k ; i += 100)
				fomca1(i,19,2); /* enabling Dup control */
			continue ;
		}

		if(i == ERROR) {	/* Given 0 in Fld#, i.e. Deleted */
			sr.nextfld = ST_FLD + (STEP * (*Item - 1)) ;

			/* DElete the Current item and readjust the items */
			/* Copy the (next item to last item) to (cur item to
			   last but one item) */
			for( i = *Item - 1 ; i < *No_Items - 1 ; i++)
		    	    if(ActiveScr == 1)
				scpy((char*)&s1_sth.s1_items[i],
				(char*)&s1_sth.s1_items[i+1],sizeof(S1_item));
			    else
				scpy((char*)&s2_sth.s2_items[i],
				(char*)&s2_sth.s2_items[i+1],sizeof(S2_item));

			/* Move HVs to last item */
			(*InitItem)((int)(*No_Items - 1),HV_SHORT, HV_CHAR) ;

			sr.endfld = ST_FLD + (STEP * (*No_Items)) - 100  ;
			(*No_Items)-- ;
		}
		else	if(i == RET_USER_ESC) {

			/*
			* When user gives ESC-F while changing fields,
			* assumption is he completed his changes, and
			* reamaining fields are same as old. But, at this
			* point STH will be having low values in the 
			* remaining fields. So move the old values form
			* image.
			*/

			/* Offset to begining of the Item in 'k' */
			fomfp((ST_FLD + (STEP * (*Item - 1))),&k,&j) ;
			/* Offset to the field where ESC-F Pressed in 'j' */
			fomfp(sr.curfld,&j,&i);
			i =  j - k ;	/* Offset within item */

			if(ActiveScr == 1) {
				j = sizeof(S1_item) - i ;  /* Length to copy */
       		        	scpy((char *)&(s1_sth.s1_items[*Item - 1])+i,
						image + i, j);
			}
			else {
				j = sizeof(S2_item) - i ;  /* Length to copy */
       		        	scpy((char *)&(s2_sth.s2_items[*Item - 1])+i,
						image + i, j);
			}
			sr.nextfld = sr.curfld ;

			sr.endfld = ST_FLD + (STEP * (*Item)) - 100  ;
		}
		i = sr.nextfld ;
		j = sr.endfld ;
		/* Write back fields */
		fomwr(CurrentScreen);
		ret(err_chk(&sr));
		/* Write again to display overlap fields. In first pass depends
		   on the field, some times it may not display */
		sr.nextfld = i ;
		sr.endfld = j ;
		/* Write back fields */
		fomwr(CurrentScreen);
		ret(err_chk(&sr));
	}	/* for( ; ; ) */

	*Item = HV_SHORT ;
	fomwf(CurrentScreen);
	ret(err_chk(&sr));

	Mesg[0] = HV_CHAR;
	ShowMesg();

	return(NOERROR);
}	/* ChangeItems() */
/*-----------------------------------------------------------------------*/
/* Display the confirmation message at the bottom of the screen, take the
   option from user and call necessary functions */
ReadOption()
{
	int	err ;

	/*
	 Options:
	   Add      - YAEC1/2
	   Change   - YAEC1/2
	   Delete   - YC
	   Inquiry  - Y1/2
	*/
	for( ; ; ) {
	    switch(s1_sth.s1_fn[0]) {
	    case ADDREC :	/* ADD */
	    case CHANGE :	/* Change */
		if(ActiveScr == 1)
#ifdef ENGLISH
		    err = GetOpt("Y(es), A(dd Items), E(dit), C(ancel), 2(nd screen)",
							"YAEC2");
		else	/* if ActiveScr == 1 */
		    err = GetOpt("Y(es), A(dd Items), E(dit), C(ancel), 1(st screen)",
							"YAEC1");
#else
		    err = GetOpt("O(ui), R(ajouter articles), M(odifier), A(nnuler), 2(e ecran)",
							"ORMA2");
		else	/* if ActiveScr == 1 */
		    err = GetOpt("O(ui), R(ajouter articles), M(odifier), A(nnuler), 1(er ecran)",
							"ORMA1");
#endif
		break ;
	    case DELETE :	/* Delete */
#ifdef ENGLISH
		err = GetOpt("Y(es), C(ancel)", "YC");
#else
		err = GetOpt("O(ui), A(nnuler)", "OA");
#endif
		break ;
	    case INQUIRE :	/* Inquiry */
		if(ActiveScr == 1)
#ifdef ENGLISH
		    err = GetOpt("Y(es), 2(nd screen)", "Y2");
		else	/* if ActiveScr == 1 */
		    err = GetOpt("Y(es), 1(st screen)", "Y1");
#else
		    err = GetOpt("O(ui), 2(e ecran)", "O2");
		else	/* if ActiveScr == 1 */
		    err = GetOpt("O(ui), 1(er ecran)", "O1");
#endif
		break ;
	    }
	    if(err == PROFOM_ERR) return(err) ;

	    switch(err) {
	    case  YES :
		if(ActiveScr == 2) Set1stScreen(0) ;
		if(s1_sth.s1_fn[0] == ADDREC || s1_sth.s1_fn[0] == CHANGE) {
		    if(No_keys == 0) {
#ifdef ENGLISH
			fomen("Index Keys Are not Given to Build Index");
#else
			fomen("Cle d'indexe non-determine pour la construction de l'index");
#endif
			get() ;
			continue ;
		    }
		}
		return(YES) ;
	    case  ADDITEM  :
		err = ReadScreen();
		break ;
	    case  EDIT  :
		err = ChangeItems();
		break ;
	    case  CANCEL :
#ifdef ENGLISH
		err = GetOpt("Confirm the Cancel (Y/N)?", "YN") ;
#else
		err = GetOpt("Confirmer l'annulation (O/N)?", "ON") ;
#endif
		if(err == YES) {
			if(ActiveScr == 2) Set1stScreen(0) ;
			return(CANCEL) ;
		}
		break ;
	    case  FIRST_SCR :
		err = Set1stScreen(1) ;
		break ;
	    case  SECOND_SCR :
		err = Set2ndScreen() ;
		break ;
	    }	/* switch err */

	    if(err == PROFOM_ERR) return(err) ;
	    if(err == DBH_ERR) return(err) ;
	}	/* for(; ; ) */
}	/* ReadOption() */
/*-----------------------------------------------------------------------*/
/* Display message and get the option */
GetOpt(msg,options)
char	*msg ;
char	*options ;
{
	int	i, j ;

	strcpy(Mesg,msg);
	ShowMesg() ;

	sr.nextfld = END_FLD ;
	for( ; ; ) {
		fomrf(CurrentScreen) ;
		ret(err_chk(&sr)) ;

		j = strlen(options) ;
		for( i = 0 ; i < j ; i++)
			if(Resp[0] == options[i]) break ;
		if(i != j) break ;	/* Valid Option Selected */
#ifdef ENGLISH
		fomer("Invalid Option..");
#else
		fomer("Option invalide..");
#endif
	}
	Mesg[0] = HV_CHAR ;
	Resp[0] = HV_CHAR ;
	sr.nextfld = END_FLD - 100 ;
	sr.endfld = END_FLD ;
	fomwr(CurrentScreen) ;
	ret(err_chk(&sr)) ;

	return((int)(options[i])) ;
}	/* GetOpt() */
/*-----------------------------------------------------------------------*/
/* Create index info file using user given keys and Input file */
RiteDetails(md)
int	md ;
{
	int	fd ;
	char	t_file[50] ;

	form_f_name(s1_sth.s1_ix_file, t_file) ;
	strcat(t_file, INDX_SUFFIX) ;

	if(md == ADD) {
		if((fd = creat(t_file, CRMODE)) < 0) {
#ifdef ENGLISH
			fomer("Index Information File Creation Error");
#else
			fomer("Erreur de creation du dossier d'information d'index");
#endif
			get() ;
			return(DBH_ERR) ;
		}
	}
	else {
		if((fd = open(t_file, WRMODE)) < 0) {
#ifdef ENGLISH
			fomer("Index Information File Creation Error");
#else
			fomer("Erreur de creation du dossier d'information d'index");
#endif
			get() ;
			return(DBH_ERR) ;
		}
		lseek(fd, 0L, 0) ;
	}

	if(write(fd, (char*)&ix_info, sizeof(Ix_info)) < sizeof(Ix_info)){
#ifdef ENGLISH
		fomer("ERROR While writing Index Information on a File");
#else
		fomer("ERREUR en ecrivant l'information d'indexe sur dossier");
#endif
		get();
		return(DBH_ERR) ;
	}

	close(fd) ;

	return(NOERROR) ;
}	/* RiteDetails() */
/*-----------------------------------------------------------------------*/
/* Copy the Scrren1 & Screen 2 fields to Index Information record */
CopyToRecord()
{
	int	i;

	/* Copy form 1st screen */
	ix_info.t_source = getfileno(s1_sth.s1_in_file) ;
	ix_info.t_date = s1_sth.s1_rundate ;

	for( i = 0 ; i < No_keys ; i++) {
		ix_info.t_keys[i] = s1_sth.s1_items[i].fld_no ;
		ix_info.t_order[i] = s1_sth.s1_items[i].fld_order[0] ;
	}

	for( ; i < PAGESIZE ; i++)
		ix_info.t_keys[i] = 0 ;

	/* Copy form 2nd screen */
	for( i = 0 ; i < No_cons ; i++) {
		ix_info.t_cons[i].c_fld_no = s2_sth.s2_items[i].fld_no ;
		switch((fields+(s2_sth.s2_items[i].fld_no-1))->type) {
		case	T_CHAR :
			strcpy(ix_info.t_cons[i].c_minimum.c_char,
				s2_sth.s2_items[i].min_char) ;
			strcpy(ix_info.t_cons[i].c_maximum.c_char,
				s2_sth.s2_items[i].max_char) ;
			break ;
		case	T_SHORT :
			ix_info.t_cons[i].c_minimum.c_short = 
				s2_sth.s2_items[i].min_short ;
			ix_info.t_cons[i].c_maximum.c_short = 
				s2_sth.s2_items[i].max_short ;
			break ;
		case	T_INT :
			if(sizeof(int) == sizeof(short)) {
				ix_info.t_cons[i].c_minimum.c_short = 
					s2_sth.s2_items[i].min_short ;
				ix_info.t_cons[i].c_maximum.c_short = 
					s2_sth.s2_items[i].max_short ;
				break ;
			}
			/* else Fall thru to next case */
		case	T_LONG :
			ix_info.t_cons[i].c_minimum.c_long = 
				s2_sth.s2_items[i].min_long ;
			ix_info.t_cons[i].c_maximum.c_long = 
				s2_sth.s2_items[i].max_long ;
			break ;
		case	T_FLOAT :
			ix_info.t_cons[i].c_minimum.c_float = 
				s2_sth.s2_items[i].min_float ;
			ix_info.t_cons[i].c_maximum.c_float = 
				s2_sth.s2_items[i].max_float ;
			break ;
		case	T_DOUBLE :
			ix_info.t_cons[i].c_minimum.c_double = 
				s2_sth.s2_items[i].min_double ;
			ix_info.t_cons[i].c_maximum.c_double = 
				s2_sth.s2_items[i].max_double ;
			break ;
		}
	}

	for( ; i < PAGESIZE ; i++)
		ix_info.t_cons[i].c_fld_no = 0 ;

	return(NOERROR) ;
}	/* CopyToRecord() */
/*-------------------------------------------------------------------*/
/* Get Index Information */

static	int
GetInfo()
{
	char	t_file[50] ;
	int	fd ;

	form_f_name(s1_sth.s1_ix_file, t_file) ;
	strcat(t_file, INDX_SUFFIX) ;

	if((fd = open(t_file, RDMODE)) < 0) {
#ifdef ENGLISH
		fomen("Given Index Details File Doesn't Exist..");
#else
		fomen("Donnee les details d'index ce dossier n'existe pas..");
#endif
		get() ;
		return(ERROR) ;
	}

	if(read(fd, (char*)&ix_info, sizeof(Ix_info)) < sizeof(Ix_info)){
		close(fd) ;
#ifdef ENGLISH
		fomen("ERROR While Reading Index Information File");
#else
		fomen("ERREUR de lecture en lisant le dossier d'information d'indexe");
#endif
		get() ;
		return(DBH_ERR) ;
	}
	close(fd) ;

	return(NOERROR) ;
}	/* GetInfo() */

/*-----------------------------------------------------------------------*/
/* Copy the Index info from record to Scrren1 & Screen 2 fields & display SCR */
CopyToScreen()
{
	int	i;

	/* Copy To 1st screen */
	getflnm(ix_info.t_source, s1_sth.s1_in_file) ;

	for(No_keys = 0 ; No_keys < IXSIZE && ix_info.t_keys[No_keys] ;
								No_keys++) {
	    s1_sth.s1_items[No_keys].fld_no = ix_info.t_keys[No_keys] ;
	    strcpy(s1_sth.s1_items[No_keys].fld_name,
			(fields+(s1_sth.s1_items[No_keys].fld_no-1))->name);
	    s1_sth.s1_items[No_keys].fld_order[0] = ix_info.t_order[No_keys] ;
	}

	for( i = No_keys ; i < PAGESIZE ; i++)
		Init1_Item(i, HV_SHORT, HV_CHAR) ;

	/* Copy To 2nd screen */
	for(No_cons = 0 ; No_cons < IXSIZE && ix_info.t_cons[No_cons].c_fld_no ;
								No_cons++) {
	    s2_sth.s2_items[No_cons].fld_no = ix_info.t_cons[No_cons].c_fld_no ;
	    strcpy(s2_sth.s2_items[No_cons].fld_name,
			(fields+(s2_sth.s2_items[No_cons].fld_no-1))->name);
	    HV_cons(No_cons) ;

	    switch((fields+(s2_sth.s2_items[No_cons].fld_no-1))->type) {
	    case	T_CHAR :
	    	strcpy(s2_sth.s2_items[No_cons].min_char,
	    		ix_info.t_cons[No_cons].c_minimum.c_char) ;
	    	strcpy(s2_sth.s2_items[No_cons].max_char,
			ix_info.t_cons[No_cons].c_maximum.c_char) ;
	    	break ;
	    case	T_SHORT :
	    	s2_sth.s2_items[No_cons].min_short =
		    	ix_info.t_cons[No_cons].c_minimum.c_short ; 
	    	s2_sth.s2_items[No_cons].max_short =
	    		ix_info.t_cons[No_cons].c_maximum.c_short ; 
	    	break ;
	    case	T_INT :
	    	if(sizeof(int) == sizeof(short)) {
	    		s2_sth.s2_items[No_cons].min_short =
		    		ix_info.t_cons[No_cons].c_minimum.c_short ;
    			s2_sth.s2_items[No_cons].max_short =
	    			ix_info.t_cons[No_cons].c_maximum.c_short ;
	    		break ;
	    	}
	    	/* else Fall thru to next case */
	    case	T_LONG :
    		s2_sth.s2_items[No_cons].min_long =
		    	ix_info.t_cons[No_cons].c_minimum.c_long ;
    		s2_sth.s2_items[No_cons].max_long =
		    	ix_info.t_cons[No_cons].c_maximum.c_long ;
	    	break ;
	    case	T_FLOAT :
    		s2_sth.s2_items[No_cons].min_float =
		    	ix_info.t_cons[No_cons].c_minimum.c_float ;
    		s2_sth.s2_items[No_cons].max_float =
		    	ix_info.t_cons[No_cons].c_maximum.c_float ;
	    	break ;
	    case	T_DOUBLE :
	    	s2_sth.s2_items[No_cons].min_double =
		    	ix_info.t_cons[No_cons].c_minimum.c_double ;
	    	s2_sth.s2_items[No_cons].max_double =
	    		ix_info.t_cons[No_cons].c_maximum.c_double ;
	    	break ;
	    }
	}

	for(i = No_cons ; i < PAGESIZE ; i++)
		Init2_Item(i, HV_SHORT, HV_CHAR) ;

	sr.nextfld = 1;
	sr.endfld = 0 ;
	fomwr(CurrentScreen) ;
	ret(err_chk(&sr));

	return(NOERROR) ;
}	/* CopyToRead() */
/*------------------------------------------------------------------------*/
/* Initialize both screen data fields with High values and display the
   current screen */
MoveHighs()
{
	int	i;

	s1_sth.s1_in_file[0] = HV_CHAR ;
	s1_sth.s1_crt_dt = HV_LONG ;

	/* Move High Values to All items in both the screen */
	for(i = 0 ; i < PAGESIZE ; i++) {
		Init1_Item(i, HV_SHORT, HV_CHAR) ;
		Init2_Item(i, HV_SHORT, HV_CHAR) ;
	}

	sr.nextfld = ST_FLD ;
	sr.endfld = END_FLD - 200 ;
	fomwr(CurrentScreen);
	ret(err_chk(&sr));

	return(NOERROR);
}	/* MoveHighs() */
/*-------------------------------------------------------------------------*/
/* Initialize Given 1st screen item with either Low values or High values */
Init1_Item(item_no, t_short, t_char)
int	item_no ;
short	t_short ;
char	t_char ;
{
	s1_sth.s1_items[item_no].fld_no = t_short ;
	s1_sth.s1_items[item_no].fld_order[0] = t_char ;

	if(t_short == HV_SHORT )
		s1_sth.s1_items[item_no].fld_name[0] = t_char ;
}	/* Init1_item() */
/*-------------------------------------------------------------------------*/
/* Initialize Given 2nd screen item with either Low values or High values */
Init2_Item(item_no, t_short, t_char)
int	item_no ;
short	t_short ;
char	t_char ;
{
	s2_sth.s2_items[item_no].fld_no = t_short ;

	if(t_short == HV_SHORT ) {
		s2_sth.s2_items[item_no].fld_name[0] = t_char ;
		HV_cons(item_no) ;	/* Move High Values Constraints */
	}
}	/* Init2_Item() */
/*-------------------------------------------------------------------------*/
/* Initialize Given 2nd screen item Constraint flds with High values */
HV_cons(item_no)
int	item_no ;
{
	s2_sth.s2_items[item_no].min_char[0] = HV_CHAR ;
	s2_sth.s2_items[item_no].max_char[0] = HV_CHAR ;
	s2_sth.s2_items[item_no].min_long    = HV_LONG ;
	s2_sth.s2_items[item_no].max_long    = HV_LONG ;
	s2_sth.s2_items[item_no].min_short   = HV_SHORT ;
	s2_sth.s2_items[item_no].max_short   = HV_SHORT ;
	s2_sth.s2_items[item_no].min_double  = HV_DOUBLE ;
	s2_sth.s2_items[item_no].max_double  = HV_DOUBLE ;
	s2_sth.s2_items[item_no].min_float   = HV_FLOAT ;
	s2_sth.s2_items[item_no].max_float   = HV_FLOAT ;
}	/* HV_cons() */
/*-------------------------------------------------------------------------*/
static	int
ShowMesg()  /* shows or clears message field */
{
	sr.nextfld = END_FLD - 100;
	fomwf(CurrentScreen) ;
	ret(err_chk(&sr)) ;
	return(NOERROR) ;
}
/*-------------------- E n d   O f   P r o g r a m ---------------------*/

