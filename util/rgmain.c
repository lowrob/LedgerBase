/*-----------------------------------------------------------------------
Source Name: rgmain.c
System     : Budgetary Financial system.
Module     : General Ledger system.
Created  On: 1st DEC 89.
Created  By: T AMARENDRA.


DESCRIPTION:
	This program provides user interface for "REPORT GENERATOR" module.


MODIFICATIONS:        

Programmer     YY/MM/DD       Description of modification
~~~~~~~~~~     ~~~~~~~~       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

------------------------------------------------------------------------*/

#define	MAIN	/* Main program. This is to declare Switches */

#define	SYSTEM		"REPORT GENERATOR"	/* Sub System Name */
#define	MOD_DATE	"23-JAN-90"		/* Program Last Modified */

#include <stdio.h>
#include <cfomstrc.h>
#include <bfs_defs.h>
#include <bfs_recs.h>
#include <fld_defs.h>
#include <indxbld.h>
#include <isnames.h>

#define	TRUE	1
#define	FALSE	0

#define	FIELD		(buffer+(fields + (cur_cons->c_fld_no - 1))->offset)

#define	PART_ADDR	(rec_buff+(fields + (ix_info.t_keys[i] - 1))->offset)

#define	TEMPIX_NAME	"T_RGix"	/* Temporary Index File Name */


/* REPORT-WRITER Executable File Names */
#define	REPNAME	"repname"	/* Logical Records Creation module */
#define	FORMS	"form"		/* Formats Creation module */

/* Options */
#define	INDEX_SETUP	'1'
#define	CRT_LOGREC	'2'
#define	CRT_FORMAT	'3'
#define	GENERATE_REP	'4'

#define	SCR_NAME	"rgmain"	/* PROFOM Screen Name */

#ifdef ENGLISH
#define EXITOPT	'E'
#define DISPLAY	'D'
#define FILE_IO	'F'
#define PRINTER	'P'
#define ASCEND	'A'
#define DESEND	'D'

#define	YES	'Y'
#else
#define EXITOPT	'F'
#define DISPLAY	'A'
#define FILE_IO	'D'
#define PRINTER	'I'
#define ASCEND	'C'
#define DESEND	'D'

#define	YES	'O'
#endif

/* PROFOM Field#s */

#define	END_FLD		2000		/* Last Field in PROFOM Screen */
#define	OPTION_FLD	900		/* Option: */
#define	OPTION_START	1000		/* Hyphen Line */
#define	OPTION_END	1800		/* Report Format#: */
#define	OUTPUT_ON_FLD	1100		/* Output On: */
#define	PRINTER_FLD	1200		/* Printer#: */
#define	FILE_FLD	1300		/* File Name: */
#define	COPIES_FLD	1400		/* No of Copies: */
#define	IXFLNM_FLD	1500		/* Index File Name: */
#define	PROJECT_FLD	1600		/* Project Name: */
#define	LOGREC_FLD	1700		/* Logical Rec#: */
#define	FORMAT_FLD	1800		/* Format#: */

/* rgmain.sth - header for C structure generated by PROFOM EDITOR */

struct	s_struct	{

	char	s_pgm[11];	/* STRING XXXXXXXXXX Field 100 */
	long	s_rundt;	/* DATE DDFMMFYY Field 300 */
	char	s_option[2];	/* STRING X Field 900 */
	char	s_dummy[2];	/* STRING X Field 1000 */
	char	s_output[2];	/* STRING X Field 1100 */
	short	s_printer;	/* NUMERIC 99 Field 1200 */
	char	s_filenm[15];	/* STRING X[14] Field 1300 */
	short	s_copies;	/* NUMERIC 99 Field 1400 */
	char	s_ixflnm[11];	/* STRING X[10] Field 1500 */
	char	s_project[11];	/* STRING X[10] Field 1600 */
	short	s_log_rec;	/* NUMERIC 99 Field 1700 */
	short	s_format;	/* NUMERIC 99 Field 1800 */
	char	s_mesg[78];	/* STRING X[77] Field 1900 */
	char	s_resp[2];	/* STRING X Field 2000 */
};

static	struct	s_struct	s_sth ;		/* PROFOM Scrren Structure */

static	prev_logrec = 1 ;

static	int	result ;	/* Result of ConstrntChk() */

/* Common Variables between all modules */

/* Field definitions */
Fld_hdr	hdr ;
Field	*fields = NULL ;

Pa_rec			pa_rec ;	/* Parameter Record */
struct	stat_rec	sr ;		/* PROFOM Status Record */
Ix_info			ix_info ;	/* Index Information */
char			key_file[11];	/* Current Index Key File Name */
char			ix_file[sizeof(TEMPIX_NAME)+3];
				/* Temporary Index File Name ( 3 for term# )*/
char			e_mesg[100] ;

int	ConstrntChk() ;	/* Record Validation fn() for Temp Index Building */

/*------------------------------------------------------------*/

main(argc,argv)
int	argc;
char	*argv[];
{
	int	err;

	if(argc < 2){
#ifdef  DEVELOP
#ifdef ENGLISH  
		printf("MAIN ARGUMENTS ARE NOT PROPER\n");
#else
		printf("ARGUMENTS PRINCIPAUX INCORRECTS\n");
#endif
		printf("Usage: %s {-tTerminal Name} {-dDist#} [{-sSwitches}]\n",
			argv[0]);
#endif
		exit(1);
	}

	err = Initialize(argc,argv) ;	/* Initialize Variables , DBH
						Environment and PROFOM */
	if(err == NOERROR) err = Process();	/* Initiate Process */

	CloseProcess() ;

	if(err != NOERROR)exit(1);
	exit(0);
}	/* main() */
/*-------------------------------------------------------------------*/
/* Initialize Variables, PROFOM, DBH etc. */
static	int
Initialize(argc, argv)
int	argc ;
char	*argv[] ;
{
	int	i ;

	/*
	*	Initialize DBH Environment
	*/
	strncpy(SYS_NAME,SYSTEM,50);	/* Sub system name */
	strncpy(CHNG_DATE,MOD_DATE,10);	/* Modification Date */

	proc_switch(argc, argv, -1) ;	/* Process Switches */

	/*
	*	Initialize PROFOM & Menu Screen
	*/
	strcpy(sr.termnm,terminal);	/* Copy Terminal Name */
	fomin(&sr);
	ret(err_chk(&sr)) ;		/* Check for PROFOM Error */
	fomcf(1,1);			/* Enable Snap screen option */
	fomcf(2,0);			/* Fomwr shouldn't update dup buffers */

	ret(SetScreen()) ;

	/*
	*	Get The Parameter Record
	*/
	i = get_param(&pa_rec, BROWSE, 1, e_mesg) ;
	if(i == ERROR) {
		DispError(e_mesg);
		return(ERROR) ;
	}
	else if(i == UNDEF) {
#ifdef ENGLISH
		DispError("Parameters Are Not Setup..");
#else
		DispError("Parametres ne sont pas etablis..");
#endif
		return(ERROR) ;
	}

	key_file[0] = '\0' ;

	strcpy(ix_file, TEMPIX_NAME) ;
	get_tnum(ix_file+strlen(ix_file)) ;

	UnlinkIxFile(ix_file) ;

	return(NOERROR) ;
}	/* Initialize() */
/*-------------------------------------------------------------------*/
/* Get Option: from user and call corresponding function */
static	int
Process()
{
	int err;

	for( ; ; ){
		/* Get the Option: from the user */
		if((err = ReadOption()) != NOERROR) return(err) ;

		err = ProcOption() ;	/* Process Option */

		if(QUIT == err)		return(NOERROR) ;	/* Exit */
		if(PROFOM_ERR == err)	return(PROFOM_ERR);  /* PROFOM ERROR */
		if(DBH_ERR == err) {
			DispError(e_mesg);
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"Erreur du systeme... Iserror:",
				iserror, dberror, errno);
			DispError(e_mesg);
			return(DBH_ERR);	/* DBH ERROR */
		}
	}      /*   end of the for( ; ; )       */
}	/* Process() */
/*----------------------------------------------------------------*/
/* Close necessary files and environment before exiting program */
static	int
CloseProcess()
{
	if(fields != NULL) {
		free((char*)fields);
		fields = NULL ;
	}

	UnlinkIxFile(ix_file) ;

	/* Set terminal back to normal mode from PROFOM */
	fomcs();
	fomrt();

	close_dbh();	/* Close DBH(files) */

	return(NOERROR) ;
}	/* CloseProcess() */
/*----------------------------------------------------------------*/
/* Read the option form user */
static	int
ReadOption()
{
	/* Read Option: field to get the option */
	sr.nextfld = OPTION_FLD ;
	fomrf( (char *)&s_sth );
	ret(err_chk(&sr));	/* Check for PROFOM error */

	return(NOERROR) ;
}	/* ReadOption() */
/*----------------------------------------------------------------*/
/* Process the user selected option */
static	int
ProcOption()
{
	int	err ;

	switch (s_sth.s_option[0]) {
	case INDEX_SETUP  :			/* Index Setup */
		err = IndexSetup() ;
		break ;
	case CRT_LOGREC  :			/* Create Logical Records */
	case CRT_FORMAT  :			/* Create Report Formats */
		err = InvokeReportWriter() ;
		break ;
	case GENERATE_REP :			/* Generate Report */
		err = GenerateReport() ;
		break ;
	case EXITOPT  :			/* Exit */
		return( QUIT ) ;
	}  /*   end of the switch statement */

	if(err == PROFOM_ERR || err == DBH_ERR) return(err) ;

	ret(SetScreen()) ;

	return(NOERROR);
}	/* ProcOption() */
/*---------------------------------------------------------------*/
/* Set PROFOM Screen to this program screen */
static	int
SetScreen()
{
	/* Initialize Screen */
	strcpy(sr.scrnam,NFM_PATH);
	strcat(sr.scrnam,SCR_NAME);

	strcpy(s_sth.s_pgm,PROG_NAME);
	s_sth.s_rundt = get_date();	/* get Today's Date in YYYYMMDD format*/

	InitScreen(HV_CHAR,HV_SHORT) ;

	s_sth.s_mesg[0]   = HV_CHAR;
	s_sth.s_resp[0]   = HV_CHAR;

	ret(WriteFields(1,0)) ;

	return(NOERROR) ;
}	/* SetScreen() */
/*-----------------------------------------------------------------*/
/* Get the project name etc from user and invoke REPORT-WRITER modules */

InvokeReportWriter()
{
	int	err ;

	err = ReadReportOptions() ;
	if(err != NOERROR) return(err);

	switch(s_sth.s_option[0]){
	case	CRT_LOGREC :
		sprintf(e_mesg,"%s%s%s %s%s %s", CTOOLS_PATH, REPNAME,
			EXTN, FMT_PATH, s_sth.s_project, sr.termnm); 
		break ;
	case	CRT_FORMAT :
		sprintf(e_mesg,"%s%s%s %s%s %s %d", CTOOLS_PATH, FORMS, EXTN,
			FMT_PATH, s_sth.s_project, sr.termnm, s_sth.s_log_rec); 
	}

	fomcs() ;
	fomrt() ;
	fflush(stdout) ;

	err = system(e_mesg) ;

	fflush(stderr) ;	/* REPORT-WRITER displays errors on stderr */
	fomst();

	if(err) {
#ifdef ENGLISH
		fomen("Press Any key to Continue");
#else
		fomen("Appuyer sur une touche pour continuer");
#endif
		get() ;
	}

	return(NOERROR) ;
}	/* InvokeReportWriter() */
/*-----------------------------------------------------------------*/
/* Get the report options from user and call report priting module */

GenerateReport()
{
	int	err ;

	err = ReadReportOptions() ;
	if(err != NOERROR) return(err);

#ifndef	ORACLE
	form_f_name(ix_file,e_mesg) ;
	if(access(e_mesg,0) < 0) {	/* Temporary Index not Created yet */
#endif
#ifdef ENGLISH
		strcpy(s_sth.s_mesg,"PLEASE WAIT... Index Creation in Progress..");
#else
		strcpy(s_sth.s_mesg,"S'il vous-plait attender... Creation de l'indexe en progres..");
#endif
		ShowMesg();
		fflush(stdout) ;

		err = BuildIndex() ;
		if(err < 0) {
			DispError(e_mesg);
			return(err) ;
		}
#ifndef	ORACLE
	}
#endif

	if(s_sth.s_output[0] == DISPLAY){
		fomcs() ;
		fomrt() ;
	}
	else {
#ifdef ENGLISH
		strcpy(s_sth.s_mesg, "Please wait.... Report is Compiling");
#else
		strcpy(s_sth.s_mesg, "S'il Vous-plait attender.... Compilation de Rapport");
#endif
		ShowMesg() ;
		fflush(stdout) ;
	}

	err = PrintReport(s_sth.s_project, s_sth.s_output, s_sth.s_filenm,
		s_sth.s_copies, s_sth.s_log_rec, s_sth.s_format );

	if(s_sth.s_output[0] == DISPLAY)
		fomst() ;

	if(err < 0) {
		DispError(e_mesg);
		return(err);
	}

	return(NOERROR);
}	/* GenerateReport() */
/*-----------------------------------------------------------------*/
/* Read Report options */
static	int
ReadReportOptions()	/* get the Report Control option */
{
	int	err ;

#ifdef ENGLISH
	strcpy(s_sth.s_mesg,"Press ESC-F To Go Back To Option:");
#else
	strcpy(s_sth.s_mesg,"Appuyer sur ESC-F pour retourner a option:");
#endif
	ShowMesg();

	/* Show Default Values */
	fomca1(OUTPUT_ON_FLD, 19, 2) ;
	s_sth.s_output[0] = PRINTER ;
	fomca1(COPIES_FLD, 19, 2) ;
	s_sth.s_copies = 1 ;
	fomca1(IXFLNM_FLD, 19, 2) ;
	strcpy(s_sth.s_ixflnm, key_file) ;
	fomca1(PROJECT_FLD, 19, 2) ;

	if(key_file[0] != '\0')
		getflnm(ix_info.t_source, s_sth.s_project) ;
	else
		s_sth.s_project[0] = '\0' ;

	fomca1(LOGREC_FLD, 19, 2) ;
	s_sth.s_log_rec = prev_logrec ;
	fomca1(FORMAT_FLD, 19, 2) ;
	s_sth.s_format = 1 ;

	sr.nextfld = OPTION_START ;
	sr.endfld  = OPTION_END ;
	fomud((char*)&s_sth);
	ret(err_chk(&sr));
	InitScreen(LV_CHAR,LV_SHORT) ;	/* Set Low Values */
	sr.nextfld = OPTION_START;
	sr.endfld = OPTION_END;

	for( ; ;){


		fomrd((char*)&s_sth);
		ret(err_chk(&sr));
		if(sr.retcode == RET_VAL_CHK){
			err = Validate() ;
			if(DBH_ERR == err || PROFOM_ERR == err) return(err);
			sr.nextfld = sr.curfld ;
			continue;
		}
		if(sr.retcode == RET_USER_ESC){
			if(sr.escchar[0] == 'f' || sr.escchar[0] == 'F')
				return(RET_USER_ESC) ;
			sr.nextfld = sr.curfld ;
			continue;
		}
		/* else RET_NO_ERROR */
		break;
	}
#ifdef ENGLISH
	err = GetOption("Confirm the Selection (Y/N)?","YN");
#else
	err = GetOption("Confirmer la selection (O/N)?","ON");
#endif
	if(err == PROFOM_ERR) return(err) ;
	if(err != YES) {
		InitScreen(HV_CHAR,HV_SHORT) ;	/* Set High Values */
		ret( WriteFields(OPTION_START, OPTION_END) ) ;
		return(ERROR) ;
	}

	return(NOERROR) ;
}	/* ReadReportOptions() */
/*------------------------------------------------------------------------*/
/* Write fields on Screen for a given Range */
static	int
WriteFields(st_fld, end_fld)
int	st_fld ;
int	end_fld ;
{
	sr.nextfld = st_fld ;
	sr.endfld  = end_fld ;

	fomwr( (char*)&s_sth ) ;
	ret(err_chk(&sr));

	return(NOERROR) ;
}	/* WriteFields() */
/*-----------------------------------------------------------------------*/
/* Display message and get the option */
static	int
GetOption(msg,options)
char	*msg ;
char	*options ;
{
	int	i, j ;

	strcpy(s_sth.s_mesg, msg);
	ShowMesg() ;

	sr.nextfld = END_FLD ;
	for( ; ; ) {
		fomrf( (char*)&s_sth ) ;
		ret(err_chk(&sr)) ;

		j = strlen(options) ;
		for( i = 0 ; i < j ; i++)
			if(s_sth.s_resp[0] == options[i]) break ;
		if(i != j) break ;	/* Valid Option Selected */
#ifdef ENGLISH
		fomer("Invalid Option..");
#else
		fomer("Option invalide..");
#endif
	}
	s_sth.s_mesg[0] = HV_CHAR;
	s_sth.s_resp[0] = HV_CHAR;

	ret( WriteFields((END_FLD - 100), END_FLD) );

	return((int)(options[i])) ;
}	/* GetOption() */
/*-----------------------------------------------------------------------*/ 
static int
Validate()	/* validates given input */
{
	int	err, file_no ;

	switch(sr.curfld){
	case OUTPUT_ON_FLD:	/* Output ON */
		if(s_sth.s_output[0] != PRINTER && 
				s_sth.s_output[0] != DISPLAY &&
				s_sth.s_output[0] != FILE_IO) {
#ifdef ENGLISH
			fomer("D(isplay), P(rinter), F(ile)");
#else
			fomer("A(fficher), I(mprimante), D(ossier)");
#endif
			s_sth.s_output[0] = LV_CHAR;
			return(ERROR) ;
		}
		if(s_sth.s_output[0] == FILE_IO)
			s_sth.s_filenm[0] = LV_CHAR;
		else if(s_sth.s_output[0] == PRINTER)
			s_sth.s_copies = LV_SHORT;
		break ;
	case FILE_FLD:	/* Filename */
		if(s_sth.s_filenm[0] == '\0') {
			s_sth.s_filenm[0] = LV_CHAR ;
			return(ERROR) ;
		}
		break;
	case IXFLNM_FLD:	/* Index File Name: */
		if(GetIndxInfo(s_sth.s_ixflnm) < 0) {
			s_sth.s_ixflnm[0] = LV_CHAR ;
			return(ERROR) ;
		}
		/* Check the Security */
		err = CheckAccess((int)ix_info.t_source, BROWSE, e_mesg) ;
		if(err == DBH_ERR) return(err) ;
		if(err < 0) {
			fomer(e_mesg) ;
			s_sth.s_ixflnm[0] = LV_CHAR ;
			return(ERROR) ;
		}
		getflnm(ix_info.t_source, s_sth.s_project) ;
		if(strcmp(key_file, s_sth.s_ixflnm)) {
			UnlinkIxFile(ix_file) ;

			if(fields != NULL) {
				free((char*)fields);
				fields = NULL ;
			}
			if( GetFields(s_sth.s_project,&hdr,&fields,e_mesg) ==
								ERROR) {
				DispError(e_mesg) ;
				return(DBH_ERR) ;
			}

		}
		strcpy(key_file, s_sth.s_ixflnm) ;
		break ;
	case PROJECT_FLD :	/* Project Name: */


		/* Report Project name should be one of the DBH File name */

		if((file_no = getfileno(s_sth.s_project)) < 0) {
#ifdef ENGLISH
			fomer("Invalid Project Name..");
#else
			fomer("Nom de projet invalide..");
#endif
			s_sth.s_project[0] = LV_CHAR ;
			return(ERROR);
		}

		/* Check the Security */
		err = CheckAccess(file_no, BROWSE, e_mesg) ;
		if(err == DBH_ERR) return(err) ;
		if(err < 0) {
			fomer(e_mesg) ;
			s_sth.s_project[0] = LV_CHAR ;
			return(ERROR) ;
		}
		break ;
	default :
#ifdef ENGLISH
		sprintf(e_mesg,"No Validity Check For Field#  %d",sr.curfld);
#else
		sprintf(e_mesg,"Pas de controle de validite pour le Champ# %d",sr.curfld);
#endif
		fomen(e_mesg);
		get();
	}
	sr.nextfld = sr.curfld;
	return(NOERROR);
}
/*-------------------------------------------------------------------*/
/* Open the user given Index info file and read the info */

static	int
GetIndxInfo(userfile)
char	*userfile ;
{
	char	t_file[50] ;
	int	fd ;

	form_f_name(userfile, t_file) ;
	strcat(t_file, INDX_SUFFIX) ;

	if((fd = open(t_file, RDMODE)) < 0) {
#ifdef ENGLISH
		fomer("This Index File Doesn't Exists...");
#else
		fomer("Ce dossier indexe n'existe pas...");
#endif
		return(ERROR) ;
	}

	if(read(fd, (char*)&ix_info, sizeof(Ix_info)) < sizeof(Ix_info)){
		fomer("ERROR While Reading Index Information File");
		close(fd) ;
		return(ERROR) ;
	}
	close(fd) ;

	return(NOERROR) ;
}	/* GetIndxInfo() */
/*------------------------------------------------------*/
/* move HVs to report options & display the screen */
static int
InitScreen(t_char,t_short)
char	t_char ;
short	t_short ;
{
	s_sth.s_printer   = HV_SHORT ;
	s_sth.s_filenm[0] = HV_CHAR ;
	s_sth.s_copies    = HV_SHORT ;

	s_sth.s_project[0] = t_char ;

	if(t_short == LV_SHORT) {
		if(s_sth.s_option[0] == GENERATE_REP ||
				s_sth.s_option[0] == CRT_FORMAT)
			s_sth.s_log_rec   = LV_SHORT ;
		else
			s_sth.s_log_rec   = HV_SHORT ;
		if(s_sth.s_option[0] == GENERATE_REP) {
			s_sth.s_output[0] = LV_CHAR ;
			s_sth.s_ixflnm[0] = LV_CHAR ;
			s_sth.s_format    = LV_SHORT ;
		}
		else {
			s_sth.s_output[0] = HV_CHAR ;
			s_sth.s_ixflnm[0] = HV_CHAR ;
			s_sth.s_format    = HV_SHORT ;
		}
		s_sth.s_dummy[0] = ' ' ;
	}

	if(t_short == HV_SHORT) {
		s_sth.s_output[0] = HV_CHAR ;
		s_sth.s_ixflnm[0] = HV_CHAR ;
		s_sth.s_log_rec   = HV_SHORT ;
		s_sth.s_format    = HV_SHORT ;
		s_sth.s_dummy[0]  = HV_CHAR ;
	}

	return(NOERROR);
}
/*-------------------------------------------------------------------------*/
static	int
DispError(s)	/* show ERROR and wait */
char *s;
{
	strcpy(s_sth.s_mesg,s);
	ShowMesg();
#ifdef ENGLISH
	fomen("Type any key to continue");
#else
	fomen("Appuyer sur une touche pour continuer");
#endif
	get();
	s_sth.s_mesg[0] = HV_CHAR ;
	ShowMesg();
	return(NOERROR);
}
/*-----------------------------------------------------------*/
static int	/* Display message field */
ShowMesg()
{
	sr.nextfld = END_FLD - 100;
	fomwf((char*)&s_sth);
	ret(err_chk(&sr)) ;

	return(NOERROR) ;
}	/* ShowMesg() */
/*---------------------------------------------------------*/
/* Set the data record start key to LOW Values for the given index key */
SetKey(rec_buff)
char	*rec_buff ;
{
	int	i ;

	for( i = 0 ; i < IXSIZE && ix_info.t_keys[i] ; i++ ){
		switch((fields + (ix_info.t_keys[i] - 1))->type) {
		case	T_CHAR :
			if(ix_info.t_order[i] == DESEND)
				*(PART_ADDR) = HV_CHAR ;
			else
				*(PART_ADDR) = LV_CHAR ;
			break ;
		case	T_SHORT :
			if(ix_info.t_order[i] == DESEND)
				*((short *)(PART_ADDR)) = HV_SHORT ;
			else
				*((short *)(PART_ADDR)) = LV_SHORT ;
			break ;
		case	T_INT :
			if(sizeof(int) == sizeof(short)) {
				if(ix_info.t_order[i] == DESEND)
					*((short *)(PART_ADDR)) = HV_SHORT ;
				else
					*((short *)(PART_ADDR)) = LV_SHORT ;
				break ;
			}
			/* Fall thru to next switch */
		case	T_LONG :
			if(ix_info.t_order[i] == DESEND)
				*((long *)(PART_ADDR)) = HV_LONG ;
			else
				*((long *)(PART_ADDR)) = LV_LONG ;
			break ;
		case	T_FLOAT :
			if(ix_info.t_order[i] == DESEND)
				*((float *)(PART_ADDR)) = HV_FLOAT ;
			else
				*((float *)(PART_ADDR)) = LV_FLOAT ;
			break ;
		case	T_DOUBLE :
			if(ix_info.t_order[i] == DESEND)
				*((double *)(PART_ADDR)) = HV_DOUBLE ;
			else
				*((double *)(PART_ADDR)) = LV_DOUBLE ;
			break ;
		}
	}

	return(NOERROR) ;
}	/* SetKey() */
/*-----------------------------------------------------------------------
/*
*  Build the Index Parts array and create Temporay Index File.
*/

BuildIndex() 
{
	int	keysarray[IXSIZE * 4 + 1] ;
	int	*k_array ;
	int 	i ;

	/*
	*	Build the Keys array
	*/

	k_array = keysarray ;
	k_array++ ;

	for( i = 0 ; i < IXSIZE && ix_info.t_keys[i] ; i++ ){
		switch((fields + (ix_info.t_keys[i] - 1))->type) {
		case	T_CHAR :
			*(k_array++) = CHAR ;
			*(k_array++) = (fields + (ix_info.t_keys[i]-1))->len ;
			break ;
		case	T_SHORT :
			*(k_array++) = SHORT ;
			*(k_array++) = 1 ;
			break ;
		case	T_INT :
			if(sizeof(int) == sizeof(short)) {
				*(k_array++) = SHORT ;
				*(k_array++) = 1 ;
				break ;
			}
			/* Fall thru to next switch */
		case	T_LONG :
			*(k_array++) = LONG ;
			*(k_array++) = 1 ;
			break ;
		case	T_FLOAT :
			*(k_array++) = FLOAT ;
			*(k_array++) = 1 ;
			break ;
		case	T_DOUBLE :
			*(k_array++) = DOUBLE ;
			*(k_array++) = 1 ;
			break ;
		}
		*(k_array++) = (fields + (ix_info.t_keys[i] - 1))->offset ;
		*(k_array++) = (ix_info.t_order[i] == DESEND) ? DESCND : ASCND ;
	}
	keysarray[0] = i ;	/* NO of Parts */

	/*
	*	Sort Constraints on fld#. This is required to apply OR
	*	condition, when more than one constraint is given on one
	*	field.
	*/
	SortConstrnts() ;

	/* NULL is dummy ptr to a record validating fn() that returns integer */
	i = CrtTmpIndx( ix_info.t_source, TMPINDX_1, keysarray, ix_file,
						ConstrntChk, e_mesg );
	if( i < 0 ) return(i);

	return(i) ;
}
/*------------------------------------------------------------------*/
/* Check whether data record is in within user given constraints. That is
   apply AND operator between all constraints, but if any field has more than
   one constraint, apply OR operator between those constarints */
#ifndef	ORACLE
static	int
#endif
ConstrntChk(buffer)
char	*buffer ;	/* Data Buffer */
{
	int	i ;
	int	len ;
	short	s_value ;
	long	l_value ;
	float	f_value ;
	double	d_value ;
	C_fld	*cur_cons ;
	int	cur_result ;

	result = TRUE ;

	for( i = 0 ; i < IXSIZE && (cur_cons = &ix_info.t_cons[i])->c_fld_no ;
									i++) {
		switch((fields+(cur_cons->c_fld_no-1))->type) {
		case	T_CHAR :
			len = (fields + (cur_cons->c_fld_no-1))->len ;
			/* Constraint length */
			if(len > sizeof(((C_val *)NULL)->c_char))
			    len = sizeof(((C_val *)NULL)->c_char) ;
			if(strncmp(FIELD,cur_cons->c_minimum.c_char,len) < 0 ||
			    strncmp(FIELD,cur_cons->c_maximum.c_char,len) > 0)
				cur_result = FALSE ;
			else
				cur_result = TRUE ;
			break ;
		case	T_SHORT :
			/* Copy to temporary variable and compare. Straight
			   comparision may fail because of alignment */
			scpy((char*)&s_value, FIELD, sizeof(short)) ;
			if(s_value < cur_cons->c_minimum.c_short ||
					s_value > cur_cons->c_maximum.c_short)
				cur_result = FALSE ;
			else
				cur_result = TRUE ;
			break ;
		case	T_INT :
			if(sizeof(int) == sizeof(short)) {
			    /* Copy to temporary variable and compare. Straight
			       comparision may fail because of alignment */
			    scpy((char*)&s_value, FIELD, sizeof(short)) ;
			    if(s_value < cur_cons->c_minimum.c_short ||
					s_value > cur_cons->c_maximum.c_short)
				cur_result = FALSE ;
			    else
				cur_result = TRUE ;
			    break ;
			}
			/* Fall thru to next switch */
		case	T_LONG :
			/* Copy to temporary variable and compare. Straight
			   comparision may fail because of alignment */
			scpy((char*)&l_value, FIELD, sizeof(long)) ;
			if(l_value < cur_cons->c_minimum.c_long ||
					l_value > cur_cons->c_maximum.c_long)
				cur_result = FALSE ;
			else
				cur_result = TRUE ;
			break ;
		case	T_FLOAT :
			/* Copy to temporary variable and compare. Straight
			   comparision may fail because of alignment */
			scpy((char*)&f_value, FIELD, sizeof(float)) ;
			if(f_value < cur_cons->c_minimum.c_float ||
					f_value > cur_cons->c_maximum.c_float)
				cur_result = FALSE ;
			else
				cur_result = TRUE ;
			break ;
		case	T_DOUBLE :
			/* Copy to temporary variable and compare. Straight
			   comparision may fail because of alignment */
			scpy((char*)&d_value, FIELD, sizeof(double)) ;
			if(d_value < cur_cons->c_minimum.c_double ||
					d_value > cur_cons->c_maximum.c_double)
				cur_result = FALSE ;
			else
				cur_result = TRUE ;
			break ;
		}
		/* Push the current_result to result */
		if(PushResult(i, (int)cur_cons->c_fld_no, cur_result) == ERROR)
			return(ERROR) ;
	}	/* For () */

	if(result == FALSE) return(ERROR) ;
	return(0) ;
}
/*--------------------------------------------------------------*/
/* Push the current_result to result */
static	int
PushResult(c_no, fld_no, cur_result)
int	c_no ;		/* Constraint# (0 - n-1) */
int	fld_no ;	/* Field# 1-n */
int	cur_result ;	/* Current Constraint Result */
{
	static	int	prev_fld ;

	if(c_no) {	/* Not first constraint */
		/* When field is changed, if the prev field result is FALSE
		   return ERROR */
		if(fld_no != prev_fld) {
			if(result == FALSE) return(ERROR) ;
		}
		else	/* Same Field */
			if(result == TRUE) return(NOERROR) ;
	}

	/* Push the currrent Result */
	prev_fld = fld_no ;
	result   = cur_result ;

	return(NOERROR) ;
}	/* PushResult() */
/*--------------------------------------------------------------*/
/* Sort constraints on field# */
static	int
SortConstrnts()
{
	C_fld	*constrnt, *cur_cons, swap_cons ;
	int	i, j ;

	for( i = 0 ; i < IXSIZE && (cur_cons = &ix_info.t_cons[i])->c_fld_no ;
									i++) {
	    constrnt = cur_cons ;
	    for( j = i+1, constrnt++ ; j < IXSIZE && constrnt->c_fld_no ;
					j++, constrnt++ )
		if(constrnt->c_fld_no < cur_cons->c_fld_no) {
			scpy((char*)&swap_cons,(char*)cur_cons,sizeof(C_fld));
			scpy((char*)cur_cons,(char*)constrnt,sizeof(C_fld));
			scpy((char*)constrnt,(char*)&swap_cons,sizeof(C_fld));
		}
	}

	return(NOERROR) ;
}	/* SortConstrnts() */
/*--------------------------------------------------------------*/
/* Unlink the Given temporay ix file */
UnlinkIxFile(tix_file)
char	*tix_file ;
{
#ifndef	ORACLE
	char	indx_flnm[50] ;

	form_f_name(tix_file, indx_flnm);

	if ( access(indx_flnm,0) >= 0 ) 
		unlink(indx_flnm) ;		/* Unlink Data File */

	strcat(indx_flnm, ".IX");
	if ( access(indx_flnm,0) >= 0 ) 
		unlink(indx_flnm) ;		/* Unlink Index File */
#endif

	return(NOERROR);
}	/* UnlinkIxFile() */
/*-------------------- E n d   O f   P r o g r a m ---------------------*/

