/*-----------------------------------------------------------------------
Source Name: chgglkey.c
System     : Genral Ledger.
Created  On: 22-Jan-95.
Created  By: L.Robichaud

DESCRIPTION:
	Program to allow changes to the keys. This program will ask the user 
	for the Key to be changed, then the old value and the new value.
	Then the G/L master file will be read from begining to end searching
	for all occurances and changeing them.

MODIFICATIONS:        

Programmer     YY/MM/DD         Description of modification

------------------------------------------------------------------------*/
#define MAIN            /* Main program. This is to declare Switches */
#define MAINFL          GLMAST	/* main file used */

#define SYSTEM          "GENERAL LEDGER"   /* Sub System Name */
#define MOD_DATE        "22-JAN-95"        /* Progran Last Modified */

#include <stdio.h>
#include <cfomstrc.h>
#include <bfs_defs.h>
#include <bfs_recs.h>

#define EXIT 12
#define NBROFKEY	12 /* Number of G/L Keys */

/* User Interface define constants */
#define INQUIRE         'I'
#define NEXT            'N'
#define PREV            'P'
#define EXITOPT         'E'
#define CHANGE		'C'

#define YES             'Y'
#define NO              'N'
#define CANCEL          'C'

/* PROFOM Releted declarations */

#define SCR_NAME        "chgglkey"        /* PROFOM screen Name */

/* Field PROFOM numbers */

/* HDR Fields */
#define FN_FLD          400     /* Fn: */
#define CHGFUND_FLD	600	/* Fund to be processed for change */
#define CHGKEY_FLD	700	/* Key to change field */
#define OLDVAL_FLD	800	/* Old Value in the key to look for */
#define NEWVAL_FLD	900	/* New value for key to be written to file */
#define DISPST_FLD	1000	/* Display start field to show record values*/
#define ACCOUNT_FLD	1100	/* Account number field */
#define RECCOD_FLD	1200	/* Record code field, part of read */
#define DISPEND_FLD	2500	/* End of display for record */

/* Message/Response Fields */
#define MESSAGE_FLD     2600
#define RESP_FLD        2700


/* chgglkey.sth - header for C structure generated by PROFOM EDITOR */

typedef struct	{

	char	s_pgm[11];	/* field 100 Program name */
	long	s_rundate;	/* field 300 Date on the top of screen */
	char	s_fn[2];	/* field 400 function */
	short	s_chgfund;	/* field 600 fund to be processed */
	short	s_chgkey;	/* field 700 the key to be changed */
	long	s_oldval;	/* field 800 the old value of the key */
	long	s_newval;	/* field 900 the new value for the key */
	short	s_fund;		/* field 1000 fund */
	char	s_accno[19];	/* field 1100 account number */
	short	s_reccod;	/* field 1200 record code */
	char	s_desc[49];	/* field 1300  account description */
	long	s_keys[12];	/* field 1400-2500 the account keys */
	char	s_mesg[78];	/* field 2600 */
	char	s_resp[2];	/* field 2700 */
} s_struct;


double  D_Roundoff();

static  s_struct  s_sth;        /* PROFOM Screen Structure */
static  struct  stat_rec  sr;           /* PROFOM status rec */

static  Pa_rec          pa_rec ;        /* Parameter Record */
static	Gl_rec		gl_rec;		/* The G/L master file */

static  char    e_mesg[100];            /* dbh will return err msg in this */

int     Validation() ;


main(argc,argv)
int argc;
char *argv[];
{
	int     retval;

	retval = Initialize(argc,argv); /* Initialization routine */

	if (retval == NOERROR) 
		retval = Process();

	CloseRtn();                     /* return to menu */
	if (retval != NOERROR) exit(-1);
	exit(0);
}

/*-------------------------------------------------------------------*/
/* Initialize PROFOM */

Initialize(argc, argv)
int     argc ;
char    *argv[] ;
{
	int     err ;

	/*
	*       Initialize DBH Environment
	*/
	strncpy(SYS_NAME,SYSTEM,50);    /* Sub system name */
	strncpy(CHNG_DATE,MOD_DATE,10); /* Modification Date */

	proc_switch(argc, argv, MAINFL) ;       /* Process Switches */

	/*
	*       Initialize PROFOM & Screen
	*/
	strcpy(sr.termnm,terminal);     /* Copy Terminal Name */
	fomin(&sr);
	ret(err_chk(&sr)) ;             /* Check for PROFOM Error */
	fomcf(1,1);                     /* Enable Snap screen option */

	err = InitScreen() ;            /* Initialize Screen */
	if(NOERROR != err) return(err) ;

	/*
	*       Get The Parameter Record
	*/
	err = get_param(&pa_rec, BROWSE, 1, e_mesg) ;
	if(err == ERROR) {
		DispError(e_mesg);
		return(ERROR) ;
	}
	else if(err == UNDEF) {
#ifdef ENGLISH
		DispError("Parameters Are Not Set Up ...");
#else
		DispError("Parametres ne sont pas etablis... ");
#endif
		return(ERROR) ;
	}


	return(NOERROR) ;
}       /* Initialize() */

/*--------------------------------------------------------------------------*/
/* Close nessary files and environment before exiting program               */

CloseRtn() 
{
	/* Set terminal back to normal mode from PROFOM */
	fomcs();
	fomrt();

	close_dbh();    /* Close files */

	return(NOERROR);
}       /* CloseRtn() */
/*----------------------------------------------------------------*/
/* Initialize screen before going to process options */

InitScreen()
{
	int     err ;

	/* move screen name to Profom status structure */
	strcpy(sr.scrnam,NFM_PATH);
	strcat(sr.scrnam,SCR_NAME) ;

	strcpy(s_sth.s_pgm,PROG_NAME);

	s_sth.s_rundate = get_date();   /* get Today's Date in YYYYMMDD format*/
	s_sth.s_mesg[0] = HV_CHAR ;
	s_sth.s_resp[0] = HV_CHAR ;

	/* Move High Values to data fields and Display the screen */
	err = ClearInputFlds() ;
	if(NOERROR != err) return(err) ;

	err = ClearDispFld() ;
	if(NOERROR != err) return(err) ;

	return(NOERROR) ;
}       /* InitScreen() */

/*-------------------------------------------------------------------*/
/* Get Option from user and call corresponding function */

Process()
{
	int err;

	for( ; ; ){

		/* Get the Fn: option from the user */
		if((err = ReadFunction()) != NOERROR) return(err) ;

		err = ProcFunction() ;  /* Process Function */

		if(QUIT == err)         return(NOERROR) ;    /* Exit */
		if(NOACCESS == err)     fomen(e_mesg);       /* security */
		if(PROFOM_ERR == err)   return(PROFOM_ERR);  /* PROFOM ERROR */
		if(DBH_ERR == err) {
			DispError(e_mesg);
#ifdef ENGLISH
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"System Error... Iserror:",
				iserror, dberror, errno);
#else
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"Erreur du systeme... Iserror:",
				iserror, dberror, errno);
#endif
			DispError(e_mesg);
			return(DBH_ERR); /* DBH ERROR */
		}
	}      /*   end of the for( ; ; )       */
}       /* Process() */
/*----------------------------------------------------------------*/
/* Display the Function (Fn:) options and get the option from the user */

ReadFunction()
{
	/* Display Fn: options */

	fomer("I(nquire), N(ext), P(rev), C(hange), E(xit)");
	
	/* Read Fn: field to get the option */
	sr.nextfld = FN_FLD ;
	fomrf( (char *)&s_sth );
	ret(err_chk(&sr));      /* Check for PROFOM error */

	return(NOERROR) ;
}       /* ReadFunction() */
/*----------------------------------------------------------------*/
/* Process the user selected Fn: option */

ProcFunction()
{
	int retval;

	switch (s_sth.s_fn[0]) {
	case CHANGE :                  /* CHANGE */
		CHKACC(retval,UPDATE,e_mesg);
		return( ChangeKey() ) ;
	case INQUIRE  :         
		CHKACC(retval,BROWSE,e_mesg);
		return( Inquire() ) ;
	case NEXT  :                    
		CHKACC(retval,BROWSE,e_mesg);
		return( GetDetails(FORWARD) ) ;
	case PREV  :            
		CHKACC(retval,BROWSE,e_mesg);
		return( GetDetails(BACKWARD) ) ;
	case EXITOPT  :                 /* Exit */
		return( QUIT ) ;
	}  /*   end of the switch statement */

	return(retval);
}       /* ProcFunction() */
/*----------------------------------------------------------------------*/
/* Get the information needed to make changes and make changes */

ChangeKey()
{
	int     err;
	int	change=0;

	SetDupBuffers( CHGFUND_FLD, NEWVAL_FLD, 2 );

	s_sth.s_chgfund = LV_SHORT;
	s_sth.s_chgkey = LV_SHORT;
	s_sth.s_oldval = LV_LONG;
	s_sth.s_newval = LV_LONG;

	/* Get reference number */
	err = ReadFields(CHGFUND_FLD, NEWVAL_FLD,
		Validation, 0) ;
	if(PROFOM_ERR == err || DBH_ERR == err) return(err) ;
	if(RET_USER_ESC == err) { /* ESC-F */
		s_sth.s_mesg[0] = HV_CHAR ;
		ShowMesg() ;
		return(NOERROR) ;
	}

	fomen("Get Everyone out of lbase to avoid Record locks");

	err = GetOption("Perform Mass Change Y/N","YN");
	if(err==NO)
		return(NOERROR);

	/* Initialize read to first of file */
	gl_rec.funds = s_sth.s_chgfund;
	gl_rec.accno[0] = LV_CHAR;
	gl_rec.reccod = LV_SHORT;
	flg_reset(GLMAST);

	/* Performing mass change */

	for(;;){
		
		get_n_gl(&gl_rec, BROWSE, 0, FORWARD, e_mesg);
		if(err == EFL)
			break;

		if(err < 0){
			DispError(e_mesg);
			return(err);
		}

		/* Make sure fund has not changed */
		if(gl_rec.funds != s_sth.s_chgfund)
			break;

		/* if the key is not equal to the old value, continue */
		if(gl_rec.keys[s_sth.s_chgkey-1] != s_sth.s_oldval)
			continue;

		/* Get the record in update mode to allow change */
		err = get_gl(&gl_rec, UPDATE, 0, e_mesg);
		if(err < 0) {
			DispError(e_mesg);
			roll_back(e_mesg);
			return(DBH_ERR);
		}

		/* Make physical change to G/L key and update file */
		gl_rec.keys[s_sth.s_chgkey-1] = s_sth.s_newval;

		err = put_gl(&gl_rec, UPDATE, e_mesg);
		if(err < 0) {
			DispError(e_mesg);
			roll_back(e_mesg);
			return(DBH_ERR);
		}
		err = commit(e_mesg);
		if(err < 0) {
			DispError(e_mesg);
			roll_back(e_mesg);
			return(DBH_ERR);
		}

		change++;
		sprintf(e_mesg,"Total records changed: %d",change);
		fomen(e_mesg);
	}

	sprintf(e_mesg,
	    "Process complete, records changed: %d ...Press Any Key",change);
	fomen(e_mesg);
	get();

	return(NOERROR);
}       /* ChangeInvoice() */
/*-----------------------------------------------------------------------*/
Inquire()
{
	int     retval;


	s_sth.s_fund = LV_SHORT;
	s_sth.s_accno[0] = LV_CHAR;
	s_sth.s_reccod = LV_SHORT;

	/* Get reference number */
	retval = ReadFields(DISPST_FLD, RECCOD_FLD,
		Validation, 0) ;
	if(PROFOM_ERR == retval || DBH_ERR == retval) return(retval) ;
	if(RET_USER_ESC == retval) { /* ESC-F */
		s_sth.s_mesg[0] = HV_CHAR ;
		ShowMesg() ;
		return(NOERROR) ;
	}

	retval = GetDetails(FORWARD) ;
	if(PROFOM_ERR == retval || DBH_ERR == retval) return(retval) ;
	if(retval < 0 || CANCEL == retval) {
		roll_back(e_mesg) ;     /* Unlock the locked Records */
		return(ClearInputFlds()) ; /* Clear the Screen */
	}

	return(NOERROR) ;
}       /* Inquire() */
/*-----------------------------------------------------------------------*/
/* Get Item Details.                                                     */
GetDetails(dir)
int	dir; /* Direction of the get next */
{
	int err;

	gl_rec.funds = s_sth.s_fund;
	strcpy(gl_rec.accno,s_sth.s_accno);
	gl_rec.reccod = s_sth.s_reccod;

	/* Check if a Next was done without anything in the read fields */
	if(s_sth.s_fund == HV_SHORT){
		gl_rec.funds = 0;
		gl_rec.accno[0] = LV_CHAR;
		gl_rec.reccod = 0;
	}
	else{
		if(dir == FORWARD)
			gl_rec.reccod ++;
		else
			gl_rec.reccod --;
	}

	flg_reset(GLMAST);

	err = get_n_gl( &gl_rec, BROWSE, 0, dir, e_mesg);
	if(ERROR == err) return(DBH_ERR) ;
	if(EFL == err){
		DispError("No More Records...");
		return(NOERROR); 
	}

	seq_over(GLMAST) ;

	err = FillScreen();
	if(err < 0) return(err);

	return(NOERROR);
}       /* GetDetails() */
/*-----------------------------------------------------------------------*/
/* Read the PROFOM Screen for a given Range of fields */
static
ReadFields(st_fld, end_fld, Validate, mode)
int	st_fld ;
int	end_fld;
int	(*Validate)() ;
int	mode ;	/* ADD or UPDATE. This is required only when reading item */
{
	int	err ;

	sr.nextfld = st_fld ;
	sr.endfld  = end_fld;
	for( ; ;){
		fomrd( (char *)&s_sth );
		ret(err_chk(&sr));

		if(sr.retcode == RET_VAL_CHK){
			err = (*Validate)(mode) ;
			if(DBH_ERR == err || PROFOM_ERR == err) return(err);
			sr.nextfld = sr.curfld ;
			continue;
		}
		if(sr.retcode == RET_USER_ESC){
			if(sr.escchar[0] == 'f' || sr.escchar[0] == 'F')
				return(RET_USER_ESC) ;
			continue;
		}
		/* else RET_NO_ERROR */
		break;
	}

	return(NOERROR) ;
}
/*------------------------------------------------------------*/
/* Write fields on Screen for a given Range */
static
WriteFields(st_fld, end_fld)
int     st_fld ;
int     end_fld ;
{
	sr.nextfld = st_fld ;
	sr.endfld  = end_fld ;

	fomwr( (char *)&s_sth );
	ret(err_chk(&sr));

	return(NOERROR) ;
}       /* WriteFields() */
/*----------------------------------------------------------------*/
/* Set Duplication buffers for fields                             */
SetDupBuffers( firstfld, lastfld, value )
int     firstfld, lastfld;      /* field numbers range */
int     value;                  /* ENABLE or DISABLE */
{
	int i;

	for( i=firstfld; i<=lastfld; i+=100 )
		fomca1( i, 19, value);
	if( value==0 )
		return(0);
	sr.nextfld = firstfld;
	sr.endfld = lastfld;
	fomud( (char *)&s_sth );
	ret( err_chk(&sr) );

	return( 0 );
}
/*----------------------------------------------------------------*/
/* Validation function() for Key and Header fields when PROFOM returns
  RET_VAL_CHK */
static
Validation()
{
	int     err ;

	switch(sr.curfld){
	case	CHGKEY_FLD:

			if(s_sth.s_chgkey > NBROFKEY || s_sth.s_chgkey < 1){
				sprintf(e_mesg,"Value must be a key number");
				fomen(e_mesg);
			}
			break;

	case    ACCOUNT_FLD:       /* account number*/

			Right_Justify_Numeric(s_sth.s_accno,
					sizeof(s_sth.s_accno)-1);
			break;

	default :
#ifdef ENGLISH
		sprintf(e_mesg,"No Validity Check For Field#  %d",sr.curfld);
#else
		sprintf(e_mesg,"Pas de controle de validite pour le Champ#  %d",sr.curfld);
#endif
		fomen(e_mesg);
		get();
		return(ERROR) ;
	}       /* Switch sr.curfld */

	return(NOERROR) ;
}       /* Validation() */
/*----------------------------------------------------------------*/
/* Display message and get the option */
static
GetOption(msg,options)
char    *msg ;
char    *options ;
{
	int     i, j ;

	strcpy(s_sth.s_mesg,msg);
	ShowMesg() ;

	sr.nextfld = RESP_FLD ;
	for( ; ; ) {
		fomrf( (char *)&s_sth ) ;
		ret(err_chk(&sr)) ;

		j = strlen(options) ;
		for( i = 0 ; i < j ; i++)
			if(s_sth.s_resp[0] == options[i]) break ;
		if(i != j) break ;      /* Valid Option Selected */
#ifdef ENGLISH
		fomer("Invalid Option..");
#else
		fomer("Option invalide..");
#endif
	}

	s_sth.s_mesg[0] = HV_CHAR ;
	s_sth.s_resp[0] = HV_CHAR ;
	
	ret( WriteFields(RESP_FLD -100, RESP_FLD) );

	return((int)(options[i])) ;
}       /* GetOption() */
/*-----------------------------------------------------------*/
/* Move High values to the input data fields to clear the screen */

ClearInputFlds()
{

	/* Move High Values to Hedaer part */
	s_sth.s_chgfund = HV_SHORT;
	s_sth.s_chgkey = HV_SHORT;
	s_sth.s_oldval = HV_LONG;
	s_sth.s_newval = HV_LONG;

	ret( WriteFields(CHGFUND_FLD, NEWVAL_FLD) );

	return(NOERROR);
}
/*-----------------------------------------------------------*/
/* Move High values to all record display fields to clear the screen */

ClearDispFld()
{
	int	i;

	/* Move High Values to Lower part of screen */
	s_sth.s_fund = HV_SHORT;
	s_sth.s_accno[0] = HV_CHAR;
	s_sth.s_reccod = HV_SHORT;
	s_sth.s_desc[0] = HV_CHAR;
	for(i=0; i < NBROFKEY; i++)
		s_sth.s_keys[i] = HV_LONG;

	ret( WriteFields(DISPST_FLD, DISPEND_FLD) );

	return(NOERROR);
}
/*-----------------------------------------------------------*/
/* This routine is designed to populate the screen with the values from file*/
FillScreen()
{

	int	i;

	/* Fill screen vaibles with file contents */
	s_sth.s_fund = gl_rec.funds;
	strcpy(s_sth.s_accno, gl_rec.accno);
	s_sth.s_reccod = gl_rec.reccod;
	strcpy(s_sth.s_desc, gl_rec.desc);
	for(i=0; i < NBROFKEY; i++)
		s_sth.s_keys[i] = gl_rec.keys[i];

	ret( WriteFields(DISPST_FLD, DISPEND_FLD) );

	return(NOERROR);
}
/*-------------------------------------------------------------------------*/

ShowMesg()  /* shows or clears message field */
{
	sr.nextfld = RESP_FLD - 100;
	fomwf( (char *)&s_sth ) ;
}
