/******************************************************************************
		Sourcename    : apreputl.c
		System        : Budgetary Financial system.
		Module        : accounts payable reports
		Created on    : 89-11-24
		Created  By   : J PRESCOTT.
		Cobol sources : 

HISTORY:
 Date           Programmer     Description of modification
____/__/__      __________     ___________________________

Calls for the user:	( Check for the value returned: -1 on error )

int	AddMenuItem( char *name, int (* fnptr)() );
int	Initialize( char *terminalname , char *heading );
int	Process();
int	DisplayMessage( char * );
int	GetResponse( char * );
int	HideMessage();
int	GetOutputon( char * );
int	GetFilename( char * );
int	GetPrinter( short * );
int	GetNbrCopies( short * );
int 	GetCurrDate( long * );
int 	GetNextDate( long * );
int	GetFollDate( long * );
int	GetFundRange( short *, short *);
int	GetSCodeRange( char *, char * );
int	GetTrefnoRange( char *, char *);
int	GetTransDateRange( long *, long *);

int	Confirm();		returns 1 for Yes, and 0 for anyother input

The programmer should make calls for appending menuitems in the following order.
		AddMenuItem( menuname, functionpointer );( max. 9 options )
		Initialize( screenheading );
		Process();	 for menu item selection
		{	Any "Get...." calls }
		Confirm();	It clears the screen and resets terminal
A maximum of 9 menuitems can be added, excluding one for Quitting the screen
which is automatically appended by the system.

For all the calls starting with "Get", user can pass any default values by 
initialising the corresponding variables before passing their address(es)
as parameters. The program doesnot do any validation except that it disallows
user's entry of end value ( range limit ) if it is smaller than starting value.

The last call should be "Confirm()",  which clears the profom screen and resets
the terminal characteristics

******************************************************************************/
#include <stdio.h>

#include <bfs_defs.h>
#include <cfomstrc.h>

#define SCREEN_NAME	"aprep"
#define EXIT		12
#define PATH_FILE_SIZE	50
#define STARTLINENUM	17
#define LOW 		-1
#define HIGH 		 1
#define HL_CHAR(VAL)	VAL==HIGH ? HV_CHAR : LV_CHAR
#define ESC_F		sr.retcode==RET_USER_ESC && \
			(sr.escchar[0]=='F'||sr.escchar[0]=='f')
#define	OPTIONLEN	39
#define MAXOPTIONS	10
#define MAXQUERYLINES	7	
#define TRDATE		0
#define	CDATE		1
#define	NDATE		2
#define FDATE		3
#define FUND		4
#define SCODE		5
#define TREFNO		6

#define TRDATE1		2000
#define TRDATE2		2100
#define CURRDATE	2200
#define NEXTDATE	2300
#define FOLLDATE	2400
#define FUND1		2500
#define FUND2		2600
#define S_CODE1		2700
#define S_CODE2		2800
#define T_REFNO1	2900
#define T_REFNO2	3000
#define MESSAGE		3100
#define RESPONSE	3200

#ifdef ENGLISH
#define PRINTER		'P'
#define DISPLAY		'D'
#define FILE_IO		'F'
#define YES		'Y'
#else
#define PRINTER		'I'
#define DISPLAY		'A'
#define FILE_IO		'D'
#define YES		'O'
#endif

/* arrep.sth - header for C structure generated by PROFOM EDITOR */

static struct	s_struct	{
	char	s_progname[12];	/* 100 program name */
	char	s_scrhdg[25];	/* 200 */
	long	s_rundt;	/* 300 DATE YYYYFMMFDD */
	char	s_item[MAXOPTIONS][OPTIONLEN];	/* 400 - 1300 options */
	short	s_option;	/* 1400 user's input */
	char	s_hypline[2];	/* 1500 mask for seperator line */
	char	s_outputon[2];	/* 1600 report output on D / F / P */
	char	s_filename[16];	/* 1700 name of file if option is F */
	short	s_printer;	/* 1800 printer# if option is P */
	short	s_nbrcopies;	/* 1900 number of copies to print */
	long	s_trandt1;
	long	s_trandt2;
	long	s_currdt;	/* 2000 current period end date */
	long	s_nextdt;	/* 2100 next period end date */
	long	s_folldt;	/* 2200 following period end date */
	short	s_fund1;	/* 2300 starting fund no. */
	short	s_fund2;	/* 2400 ending fund no. */
	char	s_scode1[11];	/* 2500 staring supplier code */
	char	s_scode2[11];	/* 2600 ending supplier code */
	char	s_trefno1[16];	/* 2700 staring trans. ref. no. */
	char	s_trefno2[16];	/* 2800 ending trans. ref. no. */
	char	s_mesg[77];	/* 3000 message field */
	char	s_resp[2];	/* 3100 response field */
}	s_rec;

typedef struct{
	char	name[OPTIONLEN];
	int	(* fnptr)();
	int	mainflno;
}Menu;

struct stat_rec 	sr;		/* profom status record */

static int		line[MAXQUERYLINES];/* for positioning key queries */
static short		call_no;
static short		totaloptions;
static int retval;	/* Global variable to store function values */
static Menu	menu[MAXOPTIONS];
static	int	initialised ;
extern	e_mesg[80];	/* storage for error messages */

static
CleanExit()/* clear and exit the screen , close files & exit program */
{
	fomcs();
	fomrt();
	exit(0);
}
Initialize( terminal,heading )	/* initialize profom and screen */
char *terminal;
char *heading;	
{
	if((retval =  InitProfom(terminal))<0 ){	/* initialize profom */
		fomcs();
		fomrt();
		return( retval );
	}
	if((retval =  InitScreen(heading))<0 ){		/* initialize screen */
		fomcs();
		fomrt();
		return(retval);
	}
	initialised = 1 ;
	return(0);
}	
static
InitProfom(terminal)	/* initialize profom */
char *terminal;
{
	if ( initialised )
		return(0) ;
	STRCPY( sr.termnm, terminal );
	fomin( &sr );		/* initialize the screen */
	ret( err_chk(&sr) );	/* if profom error return */

	return(0);
}
static
InitScreen(heading)		/* initialize the screen */
char 	*heading;
{
	/* initialize the profom screen variables */
	STRCPY( sr.scrnam, NFM_PATH );
	strcat( sr.scrnam, SCREEN_NAME );

	/* initialize the fields of the profom screen */
	if( initialised==0 ){
		if( FillScrHdg(heading)<0 ) 		return(-1);
		if( FillMenu()<0 ) 			return(-1);
		if( FillOption(HIGH)<0 )		return(-1);
		if( FillSeperatorLine(LOW)<0 ) 	return(-1);
	}

	/* Move Highs to inquiry area and write the entire screen */
	if((retval = ClearInquiryArea())<0 )
		return(retval);

	fomcf( 1,1 ) ;		/* Enable snap screen */
	return(0);
}

/* Fill the screen heading fields, the program name and the date */
static
FillScrHdg(heading)
char *heading;
{
	STRCPY( s_rec.s_progname, PROG_NAME );
	STRCPY( s_rec.s_scrhdg, heading );
	s_rec.s_rundt = get_date();
	return(0);
}

/* Add a menu item to the array of report menu items */
AddMenuItem( menuname, fnptr, mainflno )
char	*menuname;
int	(* fnptr)();
int	mainflno;
{
	if( totaloptions==0 ){ /* no options added to array yet */
#ifdef ENGLISH
		STRCPY( menu[totaloptions].name, "RETURN TO PREVIOUS MENU" );
#else
		STRCPY( menu[totaloptions].name, "RETOURNER AU MENU PRECEDENT");
#endif
		menu[totaloptions].fnptr = NULL;
		totaloptions++;
	}

	if( totaloptions>=MAXOPTIONS )	/* array can't accomodate any more */ 
		return(-1);
	if( menuname==NULL )		/* menu name can't be null */
		return(-1);
	STRCPY( menu[totaloptions].name, menuname );
	menu[totaloptions].fnptr = fnptr;	/* copy function pointer */
	menu[totaloptions].mainflno = mainflno;  /* copy main file used */

	totaloptions++;

	return(totaloptions-1);
}
/* Fill Menu Options with the proper names */
static
FillMenu()
{
	short	i;

	for( i=0; i<totaloptions; i++ )
		STRCPY( s_rec.s_item[i], menu[i].name );
	for( i=totaloptions; i<MAXOPTIONS; i++ )
		s_rec.s_item[i][0] = HV_CHAR;
	return(0);
}
static
FillOption( value )
short value;
{
	s_rec.s_option = value * HV_SHORT;
	return(0);
}
/* Fill the demarkating line field with high/low values */
static
FillSeperatorLine(value)
short	value;
{
	s_rec.s_hypline[0] = value * HV_CHAR;
	return(0);
}
/* Fill output details with high or low values */
static
FillOutputDetails( value )
short value;
{
	s_rec.s_outputon[0] = HL_CHAR(value);
	s_rec.s_filename[0] = HL_CHAR(value);
	s_rec.s_printer = HV_SHORT * value;
	s_rec.s_nbrcopies = HV_SHORT * value;
	return(0);
}
static
FillTdate1( value )
short	value;
{
	s_rec.s_trandt1 = HV_LONG * value;
	return(0);
}
static
FillTdate2( value )
short	value;
{
	s_rec.s_trandt2 = HV_LONG * value;
	return(0);
}
static
FillCdate( value )
short	value;
{
	s_rec.s_currdt = HV_LONG * value;
	return(0);
}
static
FillNdate( value )
short	value;
{
	s_rec.s_nextdt = HV_LONG * value;
	return(0);
}
static
FillFdate( value )
short	value;
{
	s_rec.s_folldt = HV_LONG * value;
	return(0);
}
static
FillFund( val1, val2 )
short	val1, val2;
{
	s_rec.s_fund1 = HV_SHORT * val1;
	s_rec.s_fund2 = HV_SHORT * val2;
	return(0);
}
static
FillSCode( val1, val2 )
short	val1, val2;
{
	s_rec.s_scode1[0] = HL_CHAR(val1);
	s_rec.s_scode2[0] = HL_CHAR(val2);
	return(0);
}
static
FillTrefno( val1, val2 )
short	val1, val2;
{
	s_rec.s_trefno1[0] = HL_CHAR(val1);
	s_rec.s_trefno2[0] = HL_CHAR(val2);
	return(0);
}
/* fill message and response fields */
static
FillMsgRespFields( value )
short value;
{
	s_rec.s_mesg[0] = HL_CHAR( value );
	s_rec.s_resp[0] = HL_CHAR( value );

	return(0);
}
/* Accept user's option and call the corresponding routine in a loop */
Process(terminal, heading)
char	*terminal ;
char	*heading  ;
{
	int	field;

	if((retval = Initialize(terminal, heading))<0 )
		return(retval);
	call_no = 0;	/* No get calls made yet */
	for( ; ; ){
		mainfileno = -1 ;

		retval = ReadOption();
		if( retval<0 )
			return(retval);
		if( s_rec.s_option>=totaloptions ){
#ifdef ENGLISH
			fomer("Invalid option");
#else
			fomer("Option invalide");
#endif
			continue;
		}
		if( s_rec.s_option==0 ){   /* option 0 is reserved to quit */
			fomcs();
			fomrt();
			return(0);
		}
		if((retval = CheckAccess(menu[s_rec.s_option].mainflno,
					BROWSE,e_mesg))<0)
			return(retval);

		mainfileno = menu[s_rec.s_option].mainflno ;

		/* Highlight option. Dehighlight in Confirm() */
		field = 400+(s_rec.s_option*100);
		fomca1( field, 9, 3 );

		/* if a corresponding function exists, call it  */
		if( menu[s_rec.s_option].fnptr ){
			if((retval=(*menu[s_rec.s_option].fnptr)())<0 )
				return(retval);
			fomst();
		}
		else 	/* there isn't corr. function,  return value */
			return (s_rec.s_option);

		if((retval =  ClearInquiryArea())<0 )
			return(retval);
	}
}

/*	The following Get....() calls display default values given as parameter 
*	and fill up the variable with the value entered by the user 
*	The fields for accepting input are positioned in the order in which
*	they are called. For this, they make use of variable 'call_no'
*/

GetTransDateRange( trandt1,trandt2 )
long *trandt1, *trandt2;
{
	int	retval=0;

	if( line[TRDATE]==0 )	/* no trans date call made yet */
		line[TRDATE] = STARTLINENUM + call_no++;
	fomca2( TRDATE1,1, line[TRDATE], 1 );
	fomca2( TRDATE1,2, line[TRDATE], 19 );
	fomca2( TRDATE2,1, line[TRDATE], 40 );
	fomca2( TRDATE2,2, line[TRDATE], 45 );

	s_rec.s_trandt1 = *trandt1;
	s_rec.s_trandt2 = *trandt2;
	fomca1( TRDATE1, 19, 2 );
	fomca1( TRDATE2, 19, 2 );
	sr.nextfld = TRDATE1;
	sr.endfld = TRDATE2;
	fomud( (char *)&s_rec );
	s_rec.s_trandt1= LV_LONG;
	s_rec.s_trandt2= LV_LONG;
	retval = ReadFields( TRDATE1, TRDATE2 );
	if( retval!=EXIT && retval>=0 ){
		*trandt1 = s_rec.s_trandt1;
		*trandt2 = s_rec.s_trandt2;
	}
	fomca1( TRDATE1, 19, 0 );
	fomca1( TRDATE2, 19, 0 );

	return(retval);
}
GetCurrDate( cdate )
long 	*cdate;
{
	int	retval=0;

	if(line[CDATE]==0 )	/* no current date call made yet */
		line[CDATE] = STARTLINENUM + call_no++;
	fomca2( CURRDATE,1, line[CDATE], 1 );
	fomca2( CURRDATE,2, line[CDATE], 24 );

	s_rec.s_currdt = *cdate;
	fomca1( CURRDATE, 19, 2 );
	sr.nextfld = CURRDATE;
	fomud( (char *)&s_rec );
	s_rec.s_currdt = LV_LONG;
	retval = ReadFields( CURRDATE, CURRDATE );
	if( retval!=EXIT && retval>=0 ){
		*cdate = s_rec.s_currdt;
	}
	fomca1( CURRDATE, 19, 0 );

	return(retval);
}
GetNextDate( ndate )
long 	*ndate;
{
	int	retval=0;

	if(line[NDATE]==0 )	/* no current date call made yet */
		line[NDATE] = STARTLINENUM + call_no++;
	fomca2( NEXTDATE,1, line[NDATE], 1 );
	fomca2( NEXTDATE,2, line[NDATE], 24 );

	s_rec.s_nextdt = *ndate;
	fomca1( NEXTDATE, 19, 2 );
	sr.nextfld = NEXTDATE;
	fomud( (char *)&s_rec );
	s_rec.s_nextdt = LV_LONG;
	retval = ReadFields( NEXTDATE, NEXTDATE );
	if( retval!=EXIT && retval>=0 ){
		*ndate = s_rec.s_nextdt;
	}
	fomca1( NEXTDATE, 19, 0 );

	return(retval);
}
GetFollDate( fdate )
long 	*fdate;
{
	int	retval=0;

	if(line[FDATE]==0 )	/* no current date call made yet */
		line[FDATE] = STARTLINENUM + call_no++;
	fomca2( FOLLDATE,1, line[FDATE], 1 );
	fomca2( FOLLDATE,2, line[FDATE], 24 );

	s_rec.s_folldt = *fdate;
	fomca1( FOLLDATE, 19, 2 );
	sr.nextfld = FOLLDATE;
	fomud( (char *)&s_rec );
	s_rec.s_folldt = LV_LONG;
	retval = ReadFields( FOLLDATE, FOLLDATE );
	if( retval!=EXIT && retval>=0 ){
		*fdate = s_rec.s_folldt;
	}
	fomca1( FOLLDATE, 19, 0 );

	return(retval);
}
GetFundRange( fund1, fund2 )
short	 *fund1, *fund2;
{
	int	retval=0;

	if( line[FUND]==0 )	/* no stock ccode call made yet */
		line[FUND] = STARTLINENUM + call_no++;
	fomca2( FUND1,1, line[FUND], 1 );
	fomca2( FUND1,2, line[FUND], 24 );
	fomca2( FUND2,1, line[FUND], 40 );
	fomca2( FUND2,2, line[FUND], 45 );

	s_rec.s_fund1 = *fund1 ;
	s_rec.s_fund2 = *fund2 ;
	fomca1( FUND1, 19, 2 );
	fomca1( FUND2, 19, 2 );
	sr.nextfld = FUND1;
	sr.endfld = FUND2;
	fomud( (char *)&s_rec );
	s_rec.s_fund1 = LV_SHORT ;
	s_rec.s_fund2 = LV_SHORT ;
	retval = ReadFields( FUND1, FUND2 );
	if( retval!=EXIT && retval>=0 ){
		*fund1 = s_rec.s_fund1 ;
		*fund2 = s_rec.s_fund2 ;
	}
	fomca1( FUND1, 19, 0 );
	fomca1( FUND2, 19, 0 );

	return(retval);
}
	
GetSCodeRange( scode1, scode2 )
char *scode1, *scode2;
{
	int	retval=0;

	if( line[SCODE]==0 )	/* no stock ccode call made yet */
		line[SCODE] = STARTLINENUM + call_no++;
	fomca2( S_CODE1,1, line[SCODE], 1 );
	fomca2( S_CODE1,2, line[SCODE], 24 );
	fomca2( S_CODE2,1, line[SCODE], 40 );
	fomca2( S_CODE2,2, line[SCODE], 45 );

	STRCPY( s_rec.s_scode1, scode1 );
	STRCPY( s_rec.s_scode2, scode2 );
	fomca1( S_CODE1, 19, 2 );
	fomca1( S_CODE2, 19, 2 );
	sr.nextfld = S_CODE1;
	sr.endfld = S_CODE2;
	fomud( (char *)&s_rec );
	s_rec.s_scode1[0] = LV_CHAR;
	s_rec.s_scode2[0] = LV_CHAR;
	retval = ReadFields( S_CODE1, S_CODE2 );
	if( retval!=EXIT && retval>=0 ){
		strcpy( scode1, s_rec.s_scode1 );
		strcpy( scode2, s_rec.s_scode2 );
	}
	fomca1( S_CODE1, 19, 0 );
	fomca1( S_CODE2, 19, 0 );

	return(retval);
}
GetTrefnoRange( trefno1,trefno2 )
char *trefno1, *trefno2;
{
	int	retval=0;

	if( line[TREFNO]==0 )	/* no stock code call made yet */
		line[TREFNO] = STARTLINENUM + call_no++;
	fomca2( T_REFNO1,1, line[TREFNO], 1 );
	fomca2( T_REFNO1,2, line[TREFNO], 24 );
	fomca2( T_REFNO2,1, line[TREFNO], 40 );
	fomca2( T_REFNO2,2, line[TREFNO], 45 );

	STRCPY( s_rec.s_trefno1, trefno1 );
	STRCPY( s_rec.s_trefno2, trefno2 );
	fomca1( T_REFNO1, 19, 2 );
	fomca1( T_REFNO2, 19, 2 );
	sr.nextfld = T_REFNO1;
	sr.endfld = T_REFNO2;
	fomud( (char *)&s_rec );
	s_rec.s_trefno1[0] = LV_CHAR;
	s_rec.s_trefno2[0] = LV_CHAR;
	retval = ReadFields( T_REFNO1, T_REFNO2 );
	if( retval!=EXIT && retval>=0 ){
		strcpy( trefno1, s_rec.s_trefno1 );
		strcpy( trefno2, s_rec.s_trefno2 );
	}
	fomca1( T_REFNO1, 19, 0 );
	fomca1( T_REFNO2, 19, 0 );

	return(retval);
}

Confirm()	/* returns 1 for yes, 0 for no, -1 for error */
{		/* Clears the profom screen when user's response is 'Y' */
	int	field;

#ifdef ENGLISH
	if((retval = DisplayMessage("Confirm (Y/N)?"))<0 )
#else
	if((retval = DisplayMessage("Confirmer (O/N)?"))<0 )
#endif
		return(retval);
	if((retval = GetResponse(s_rec.s_resp))<0 )
		return(retval);
	field = s_rec.s_option*100 + 400;

	if( s_rec.s_resp[0]==YES ){
		fflush( stdout );
		fomcs();
		fomrt();
		return(1);
	}
	/* Dehighlight the option which is highlighted in Process() */
	fomca1( field, 9, 5 );

	return( HideMessage() );
}

static
ClearInquiryArea()
{
	short i;

	call_no = 0;	/* Reset the call_no */
	for( i=0; i<MAXQUERYLINES; i++ )/* so that next time fields can be */
		line[i] = 0;	/* repositioned for next routine calls */
	if(FillOutputDetails(HIGH)<0 )
		return(-1);
	if(FillTdate1(HIGH)<0 )
		return(-1);
	if(FillTdate2(HIGH)<0 )
		return(-1);
	if(FillCdate(HIGH)<0 )
		return(-1);
	if(FillNdate(HIGH)<0 )
		return(-1);
	if(FillFdate(HIGH)<0 )
		return(-1);
	if(FillFund(HIGH,HIGH)<0 )
		return(-1);
	if(FillSCode(HIGH,HIGH)<0 )
		return(-1);
	if(FillTrefno(HIGH,HIGH)<0 )
		return(-1);
	if(FillMsgRespFields(HIGH)<0 )
		return(-1);
	return(WriteFields(1,0));
}
static
ReadOption()
{
	s_rec.s_option = LV_SHORT;
	return( ReadFields( 1400, 1400 ));
}
static
ReadFields(start,end)	/* read fields whose numbers range from start to end */
int start, end;		/* start and end fields */
{
	int retval;

	sr.nextfld = start;
	sr.endfld = end;
	for( ; ; ){
		fomrd( (char *)&s_rec );
		ret(err_chk(&sr));
		if( sr.retcode==RET_USER_ESC || sr.retcode==RET_VAL_CHK ){
			if( ESC_F ) return(EXIT);
			retval=Validate();
			if( retval<0 || retval==EXIT)	return(retval);
			continue;
		}
		break;
	}
	return(0);
}
static
WriteFields( start,end )/* write fields whose numbers range from start to end */
int start, end;
{
	sr.nextfld = start;
	sr.endfld = end;
	fomwr( (char *)&s_rec );
	ret( err_chk(&sr) );
	return(0);
}
static
Validate()	/* Validate the values entered by the user */
{
	switch( sr.curfld ){
		case 1400:	/* menu option */
			if( s_rec.s_option<0 || s_rec.s_option>=totaloptions ){
#ifdef ENGLISH
				fomer("Invalid option");
#else
				fomer("Option invalide");
#endif
				s_rec.s_option = LV_SHORT;
			}
			break;
		case 1600:	/* output on */
			if( s_rec.s_outputon[0]!= DISPLAY &&
			    s_rec.s_outputon[0]!= PRINTER &&
			    s_rec.s_outputon[0]!= FILE_IO   ){
#ifdef ENGLISH
				fomer("D(isplay), P(rinter), F(ile)");
#else
				fomer("A(fficher), I(mprimante), D(ossier)");
#endif
				s_rec.s_outputon[0] = LV_CHAR;
			}
			break;
		case 1800:	/* number of copies */
			if( s_rec.s_nbrcopies == 0) {
#ifdef ENGLISH
				fomer("No. of Copies can't be Zero");
#else
				fomer("Nombre de copies ne peut pas etre zero");
#endif
				s_rec.s_nbrcopies = LV_SHORT;
			}
			break;
		case CURRDATE:	/* current period ends */
			if( s_rec.s_currdt < s_rec.s_rundt) {
#ifdef ENGLISH
				fomer("Current period ending date cannot be less than today's date");
#else
				fomer("Date de la fin de la periode courante ne peut pas etre plus tot qu'aujourd'hui");
#endif
				s_rec.s_currdt = LV_LONG;
			}
			break;
		case NEXTDATE:  /* next period ends */
			if( s_rec.s_nextdt <= s_rec.s_currdt) {
#ifdef ENGLISH
				fomer("This date must be greater than Current period ending date");
#else
				fomer("Cette date doit etre plus tard que la date de la fin de la periode courante");
#endif
				s_rec.s_nextdt = LV_LONG;
			}
			break;
		case FOLLDATE:  /* following period ends */
			if( s_rec.s_folldt <= s_rec.s_nextdt) {
#ifdef ENGLISH
				fomer("This date must be greater than Next period ending date");
#else
				fomer("Cette date doit etre plus tard que la date de la fin de la prochaine periode");
#endif
				 s_rec.s_folldt = LV_LONG;
			}
			break;
		case FUND2:  /* ending fund */
			if( s_rec.s_fund2 < s_rec.s_fund1 || s_rec.s_fund2 < 1){
#ifdef ENGLISH
				fomer("Ending fund is Invalid");
#else
				fomer("Fond finissant est invalide");
#endif
				s_rec.s_fund2 = LV_LONG;
			}
			break;
		case S_CODE1:  /* starting supplier code */
			Right_Justify_Numeric(s_rec.s_scode1,(sizeof(
						s_rec.s_scode1)-1));
			break;
		case S_CODE2:  /* ending supplier code */
			Right_Justify_Numeric(s_rec.s_scode2,(sizeof(
						s_rec.s_scode2)-1));
			if(strcmp(s_rec.s_scode2,s_rec.s_scode1)<0) {
#ifdef ENGLISH
				fomer("Ending supplier code cannot be less than starting supplier code");
#else
				fomer("Code du fourn. finnissant ne peut pas etre moins que le code du fourn. debutant");
#endif
				s_rec.s_scode2[0] = LV_CHAR;
			}
			break;
		case T_REFNO2:  /*ending trans. ref. no. */
			if(strcmp(s_rec.s_trefno2,s_rec.s_trefno1)<0) {
#ifdef ENGLISH
				fomer("Ending trans. ref. no. cannot be less than starting trans. ref. no.");
#else
				fomer("#ref de trans. finnissant ne peut pas etre moins que #ref de trans. debutant");
#endif
				s_rec.s_trefno2[0] = LV_CHAR;
			}
			break;
	}
	sr.nextfld = sr.curfld;
	return(0);
}
DisplayMessage(mesg)	/* Display the given message in the message field */
char *mesg;
{
	STRCPY( s_rec.s_mesg, mesg );
	return( WriteFields(MESSAGE,MESSAGE));
}
HideMessage()	/* Hide the message field */
{
	if( FillMsgRespFields(HIGH)<0 )	return(-1);
	return( WriteFields(MESSAGE,RESPONSE));
}
GetResponse( respchar )
char *respchar;
{
	int	retval;

	s_rec.s_resp[0] = LV_CHAR;
	retval = ReadFields( RESPONSE, RESPONSE );
	if( retval!=EXIT && retval>=0 )
		*respchar = s_rec.s_resp[0];
	return( retval );
}
GetOutputon( outputon )
char	*outputon;
{
	int	retval;

#ifdef ENGLISH
	fomer("D(isplay), P(rinter), F(ile)");
#else
	fomer("A(fficher), I(mprimante), D(ossier)");
#endif
	STRCPY( s_rec.s_outputon, outputon );
	fomca1( 1600, 19, 2 );
	sr.nextfld = 1600;
	sr.endfld = 1600;
	fomud( (char *)&s_rec );
	s_rec.s_outputon[0] = LV_CHAR;
	retval = ReadFields(1600,1600);
	if( retval!=EXIT && retval>=0 )
		*outputon = s_rec.s_outputon[0];
	fomca1( 1600, 19, 0 );
	return( retval );
}
GetFilename( filename )
char	*filename;
{
	int	retval;

	STRCPY( s_rec.s_filename, filename );
	fomca1( 1700, 19, 2 );
	sr.nextfld = 1700;
	sr.endfld = 1700;
	fomud( (char *)&s_rec );
	s_rec.s_filename[0] = LV_CHAR;
	retval = ReadFields(1700,1700);
	if( retval!=EXIT && retval>=0 )
		strcpy( filename , s_rec.s_filename ) ;
	fomca1( 1700, 19, 0 );
	return( retval );
}
GetPrinter( printer )
short	*printer;
{
	int	retval;

	s_rec.s_printer = *printer ;
	fomca1( 1800, 19, 2 );
	sr.nextfld = 1800;
	sr.endfld = 1800;
	fomud( (char *)&s_rec );
	s_rec.s_printer = LV_SHORT;
	retval = ReadFields(1800,1800);
	if( retval!=EXIT && retval>=0 )
		*printer = s_rec.s_printer;
	fomca1( 1800, 19, 0 );
	return( retval );
}
GetNbrCopies( nbrcopies )
short	*nbrcopies;
{
	int	retval;

	s_rec.s_nbrcopies = *nbrcopies ;
	fomca1( 1900, 19, 2 );
	sr.nextfld = 1900;
	sr.endfld = 1900;
	fomud( (char *)&s_rec );
	s_rec.s_nbrcopies = LV_SHORT;
	retval = ReadFields(1900,1900);
	if( retval!=EXIT && retval>=0 )
		*nbrcopies = s_rec.s_nbrcopies;
	fomca1( 1900, 19, 0 );
	return( retval );
}
