/*------------------------------------------------------------------------
Source Name: cheque.c
System     : Accounts Payables.
Created  On: 10th December 89.
Created  By: CATHY BURNS.

DESCRIPTION:
	Program to enter do Cheque Processing.

MODIFICATIONS:        

Programmer     YY/MM/DD       Description of modification
~~~~~~~~~~     ~~~~~~~~       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
F.Tao	       90/11/22	      1. Print No blank lines on cheque;
F.Tao 	       90/12/18	      Round up amounts before printing and writing to 
			      file.
L.Robichaud    92/12/01	      print the originial supplier to aphistory 
			      rather than the supplier code of the person
			      or company that is paying. 
L.Robichaud    93/07/07	      Call function to check if invoice entry is in 
			      process.
L.Robichaud	1993/10/13	Pass new parameter to close_rep function for 
				a banner to print with 3000 family.
------------------------------------------------------------------------*/
#define 	MAIN 
#define		MAINFL	CHQHIST		/* main file used */

#include <stdio.h>
#include <cfomstrc.h>
#include <reports.h>

#define	SYSTEM		"ACCOUNTS PAYABLE"	/* Sub System Name */
#define	MOD_DATE	"23-JAN-90"		/* Program Last Modified */
#define	SCR_NAME	"cheque"		/* First screen */

#define	SHORT_CHQS 	SW1
#define MED_CHQS	SW2

#define	ST_FLD		400 
#define	END_FLD		1600 
#define MESG_FLD	1600
#define FUND_FLD	400
#define ACCT_FLD	500
#define CHQNO_FLD	600
#define CHQDATE_FLD	700
#define PRINTER_FLD	750
#define OPTION_FLD	800

#define EXIT	12

#ifdef ENGLISH
#define PAID_Y	"Y"
#define PAID_N	"N"

#define AP_SYS	'A'
#define PROCCHQ	'C'
#define EXITOPT	'E'

#define	YES	'Y'
#define NO	'N'
#define EDIT	'E'
#define CANCEL	'C'
#else
#define PAID_Y	"O"
#define PAID_N	"N"

#define AP_SYS	'S'
#define PROCCHQ	'T'
#define EXITOPT	'F'

#define	YES	'O'
#define NO	'N'
#define EDIT	'M'
#define CANCEL	'A'
#endif
/* cheque.sth - header for C structure generated by PROFOM EDITOR */

typedef struct	{

	char	s_pgm[11];	/* STRING XXXXXXXXXX 	Field 100 */
	long	s_rundate;	/* NUMERIC 9999F99F99 	Field 300 */
	short	s_funds;	/* NUMERIC 999		Field 400 */
	char	s_acct[19];	/* STRING X(18)		Field 500 */
	long	s_chq_no;	/* NUMERIC 999999 	Field 600 */
	long	s_chq_date;	/* NUMERIC 9999F99F99 	Field 700 */
	short	s_printer;	/* NUMERIC 99 		Field 750 */
	char	s_resp[2]; 	/* STRING X 		Field 800 */
	long	s_no_can;	/* NUMERIC 99999 	Field 900 */
	long	s_no_man;	/* NUMERIC 99999 	Field 1000 */
	long	s_no_writ;	/* NUMERIC 99999 	Field 1000 */
	long	s_no_tot;	/* NUMERIC 99999 	Field 1100 */
	double	s_gross;	/* NUMERIC 999999999.99 Field 1200 */
	double	s_disc;		/* NUMERIC 999999999.99 Field 1300 */
	double	s_netpay;	/* NUMERIC 999999999.99 Field 1400 */
	char	s_mesg[78];	/* STRING X(78) 	Field 1500 */
	char	s_opt[2];	/* STRING X 		Field 1600 */
	} S_STRUCT;

static	S_STRUCT	s_sth ;

/* PROFOM Related variables */

struct  	stat_rec  sr;	/* PROFOM status rec */

static	Chq_rec		chq_rec ;	/* Cheque record */
static	Chq_hist	chq_hist ;	/* Cheque History record */
static	Reg_rec		reg_rec ;	/* Cheque Register record */
static	Gl_rec		gl_rec ;	/* gl master record */
static	Supplier	supp_rec ;
static	Ap_hist		aphist ;
static 	Tr_hdr		tr_hdr ;
static	Tr_item		tr_item ;
static	Invoice		invoice ;
static	Pa_rec		pa_rec ;

Ctl_rec		ctl_rec ;	/* Control record */

static	char 	e_mesg[200];	/* dbh will return err msg in this */
static	long	chq_no,	temp_chq_no  ;
static	int	no_of_items ;
static	char	temp_buf[80] ;	/* work variable for tedit */
static	double	total_disc,	total_gross ;
static	char	prev_supp[11] ;
static	double	ordinary_amt, contract_amt, disc_amt, bank_amt ;
static 	long	parm_date ; 
static  int	NO_OF_ITEMS ;

double 	D_Roundoff();

static	long	w_chq_no ;

main(argc,argv)
int argc;
char *argv[];
{
int 	retval, numprocess ;

	strncpy(SYS_NAME,SYSTEM,50);	/* Sub system name */
	strncpy(CHNG_DATE,MOD_DATE,10);	/* Modification Date */
	proc_switch(argc, argv, CHQHIST) ; 	/* Process Switches */

	if (SHORT_CHQS)
		NO_OF_ITEMS = 12;  
	else if(MED_CHQS) 
		NO_OF_ITEMS = 12;
	else
		NO_OF_ITEMS = 20;  

	STRCPY(sr.termnm,terminal);	/* Copy Terminal Name */

	retval = get_param(&pa_rec, BROWSE, 1, e_mesg) ;
	if(retval < 1) {
#ifdef ENGLISH
		printf("Parameters Are Not Setup..") ;
#else
		printf("Parametres ne sont pas etablis..") ;
#endif
		close_dbh() ;
		exit(-1) ;
	}


	if (Initialize()<0)
		exit(-1);		/* Initialization routine */

#ifndef DOS
	numprocess = invcheck();	/* Check for invoice entry processes */
	if(numprocess == ERROR){
		DispError("Error Occured Checking Active Processes");
		close_dbh();
		exit(0);
	}
	if(numprocess > 0){
		DispError("Can Not Proceed, Invoice Entry In Process");
		close_dbh();
		exit(0);
	}
#endif

	if ( Process() < 0) { 		/* Initiate Process */
		Close();
		exit(-1);
	}

	Close();			/* return to menu */
	exit(NOERROR);

} /* END OF MAIN */

/*-------------------------------------------------------------------*/
/* Reset information */
Close()
{
	/* Set terminal back to normal mode from PROFOM */
	fomcs();
	fomrt();
	close_dbh();			/* Close files */
	close_rep(NOBANNER);
}
/*-------------------------------------------------------------------*/
/* Initialize PROFOM  and Screens*/
Initialize()
{
	if(InitProfom()<0) { 			/* Initialize PROFOM */
		fomcs();
		fomrt();
		return(-1);
	}	
	if(InitScreens()<0) { 
		fomcs();
		fomrt();
		return(-1);
	}	
	return(NOERROR);
}

/*-------------------------------------------------------------------*/
/* Initialize PROFOM */

InitProfom()
{
	fomin(&sr);
	/* Check for Error */
	ret( err_chk(&sr) );

	fomcf(1,1);			/* Enable Print screen option */
	return(NOERROR);
}	/* InitProfom() */
/*----------------------------------------------------------------*/
/* Initialize screens before going to process options */
InitScreens()
{
	int	retval ;

	STRCPY(sr.scrnam,NFM_PATH);
	strcat(sr.scrnam,SCR_NAME) ;

	STRCPY(s_sth.s_pgm,PROG_NAME);
	s_sth.s_rundate = get_date();	/* get Today's Date in YYMMDD format */
	s_sth.s_mesg[0] = HV_CHAR ;
	s_sth.s_opt[0] = HV_CHAR ;

	/* Move High Values to 1st screen data fields & Display */
	retval = ClearScreen() ;
	if( retval < 0 ) return(-1) ;

	return(NOERROR);

}	/* InitScreens() */
InitPrinter()
{
	char	resp[2] ;
	char	discfile[15] ;

	/* Always to Printer */
	STRCPY( resp, "P" );
	discfile[0]='\0';

	if( opn_prnt( resp, discfile, s_sth.s_printer, e_mesg, 0 )<0 ){
		fomen(e_mesg); get();
		return(-1);
	}
	return(NOERROR) ;
}
/*-----------------------------------------------------------------*/
/* Clears the screen. 						   */
ClearScreen()
{
	s_sth.s_funds = LV_SHORT;
	s_sth.s_acct[0] = LV_CHAR;
	s_sth.s_chq_no = LV_LONG;
	s_sth.s_chq_date = LV_LONG;
	s_sth.s_printer = LV_SHORT;
	s_sth.s_resp[0] = LV_CHAR ;
	s_sth.s_no_can = HV_LONG;
	s_sth.s_no_man = HV_LONG;
	s_sth.s_no_writ = HV_LONG;
	s_sth.s_no_tot = HV_LONG;
	s_sth.s_gross = HV_DOUBLE;
	s_sth.s_disc = HV_DOUBLE;	
	s_sth.s_netpay = HV_DOUBLE;
	
	return(WriteFields(ST_FLD,END_FLD) ) ;
}
/*-----------------------------------------------------------------*/
Process()
{
	int	err;

	s_sth.s_mesg[0] = HV_CHAR;
	ShowMesg();	
	if(!SW3) {
		for( ; ; ){

#ifdef ENGLISH
			fomer("C(heque Processing), E(xit)");
#else
			fomer("T(raitement de cheque), F(in)");
#endif
			sr.nextfld = OPTION_FLD;
			fomrf((char *)&s_sth);
			ret(err_chk(&sr));
	
			switch(s_sth.s_resp[0]) {
			case  EXITOPT :
				return(EXIT);
			case  PROCCHQ :
				CHKACC(err,ADD,e_mesg);	
				CHKACC(err,UPDATE,e_mesg);	
				err = ChqProcess() ;
				break ;
			default :
				continue;
			}

			if(NOACCESS == err) {
				fomen(e_mesg);
				get();
			}
			if(PROFOM_ERR == err)	return(PROFOM_ERR);  /* PROFOM ERROR */
			if(DBH_ERR == err) {
				DispError(e_mesg);
#ifdef ENGLISH
				sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
					"System Error... Iserror:",
					iserror, dberror, errno);
#else
				sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
					"Erreur du systeme... Iserror:",
					iserror, dberror, errno);
#endif
				DispError(e_mesg);
				return(DBH_ERR); /* DBH ERROR */
		
			}
		}      /*   end of the for( ; ; )       */
	}	/* End of If !SW3 */
	else {
		err = CheckAccess(MAINFL,ADD,e_mesg);	
		if(NOACCESS == err) {
			fomen(e_mesg);
			get();
			return(ERROR);
		}
		err = CheckAccess(MAINFL,UPDATE,e_mesg);	
		if(NOACCESS == err) {
			fomen(e_mesg);
			get();
			return(ERROR);
		}
		err = ChqProcess() ;

		if(PROFOM_ERR == err)	return(PROFOM_ERR);  /* PROFOM ERROR */
		if(DBH_ERR == err) {
			DispError(e_mesg);
#ifdef ENGLISH
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
					"System Error... Iserror:",
					iserror, dberror, errno);
#else
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
					"Erreur du systeme... Iserror:",
					iserror, dberror, errno);
#endif
			DispError(e_mesg);
			return(DBH_ERR); /* DBH ERROR */
		
		}
	}
}
/*-----------------------------------------------------------------*/
ChqProcess()
{
	int 	retval ;

	retval = ReadInfo() ;
	if( retval < 0 ) return(retval) ;
	if( retval == EXIT ) return(NOERROR) ;

	retval = Confirm() ;
	if( retval != YES ) 
		return(NOERROR) ;
	
#ifdef ENGLISH
        retval = GetOpt( "Are you ready to print CHEQUES (Y/N)?","YN") ;
#else
        retval = GetOpt( "Etes-vous prets a imprimer les cheques (O/N)?","ON") ;
#endif

	if(retval != YES) 
	return(NOERROR) ;

	if(InitPrinter()<0) {
		return(-1);
	}	

	retval = DoTestPrint() ;

	retval = Backup_Files() ;	/* Backup data files */

	retval = ChequeProcess();
	if( retval < 0 ) 
		return(retval) ;

	close_dbh() ;
	close_rep(NOBANNER);

	for( ; ; ) {
#ifdef ENGLISH
        	retval = GetOpt( "Are you ready to print CHEQUE REGISTER (Y/N)?","YN") ;
#else
        	retval = GetOpt( "Etes-vous prets a imprimer le REGISTRE DES CHEQUES (O/N)?","ON") ;
#endif
		if(retval == YES) 
			break ;
	}

#ifdef ENGLISH
	STRCPY(s_sth.s_mesg, "Generating and Printing the CHEQUE REGISTER") ;
#else
	STRCPY(s_sth.s_mesg, "Engendre et imprime le REGISTRE DES CHEQUES") ;
#endif
	ShowMesg() ;
	fflush(stdout) ;
	if ( (retval = Register(s_sth.s_acct)) < 0) {	/* Print Register */
		return(retval);
	}
	/* Update History */
	if ( (retval = ChequeUpdate(s_sth.s_funds,s_sth.s_acct)) < 0) {
		return(retval);
	}
#ifdef ENGLISH
	STRCPY(s_sth.s_mesg, "CHEQUE REGISTER Printed Sucessfully") ;
#else
	STRCPY(s_sth.s_mesg, "Impression du REGISTRE DES CHEQUES reussie");
#endif
	ShowMesg() ;
	fflush(stdout) ;
	retval = WriteFields(ST_FLD,END_FLD) ;

	return(NOERROR) ;
 
}
Backup_Files() 
{
	char	file1[50], file2[50];
	char	in_str[80] ;

#ifdef ENGLISH
	fomer("Please wait while data files are being copied.");
#else
	fomer("S.V.P. attendre; les donnees se copient en reserve.");
#endif
	fflush(stdout);

	form_f_name("", file1);
	form_f_name(BACK_UP, file2); 
#ifdef	MS_DOS
	sprintf(in_str,"copy %sinv* %s", file1, file2);
#else
	sprintf(in_str,"cp %sinv* %s", file1, file2);
#endif
	system(in_str);
#ifdef	MS_DOS
	sprintf(in_str,"copy %scheque* %s", file1, file2);
#else
	sprintf(in_str,"cp %scheque* %s", file1, file2);
#endif
	system(in_str);
#ifdef	MS_DOS
	sprintf(in_str,"copy %schq* %s", file1, file2);
#else
	sprintf(in_str,"cp %schq* %s", file1, file2);
#endif
	system(in_str);
#ifdef	MS_DOS
	sprintf(in_str,"copy %saphist* %s", file1, file2);
#else
	sprintf(in_str,"cp %saphist* %s", file1, file2);
#endif
	system(in_str);
#ifdef	MS_DOS
	sprintf(in_str,"copy %scontrol* %s", file1, file2);
#else
	sprintf(in_str,"cp %scontrol* %s", file1, file2);
#endif
	system(in_str);
#ifdef	MS_DOS
	sprintf(in_str,"copy %ssupplier* %s", file1, file2);
#else
	sprintf(in_str,"cp %ssupplier* %s", file1, file2);
#endif
	system(in_str);
#ifdef	MS_DOS
	sprintf(in_str,"copy %sgltr* %s", file1, file2);
#else
	sprintf(in_str,"cp %sgltr* %s", file1, file2);
#endif
	system(in_str);
#ifdef	MS_DOS
	sprintf(in_str,"copy %sglmast* %s", file1, file2);
#else
	sprintf(in_str,"cp %sglmast* %s", file1, file2);
#endif
	system(in_str);
	
	fomer("                                                   ");
	fflush(stdout);

	return(NOERROR) ;
}
/*-----------------------------------------------------------------------*/
/*                                                                       */
/* Reads Cheque processing information.                                  */
ReadInfo()
{
	int 	i,retval ;

	/* In Add mode turn off dup control for key fields.
	   Other modes reverse it */
	for(i = FUND_FLD ; i <= CHQDATE_FLD ; i += 100) {
		fomca1(i,19,2) ;	/* On Dup Control */
		fomca1(i,10,1) ;
	}
	fomca1(750,19,2) ;	/* The printer duplication and ESC F */
	fomca1(750,10,1) ;

	sr.nextfld = FUND_FLD;
	sr.endfld = PRINTER_FLD;
	fomud((char*)&s_sth);	/* Update Dup Buffers */

#ifdef ENGLISH
	STRCPY(s_sth.s_mesg,"Press ESC-F to Go Back to Option:");
#else
	STRCPY(s_sth.s_mesg,"Appuyer sur ESC-F pour retourner a Option:");
#endif
	ShowMesg();

	s_sth.s_funds = 1 ;
	retval = WriteFields(FUND_FLD,FUND_FLD) ;
	if (retval < 0) return(retval) ; 
	s_sth.s_funds = LV_SHORT ;
	s_sth.s_printer = 1 ;
	retval = WriteFields(PRINTER_FLD,PRINTER_FLD) ;
	if (retval < 0) return(retval) ; 
	s_sth.s_printer = LV_SHORT ;

	i = ReadFields(FUND_FLD, PRINTER_FLD); 
	if(PROFOM_ERR == i || DBH_ERR == i) return(i) ;
	if(EXIT == i){
		s_sth.s_mesg[0] = HV_CHAR;
		ShowMesg();
		return(i) ;
	}
	return(NOERROR) ;
}

/*-----------------------------------------------------------------------*/
/*  Printing the Test as many times needed for cheques to line up        */
DoTestPrint()
{
	int 	i,	retval ;

	STRCPY(temp_buf, "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX") ;

	for( ; ; ) {
#ifdef ENGLISH
		retval = GetOpt("Alignment Check OK (Y/N)?","YN") ;
#else
		retval = GetOpt("Test d'impression OK (O/N)?","ON") ;
#endif

		if( retval == YES ) 
			break ;
		mkln(3,"ZZ9",3) ;
		mkln(8,"ZZZZZ9",6) ;
		mkln(15,"ZZZZZZZZZ9",10) ;
		if( prnt_line() < 0) return(-1) ;
		if( prnt_line() < 0) return(-1) ;
		if( prnt_line() < 0) return(-1) ;
		if (!SHORT_CHQS)
			if( prnt_line() < 0) return(-1) ;
		mkln(1,"XXXXXXXXXXXXXXX",10) ;
		mkln(16,"99*99*99",8) ;
		mkln(25,"ZZZ,ZZZ,ZZ9.99-",15) ;
		mkln(41,"ZZZ,ZZZ,ZZ9.99-",15) ;
		mkln(57,"ZZZ,ZZZ,ZZ9.99-",15) ;
		if( prnt_line() < 0) return(-1) ;
		for( i=0; i<NO_OF_ITEMS ;i++)    	/* print blank lines */
			if( prnt_line() < 0) return(-1) ;
		mkln(57,"ZZZ,ZZZ,ZZ9.99-",15) ; 
		if( prnt_line() < 0) return(-1) ;
		if (SHORT_CHQS) {
			for( i=0; i<=7 ;i++)   		/* print blank lines */
				if( prnt_line() < 0) return(-1) ;
		}
		else if(MED_CHQS) {
			for( i=0; i<=5 ;i++)   		/* print blank lines */
				if( prnt_line() < 0) return(-1) ;
		}
		else  {
			for( i=0; i<=6 ;i++)   		/* print blank lines */
				if( prnt_line() < 0) return(-1) ;
		}
		mkln(22,"ZZ9",3) ;
		mkln(27,"ZZZZZ9",6) ;
		mkln(35,"ZZZZZZZZZ9",10) ;
		mkln(47,"99/99/99",8) ;
		mkln(57,"ZZZ,ZZZ,ZZ9.99-",15) ;
		if( prnt_line() < 0) return(-1) ;
		if(MED_CHQS) {
			for( i=0; i<=3 ;i++)    	/* print blank lines */
				if( prnt_line() < 0) return(-1) ;
		}
		else {
			for( i=0; i<=2 ;i++)    	/* print blank lines */
				if( prnt_line() < 0) return(-1) ;
		}
		mkln(7,temp_buf,48);
		if( prnt_line() < 0) return(-1) ;
		mkln(7,temp_buf,30);
		if( prnt_line() < 0) return(-1) ;
		mkln(7,temp_buf,30);
		if( prnt_line() < 0) return(-1) ;
		mkln(7,temp_buf,30);
		if( prnt_line() < 0) return(-1) ;
		mkln(7,temp_buf,7) ;
		if( prnt_line() < 0) return(-1) ;

#ifdef ENGLISH
		fomen("The Test Print Is Printing. Press any key to continue.");
#else
		fomen("La copie d'essaie imprime. Appuyer une touche pour continuer.");
#endif
		get();
		rite_top();
	}
	return(NOERROR) ;
}
/*-----------------------------------------------------------------------*/
/*                                                                       */
/* Reads the cheque and prints the cheque after accumulating invoices.   */
ChequeProcess()
{
	int	retval ;

#ifdef ENGLISH
	STRCPY(s_sth.s_mesg, "CHEQUES being Printed, PLEASE WAIT");
#else
	STRCPY(s_sth.s_mesg, "Les CHEQUES sont en train d'etre imprimes, ATTENDEZ S.V.P.");
#endif
	ShowMesg() ;
	fflush(stdout) ;

	s_sth.s_no_can = 0 ;	/* Initialize summary screen fields */
	s_sth.s_no_man = 0;
	s_sth.s_no_writ = 0 ;
	s_sth.s_no_tot = 0 ;
	s_sth.s_gross = 0.00 ;
	s_sth.s_disc = 0.00 ;
	s_sth.s_netpay = 0.00 ;
	
	ordinary_amt = 0.00 ;
	contract_amt = 0.00 ;
	disc_amt = 0.00 ;
	bank_amt = 0.00 ;
	total_disc = 0.0 ;
	total_gross = 0.0 ;

	temp_chq_no = 0 ;

	chq_rec.c_funds = s_sth.s_funds ;
	chq_rec.c_accno[0]   = '\0' ;
	chq_rec.c_chq_no = 0 ;
	chq_rec.c_supp_cd[0] = '\0' ;
	chq_rec.c_invc_no[0] = '\0' ;
	chq_rec.c_tr_type[0] = '\0' ;

	flg_reset(CHEQUE) ;

	prev_supp[0] = '\0' ;
	chq_no = s_sth.s_chq_no ;

	for( ; ; ) {
		retval = get_n_chq(&chq_rec,UPDATE,1,FORWARD,e_mesg) ;
		if( retval == EFL ) 
			break;

		if( retval < 0) {
			roll_back(e_mesg);
			DispError(e_mesg) ;
			return(retval) ;
		}
		if( chq_rec.c_funds != s_sth.s_funds) 
			break;

		/* Manual or Cancelled Cheques come at the end with in fund.
		   Regular cheques will be having chq_no & accno as 0s. So
		   if the bank account is smaller than current account skip the
		   records or if greater, then no more records to process */
		if(chq_rec.c_chq_no != 0) {
			retval = strcmp(chq_rec.c_accno, s_sth.s_acct) ;
			if(retval < 0) {
				STRCPY(chq_rec.c_accno, s_sth.s_acct) ;
				chq_rec.c_chq_no = 0 ;
				chq_rec.c_supp_cd[0] = '\0' ;
				chq_rec.c_invc_no[0] = '\0' ;
				chq_rec.c_tr_type[0] = '\0' ;
				flg_reset(CHEQUE) ;
				continue ;
			}
			if(retval > 0) break;
		}

		/* Check to see if a rerun */
		if ( chq_rec.c_cp_chq_no != 0 ) {
			retval = AccumulateTotals() ;
			if (retval < 0) return(retval) ;

#ifndef	ORACLE
			roll_back(e_mesg) ;
			retval = LockGlRecords() ;
			if (retval < 0) return(retval) ;
#endif
			continue ;
		}

		/* if manual or cancelled cheque number change */
		if( (chq_rec.c_chq_no != 0) && 
		    (chq_rec.c_chq_no != reg_rec.cr_chq_no) ) {
			retval = NewCheque() ;
			if(retval < 0) return(retval) ;
		}

		if( (strcmp(chq_rec.c_supp_cd, prev_supp)) != 0 ) {
			retval = NewCheque() ;
			if(retval < 0) return(retval) ;
		}

		retval = AccumulateTotals() ;
		if (retval < 0) return(retval) ;

		total_disc = total_disc + chq_rec.c_disc_taken ;
		total_disc = D_Roundoff(total_disc);
		total_gross = total_gross + chq_rec.c_gr_amt ;
		total_gross = D_Roundoff(total_gross);
		if( (chq_rec.c_chq_type[0] == REGULAR) &&
		    (chq_rec.c_cancelled[0] == NO) ) {
			retval = PrintDetail() ;	/* print invoice info */
			if (retval < 0) return(retval) ;
		}
		chq_rec.c_cp_chq_no = temp_chq_no ;

		if( UpdtAphist()<0) {		/* Write Aphistory record */
			DispError(e_mesg) ;
			roll_back(e_mesg);
			return(-1);
		}

		retval = put_chq(&chq_rec,UPDATE,e_mesg) ;
		if (retval < 0) return(retval) ;

		inc_str(chq_rec.c_tr_type, sizeof(chq_rec.c_tr_type)-1,FORWARD);
			
	}
	if (temp_chq_no == 0) {
#ifdef ENGLISH
		DispError("No CHEQUES to Process") ;
#else
		DispError("Pas de CHEQUES a traiter") ;
#endif
		return(ERROR) ;
	}
	if (prev_supp[0] != '\0') {
		retval = ProcessDtl() ;
		if (retval < 0) return(retval) ;
	}

	seq_over(CHEQUE) ;
	if( UpdtGlTran()<0) {
		DispError(e_mesg) ;
		roll_back(e_mesg);
		return(-1);
	}
	if( commit(e_mesg)<0 ){	/* If everything goes right, commit */
		DispError(e_mesg) ;
		return(-1);
	}
	retval = WriteFields(ST_FLD, END_FLD - 200) ;
	if (retval < 0) return(-1) ;
#ifdef ENGLISH
	STRCPY(s_sth.s_mesg, "CHEQUES Printed Successfully");
#else
	STRCPY(s_sth.s_mesg, "Impression des CHEQUES reussie");
#endif
	ShowMesg() ;
	fflush(stdout) ;
	return(NOERROR) ;

}
/*----------------------------------------------------------------------------*/
AccumulateTotals()
{
	int retval ;
	
	if ((strcmp(supp_rec.s_supp_cd,chq_rec.c_supp_cd)) != 0 ) {
		STRCPY( supp_rec.s_supp_cd, chq_rec.c_supp_cd ) ;
		retval = get_supplier(&supp_rec,BROWSE,0,e_mesg) ;
		if( retval < 0) { 
			DispError(e_mesg) ;
			return(retval) ;
		}
	}

	if( supp_rec.s_type[0] == CONTRACT ) 
	   	contract_amt += chq_rec.c_gr_amt ;
	else {
	   	ordinary_amt += chq_rec.c_gr_amt ;
	}

	disc_amt += chq_rec.c_disc_taken ;
	bank_amt += (chq_rec.c_gr_amt - chq_rec.c_disc_taken) ;

	return(NOERROR) ;
}

/*----------------------------------------------------------------------------*/
/*  Manual cheques are written to the register where regular cheques must be  */
/*  printed.								      */
NewCheque()
{
	int	retval ;

	if( prev_supp[0] != '\0' )  { 	/* Not first time */
		/* Manual cheques are only written to the register */
		retval = ProcessDtl() ;
		if (retval < 0) return(retval) ;
		retval = get_chq(&chq_rec,UPDATE,1,e_mesg) ;
		if (retval < 0) return(retval) ;
	}

	if( (chq_rec.c_chq_type[0] == REGULAR) &&
	    (chq_rec.c_cancelled[0] == NO) ) {
		chq_no++ ;
		temp_chq_no = chq_no ;
	}
	else   	temp_chq_no = chq_rec.c_chq_no ;

	STRCPY( prev_supp, chq_rec.c_supp_cd ) ;
	retval = InitRecords() ;
	if (retval < 0) return(retval) ;

	if( (chq_rec.c_chq_type[0] == REGULAR) &&
	    (chq_rec.c_cancelled[0] == NO) ) {
		retval = PrintHeader() ;	/* print hdr */
		if (retval < 0) return(retval) ;
	}

	return(NOERROR) ;
}
/*----------------------------------------------------------------------------*/
UpdtSummary()
{
	if( reg_rec.cr_cancelled[0] == YES ) 
		s_sth.s_no_can++ ;
	else
		if ( reg_rec.cr_chq_type[0] == MANUAL )
			s_sth.s_no_man++ ;
		else
			s_sth.s_no_writ++ ;
	
	s_sth.s_no_tot++ ;
	s_sth.s_gross += total_gross ;
	s_sth.s_disc += total_disc ;
	s_sth.s_netpay += (total_gross - total_disc) ;
	
	s_sth.s_gross = D_Roundoff(s_sth.s_gross);
	s_sth.s_disc  = D_Roundoff(s_sth.s_disc);
	s_sth.s_netpay= D_Roundoff(s_sth.s_netpay);
}
 	 
/*----------------------------------------------------------------------------*/
/*  Print Cheque Stub header information				      */
PrintHeader()
{
	tedit((char *)&s_sth.s_funds,"_0_",temp_buf,R_SHORT) ;
	mkln(1,temp_buf,3) ;
	tedit((char *)&temp_chq_no,"______0_",temp_buf,R_LONG) ;
	mkln(6,temp_buf,8) ;
	mkln(16,chq_rec.c_supp_cd,10) ;
	if( prnt_line() < 0) return(-1) ;
	if( prnt_line() < 0) return(-1) ;
	if( prnt_line() < 0) return(-1) ;
	if (!SHORT_CHQS) 
		if( prnt_line() < 0) return(-1) ;

	no_of_items = NO_OF_ITEMS ; 

	return(NOERROR) ;
}
/*----------------------------------------------------------------------------*/
/*  Prints invoice by invoice details in the cheque stub information          */
PrintDetail()
{
	int retval ;

	double	net_amt ;

	net_amt = 0.00 ;

	if( no_of_items == 0 ) {
		PrintCancel();
		rite_top();
		PrintHeader() ;
		if (retval < 0) return(retval) ;
	}

	mkln(3,chq_rec.c_invc_no,13) ;
	tedit((char *)&chq_rec.c_invc_dt,"____/__/__",temp_buf,R_LONG) ;
	mkln(16,temp_buf + 2, 8) ;
	chq_rec.c_gr_amt = D_Roundoff(chq_rec.c_gr_amt);
	tedit((char *)&chq_rec.c_gr_amt,"___,___,_0_.__-",temp_buf,R_DOUBLE) ;
	mkln(24,temp_buf,15) ;
	chq_rec.c_disc_taken = D_Roundoff(chq_rec.c_disc_taken);
	tedit((char *)&chq_rec.c_disc_taken,"___,___,_0_.__-",temp_buf,R_DOUBLE) ;
	mkln(41,temp_buf,15) ;

	net_amt = chq_rec.c_gr_amt - chq_rec.c_disc_taken ;
	net_amt = D_Roundoff(net_amt);
	tedit((char *)&net_amt,"___,___,_0_.__-",temp_buf,R_DOUBLE) ;
	mkln(25,temp_buf,15) ;
	mkln(57,temp_buf,15) ;
	temp_buf[0] = ' ' ;
	mkln(73,temp_buf,1) ;		/* Payment code */
	if( prnt_line() < 0) return(-1) ;

	no_of_items-- ;
	return(NOERROR) ;

}
/*----------------------------------------------------------------------------*/
/*  Prints Cheque after all cheque stub information is printed		      */
PrintCheque()
{
	int	i ;
	double	net_amt ;

	for( i=0; i<=no_of_items ;i++)    		/* print blank lines */
		if( prnt_line() < 0) return(-1) ;
	net_amt = total_gross - total_disc ;
	net_amt = D_Roundoff(net_amt);
	tedit((char *)&net_amt,"___,___,_0_.__-",temp_buf,R_DOUBLE) ;
	mkln(57,temp_buf,15) ; 
	if( prnt_line() < 0) return(-1) ;
	if (SHORT_CHQS) {
		for( i=0; i<=7 ;i++)   		/* print blank lines */
			if( prnt_line() < 0) return(-1) ;
	}
	else if(MED_CHQS) {
		for( i=0; i<=5 ;i++)   		/* print blank lines */
			if( prnt_line() < 0) return(-1) ;
	}
	else {
		for( i=0; i<=6 ;i++)   		/* print blank lines */
			if( prnt_line() < 0) return(-1) ;
	}
	tedit((char *)&s_sth.s_funds,"_0_",temp_buf,R_SHORT) ;
	mkln(22,temp_buf,3) ;
	tedit((char *)&temp_chq_no,"______0_",temp_buf,R_LONG) ;
	mkln(26,temp_buf,8) ;
	mkln(35,supp_rec.s_supp_cd,10) ;
	tedit((char *)&s_sth.s_chq_date,"____/__/__",temp_buf,R_LONG) ;
	mkln(47,temp_buf + 2, 8) ;
	net_amt = D_Roundoff(net_amt);
	tedit((char *)&net_amt,"$$$,$$$,$$_.__-",temp_buf,R_DOUBLE) ;
	mkln(57,temp_buf,15) ; 
	if( prnt_line() < 0) return(-1) ;

	if (SHORT_CHQS || MED_CHQS) 
		if (prnt_line() < 0) return(-1) ;
	if(MED_CHQS) 
		if (prnt_line() < 0) return(-1) ;

	for( i=0; i<=2 ;i++)    		/* print blank lines */
		if( prnt_line() < 0) return(-1) ;
	mkln(7,supp_rec.s_name,48);
	if( prnt_line() < 0) return(-1) ;
	/* Address Line 1	*/
	if (strcmp(supp_rec.s_add1,"")){
		mkln(7,supp_rec.s_add1,30);
		if( prnt_line() < 0) return(-1) ;
	}	
	else{
		if (strcmp(supp_rec.s_add2,"")){
			mkln(7,supp_rec.s_add2,30);
			if( prnt_line() < 0) return(-1) ;
			if (strcmp(supp_rec.s_add3,"")){
				mkln(7,supp_rec.s_add3,30);
				if( prnt_line() < 0) return(-1) ;
				mkln(7,supp_rec.s_pc,10);
				if( prnt_line() < 0) return(-1) ;
				return(NOERROR) ;
			}	
			else{
				mkln(7,supp_rec.s_pc,10);
				if( prnt_line() < 0) return(-1) ;
				return(NOERROR) ;
			}	
		}
		else{
			if (strcmp(supp_rec.s_add3,"")){
				mkln(7,supp_rec.s_add3,30);
				if( prnt_line() < 0) return(-1) ;
				mkln(7,supp_rec.s_pc,10);
				if( prnt_line() < 0) return(-1) ;
				return(NOERROR) ;
			}	
			else{
				mkln(7,supp_rec.s_pc,10);
				if( prnt_line() < 0) return(-1) ;
				return(NOERROR) ;
			}	
		}
	}
	/* Address Line 2	*/
	if (strcmp(supp_rec.s_add2,"")){
		mkln(7,supp_rec.s_add2,30);
		if( prnt_line() < 0) return(-1) ;
	}	
	else{
		if (strcmp(supp_rec.s_add3,"")){
			mkln(7,supp_rec.s_add3,30);
			if( prnt_line() < 0) return(-1) ;	
			mkln(7,supp_rec.s_pc,10);
			if( prnt_line() < 0) return(-1) ;
			return(NOERROR) ;
		}
		else{
			mkln(7,supp_rec.s_pc,10);
			if( prnt_line() < 0) return(-1) ;
			return(NOERROR) ;
		}	
	}
	/* Address Line 3	*/
	if (strcmp(supp_rec.s_add3,"")){
		mkln(7,supp_rec.s_add3,30);
		if( prnt_line() < 0) return(-1) ;
	}
	else{
		mkln(7,supp_rec.s_pc,10);
		if( prnt_line() < 0) return(-1) ;
		return(NOERROR) ;
	}

	mkln(7,supp_rec.s_pc,10);
	if( prnt_line() < 0) return(-1) ;

	return(NOERROR) ;
}
/*----------------------------------------------------------------------------*/
PrintCancel() 
{
	int	i ;

	for( i=0; i<= NO_OF_ITEMS - 7; i++) 
		if( prnt_line() < 0) return(-1) ;

	if (SHORT_CHQS) {
		for( i= 0; i<=4 ; i++) {
			if( prnt_line() < 0) return(-1) ;
		}
	}

	for( i= 0; i<=4 ; i++) {
#ifdef ENGLISH
		mkln(48,"**** C A N C E L ****",21) ;
#else
		mkln(48,"****A N N U L E R****",21) ;
#endif
		if( prnt_line() < 0) return(-1) ;
	}
	return(NOERROR);
}

/*----------------------------------------------------------------------------*/
/*  Initialize Register and Cheque History records 			      */
InitRecords()
{
	int	retval ;

	retval = CheckSupp(chq_rec.c_supp_cd) ;
	if (retval < 0) return(retval) ;

	InitChqHist() ;
	InitRegister() ;

	return(NOERROR) ;
}
/*----------------------------------------------------------------------------*/
InitChqHist()
{
	chq_hist.ch_sys[0] = AP_SYS ;
	STRCPY(chq_hist.ch_accno, s_sth.s_acct) ;
	chq_hist.ch_chq_no = temp_chq_no ;
	chq_hist.ch_funds = chq_rec.c_funds ;
	chq_hist.ch_date = s_sth.s_chq_date ;
	chq_hist.ch_net_amt = 0 ;
	STRCPY( chq_hist.ch_name, supp_rec.s_name) ;
	if( chq_rec.c_cancelled[0] == YES ) 
		chq_hist.ch_status[0] = CANCELLED ;
	else
		chq_hist.ch_status[0] = OUTSTANDING ;
}
/*----------------------------------------------------------------------------*/
InitRegister() 
{
	reg_rec.cr_funds = chq_rec.c_funds ;
	reg_rec.cr_chq_no = temp_chq_no ;
	reg_rec.cr_date = s_sth.s_chq_date ;
	STRCPY( reg_rec.cr_supp_cd, chq_rec.c_supp_cd ) ;
	reg_rec.cr_chq_type[0] = chq_rec.c_chq_type[0] ;
	reg_rec.cr_cancelled[0] = chq_rec.c_cancelled[0] ;
	reg_rec.cr_sys[0] = AP_SYS ;
	reg_rec.cr_disc_taken = 0.00 ;
	reg_rec.cr_gr_amt = 0.00 ;
}
/*----------------------------------------------------------------------------*/
/* Writes Cheque History and Cheque Register records.			      */
WriteRecords()
{
	int	retval ;

	if( UpdtSupplier()<0) {		/* Update discount field */
		DispError(e_mesg) ;
		roll_back(e_mesg);
		return(-1);
	}

	if( UpdtHistory()<0) {		/* Write Chq History record */
		DispError(e_mesg) ;
		roll_back(e_mesg);
		return(-1);
	}

	if( UpdtRegister()<0) {		/* Write Register Record */
		DispError(e_mesg) ;
		roll_back(e_mesg);
		return(-1);
	}

	if( reg_rec.cr_chq_type[0] == REGULAR && 
			reg_rec.cr_cancelled[0] == NO ) {
		if( UpdtControl()<0) {
			DispError(e_mesg) ;
			roll_back(e_mesg);
			return(-1);
		}
	}

	if( commit(e_mesg)<0 ){	/* If everything goes right, commit */
		DispError(e_mesg) ;
		return(-1);
	}

	retval = LockGlRecords() ;
	if (retval < 0) return(retval) ;

	total_gross = total_disc = 0.00 ;

	return(NOERROR) ;
}
/*-----------------------------------------------------------------------*/ 
/* Initialize Gl Trans. Header and item with necessary information */

UpdtGlTran()
{
	int	err ;
#ifdef	ORACLE
	long	get_maxsno(), sno ;
#endif

	parm_date = get_date() ;

	/* generate the Unique Trans key */
	tr_hdr.th_fund = ctl_rec.fund ;
	tr_hdr.th_reccod = 99 ;
	tr_hdr.th_create[0] = 'G';
#ifndef	ORACLE
	tr_hdr.th_seq_no = 32767 ; 
	
	flg_reset( GLTRHDR ) ;

	err = get_n_trhdr(&tr_hdr, BROWSE, 0, BACKWARD, e_mesg) ;
	seq_over( GLTRHDR );
	if(err < 0 && err != EFL) return(DBH_ERR) ;
	/* If EFL or Key Cahnged */
	if(err == EFL || tr_hdr.th_fund != ctl_rec.fund || 
				tr_hdr.th_reccod != 99 ||
				tr_hdr.th_create[0] != 'G') {
		tr_hdr.th_fund = ctl_rec.fund ;
		tr_hdr.th_reccod = 99 ;
		tr_hdr.th_create[0] = 'G';
		tr_hdr.th_seq_no = 1 ;
	}
	else
		tr_hdr.th_seq_no++ ;
#else
	sno = get_maxsno(GLTRHDR, (char*)&tr_hdr, 0, -1, e_mesg) ;
	if(sno < 0) return(DBH_ERR) ;
	tr_hdr.th_seq_no = sno + 1 ;
#endif

	STRCPY(tr_hdr.th_userid, User_Id) ;
	tr_hdr.th_sys_dt = parm_date ;
	tr_hdr.th_period = pa_rec.pa_cur_period ;
	tr_hdr.th_date = get_date() ;
	tr_hdr.th_debits = ordinary_amt + contract_amt ; 
	tr_hdr.th_credits = bank_amt + disc_amt;

	tr_hdr.th_debits = D_Roundoff( tr_hdr.th_debits );
	tr_hdr.th_credits = D_Roundoff( tr_hdr.th_credits);

#ifdef ENGLISH
	STRCPY(tr_hdr.th_descr, "Cheque Run ") ;
#else
	STRCPY(tr_hdr.th_descr, "Impression des cheques") ;
#endif
	tr_hdr.th_type[0] = '6' ;	/* Invoice */

	tr_hdr.th_supp_cd[0] = '\0' ;
#ifdef ENGLISH
	STRCPY(tr_hdr.th_reference, "Cheque Run ") ;
#else
	STRCPY(tr_hdr.th_reference, "Impression des cheques") ;
#endif

	err = put_trhdr(&tr_hdr,ADD,e_mesg) ;
	if (err < 0) return(err) ;

	/* Initialize Item */
	tr_item.ti_fund = tr_hdr.th_fund ;
	tr_item.ti_reccod = tr_hdr.th_reccod ;
	tr_item.ti_create[0] = 'G';
	tr_item.ti_seq_no = tr_hdr.th_seq_no ;
	tr_item.ti_item_no = 0 ;
	tr_item.ti_sys_dt = tr_hdr.th_sys_dt ;
	tr_item.ti_period = tr_hdr.th_period ;
	tr_item.ti_status = 0 ;

	if (ordinary_amt != 0.00 ) {
		err = CheckGlAcnt(ctl_rec.ap_gen_acnt,UPDATE) ;
		if(err < 0) return(err) ;
		ordinary_amt = D_Roundoff(ordinary_amt);
		err = WriteItem(ordinary_amt) ;
		if(err < 0) return(err); 
	}
	if (contract_amt != 0.00 ) {
		err = CheckGlAcnt(ctl_rec.ap_cnt_acnt,UPDATE) ;
		if(err < 0) return(err) ;
		contract_amt =  D_Roundoff(contract_amt);
		err = WriteItem(contract_amt) ;
		if(err < 0) return(err) ;
	}
	if (disc_amt != 0.00 ) {
		err = CheckGlAcnt(ctl_rec.dis_acnt,UPDATE) ;
		if(err < 0) return(err) ;
		disc_amt = D_Roundoff(disc_amt);
		err = WriteItem(-(disc_amt)) ;
		if(err < 0) return(err) ;
	}
	if (bank_amt != 0.00 ) {
		err = CheckGlAcnt(s_sth.s_acct,UPDATE) ;	
		if(err < 0) return(err) ;
		bank_amt = D_Roundoff(bank_amt);
		err = WriteItem(-(bank_amt)) ;
		if(err < 0) return(err) ;
	}
	
	return(NOERROR) ;
}	/* InitGlTrans() */
/*-----------------------------------------------------------------------*/ 
/* Create the Gl Trans. Item for given amount and type */

WriteItem(amount)
double	amount ;
{
	int	err ;

	tr_item.ti_item_no++ ;
	STRCPY(tr_item.ti_accno, gl_rec.accno) ;
	tr_item.ti_amount = amount ;
	tr_item.ti_section = gl_rec.sect ;

	/* Update the GL Master record */
	gl_rec.currel[pa_rec.pa_cur_period - 1] += tr_item.ti_amount ;
	gl_rec.ytd += tr_item.ti_amount ;
	if(amount > 0.00)
		gl_rec.curdb += amount ;
	else
		gl_rec.curcr += amount ;

	gl_rec.currel[pa_rec.pa_cur_period - 1] =
		D_Roundoff( gl_rec.currel[pa_rec.pa_cur_period - 1] );
	gl_rec.ytd = D_Roundoff(gl_rec.ytd);
	gl_rec.curdb = D_Roundoff(gl_rec.curdb); 
	gl_rec.curcr = D_Roundoff(gl_rec.curcr);

	err = put_tritem(&tr_item, ADD, e_mesg) ;
	if(err < 0) return(err) ;

	/* Update The GL Account */
	err = put_gl(&gl_rec,UPDATE,e_mesg) ;
	if(err < 0) return(err) ;

	return(NOERROR) ;
}	/* WriteItem() */
	
/*----------------------------------------------------------------------------*/
UpdtControl()
{
	if( chq_no == s_sth.s_chq_no ) return(NOERROR) ;

	if( (strcmp(s_sth.s_acct, ctl_rec.bank1_acnt)) == 0 ) 
		ctl_rec.bank1_chq = chq_no;
	else
		ctl_rec.bank2_chq = chq_no;

	return(put_ctl(&ctl_rec,UPDATE,e_mesg)) ;
}
/*----------------------------------------------------------------------------*/
/* Update supplier discount only if supplier is an ordinary supplier.         */
UpdtSupplier()
{
	int retval ;
	
	/* Don't touch Supplier unless there is a discount */
	if(total_disc == 0.00) return(NOERROR);

	STRCPY( supp_rec.s_supp_cd, reg_rec.cr_supp_cd ) ;
	retval = get_supplier(&supp_rec,UPDATE,0,e_mesg) ;
	if( retval < 0) { 
		DispError(e_mesg) ;
		return(retval) ;
	}

	if( supp_rec.s_type[0] == CONTRACT ) 
		return(NOERROR) ;

	supp_rec.s_ytd_disc += total_disc ;
	supp_rec.s_ytd_disc = D_Roundoff(supp_rec.s_ytd_disc); 

	retval = put_supplier(&supp_rec,UPDATE,e_mesg) ;
	if (retval < 0) {
		DispError(e_mesg) ;
		return(retval) ;
	}
	return(NOERROR) ;
}
UpdtAphist()
{
	int 	retval ;

	invoice.in_funds = chq_rec.c_funds ;
	STRCPY( invoice.in_supp_cd, chq_rec.c_supp_cd ) ;
	STRCPY( invoice.in_invc_no, chq_rec.c_invc_no ) ;
	STRCPY( invoice.in_tr_type, chq_rec.c_tr_type ) ;

	retval = get_invc(&invoice,BROWSE,1,e_mesg) ;
	if (retval < 0) {
		DispError(e_mesg) ;
		roll_back(e_mesg) ;
		return(retval) ;
	}
	if( invoice.in_pmtcode[0] == COMPLETE) {	/* Flag as */
		retval = FlagHistoryPaid(PAID_Y) ;		/* paid  */
		if (retval < 0) {
			DispError(e_mesg) ;
			roll_back(e_mesg) ;
			return(retval) ;
		}
	}
	if( chq_rec.c_cancelled[0] == YES ) {
		if (invoice.in_pmtcode[0] != COMPLETE) {
			retval = FlagHistoryPaid(PAID_N) ;	/* paid  */
			if (retval < 0) {
				DispError(e_mesg) ;
				roll_back(e_mesg) ;
				return(retval) ;
			}
		}
	}
	retval = WriteAphist() ;	/* Create New Record */
	if (retval < 0) {
		DispError(e_mesg) ;
		roll_back(e_mesg) ;
		return(retval) ;
	}

	return(NOERROR) ;
}
/*---------------------------------------------------------------------------*/
/*  Flag all aphist records for that invoice as paid . 			     */
FlagHistoryPaid(paid)
char	*paid; 
{
	int	retval ;

	STRCPY(aphist.a_supp_cd, chq_rec.c_supp_cd) ;
	aphist.a_chq_no = chq_rec.c_cp_chq_no;
	aphist.a_sno = 0 ;
	flg_reset( APHIST );

	for( ; ; ) {
#ifndef	ORACLE
		retval = get_n_aphist(&aphist,BROWSE,3,FORWARD,e_mesg) ;
#else
		retval = get_n_aphist(&aphist,BROWSE,3,EQUAL,e_mesg) ;
#endif
		if (retval == EFL) break;
		if (retval < 0) {
			DispError(e_mesg) ;
			return(retval) ;
		}
#ifndef	ORACLE
		if ( ((strcmp(aphist.a_supp_cd, chq_rec.c_supp_cd)) != 0) ||
		     aphist.a_chq_no != chq_rec.c_cp_chq_no )
			break ;
#endif

		retval = get_aphist(&aphist,UPDATE,0,e_mesg) ;
		if (retval < 0) {
			DispError(e_mesg) ;
			return(retval) ;
		}

		aphist.a_paid[0] = paid[0] ;
		retval = put_aphist(&aphist,UPDATE,e_mesg) ;
		if (retval < 0) {
			DispError(e_mesg) ;
			return(retval) ;
		}
		aphist.a_sno++ ;
	}
	seq_over( APHIST );
	return(NOERROR) ;
}
/*---------------------------------------------------------------------------*/
/*  Write Aphist record for the cheque that was just printed .		     */
WriteAphist()
{
	int	retval ;
	retval = GetUniqueNo() ;
	if (retval < 0) return(retval) ;

	if (invoice.in_pmtcode[0] == COMPLETE ) 
		aphist.a_paid[0] = YES ;
	else
		aphist.a_paid[0] = NO ;
	aphist.a_tr_date = invoice.in_invc_dt ;
	aphist.a_period = invoice.in_period ;
	aphist.a_po_no = invoice.in_po_no ;
	aphist.a_chq_no = chq_rec.c_cp_chq_no ;
	aphist.a_fund = chq_rec.c_funds ;
	STRCPY( aphist.a_accno, s_sth.s_acct );
	aphist.a_disc_taken = chq_rec.c_disc_taken ;
	aphist.a_gr_amt = chq_rec.c_gr_amt ;

	aphist.a_gr_amt = D_Roundoff(aphist.a_gr_amt);	

	return( put_aphist(&aphist,ADD,e_mesg) ) ;
}
/*---------------------------------------------------------------------------*/
/*  Get Next Serial No for the supplier-Invoice-tran type 	    	     */
GetUniqueNo()
{
	int err ;
#ifdef	ORACLE
	long	get_maxsno(), sno ;
#endif

	/* Change to be Original Supplier not Payee 
	STRCPY(aphist.a_supp_cd, chq_rec.c_supp_cd) ;
	**********/
	STRCPY(aphist.a_supp_cd, invoice.in_orgsupp_cd) ;

	STRCPY(aphist.a_invc_no, chq_rec.c_invc_no) ;
	STRCPY(aphist.a_tr_type, chq_rec.c_tr_type) ;
#ifndef	ORACLE
	aphist.a_sno = 32767 ; 

	flg_reset( APHIST ) ;
	err = get_n_aphist(&aphist, BROWSE, 0, BACKWARD, e_mesg) ;
	seq_over( APHIST );
	if(err < 0 && err != EFL) return(DBH_ERR) ;
	/* If EFL or Key Changed */
	if(err == EFL || strcmp(invoice.in_orgsupp_cd, aphist.a_supp_cd ) ||
		         strcmp(chq_rec.c_invc_no, aphist.a_invc_no ) ||
			 strcmp(chq_rec.c_tr_type, aphist.a_tr_type ) ) { 
		STRCPY(aphist.a_supp_cd, invoice.in_orgsupp_cd) ;
		STRCPY(aphist.a_invc_no, chq_rec.c_invc_no) ;
		STRCPY(aphist.a_tr_type, chq_rec.c_tr_type) ;
		aphist.a_sno = 1 ;
	}
	else
		aphist.a_sno++ ;
#else
	sno = get_maxsno(APHIST, (char*)&aphist, 0, -1, e_mesg) ;
	if(sno < 0) return(DBH_ERR) ;
	aphist.a_sno = sno + 1 ;
#endif

	return(NOERROR) ;
}
/*----------------------------------------------------------------------------*/
UpdtHistory()
{
	int 	retval ;

	if( reg_rec.cr_cancelled[0] == YES ) { 
		retval = get_chqhist(&chq_hist,UPDATE,0,e_mesg) ;
		if (retval < 0) {
#ifdef ENGLISH
			fomer("Cheque History Record cannot be cancelled") ;
#else
			fomer("Fiche de l'historique des cheques ne peut pas etre annulee") ;
#endif
			return(retval) ;
		}
		chq_hist.ch_net_amt = total_gross - total_disc ; 
		chq_hist.ch_net_amt = D_Roundoff(chq_hist.ch_net_amt);
		chq_hist.ch_status[0] = CANCELLED ;
		return(put_chqhist(&chq_hist,UPDATE,e_mesg)) ;
	}
	else {
		chq_hist.ch_net_amt = total_gross - total_disc ; 
		chq_hist.ch_net_amt = D_Roundoff(chq_hist.ch_net_amt);
		return(put_chqhist(&chq_hist,ADD,e_mesg)) ;
	}

}
/*----------------------------------------------------------------------------*/
UpdtRegister() 
{
	reg_rec.cr_disc_taken = total_disc ;
	reg_rec.cr_gr_amt = total_gross ;
	
	reg_rec.cr_disc_taken = D_Roundoff(reg_rec.cr_disc_taken);
	reg_rec.cr_gr_amt = D_Roundoff(reg_rec.cr_gr_amt);

	return(put_reg(&reg_rec,ADD,e_mesg)) ;
}
/*-----------------------------------------------------------------------*/
ProcessDtl()
{
	int	retval ;

	if( (reg_rec.cr_chq_type[0] == REGULAR) &&
	    (reg_rec.cr_cancelled[0] == NO) ) {
		retval = PrintCheque() ;
		if (retval < 0) return(retval) ;
		rite_top();
	}
	UpdtSummary() ;	/* Updt summary to print on screen */
	retval = WriteRecords() ;
	if (retval < 0) return(retval) ;

	return(NOERROR) ;
}
/*-----------------------------------------------------------------------*/
/*                                                                       */
/* Reads the fields in the range given in the parameters.                */
ReadFields(begin,end)
int 	begin, end;
{
	int err ;
	sr.nextfld = begin;
	sr.endfld = end;

	for(; ;) {
		fomrd((char*)&s_sth);
		ret(err_chk(&sr));

		if(sr.retcode == RET_VAL_CHK){
			err = Validation() ; 
			if( DBH_ERR == err || PROFOM_ERR == err) return(err);
			sr.nextfld = sr.curfld ;
			continue;
		}

		if(sr.retcode == RET_USER_ESC){
			if(sr.escchar[0] == 'F' || sr.escchar[0] == 'f') { 
				return(EXIT);
			}
			continue;
		}
		break;
	}			/* end of for loop */
	return(NOERROR) ;
} 	/* end of ReadFields */

/*-----------------------------------------------------------------------*/
/*                                                                       */
/* Writes the fields in the range given in the parameters.               */

WriteFields(begin,end)
int 	begin, end;
{
	sr.nextfld = begin;
	sr.endfld = end;

	fomwr((char*)&s_sth);
	ret(err_chk(&sr));

	return(NOERROR);

}	/* end of WriteFields */
/*----------------------------------------------------------------*/
/* Validation function() for Key and Header fields when PROFOM returns
  RET_VAL_CHK */

static int
Validation()
{
	int	err,	begin_fld,	end_fld ;

	switch(sr.curfld){
	case	FUND_FLD	:	/* Fund :	*/
		err = CheckFund(s_sth.s_funds,UPDATE) ;
		if(DBH_ERR == err) return(DBH_ERR) ;
		if(err < 0) {
			s_sth.s_funds = LV_SHORT ;
			return(ERROR) ;
		}
		fomer(ctl_rec.desc);
		begin_fld = sr.curfld ;
		end_fld = sr.endfld ;
		STRCPY( s_sth.s_acct, ctl_rec.bank1_acnt) ;
		WriteFields( ACCT_FLD, ACCT_FLD ) ;
		s_sth.s_acct[0] = LV_CHAR ;
		sr.curfld = begin_fld ;
		sr.endfld = end_fld ;
		break ;
	case	ACCT_FLD	:	/* Acct No:	*/
		if (acnt_chk(s_sth.s_acct) < 0)  {
			s_sth.s_acct[0] = LV_CHAR ;
#ifdef ENGLISH
			fomer("Invalid GL Account Number");
#else
			fomer("Numero de compte G/L invalide");
#endif
			return(ERROR) ;
		}
		if( ((strcmp(s_sth.s_acct, ctl_rec.bank1_acnt)) != 0) &&
		    ((strcmp(s_sth.s_acct, ctl_rec.bank2_acnt)) != 0) ) {
#ifdef ENGLISH
			fomer("Must be a Bank Account Number") ;
#else
			fomer("Doit etre un numero de compte de banque") ;
#endif
			s_sth.s_acct[0] = LV_CHAR ;
			return(ERROR) ;
		}
		err = LockGlRecords() ;
		if(err < 0) {
			s_sth.s_acct[0] = LV_CHAR ;
			return(ERROR) ;
		}
		fomer(gl_rec.desc);
		if( (strcmp(s_sth.s_acct, ctl_rec.bank1_acnt)) == 0 ) 
			w_chq_no = ctl_rec.bank1_chq ;
		else
			w_chq_no = ctl_rec.bank2_chq ;
			
		begin_fld = sr.curfld ;
		end_fld = sr.endfld ;
		s_sth.s_chq_no = w_chq_no ;
		WriteFields( CHQNO_FLD, CHQNO_FLD ) ;
		s_sth.s_chq_no = LV_LONG ;
		sr.curfld = begin_fld ;
		sr.endfld = end_fld ;
		break ;
	case	CHQNO_FLD	:	/* Cheque no: */
		if(s_sth.s_chq_no < w_chq_no) { 
#ifdef ENGLISH
			fomer("Cheque Number must be greater than last cheque number");
#else
			fomer("Numero de cheque doit etre plus gros que le dernier numero de cheque");
#endif
			s_sth.s_chq_no = LV_LONG;
			return(ERROR) ;
		}
		begin_fld = sr.curfld ;
		end_fld = sr.endfld ;
		s_sth.s_chq_date = get_date() ;
		WriteFields( CHQDATE_FLD, CHQDATE_FLD ) ;
		s_sth.s_chq_date = LV_LONG ;
		sr.curfld = begin_fld ;
		sr.endfld = end_fld ;
		break ;
	default :
#ifdef ENGLISH
		sprintf(e_mesg,"No Validity Check For Field#  %d",sr.curfld);
#else
		sprintf(e_mesg,"Pas de controle de validite pour le Champ#  %d",sr.curfld);
#endif
		fomen(e_mesg);
		get();
		return(ERROR) ;
	}	/* Switch sr.curfld */

	return(NOERROR) ;
}	/* Validation() */
/*----------------------------------------------------------------*/
/* Check the given funds availability in file */

CheckFund(fund,mode)
short	fund ;
int	mode ;
{
	int	err ;

	ctl_rec.fund = fund ;

	err = get_ctl(&ctl_rec, mode, 0, e_mesg) ;
	if(ERROR == err) return(DBH_ERR);
	if(err < 0) {
		fomer(e_mesg) ;
		return(ERROR) ;
	}
	return(NOERROR) ;
}	/* CheckFund() */
/*---------------------------------------------------------------*/
/* Lock Ordinary, Contract, Bank and discount records from the   */
/* chart of accounts 						 */
LockGlRecords()
{
	int 	err ;

	err = CheckGlAcnt(ctl_rec.ap_gen_acnt,UPDATE) ;
	if(DBH_ERR == err) return(DBH_ERR) ;
	if(err < 0) return(ERROR) ;

	err = CheckGlAcnt(ctl_rec.ap_cnt_acnt,UPDATE) ;
	if(DBH_ERR == err) return(DBH_ERR) ;
	if(err < 0) return(ERROR) ;

	err = CheckGlAcnt(ctl_rec.dis_acnt,UPDATE) ;
	if(DBH_ERR == err) return(DBH_ERR) ;
	if(err < 0) return(ERROR) ;
	
	err = CheckFund(s_sth.s_funds,UPDATE) ;
	if(DBH_ERR == err) return(DBH_ERR) ;
	if(err < 0) return(ERROR) ;

	err = CheckGlAcnt(s_sth.s_acct,UPDATE) ;
	if(DBH_ERR == err) return(DBH_ERR) ;
	if(err < 0) return(ERROR) ;

	return(NOERROR) ;
}
/*----------------------------------------------------------------*/
/* Check the given GL account availability in file */

CheckGlAcnt(accno,mode)
char	*accno ;
int	mode ;
{
	int	err ;

	gl_rec.funds = s_sth.s_funds ;
	STRCPY( gl_rec.accno, accno);
	gl_rec.reccod = 99;
	err = get_gl(&gl_rec, mode, 0, e_mesg) ;
	if(ERROR == err) return(err);
	if(err < 0) {
		DispError(e_mesg) ;
		return(ERROR) ;
	}
	return(NOERROR) ;
}	/* CheckGlAcnt() */
/*----------------------------------------------------------------*/
/* Check the given supplier availability in file */

CheckSupp(supp_cd)
char	*supp_cd ;
{
	int	err ;

	STRCPY(supp_rec.s_supp_cd, supp_cd) ;
	err = get_supplier(&supp_rec, BROWSE, 0, e_mesg) ;
	if(ERROR == err) return(DBH_ERR) ;
	if(err < 0) {
		fomer(e_mesg) ;
		get();
		return(ERROR) ;
	}

	return(NOERROR) ;
}	/* CheckSupp() */
/*-----------------------------------------------------------------------*/
/*                                                                       */
Confirm() 
{
	int	err ;

	for( ; ; ) {
		if(!SW3) {
#ifdef ENGLISH
			err = GetOpt("Y(es), E(dit), C(ancel)", "YEC");
#else
			err = GetOpt("O(ui), M(odifier), A(nnuler)", "OMA");
#endif
		}
		else {
#ifdef ENGLISH
			err = GetOpt("Y(es), E(dit)", "YE");
#else
			err = GetOpt("O(ui), M(odifier)", "OM");
#endif
		}
		if(err == PROFOM_ERR) return(err) ;

		switch(err) {
		case  YES :
			return(YES) ;
		case  EDIT  :
			err = ReadInfo();
			break ;
		case  CANCEL :
#ifdef ENGLISH
			err = GetOpt("Confirm the Cancel (Y/N)?", "YN") ;
#else
			err = GetOpt("Confirmer l'annulation (O/N)?", "ON") ;
#endif
			if(err == YES) { 
				roll_back(e_mesg) ;	/* Unlock  Records */
				return(CANCEL) ;
			}
			break ;
		}	/* switch err */

		if(err == PROFOM_ERR) return(err) ;
		if(err == DBH_ERR) return(err) ;
	}	/* for(; ; ) */
}	/* Confirm() */

/*-----------------------------------------------------------------------*/
/*                                                                       */
/* Display message and get the option */
GetOpt( msg, option )
       char *msg;
       char *option;
{
        int	j,  i;
	
        STRCPY( s_sth.s_mesg, msg );
        ShowMesg();

	for ( ; ; ) {
		s_sth.s_opt[0] = LV_CHAR ;
		if ( ReadFields(MESG_FLD, MESG_FLD) < 0 ) return(-1);
                j = strlen(option);
		for ( i = 0; i < j; i++ ) 
			if ( s_sth.s_opt[0] == option[i ] )
                           break;
                if(i != j) break ;
#ifdef  ENGLISH
                fomer( " Invalid Option." );
#else
                fomer( "Option invalide." );
#endif
	}
        s_sth.s_mesg[0] = HV_CHAR ;
        s_sth.s_opt[0] = HV_CHAR ;
	if ( WriteFields(MESG_FLD -100, MESG_FLD) < 0 ) return(-1);
 
        return( (int)(option[i])) ;
}  /* GetOpt */
/*-----------------------------------------------------------------------*/
/*                                                                       */
/* show ERROR and wait 							 */
DispError(s)    
char *s;
{
        STRCPY( s_sth.s_mesg, s) ;
	ShowMesg();
	get();
	s_sth.s_mesg[0] = HV_CHAR;
	ShowMesg();
	return(ERROR);
}
/*-----------------------------------------------------------------------*/
/*                                                                       */
/* show or clears message field 					 */
ShowMesg()  
{
	sr.nextfld = MESG_FLD - 100;
        fomwf((char*)&s_sth);
}
/*-------------------- E n d   O f   P r o g r a m ---------------------*/

