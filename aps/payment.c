/*------------------------------------------------------------------------
Source Name: payment.c
System     : Accounts Payables.
Created  On: 10th November 89.
Created  By: CATHY BURNS.

DESCRIPTION:
	Program to enter Manual/Partial/Stop Payments.

MODIFICATIONS:        

Programmer     YY/MM/DD       Description of modification
~~~~~~~~~~     ~~~~~~~~       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
F.Tao 	       1990/12/18	Round up amounts before writing to file.
C.Leadbeater   1991/01/31	In edit mode, allow all fields for Manual,
			       	1&2 for Stop, and 1,2&3 for Partial.
------------------------------------------------------------------------*/

#include <stdio.h>
#include <cfomstrc.h>
#include <bfs_defs.h>
#include <bfs_recs.h>
#include <apinvc.h>

/* User Interface define constants */
#ifdef ENGLISH
#define ADDREC		'A'
#define EXITOPT		'E'

#define	YES		'Y'
#define	EDIT		'E'
#define	CANCEL		'C'
#else
#define ADDREC		'R'
#define EXITOPT		'F'

#define	YES		'O'
#define	EDIT		'M'
#define	CANCEL		'A'
#endif
/* PROFOM Releted declarations */

#define	SCR_NAME	"payment"	/* PROFOM screen Name */

/* line numbers for edit mode */

#define	MANU_PMT_LIM	5	/* edit limit for manual payment */
#define	STOP_PMT_LIM 	2	/* edit limit for stop payment */
#define	PART_PMT_LIM	3	/* edit	limit for partial payment */

/* Field PROFOM numbers */
#define	FN_FLD		400	/* Fn: */
#define	KEY_START	500	/* Supplier Cd: */
#define	KEY_END		600	/* Type: */
#define	CHG_FLD		700	/* Field: */

#define INV_START 	900	/* Start Field of the screen */
#define INV_END		1000	/* Last Field for invoice key entry */
#define START_FLD 	1100	/* Start Field of the screen */
#define	SCR_END_FLD	1500	/* Last Field of the screen */

#define TRANS_FLD	500	/* Transaction : */
#define	SUPPCD_FLD	600	/* Supplier Cd: */
#define INV_FLD		900
#define	TYPE_FLD	1000	/* Type: */
#define TOTAL_FLD	1100 	/* Total amount: */
#define CHQNO_FLD	1200 	/* Cheque No : */
#define ACCNO_FLD	1300 	/* Bank Acct# : */

/* payment.sth - header for C structure generated by PROFOM EDITOR */

typedef struct	{

	char	s_pgm[11];	/* STRING XXXXXXXXXX Field 100 */
	long	s_rundate;	/* DATE 9999F99F99 Field 300*/
	char	s_fn[2];	/* STRING X Field 400*/
	char	s_trans[2];	/* STRING X Field 500 */
	char	s_supp_cd[11];	/* NUMERIC 999999 Field 600 */
	short	s_field;	/* NUMERIC 999 Field 700 */
	char	s_invc_no[16];	/* STRING XXXXXXXXXX Field 900 */
	char	s_tr_type[3];	/* STRING XX Field 1000 */
	double	s_amt;		/* NUMERIC 99F999F999.99 Field 1100 */
	long	s_chq_no;	/* NUMERIC 99999999 Field 1200 */
	char	s_accno[19];	/* STRING X[18] Field 1300 */
	char	s_mesg[78];	/* STRING X(78) Field 1400  */
	char	s_resp[2];	/* STRING X Field 1500 */
	} S_STRUCT;


static	S_STRUCT	s_sth;	/* PROFOM Screen Structure */

struct	stat_rec	sr;

int	Validation(),WindowHelp() ;
double  D_Roundoff();
static	int 	err, retval;

Payment()
{
	int 	err, retval;

	retval = InitScreen();		/* Initialization routine */

	if (retval == NOERROR) retval = Process();

	if( retval == DBH_ERR || retval == PROFOM_ERR ) return(retval) ;
	
	return(NOERROR) ;
}

/*----------------------------------------------------------------*/
/* Initialize screen before going to process options */

static int
InitScreen()
{
	int	err ;

	CurrentScr = (char *)&s_sth ;
	END_FLD	= SCR_END_FLD ;

	/* move screen name to Profom status structure */
	STRCPY(sr.scrnam,NFM_PATH);
	strcat(sr.scrnam,SCR_NAME) ;

	STRCPY(s_sth.s_pgm,PROG_NAME);
	s_sth.s_rundate = get_date();	/* get Today's Date in YYYYMMDD format*/
	s_sth.s_field = HV_SHORT ;
	s_sth.s_mesg[0] = HV_CHAR ;
	s_sth.s_resp[0] = HV_CHAR ;

	/* Initialize Key Fields. So that, if user selectes 'N' option
	   immediately after invoking program, then he gets the first
	   record in the file */

	s_sth.s_trans[0] = '\0' ;
	s_sth.s_supp_cd[0] = '\0' ;

	/* Move High Values to data fields and Display the screen */
	err = ClearScreen() ;
	if(NOERROR != err) return(err) ;

	return(NOERROR) ;
}	/* InitScreen() */

/*-------------------------------------------------------------------*/
/* Get Option from user and call corresponding function */

static int
Process()
{
	int err;

	for( ; ; ){

		/* Get the Fn: option from the user */
		if((err = ReadFunction()) != NOERROR) return(err) ;

		err = ProcFunction() ;	/* Process Function */

		if(QUIT == err)		return(NOERROR) ;    /* Exit */
		if(PROFOM_ERR == err)	return(PROFOM_ERR);  /* PROFOM ERROR */
		if(DBH_ERR == err) {
			DispError(e_mesg);
#ifdef ENGLISH
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"System Error... Iserror:",
				iserror, dberror, errno);
#else
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"Erreur du systeme... Iserror:",
				iserror, dberror, errno);
#endif
			DispError(e_mesg);
			return(DBH_ERR); /* DBH ERROR */
		}
	}      /*   end of the for( ; ; )       */
}	/* Process() */
/*----------------------------------------------------------------*/
/* Display the Function (Fn:) options and get the option from the user */

static int
ReadFunction()
{
	/* Display Fn: options */
#ifdef ENGLISH
	fomer("A(dd), E(xit)");
#else
	fomer("R(ajouter), F(in)");
#endif
	/* Read Fn: field to get the option */
	sr.nextfld = FN_FLD ;
	fomrf( (char *)&s_sth );
	ret(err_chk(&sr));	/* Check for PROFOM error */

	return(NOERROR) ;
}	/* ReadFunction() */
/*----------------------------------------------------------------*/
/* Process the user selected Fn: option */

static int
ProcFunction()
{
	switch (s_sth.s_fn[0]) {
	case ADDREC  :			/* ADD */
		return( AddPayment() ) ;
	case EXITOPT  :			/* Exit */
		return( QUIT ) ;
	}  /*   end of the switch statement */


	return(NOERROR);
}	/* ProcFunction() */
/*----------------------------------------------------------------------*/
/* Adding Cheque. Get the unique Key, accept details and update the files */

AddPayment()
{
	int	err ;

	ClearScreen() ;		/* Clear the Screen */

	err = ReadKey();
	if(err != NOERROR) { 
		roll_back(e_mesg) ;
		return(err) ;
	}

	err = ReadInvoice() ;
	if(NOERROR != err) { 
		roll_back(e_mesg) ;
		return(err) ;
	}
	if( (s_sth.s_trans[0] == MANUAL) || (s_sth.s_trans[0] == PARTIAL) )  {
		if (in_rec.in_pmtcode[0] == COMPLETE)  {
#ifdef ENGLISH
			fomen("Invoice status is complete") ;
#else
			fomen("L'etat de la facture est complet") ;
#endif
			get();
			roll_back(e_mesg) ;
			return(err) ;
		}
	    	else if (in_rec.in_pmtcode[0] == REL_HB) {
#ifdef ENGLISH
			fomen("Invoice is in Holdback status") ;
#else
			fomen("La facture est en etat de paiement retenu");
#endif
			get();
			roll_back(e_mesg) ;
			return(err) ;
		}
		if( in_rec.in_pmtcode[0] == PARTIAL && in_rec.in_chq_no != 0 ) {
#ifdef ENGLISH
			fomen("Already Manually Paid") ;
#else
			fomen("Deja paye manuellement") ;
#endif
			get();
			roll_back(e_mesg) ;
			return(err) ;
		}
	}

	if (s_sth.s_trans[0] == MANUAL) {
		/* Get the Control record of this transaction */
		err = CheckFund(in_rec.in_funds) ;
		if(err != NOERROR) return(err) ;
		/* Show the Bank Acct1 as a default acct */
		fomca1(ACCNO_FLD, 19, 2) ;
		STRCPY( s_sth.s_accno, ctl_rec.bank1_acnt) ;
		sr.nextfld = ACCNO_FLD ;
		sr.endfld  = ACCNO_FLD ;
		fomud((char*)&s_sth) ;
		ret(err_chk(&sr)) ;
		s_sth.s_amt = LV_DOUBLE ;
		s_sth.s_chq_no = LV_LONG ;
		s_sth.s_accno[0] = LV_CHAR ;
	}
	else if( s_sth.s_trans[0] == PARTIAL )
		s_sth.s_amt = LV_DOUBLE ;

	err = ReadFields(START_FLD, END_FLD - 200,Validation,WindowHelp,0,ESC_F); 
	if(PROFOM_ERR == err || DBH_ERR == err) {
		roll_back(e_mesg) ;
		return(err) ;
	}
	if(RET_USER_ESC == err) {	/* ESC-F */
		InitFields(HV_CHAR,HV_LONG,HV_DOUBLE) ;

		ret( WriteFields(START_FLD, END_FLD) ) ;

		s_sth.s_mesg[0] = HV_CHAR ;
		ShowMesg() ;
		roll_back(e_mesg) ;
		return(ERROR) ;
	}

	for( ; ; ) {
		err = Confirm() ;
		if (err < 0) { 
			roll_back(e_mesg) ;
			return(err) ;
		}
		if (err == CANCEL) {
			roll_back(e_mesg) ;
			return(CANCEL);
		}

		err = WriteRecords() ;
		if(err==NOERROR) break;
		if(err==LOCKED) {
			roll_back(e_mesg);
			continue;
		}
		if(err<0) return(err);
	}

	return(NOERROR);
}	/* AddPayment() */
/*----------------------------------------------------------------------*/
/* Read the Invoice. Check whether the invoice exists with this key */
ReadInvoice()
{
	int 	retval ;

	s_sth.s_invc_no[0] = LV_CHAR ;
	s_sth.s_tr_type[0] = LV_CHAR ;
	retval = ReadFields(INV_START, INV_END,Validation,WindowHelp,0,ESC_F); 
	if(PROFOM_ERR == retval || DBH_ERR == retval) return(retval) ;
	if(RET_USER_ESC == retval) {	/* ESC-F */
		InitFields(HV_CHAR,HV_LONG,HV_DOUBLE) ;

		ret( WriteFields(INV_START, INV_END) ) ;

		s_sth.s_mesg[0] = HV_CHAR ;
		ShowMesg() ;

		return(ERROR) ;
	}
	return(NOERROR);

}
/*----------------------------------------------------------------------*/
/* Get the po key from user. In ADD mode disable dup buffers, other
   modes enable dup buffers and show the current key as a default key */

static int
ReadKey()
{
	int	i;
	char	save_supp[11] ;

	/* In Add mode turn off dup control for key fields.
	   Other modes reverse it */
	for(i = KEY_START ; i <= KEY_END ; i += 100)
		fomca1(i,19,0) ;	/* Off Dup Control */

	sr.nextfld = KEY_START;
	sr.endfld = KEY_END;
	fomud((char*)&s_sth);	/* Update Dup Buffers */

	/* Store fields to copy back when user gives ESC-F */
	STRCPY(save_supp, s_sth.s_supp_cd) ;

	s_sth.s_trans[0] = LV_CHAR ;
	s_sth.s_supp_cd[0] = LV_CHAR ;

#ifdef ENGLISH
	STRCPY(s_sth.s_mesg,"Key ESC-F to Go Back to Fn:");
#else
	STRCPY(s_sth.s_mesg,"Appuyer sur ESC-F pour retourner a Fn:");
#endif
	ShowMesg();

	i = ReadFields(KEY_START, KEY_END,Validation,WindowHelp,0,ESC_F); 
	if(PROFOM_ERR == i || DBH_ERR == i) return(i) ;
	if(RET_USER_ESC == i){
		/* copy back key fields */
		STRCPY(s_sth.s_supp_cd, save_supp);

		ret( WriteFields(KEY_START, KEY_END) ) ;

		s_sth.s_mesg[0] = HV_CHAR;
		ShowMesg();

		return(RET_USER_ESC) ;
	}

	return(NOERROR);
}	/*  ReadKey() */
/*-----------------------------------------------------------------------*/ 
/* Update the records and write to files */

static int
WriteRecords()
{
	int	retval;

	UpdateSummary();		/* Update Summary Print */

	retval = UpdtInvoice();
	if(retval == LOCKED) return(LOCKED);
	if(retval < 0) {
		DispError(e_mesg) ;
		roll_back(e_mesg);
		return(-1);
	}

	return(0);

}	/* WriteRecords() */

/*-----------------------------------------------------------*/
/* Update the Partition Summary Totals */
static	int
UpdateSummary()
{
	/* make payment a negative */
	if( ((strcmp(s_sth.s_tr_type, T_INVOICE)) == 0) ||
	    ((strcmp(s_sth.s_tr_type, T_CRMEMO)) == 0) )
		s_sth.s_amt = -(s_sth.s_amt) ;

	if( s_sth.s_trans[0] == MANUAL ) {
		ManCheques.no_trans++ ;
		ManCheques.tot_amt += s_sth.s_amt ;
		ManCheques.tot_amt = D_Roundoff(ManCheques.tot_amt);
	}
	else  if( s_sth.s_trans[0] == PARTIAL ) {
		PartPmnt.no_trans++ ;
		PartPmnt.tot_amt += s_sth.s_amt ;
		PartPmnt.tot_amt = D_Roundoff(PartPmnt.tot_amt);
	}

	TotalsUpdated = 1 ;	/* Print Summary Reports, at the end */

	return(NOERROR) ;
}	/* UpdateSummary() */
static
UpdtInvoice()	/* Update Invoice by the amount of transaction */
{
	int retval;
	Invoice	pre_rec ; 

	STRCPY(in_rec.in_supp_cd, s_sth.s_supp_cd) ;
	STRCPY(in_rec.in_invc_no, s_sth.s_invc_no) ;
	STRCPY(in_rec.in_tr_type, s_sth.s_tr_type) ;

	if( s_sth.s_trans[0] == STOPPMT ) {
		retval = StopPayment();
		if(retval == LOCKED) return(LOCKED) ;
		if( retval < 0 ) return(retval) ;
	}
	else {
		retval = get_invc(&in_rec,UPDATE,0,e_mesg) ;
		if( retval == EFL ) {
#ifdef ENGLISH
			fomen("Record no longer exists") ;
#else
			fomen("Fiche n'existe plus");
#endif
			get();
			return(-1) ;
		}
		else
			if( retval < 0 ) return(retval) ;
		scpy((char *)&pre_rec,(char *)&in_rec,sizeof(Invoice)) ;

		in_rec.in_part_amt += s_sth.s_amt ;
		in_rec.in_part_amt = D_Roundoff(in_rec.in_part_amt);

		in_rec.in_pmtcode[0] = s_sth.s_trans[0] ;
		if( in_rec.in_pmtcode[0] == MANUAL ) {
			in_rec.in_pmtcode[0] = PARTIAL ;
			in_rec.in_chq_no = s_sth.s_chq_no ;
			STRCPY(in_rec.in_accno, s_sth.s_accno) ;
		}
		else {
			in_rec.in_chq_no = 0 ;
			in_rec.in_accno[0] = '\0' ;
		}

		retval = put_invc(&in_rec,UPDATE,e_mesg);
		if( retval < 0 ) return(retval) ;
		err = rite_audit((char*)&s_sth, APINVOICE, UPDATE, 
				(char*)&in_rec, (char*)&pre_rec, e_mesg);
		if(err==LOCKED) {
			DispError(e_mesg);
			roll_back(e_mesg);
			return(LOCKED);
		}

		if(err != NOERROR){
#ifdef ENGLISH
			DispError("ERROR in Saving Records"); 
#else
			DispError("ERREUR en conservant les fiches");
#endif
			DispError(e_mesg);
			roll_back(e_mesg);
			InitFields(HV_CHAR, HV_LONG, HV_DOUBLE) ;
			return(DBH_ERR);
		}
		if(commit(e_mesg) < 0) {
#ifdef ENGLISH
			DispError("ERROR in Saving Records"); 
#else
			DispError("ERREUR en conservant les fiches");
#endif
			DispError(e_mesg);
			InitFields(HV_CHAR, HV_LONG, HV_DOUBLE) ;
			return(DBH_ERR);
		}
	}
	
	return(NOERROR);
}
/*  The Stop Payment will stop payments on all supplier invoice entries 
	or for all entries for a supplier and invoice or for only one
	entry. 
**************************************************************************/

StopPayment()
{
	int 	retval ;
	Invoice	pre_rec ;

	flg_reset(APINVOICE);
	for ( ; ; ) {	
		retval = get_n_invc(&in_rec,UPDATE,0,FORWARD,e_mesg);
		if( retval == EFL ) break;
		if( retval < 0) return(retval) ;
		scpy((char *)&pre_rec,(char *)&in_rec,sizeof(Invoice)) ;

		if( (strcmp(s_sth.s_supp_cd, in_rec.in_supp_cd)) != 0 ) {
			roll_back(e_mesg) ;
			break;
		}

		if( s_sth.s_invc_no[0] != '\0' ) { 
			if( (strcmp(s_sth.s_invc_no,in_rec.in_invc_no)) != 0) {
				roll_back(e_mesg) ;
				break;
			}
		}

		if( s_sth.s_tr_type[0] != '\0' ) {
			if( (strcmp(s_sth.s_tr_type,in_rec.in_tr_type)) != 0) {
				roll_back(e_mesg) ;
				break;
			}
		}
		if( (in_rec.in_pmtcode[0] == STOPPMT) ||  /* Stop Payment   */
		    (in_rec.in_pmtcode[0] == REL_HB) ||    /* Release */
		    (in_rec.in_pmtcode[0] == COMPLETE)){   /* Complete cannot */
#ifndef	ORACLE
			roll_back(e_mesg) ;
#endif
			continue ;			/* be stopped.     */
		}

		if( in_rec.in_pmtcode[0] == PARTIAL &&	/* Manual Payment */
		    in_rec.in_chq_no != 0 ) { 		/* already exists */
#ifndef	ORACLE
			roll_back(e_mesg) ;
#endif
			continue ;
		}
 
		if( s_sth.s_trans[0] == STOPPMT ) {	/* Update summary */
			StopPmnt.no_trans++ ;
			StopPmnt.tot_amt += in_rec.in_amount ;
		}
	
		in_rec.in_pmtcode[0] = STOPPMT ;
		in_rec.in_chq_no = 0 ;
		in_rec.in_part_amt = 0.00 ;
		retval = put_invc(&in_rec,UPDATE,e_mesg);
		if( retval < 0) return(retval);
		err = rite_audit((char*)&s_sth, APINVOICE, UPDATE, 
				(char*)&in_rec, (char*)&pre_rec, e_mesg);

		if(err==LOCKED) {
			DispError(e_mesg);
			roll_back(e_mesg);
			return(LOCKED);
		}

		if(err != NOERROR){
#ifdef ENGLISH
			DispError("ERROR in Saving Records"); 
#else
			DispError("ERREUR en conservant les fiches");
#endif
			DispError(e_mesg);
			roll_back(e_mesg);
			InitFields(HV_CHAR, HV_LONG, HV_DOUBLE) ;
			return(DBH_ERR);
		}
		if(commit(e_mesg) < 0) {
#ifdef ENGLISH
			DispError("ERROR in Saving Records"); 
#else
			DispError("ERREUR en conservant les fiches");
#endif
			DispError(e_mesg);
			InitFields(HV_CHAR, HV_LONG, HV_DOUBLE) ;
			return(DBH_ERR);
		}
		inc_str( in_rec.in_tr_type, sizeof(in_rec.in_tr_type) - 1,
			 FORWARD);
	}
	seq_over(APINVOICE);
	return(NOERROR);
}
/*----------------------------------------------------------------*/
/* Validation function() for Key and Header fields when PROFOM returns
  RET_VAL_CHK */

static int
Validation()
{
	int	err ;
	double	diff ;

	switch(sr.curfld){
	case	TRANS_FLD	:	/* Trans Type: */
		if( (s_sth.s_trans[0] != MANUAL) &&
		    (s_sth.s_trans[0] != PARTIAL) &&
		    (s_sth.s_trans[0] != STOPPMT) ) {
#ifdef ENGLISH
			fomer("Valid types are M(anual), P(artial), S(top Payment)");
#else
			fomer("Genres valables sont M(anuel), P(artiel), A(rret de paiement)");
#endif
			s_sth.s_trans[0] = LV_CHAR ;
			return(ERROR) ;
		}
		break;
	case	SUPPCD_FLD	:	/* Supplier Cd: */
		err = CheckSupp(s_sth.s_supp_cd, BROWSE) ;
		if(DBH_ERR == err) return(DBH_ERR) ;
		if(err < 0) {
			s_sth.s_supp_cd[0] = LV_CHAR ;
			return(ERROR) ;
		}
		fomer(supp_rec.s_name);
		break ;
	case	TYPE_FLD	:	/* Trans Type: */
		if( (s_sth.s_trans[0] == STOPPMT) &&
		   ((strcmp(s_sth.s_tr_type, "\0")) == 0 )) { 
			sr.curfld += 100 ;
			break;
		}

		if(CheckTransType(s_sth.s_tr_type) == ERROR) {
			s_sth.s_tr_type[0] = LV_CHAR ;
			return(ERROR) ;
		}
		err = CheckInvoice(s_sth.s_supp_cd,s_sth.s_invc_no,s_sth.s_tr_type);
		if(err!=NOERROR) {
			s_sth.s_invc_no[0] = LV_CHAR ;
			s_sth.s_tr_type[0] = LV_CHAR ;
			sr.curfld = INV_START ;
			fomen(e_mesg); get(); return(err);
			
		}

		break ;
	case	CHQNO_FLD	:	/* Cheque no: */
		if(s_sth.s_chq_no < 1) { 
#ifdef ENGLISH
			fomer("Cheque Number must be greater than Zero ");
#else
			fomer("Numero de cheque doit etre plus grand zero ");
#endif
			s_sth.s_chq_no = LV_LONG;
			return(ERROR) ;
		}
		break ;
	case	ACCNO_FLD	:	/* Bank Acct# : */
		if (acnt_chk(s_sth.s_accno) < 0)  {
			s_sth.s_accno[0] = LV_CHAR ;
#ifdef ENGLISH
			fomer("Invalid GL Account Number");
#else
			fomer("Numero de compte G/L invalide");
#endif
			return(ERROR) ;
		}
		if( ((strcmp(s_sth.s_accno, ctl_rec.bank1_acnt)) != 0) &&
		    ((strcmp(s_sth.s_accno, ctl_rec.bank2_acnt)) != 0) ) {
#ifdef ENGLISH
			sprintf(e_mesg,
				"Valid Account Numbers.. BANK1: %s  BANK2: %s",
				ctl_rec.bank1_acnt, ctl_rec.bank2_acnt );
#else
			sprintf(e_mesg,
				"Numeros de comptes valables..BANQUE1: %s  BANQUE2: %s",
				ctl_rec.bank1_acnt, ctl_rec.bank2_acnt );
#endif
			fomer(e_mesg) ;
			s_sth.s_accno[0] = LV_CHAR ;
			return(ERROR) ;
		}
		err = CheckGlAcnt(in_rec.in_funds,s_sth.s_accno,99,BROWSE) ;
		if(DBH_ERR == err) return(err) ;
		if(ERROR == err) {
			s_sth.s_accno[0] = LV_CHAR ;
			return(ERROR) ;
		}
		chqhist.ch_funds = in_rec.in_funds;
		STRCPY( chqhist.ch_accno, s_sth.s_accno );
		chqhist.ch_chq_no = s_sth.s_chq_no;
		err = get_chqhist(&chqhist,BROWSE,0,e_mesg);
		if( err==NOERROR ){
			fomen("Cheque Number Already Exists In Cheque History");
			get();
			s_sth.s_chq_no = LV_LONG ;
			s_sth.s_accno[0] = LV_CHAR ;
			sr.curfld -= 100;
			return(ERROR);
		}
		break ;
	case	TOTAL_FLD	:	/* Amount: */
		if(s_sth.s_amt < DELTA_AMT) { 
#ifdef ENGLISH
			fomer("Cheque Amount can't be Zero");
#else
			fomer("Montant du cheque ne peut pas etre zero");
#endif
			s_sth.s_amt = LV_DOUBLE;
			return(ERROR) ;
		}

		diff = (in_rec.in_amount - in_rec.in_disc_amt)
			  - in_rec.in_part_amt ;
	 	if( ((strcmp(s_sth.s_tr_type, T_CRMEMO)) == 0) || 
		    ((strcmp(s_sth.s_tr_type, T_INVOICE)) == 0) ) {
			if(s_sth.s_amt > -(diff)) {
#ifdef ENGLISH
				fomer("Cheque Amount can't be more than amount remaining in invoice");
#else
				fomer("Montant du cheque ne peut pas etre plus que le montant qui reste dans facture");
#endif
				s_sth.s_amt = LV_DOUBLE;
				return(ERROR) ;
			}
		}
		else {
			if(s_sth.s_amt > diff) {
#ifdef ENGLISH
				fomer("Cheque Amount can't be more than amount remaining in invoice");
#else
				fomer("Montant du cheque ne peut pas etre plus que le montant qui reste dans facture");
#endif
				s_sth.s_amt = LV_DOUBLE;
				return(ERROR) ;
			}
		}
		break ;
	default :
#ifdef ENGLISH
		sprintf(e_mesg,"No Validity Check For Field#  %d",sr.curfld);
#else
		sprintf(e_mesg,"Pas de controle de validite pour le Champ#  %d",sr.curfld);
#endif
		fomen(e_mesg);
		get();
		return(ERROR) ;
	}	/* Switch sr.curfld */

	return(NOERROR) ;
}	/* Validation() */
/*----------------------------------------------------------------*/
/* Check the given GL account availability in file */

CheckInvoice(supplier,invc_no,type)
char	*supplier ;
char	*invc_no ;
char	*type ;
{
	int 	err, cur_fld, end_fld ;
	double  diff ;

	STRCPY(in_rec.in_supp_cd, supplier);
	STRCPY(in_rec.in_invc_no, invc_no);
	STRCPY(in_rec.in_tr_type, type);
	flg_reset(APINVOICE);
	err = get_invc(&in_rec,BROWSE,0,e_mesg);
	if(ERROR == err) return(err);
	if(err < 0) {
		fomer(e_mesg) ;
		return(ERROR) ;
	}
	cur_fld = sr.nextfld ;
	end_fld = sr.endfld ;

       	fomca1( TOTAL_FLD,19,2 );      		/*  disable Dup Control */
	sr.nextfld = TOTAL_FLD ;
	sr.endfld = TOTAL_FLD ;
     	fomud( (char *) &s_sth );
     	ret(err_chk(&sr));
	if( (s_sth.s_trans[0] == MANUAL) || (s_sth.s_trans[0] == PARTIAL) ) {
		diff = (in_rec.in_amount - in_rec.in_disc_amt)
			 - in_rec.in_part_amt ;
	 	if( ((strcmp(s_sth.s_tr_type, T_CRMEMO)) == 0) || 
		    ((strcmp(s_sth.s_tr_type, T_INVOICE)) == 0) ) 
			s_sth.s_amt = -(diff) ;
		else
			s_sth.s_amt = diff ;
				
		s_sth.s_amt = D_Roundoff(s_sth.s_amt);
	}
	if (WriteFields(TOTAL_FLD,TOTAL_FLD) < 0) return(-1);
	sr.nextfld = cur_fld ;
	sr.endfld = end_fld ;

	return(NOERROR) ;
}
/*----------------------------------------------------------------*/
/* Show Help Windows, if applicable, when user gives ESC-H in key
   and header fields */

static int
WindowHelp()
{
	int	err ;

	switch(sr.curfld){
	case	SUPPCD_FLD	:	/* Supplier Cd: */
		err = supp_hlp(s_sth.s_supp_cd, 7, 13 );
		if(err == DBH_ERR) return(err) ;
		if(err >=0 ) redraw();
		if(err < 1) return(ERROR) ;

		err = CheckSupp(s_sth.s_supp_cd,BROWSE) ;
		if( DBH_ERR == err) return(err) ;
		if(err < 0) {
			s_sth.s_supp_cd[0] = LV_CHAR ;
			return(ERROR) ;
		}
		break ;
	default :
#ifdef ENGLISH
		fomer("No Help Window For This Field");
#else
		fomer("Pas de fenetre d'assistance pour ce champ");
#endif
	}	/* Switch sr.curfld */

	return(NOERROR) ;
}	/* WindowHelp() */
/*-----------------------------------------------------------------------*/
/* Take the confirmation from user for the header part */

static int
Confirm()
{
	int	err ;

	/* Options:
	   Add      - AEC
	*/

	for( ; ; ) {
#ifdef ENGLISH
		err = GetOption("Y(es), E(dit), C(ancel)", "YEC");
#else
		err = GetOption("O(ui), M(odifier), A(nnuler)", "OMA");
#endif
		if(err == PROFOM_ERR) return(err) ;

		switch(err) {
		case  YES :
			return(YES) ;
		case  EDIT  :
			err = FieldEdit();
			break ;
		case  CANCEL :
#ifdef ENGLISH
			err = GetOption("Confirm the Cancel (Y/N)?", "YN") ;
#else
			err = GetOption("Confirmer l'annulation (O/N)?", "ON") ;
#endif
			if(err == YES) { 
				roll_back(e_mesg) ;	/* Unlock  Records */
				ClearScreen() ;		/* Clear the Screen */
				return(CANCEL) ;
			}
			break ;
		}	/* switch err */

		if(err == PROFOM_ERR) return(err) ;
		if(err == DBH_ERR) return(err) ;
	}	/* for(; ; ) */
}	/* Confirm() */
/*-----------------------------------------------------------------------*/
/*                                                                       */
/* Changing fields. Accept fld to be changed and read that fld 		 */

static int
FieldEdit()
{

     	int i,fld_no;

#ifdef ENGLISH
	STRCPY(s_sth.s_mesg,"Enter RETURN to terminate Edit");
#else
	STRCPY(s_sth.s_mesg,"Appuyer sur RETURN pour terminer l'ajustement");
#endif
	ShowMesg() ;

     	for ( i = INV_START; i <= END_FLD-200 ; i += 100 ) {
       		fomca1( i,19,2 );      		/*  disable Dup Control */
       		fomca1( i,10,1 );      		/*  enable user escape */
     	}

     	sr.nextfld = INV_START;
     	sr.endfld = END_FLD-200;
     	fomud( (char *) &s_sth );
     	ret(err_chk(&sr));
     	for (; ;) {
		sr.nextfld = CHG_FLD ;
		fomrf((char *)&s_sth) ;
     		ret(err_chk(&sr));

       		if (s_sth.s_field == 0 ) break;	/* Finished changing fields */

			/* CL 1991/01/31 */
		if((s_sth.s_field > MANU_PMT_LIM && s_sth.s_trans[0]==MANUAL) ||
		  (s_sth.s_field > STOP_PMT_LIM && s_sth.s_trans[0]==STOPPMT) ||
		  (s_sth.s_field > PART_PMT_LIM && s_sth.s_trans[0]==PARTIAL)){
#ifdef ENGLISH
			fomer("Field not in Range");
#else
			fomer("Champ n'est pas dans les limites");
#endif
			continue;
		}

        	fld_no = INV_START + (100 * (s_sth.s_field - 1)) ;

		sr.nextfld = fld_no;
		for(; ;) {
			fomrf((char*)&s_sth);
			ret(err_chk(&sr));

			if(sr.retcode == RET_VAL_CHK){
				if (Validation() != NOERROR) { 
					sr.nextfld = sr.curfld;
					if(sr.curfld == ACCNO_FLD) 
						sr.nextfld = CHQNO_FLD;
					continue;
				}
			}

			if( fld_no == INV_FLD ) {
/**
				fld_no = sr.nextfld = TYPE_FLD ;
**/
				/* if editing Invoice number edit all the 
				   fields pertaining to that trans type */
				sr.nextfld += 100;
				if((sr.nextfld > ACCNO_FLD && 
				    s_sth.s_trans[0]==MANUAL) ||
				   (sr.nextfld > TYPE_FLD && 
				    s_sth.s_trans[0]==STOPPMT) ||
				   (sr.nextfld > TOTAL_FLD && 
				    s_sth.s_trans[0]==PARTIAL)){
					fld_no = sr.nextfld - 100;
				}
				else 
					continue ;
			}
			if (fld_no == CHQNO_FLD) {
				fld_no = sr.nextfld = ACCNO_FLD ;
				continue;
			}
			break;
		}
	}

     	s_sth.s_field = HV_SHORT ;
	if ( WriteFields(CHG_FLD, CHG_FLD) < 0 ) return(-1);

     	s_sth.s_mesg[0] = HV_CHAR ;
     	ShowMesg();

	return(NOERROR) ;
}	/* FieldEdit() */
/*------------------------------------------------------------------------*/
/* Move High values to all data fields and clear the screen */

static int
ClearScreen()
{
	/* Move High Values to Hedaer part */
	InitFields(HV_CHAR, HV_LONG, HV_DOUBLE) ;


	ret( WriteFields(START_FLD, (END_FLD - 200)) );

	return(NOERROR);
}	/* ClearScreen() */
/*-------------------------------------------------------------------------*/
/* Initialize Screen Header with either Low or High Values */

static int
InitFields( t_char, t_long, t_double )
char	t_char ;
long	t_long ;
double	t_double ;
{

	s_sth.s_invc_no[0] = t_char ;
	s_sth.s_tr_type[0] = t_char ;
	s_sth.s_amt = t_double ;
	s_sth.s_chq_no = t_long ;
	s_sth.s_accno[0] = t_char ;

	return(NOERROR) ;
}	/* InitFields() */
/*-------------------- E n d   O f   P r o g r a m ---------------------*/

