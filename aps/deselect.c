/*-----------------------------------------------------------------------
Source Name: deselect.c
System     : Accounts Payables.
Created  On: 24 NOVEMBER 89.
Created  By: T AMARENDRA.

COBOL Source(s): cp130---01

DESCRIPTION:
	Program to De-Select the invoices from Cheque Processing.

	NOTE:
	   Not possible to De-Select Cancelled Cheques. Even though program
	   is not checking for 'cancelled' status, because you can't enter
	   -ve cheque amount it is not possible.

MODIFICATIONS:        

Programmer     YY/MM/DD       Description of modification
~~~~~~~~~~     ~~~~~~~~       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
peter ralph    90/11/23       Right Justify numeric supplier code
C.Leadbeater   90/12/18	      Added D_Roundoff() for double values, if used 
			      in calculations, before writing to files.
L.Robichaud    93/07/08	      Call function to check if anyone is doing Invoice
`			      Entry.(invcheck.c()). Do not continue if anyone
			      is running invoice entry.
------------------------------------------------------------------------*/

#define	MAIN

#include <stdio.h>
#include <cfomstrc.h>
#include <bfs_defs.h>
#include <bfs_recs.h>

#define	SYSTEM		"ACCOUNTS PAYABLE"	/* Sub System Name */
#define	MOD_DATE	"18-DEC-90"		/* Program Last Modified */

#define	DELTA_AMT	0.005	/* To Check float & double amounts for 0 */
#define	ESC_F		1	/* ESC-F is active */

/* User Interface define constants */
#ifdef ENGLISH
#define DESELECT	'D'
#define EXITOPT		'E'

#define	YES		'Y'
#define	EDIT		'E'
#define	CANCEL		'C'
#else
#define DESELECT	'R'
#define EXITOPT		'F'

#define	YES		'O'
#define	EDIT		'M'
#define	CANCEL		'A'
#endif
/* PROFOM Releted declarations */

#define	SCR_NAME	"deselect"	/* PROFOM screen Name */

/* PROFOM Screen STH file */

/* Field PROFOM numbers */

#define	OPTION_FLD	1300	/* Option: */
#define	KEY_START	400	/* Key Start Field */
#define	KEY_END		700	/* Key Start Field */
#define	END_FLD		1500	/* Last Field of the screen */
#define	SUPPCD_FLD	400	/* Supplier Cd: */
#define	SUPPNAME_FLD	800	/* Supplier Name: */
#define	POSTALCD_FLD	1200	/* Postal Code: */
#define	FUND_FLD	500	/* Fund#: */
#define	CHQAMT_FLD	700	/* Cheque amt : */

/* deselect.sth - header for C structure generated by PROFOM EDITOR */

struct	s_struct	{

	char	s_pgm[11];	/* STRING XXXXXXXXXX Field 100 */
	long	s_rundate;	/* DATE YYYYFMMFDD Field 300 */
	char	s_supp_cd[11];	/* STRING XXXXXXXXXX Field 400 */
	short	s_fund;		/* NUMERIC 999 Field 500 */
	long	s_chq_no;	/* NUMERIC 99999999 Field 600 */
	double	s_chq_amt;	/* NUMERIC 999F999F999.99 Field 700 */
	char	s_name[49];	/* STRING X[49] Field 800 */
	char	s_add1[31];	/* STRING X[30] Field 900 */
	char	s_add2[31];	/* STRING X[30] Field 1000 */
	char	s_add3[31];	/* STRING X[30] Field 1100 */
	char	s_pc[11];	/* STRING X[7] Field 1200 */
	char	s_option[2];	/* STRING X Field 1300 */
	char	s_mesg[78];	/* STRING X[77] Field 1400 */
	char	s_resp[2];	/* STRING X Field 1500 */
};

static	struct	s_struct  s_sth;	/* PROFOM Screen Structure */

static	struct  	stat_rec  sr;	/* PROFOM status rec */

Pa_rec		pa_rec ;	/* Parameters Record */
Ctl_rec		ctl_rec ;	/* Fund/Control Record */
Supplier	supp_rec ;	/* Supplier */
Invoice		in_rec ;	/* Purchase Invoice */
Chq_rec		chq_rec ;	/* Cheque Record */

char 		e_mesg[100];	/* dbh will return err msg in this */

int	Validate(), WindowHelp() ;
double	D_Roundoff();

/*------------------------------------------------------------------------*/

main(argc,argv)
int	argc;
char	*argv[];
{
	int	err, numprocess;

	if(argc < 2){
#ifdef  DEVELOP
		printf("MAIN ARGUMENTS ARE NOT PROPER\n");
		printf("Usage: %s {-tTerminal Name} {-dDist#} [{-sSwitches}]\n",
			argv[0]);
#endif
		exit(1);
	}

	err = Initialize(argc,argv) ;	/* Initialize Variables , DBH
						Environment and PROFOM */
#ifndef DOS
	numprocess = invcheck();	/* Check for invoice entry processes */
	if(numprocess == ERROR){
		DispError("Error Occured Checking Active Processes");
		close_dbh();
		exit(0);
	}
	if(numprocess > 0){
		DispError("Can Not Proceed, Invoice Entry In Process");
		close_dbh();
		exit(0);
	}
#endif
	if(err == NOERROR) err = Process();	/* Initiate Process */

	CloseProcess() ;

	if(err != NOERROR)exit(1);
	exit(0);
}	/* main() */
/*-------------------------------------------------------------------*/
/* Initialize Variables, PROFOM, DBH etc. */

Initialize(argc, argv)
int	argc ;
char	*argv[] ;
{
	int	i ;

	/*
	*	Initialize DBH Environment
	*/
	strncpy(SYS_NAME,SYSTEM,50);	/* Sub system name */
	strncpy(CHNG_DATE,MOD_DATE,10);	/* Modification Date */

	proc_switch(argc, argv, CHEQUE) ;	/* Process Switches */

	/*
	*	Initialize PROFOM & Menu Screen
	*/
	STRCPY(sr.termnm,terminal);	/* Copy Terminal Name */
	fomin(&sr);
	ret(err_chk(&sr)) ;		/* Check for PROFOM Error */
	fomcf(1,1);			/* Enable Snap screen option */

	/* move screen name to Profom status structure */
	STRCPY(sr.scrnam,NFM_PATH);
	strcat(sr.scrnam,SCR_NAME) ;

	/* Initialize SCR */
	STRCPY(s_sth.s_pgm,PROG_NAME);
	s_sth.s_rundate = get_date();	/* get Today's Date in YYYYMMDD format*/
	s_sth.s_mesg[0] = HV_CHAR ;
	s_sth.s_resp[0] = HV_CHAR ;

	MoveLVs() ;

	ret( WriteFields(1, 0) );

	/*
	*	Get The Parameter Record
	*/
	i = get_param(&pa_rec, BROWSE, 1, e_mesg) ;
	if(i == ERROR) {
		DispError(e_mesg);
		return(ERROR) ;
	}
	else if(i == UNDEF) {
#ifdef ENGLISH
		DispError("Parameters Are Not Setup..");
#else
		DispError("Parametres ne sont pas etablis..");
#endif
		return(ERROR) ;
	}

	/* Open Report File */
	i = OpenReport() ;
	if(i < 0) return(i) ;

	return(NOERROR) ;
}	/* Initialize() */
/*-------------------------------------------------------------------*/
/* Get Option: from user and call corresponding function */

Process()
{
	int err;

	for( ; ; ){
		/* Get the Option: from the user */
		if((err = ReadOption()) != NOERROR) return(err) ;

		err = ProcOption() ;	/* Process Option */

		if(QUIT == err)		return(NOERROR) ;	/* Exit */
		if(NOACCESS == err)	fomen(e_mesg);
		if(PROFOM_ERR == err)	return(PROFOM_ERR);  /* PROFOM ERROR */
		if(DBH_ERR == err) {
			DispError(e_mesg);
#ifdef ENGLISH
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"System Error... Iserror:",
				iserror, dberror, errno);
#else
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"Erreur du systeme... Iserror:",
				iserror, dberror, errno);
#endif
			DispError(e_mesg);
			return(DBH_ERR);	/* DBH ERROR */
		}
	}      /*   end of the for( ; ; )       */
}	/* Process() */
/*----------------------------------------------------------------*/
/* Close necessary files and environment before exiting program */

CloseProcess()
{
	CloseReport() ;

	/* Set terminal back to normal mode from PROFOM */
	fomcs();
	fomrt();

	close_dbh();	/* Close DBH(files) */

	return(NOERROR) ;
}	/* CloseProcess() */
/*----------------------------------------------------------------*/
/* Display the Options (Option:) and get the option from the user */

ReadOption()
{
	/* Display options */
#ifdef ENGLISH
	fomer("D(e-Select), E(xit)");
#else
	fomer("R(etrait), F(in)");
#endif
	/* Read Option: field */
	sr.nextfld = OPTION_FLD ;
	fomrf( (char *)&s_sth );
	ret(err_chk(&sr));	/* Check for PROFOM error */

	return(NOERROR) ;
}	/* ReadOption() */
/*----------------------------------------------------------------*/
/* Process the user selected option */

ProcOption()
{
	int retval;

	switch (s_sth.s_option[0]) {
	case DESELECT  :		/* De-Select */
		CHKACC(retval,P_DEL,e_mesg);
		return( DeSelectProcess() ) ;
	case EXITOPT  :			/* Exit */
		return( QUIT ) ;
	}  /*   end of the switch statement */

	if(retval<0) 
		return(retval);

	return(NOERROR);
}	/* ProcOption() */
/*-----------------------------------------------------------------------*/
/* Take the Keys for de-selection from the user. When he confirms it
   do the de-selection */

DeSelectProcess()
{
	int	err ;

	/* If the Current Period == 0 (i.e before yearly closing), Add or
	   Change is not allowed */
	if(pa_rec.pa_cur_period == 0) {
#ifdef ENGLISH
		DispError("Not Allowed Before Yearly Closing...");
#else
		DispError("Pas permis avant la fermeture annuelle...");
#endif
		return(NOERROR) ;
	}

	err = GetItemKey() ;
	if(PROFOM_ERR == err || DBH_ERR == err) return(err) ;
	if(NOERROR != err) {
		MoveLVs() ;
		ret( WriteFields(KEY_START, POSTALCD_FLD) ) ;
		roll_back(e_mesg) ;	/* Unlock the locked Records */
		return(err) ;
	}

	err = CancelCheques() ;
	if(NOERROR != err) {
		roll_back(e_mesg) ;	/* Unlock the locked Records */
		return(err) ;
	}

	return(NOERROR) ;
}	/* DeSelectProcess() */
/*----------------------------------------------------------------------*/
/* Get the De-selection key from user */

GetItemKey()
{
	int	i;

	for(i = KEY_START ; i <= KEY_END ; i += 100)
		fomca1(i,19,0) ;

#ifdef ENGLISH
	STRCPY(s_sth.s_mesg,"Press ESC-F to Go Back to Fn:");
#else
	STRCPY(s_sth.s_mesg,"Appuyer sur ESC-F pour retourner a Fn:");
#endif
	ShowMesg();

	MoveLVs() ;

	i = ReadFields(KEY_START, KEY_END, ESC_F) ;
	if(PROFOM_ERR == i || DBH_ERR == i) return(i) ;
	if(RET_USER_ESC == i){
		s_sth.s_mesg[0] = HV_CHAR;
		ShowMesg();
		return(ERROR) ;
	}

	i = Confirm() ;		/* Confirm the Selection */
	if(i != YES) return(i) ;

	i = IsValidItemKey();		/* Is User given Key Valid? */
	if(i != NOERROR) return(i) ;

	return(NOERROR);
}	/*  GetItemKey() */
/*-----------------------------------------------------------------------*/
/* Take the confirmation from user for the keys */

Confirm()
{
	int	err ;

	for( ; ; ) {
#ifdef ENGLISH
		err = GetOption("Y(es), E(dit), C(ancel)", "YEC");
#else
		err = GetOption("O(ui), M(odifier), A(nnuler)", "OMA");
#endif
		if(err == PROFOM_ERR) return(err) ;

		switch(err) {
		case  YES :
		    return(YES) ;
		case  EDIT  :
		    err = ChangeItemKey();
		    break ;
		case  CANCEL :
#ifdef ENGLISH
		    err = GetOption("Confirm the Cancel (Y/N)?", "YN") ;
#else
		    err = GetOption("Confirmer l'annulation (O/N)?", "ON") ;
#endif
		    if(err == YES) return(CANCEL) ;
		    break ;
		}	/* switch err */

		if(err == PROFOM_ERR) return(err) ;
		if(err == DBH_ERR) return(err) ;
	}	/* for(; ; ) */
}	/* Confirm() */
/*----------------------------------------------------------------------*/
/* Changing user given keys */

ChangeItemKey()
{
	int	i;

	for(i = KEY_START ; i <= KEY_END ; i += 100)
		fomca1(i,19,2) ;

	sr.nextfld = KEY_START ;
	sr.endfld  = KEY_END ;
	fomud((char*)&s_sth) ;
	ret(err_chk(&sr));

	MoveLVs() ;

	i = ReadFields(KEY_START, KEY_END, 0) ;
	if(i < 0) return(i) ;

	return(NOERROR);
}	/* ChangeItemKey() */
/*------------------------------------------------------------*/
/* If the user given key is valid?. Total of all the cheques for the
   user given key should equal to user given amount */

IsValidItemKey()
{
	int	err, i ;
	double	chq_amt ;

	STRCPY(chq_rec.c_supp_cd, s_sth.s_supp_cd) ;
	chq_rec.c_funds  = s_sth.s_fund ;
	chq_rec.c_chq_no = s_sth.s_chq_no ;
	chq_rec.c_invc_no[0] = '\0';
	chq_rec.c_tr_type[0] = '\0';
	flg_reset(CHEQUE) ;

	chq_amt = 0.0 ;
	i = 0 ;
	for ( ; ; ) {
		err = get_n_chq(&chq_rec, BROWSE, 0, FORWARD, e_mesg) ;
		if(err == ERROR) return(DBH_ERR) ;
		if(err == EFL) break ;

		/* If key changes break */
		if(strcmp(chq_rec.c_supp_cd, s_sth.s_supp_cd) != 0 ||
			chq_rec.c_funds  != s_sth.s_fund ||
			chq_rec.c_chq_no != s_sth.s_chq_no) break ;

		chq_amt += chq_rec.c_gr_amt - chq_rec.c_disc_taken ;
		i = 1 ;
	}
	seq_over(CHEQUE) ;

	if(i == 0) {
#ifdef ENGLISH
	    DispError("Invalid Cheque...  No Cheque Exists with the given Key");
#else
	    DispError("Cheque invalide...  Cheque n'existe pas avec la cle donnee");
#endif
	    return(ERROR) ;
	}

	/* Check whether cumulative total of cheques and user given amount
	   is same */

	chq_amt -= s_sth.s_chq_amt ;

	if(chq_amt < -(DELTA_AMT) || chq_amt > DELTA_AMT) {
#ifdef ENGLISH
		DispError("Invalid Cheque....   Cheque Amount Discrepancy");
#else
		DispError("Cheque invalide....   Divergence de montants de cheque");
#endif
		return(ERROR) ;
	}

	return(NOERROR) ;
}	/* IsValidItemKey() */
/*------------------------------------------------------------*/
/* Read the cheque records for user given key and cancel them */

CancelCheques()
{
	int	i, err ;

	STRCPY(chq_rec.c_supp_cd, s_sth.s_supp_cd) ;
	chq_rec.c_funds  = s_sth.s_fund ;
	chq_rec.c_chq_no = s_sth.s_chq_no ;
	chq_rec.c_invc_no[0] = '\0';
	chq_rec.c_tr_type[0] = '\0';
	flg_reset(CHEQUE) ;

	err = PrintSubHdg() ;	/* Print Supplier name as a sub heading */
	if(err < 0) return(ShowError()) ;

	i = 0 ;
	for ( ; ; ) {
		err = get_n_chq(&chq_rec, UPDATE, 0, FORWARD, e_mesg) ;
		if(err == ERROR) return(ShowError()) ;
		if(err == EFL) break ;

		/* If key changes break */
		if(strcmp(chq_rec.c_supp_cd, s_sth.s_supp_cd) != 0 ||
			chq_rec.c_funds  != s_sth.s_fund ||
			chq_rec.c_chq_no != s_sth.s_chq_no) break ;

		/* Get the Invoice Record */
		STRCPY(in_rec.in_supp_cd, chq_rec.c_supp_cd) ;
		STRCPY(in_rec.in_invc_no, chq_rec.c_invc_no) ;
		STRCPY(in_rec.in_tr_type, chq_rec.c_tr_type) ;

		err = get_invc(&in_rec, UPDATE, 0, e_mesg) ;
		if(err < 0) return(ShowError()) ;

		/* Subtract the cheque amount from invoice record. Because for
		   INVOICE and CRMEMO amounts will be -ve and for others +ve in
		   Invoice rec. Whereas in cheque record this is reverse */
		
		in_rec.in_amount   -= chq_rec.c_gr_amt ;
		in_rec.in_disc_amt -= chq_rec.c_disc_taken ;

		/* Initialize Payment Related fields */
		in_rec.in_pmtcode[0] = OPEN ;
		in_rec.in_part_amt   = 0.0 ;
		in_rec.in_chq_no     = 0 ;
		in_rec.in_accno[0] = '\0';
		
		in_rec.in_amount = D_Roundoff(in_rec.in_amount); 
		in_rec.in_disc_amt = D_Roundoff(in_rec.in_disc_amt);

		err = put_invc(&in_rec, UPDATE, e_mesg) ;
		if(err < 0) return(ShowError()) ;

		err = PrintPayment() ;
		if(err < 0) return(ShowError()) ;

		/* Update The Supplier */
		/* Cheque Gross amount & Discount Taken are stored as +ve for
		   INVOICES, because its amounts are stored as -ve. So
		   subtracting from balance physically increases it */

		supp_rec.s_balance -= chq_rec.c_gr_amt ;
		/**  NUll statement. For contract suppliers disc_taken is
		    always 0.0.
		if(supp_rec.s_type[0] == CONTRACT)
			supp_rec.s_ytd_disc -= chq_rec.c_disc_taken ;
		***/

		/* Delete the Cheque Record */
		err = put_chq(&chq_rec, P_DEL, e_mesg) ;
		if(err < 0) return(ShowError()) ;

		/* Commit the records for every 10 records */

		i++ ;
		if(i % 10 == 0) {
			err = commit(e_mesg) ;
			if(err < 0) return(ShowError()) ;
			/* Commit() will release the lock on supplier record
			   also. So, lock the record agian */
			err = CheckSupp(supp_rec.s_supp_cd, UPDATE) ;
			if(err < 0) return(ShowError());
		}
		/* Position the cheque file for next cheque record */
		inc_str(chq_rec.c_tr_type,sizeof(chq_rec.c_tr_type)-1,FORWARD);
	}
	seq_over(CHEQUE) ;

	supp_rec.s_balance = D_Roundoff(supp_rec.s_balance); 
	supp_rec.s_ytd_disc = D_Roundoff(supp_rec.s_ytd_disc); 

	err = put_supplier(&supp_rec, UPDATE, e_mesg) ;
	if(err < 0) return(ShowError()) ;

	err = commit(e_mesg) ;
	if(err < 0) return(ShowError()) ;

	err = PrintChqTotals() ;
	if(err < 0) return(ShowError()) ;

	return(NOERROR) ;
}	/* CancelCheques() */
/*-----------------------------------------------------------*/
/* Show the Updation error message */
static	int
ShowError()
{
#ifdef ENGLISH
	DispError("ERROR in De-Selection Process"); 
#else
	DispError("ERREUR dans le processus de retrait");
#endif
	DispError(e_mesg);
	roll_back(e_mesg) ;	/* Unlock the locked Records */

	return(DBH_ERR);
}	/* ShowError() */
/*------------------------------------------------------------*/
/* Read the PROFOM Screen for a given Range of fields */

ReadFields(st_fld, end_fld, esc_f)
int	st_fld ;
int	end_fld ;
int	esc_f ;		/* Is ESC_F active? */
{
	int	err ;

	sr.nextfld = st_fld ;
	sr.endfld  = end_fld ;

	for( ; ;){
		fomrd( (char*)&s_sth );
		ret(err_chk(&sr));
		if(sr.retcode == RET_VAL_CHK){
			err = Validate() ;
			if(DBH_ERR == err || PROFOM_ERR == err) return(err);
			sr.nextfld = sr.curfld ;
			continue;
		}
		if(sr.retcode == RET_USER_ESC){
			if(esc_f &&
			    (sr.escchar[0] == 'f' || sr.escchar[0] == 'F') )
				return(RET_USER_ESC) ;
			if(sr.escchar[0] == 'h' || sr.escchar[0] == 'H'){
				err = WindowHelp() ;
				if(DBH_ERR == err || PROFOM_ERR == err)
					return(err) ;
			}
			sr.nextfld = sr.curfld ;
			continue;
		}
		/* else RET_NO_ERROR */
		break;
	}

	return(NOERROR) ;
}	/* ReadFields() */
/*----------------------------------------------------------------*/
/* Validation function() for Data fields when PROFOM returns RET_VAL_CHK */

Validate()
{
	int	err ;
	int	save_nextfld, save_endfld;

	switch(sr.curfld){
	case	SUPPCD_FLD	:	/* Supplier Cd: */
		err = CheckSupp(s_sth.s_supp_cd,UPDATE) ;
		if(DBH_ERR == err) return(err) ;
		if(ERROR == err) {
			s_sth.s_supp_cd[0] = LV_CHAR ;
			return(ERROR) ;
		}
		err = DisplayAddress() ;
		if(NOERROR != err) return(err) ;
		
		save_nextfld = sr.nextfld;
		save_endfld = sr.endfld;
		fomca1(FUND_FLD,19,2);
		s_sth.s_fund = 1;
		WriteFields(FUND_FLD,FUND_FLD);
		s_sth.s_fund = LV_SHORT;
		sr.nextfld = save_nextfld ;
		sr.endfld = save_endfld ;
		break ;
	case	FUND_FLD	:	/* Fund: */
		err = CheckFund(s_sth.s_fund) ;
		if(DBH_ERR == err) return(err) ;
		if(ERROR == err) {
			s_sth.s_fund = LV_SHORT ;
			return(ERROR) ;
		}
		fomer(ctl_rec.desc) ;
		break ;
	case	CHQAMT_FLD	:	/* Cheque Amt: */
		if(s_sth.s_chq_amt <= DELTA_AMT) {
#ifdef ENGLISH
			fomer("Can't Be Zero");
#else
			fomer("Ne peut pas etre zero");
#endif
			s_sth.s_chq_amt = LV_DOUBLE ;
			return(ERROR) ;
		}

		break ;
	default :
#ifdef ENGLISH
		sprintf(e_mesg,"No Validity Check For Field#  %d",sr.curfld);
#else
		sprintf(e_mesg,"Pas de controle de validite pour le Champ#  %d",sr.curfld);
#endif
		fomen(e_mesg);
		get();
		return(ERROR) ;
	}	/* Switch sr.curfld */

	return(NOERROR) ;
}	/* Validate() */
/*----------------------------------------------------------------*/
/* Show Help Windows, if applicable, when user gives ESC-H */

WindowHelp()
{
	int	err ;

	switch(sr.curfld){
	case	SUPPCD_FLD	:	/* Supplier Cd: */
		err = supp_hlp(s_sth.s_supp_cd, 7, 13 );
		if(err == DBH_ERR) return(err) ;
		if(err >=0 ) redraw();
		if(err < 1) return(ERROR) ;

		/* Lock the Supplier */
		err = CheckSupp(s_sth.s_supp_cd,UPDATE) ;
		if(DBH_ERR == err) return(err) ;
		if(ERROR == err) {
			s_sth.s_supp_cd[0] = LV_CHAR ;
			return(ERROR) ;
		}
		err = DisplayAddress() ;
		if(NOERROR != err) return(err) ;
		break ;
	default :
#ifdef ENGLISH
		fomer("No Help Window For This Field");
#else
		fomer("Pas de fenetre d'assistance pour ce champ");
#endif
		return(ERROR) ;
	}	/* Switch sr.curfld */

	return(NOERROR) ;
}	/* WindowHelp() */
/*-------------------------------------------------------------------------*/
/* Display the supplier Name and Address */

DisplayAddress()
{
	int	curfld, endfld ;

	curfld = sr.curfld ;
	endfld = sr.endfld ;

	STRCPY(s_sth.s_name, supp_rec.s_name) ;
	STRCPY(s_sth.s_add1, supp_rec.s_add1) ;
	STRCPY(s_sth.s_add2, supp_rec.s_add2) ;
	STRCPY(s_sth.s_add3, supp_rec.s_add3) ;
	STRCPY(s_sth.s_pc  , supp_rec.s_pc  ) ;

	ret( WriteFields( SUPPNAME_FLD, POSTALCD_FLD) ) ;

	sr.curfld = curfld ;
	sr.endfld = endfld ;
	
	return(NOERROR) ;
}	/* DisplayAddress() */
/*-------------------------------------------------------------------------*/
/* MOve low values to screen data fields */

MoveLVs()
{
	s_sth.s_supp_cd[0] = LV_CHAR ;
	s_sth.s_fund       = LV_SHORT ;
	s_sth.s_chq_no     = LV_LONG ;
	s_sth.s_chq_amt    = LV_DOUBLE ;

	s_sth.s_name[0] = LV_CHAR ;
	s_sth.s_add1[0] = LV_CHAR ;
	s_sth.s_add2[0] = LV_CHAR ;
	s_sth.s_add3[0] = LV_CHAR ;
	s_sth.s_pc[0]   = LV_CHAR ;

	return(NOERROR) ;
}	/* MoveLVs()() */
/*------------------------------------------------------------------------*/
/* Write fields on Screen for a given Range */

WriteFields(st_fld, end_fld)
int	st_fld ;
int	end_fld ;
{
	sr.nextfld = st_fld ;
	sr.endfld  = end_fld ;

	fomwr( (char*)&s_sth ) ;
	ret(err_chk(&sr));

	return(NOERROR) ;
}	/* WriteFields() */
/*-----------------------------------------------------------------------*/
/* Display message and get the option */

GetOption(msg,options)
char	*msg ;
char	*options ;
{
	int	i, j ;

	STRCPY(s_sth.s_mesg, msg);
	ShowMesg() ;

	sr.nextfld = END_FLD ;
	for( ; ; ) {
		fomrf( (char*)&s_sth ) ;
		ret(err_chk(&sr)) ;

		j = strlen(options) ;
		for( i = 0 ; i < j ; i++)
			if(s_sth.s_resp[0] == options[i]) break ;
		if(i != j) break ;	/* Valid Option Selected */
#ifdef ENGLISH
		fomer("Invalid Option..");
#else
		fomer("Option invalide..");
#endif
	}
	s_sth.s_mesg[0] = HV_CHAR;
	s_sth.s_resp[0] = HV_CHAR;

	ret( WriteFields((END_FLD - 100), END_FLD) );

	return((int)(options[i])) ;
}	/* GetOption() */
/*-------------------------------------------------------------------------*/
/* Copy the given message to SCR message line, display it and seek
   user response */

DispError(s)    /* show ERROR and wait */
char	*s;
{
	STRCPY(s_sth.s_mesg, s);
	ShowMesg();
#ifdef ENGLISH
	fomen("Press any key to continue");
#else
	fomen("Appuyer sur une touche pour continuer");
#endif
	get();
	s_sth.s_mesg[0] = HV_CHAR;
	ShowMesg();

	return(NOERROR);
}	/* DispError() */
/*-------------------------------------------------------------------------*/
/* Write the Message Field */

ShowMesg()  /* shows or clears message field */
{
	sr.nextfld = END_FLD - 100;
	fomwf( (char*)&s_sth ) ;

	return(NOERROR) ;
}	/* ShowMesg() */
/*----------------------------------------------------------------*/
/* Check the given Suppliers availability in file */

CheckSupp(supp_cd,mode)
char	*supp_cd ;
int	mode ;
{
	int	err ;
	Right_Justify_Numeric(supp_cd,(sizeof(supp_rec.s_supp_cd)-1));
	STRCPY(supp_rec.s_supp_cd, supp_cd) ;
	err = get_supplier(&supp_rec, mode, 0, e_mesg) ;
	if(ERROR == err) return(DBH_ERR) ;
	if(err < 0) {
		fomer(e_mesg) ;
		return(ERROR) ;
	}

	return(NOERROR) ;
}	/* CheckSupp() */
/*----------------------------------------------------------------*/
/* Check the given funds availability in file */

CheckFund(fund)
short	fund ;
{
	int	err ;

	ctl_rec.fund = fund ;

	err = get_ctl(&ctl_rec, BROWSE, 0, e_mesg) ;
	if(ERROR == err) return(DBH_ERR);
	if(err < 0) {
		fomer(e_mesg) ;
		return(ERROR) ;
	}
	return(NOERROR) ;
}	/* CheckFund() */
/*-------------------- E n d   O f   P r o g r a m ---------------------*/

