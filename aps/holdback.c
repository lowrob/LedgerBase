/*-----------------------------------------------------------------------
Source Name: holdback.c
System     : Accounts Payables.
Created  On: 24 NOVEMBER 89.
Created  By: T AMARENDRA.

DESCRIPTION:
	Program to release Holdbacks.

MODIFICATIONS:        

Programmer     YY/MM/DD       Description of modification
~~~~~~~~~~     ~~~~~~~~       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1990/12/18	F.Tao 	       Round up amounts before writing to file.
1991/01/01	C.Leadbeater   Implemented record locking routines.
------------------------------------------------------------------------*/

#include <stdio.h>
#include <cfomstrc.h>
#include <bfs_defs.h>
#include <bfs_recs.h>
#include <apinvc.h>

/* User Interface define constants */
#ifdef ENGLISH
#define CHANGE		'C'
#define INQUIRE		'I'
#define	EXITOPT		'E'

#define	YES		'Y'
#define	CANCEL		'C'
#else
#define CHANGE		'C'
#define INQUIRE		'I'
#define	EXITOPT		'F'

#define	YES		'O'
#define	CANCEL		'A'
#endif

#define EXIT		12	

/* PROFOM Releted declarations */

#define	SCR_NAME	"holdback"	/* PROFOM screen Name */

/* PROFOM Screen STH file */

/* Field PROFOM numbers */

#define	ST_FLD		1100	/* Header Start Field */
#define	SCR_END_FLD	2600	/* Last Field of the screen */

/* HDR Fields */
#define	FN_FLD		500	/* Fn: */
#define	KEY_START	600	/* Supplier Cd: */
#define	KEY_END		1000	/* Type: */
#define	SUPPCD_FLD	600	/* Supplier Cd: */
#define	REFNO_FLD	900	/* Ref#: */
#define	TRTYPE_FLD	1000	/* Trans. Type: */
#define	CHG_FLD		700	/* Field: */
#define	INVCDT_FLD	1400	/* Ref date: */
#define	DUEDT_FLD	1500	/* Due Date: */
#define	DISCPER_FLD	1800	/* Disc% */
#define	DISCAMT_FLD	1900	/* Disc Amt: */
#define	PMNTCD_FLD	2000	/* Disc Amt: */
#define	PMNTDESC_FLD	2050	/* (Pmtcode Description) */
#define	CHEQUENO_FLD	2200	/* Disc Amt: */

/* holdback.sth - header for C structure generated by PROFOM EDITOR */

struct	s_struct	{

	char	s_pgm[11];	/* STRING XXXXXXXXXX Field 100 */
	long	s_rundate;	/* DATE YYYYFMMFDD Field 300 */
	char	s_fn[2];	/* STRING X Field 500 */
	char	s_supp_cd[11];	/* STRING XXXXXXXXXX Field 600 */
	short	s_field;	/* NUMERIC 999 Field 700 */
	char	s_invc_no[16];	/* STRING XXXXXXXXXX Field 900 */
	long	s_cutoff;	/* DATE YYYYFMMFDD Field 950 */
	char	s_tr_type[3];	/* STRING XX Field 1000 */
	short	s_fund;		/* NUMERIC 999 Field 1100 */
	short	s_period;	/* NUMERIC 99 Field 1200 */
	long	s_po_no;	/* NUMERIC 999999 Field 1300 */
	long	s_invc_dt;	/* DATE YYYYFMMFDD Field 1400 */
	long	s_due_dt;	/* DATE YYYYFMMFDD Field 1500 */
	char	s_type[2];	/* STRING X Field 1600 */
	double	s_tran_amt;	/* NUMERIC S99F999F999.99 Field 1700 */
	double	s_disc_per;	/* NUMERIC 99.99 Field 1800 */
	double	s_disc_amt;	/* NUMERIC S99F999F999.99 Field 1900 */
	char	s_pmtcode[2];	/* STRING X Field 2000 */
	char	s_pmt_desc[9] ;	/* STRING X[9] Field 2050 */
	double	s_part_amt;	/* NUMERIC S99F999F999.99 Field 2100 */
	long	s_chq_no;	/* NUMERIC 99999999 Field 2200 */
	char	s_accno[19];	/* STRING X[18] Field 2300 */
	char	s_remarks[21];	/* STRING X[24] Field 2400 */
	char	s_mesg[78];	/* STRING X[77] Field 2500 */
	char	s_resp[2];	/* STRING X Field 2600 */
};

static	struct	s_struct  s_sth;	/* PROFOM Screen Structure */

struct	stat_rec	sr;

static	short	TransType ;

int	Validate(), WindowHelp() ;

double 	D_Roundoff();

/*------------------------------------------------------------------------*/

ReleaseHoldback()
{
	int	err;

	err = Initialize() ;	/* Initialize Variables , DBH
						Environment and PROFOM */
	if(err == NOERROR) err = Process();	/* Initiate Process */

	if(err == PROFOM_ERR || err == DBH_ERR) return(err) ;

	return(NOERROR) ;
}	/* OpenItemMaintenance() */
/*-------------------------------------------------------------------*/
/* Initialize Variables and Screen etc. */
static	int
Initialize()
{
	flg_reset(APINVOICE) ;
	/*
	*	Initialize Screen & Screen Varibles
	*/

	CurrentScr = (char*)&s_sth ;
	END_FLD	   = SCR_END_FLD ;

	/* move screen name to Profom status structure */
	STRCPY(sr.scrnam,NFM_PATH);
	strcat(sr.scrnam,SCR_NAME) ;

	STRCPY(s_sth.s_pgm,PROG_NAME);
	s_sth.s_rundate = get_date();	/* get Today's Date in YYYYMMDD format*/
	s_sth.s_fn[0]   = LV_CHAR ;
	s_sth.s_field   = HV_SHORT ;
	s_sth.s_mesg[0] = HV_CHAR ;
	s_sth.s_resp[0] = HV_CHAR ;

	/* Initialize Key Fields. So that, if user selectes 'N' option
	   immediately after invoking program, then he gets the first
	   record in the file */

	s_sth.s_supp_cd[0] = '\0' ;
	s_sth.s_invc_no[0] = '\0';

	/* Move High Values to data fields and Display the screen */
	InitScreen() ;

	return(NOERROR) ;
}	/* Initialize() */
/*-------------------------------------------------------------------*/
/* Get Fn: from user and call corresponding function */
static	int
Process()
{
	int err;

	for( ; ; ){
		/* Get the Fn: option from the user */
		if((err = ReadFunction()) != NOERROR) return(err) ;

		err = ProcFunction() ;	/* Process Function */

		if(PROFOM_ERR == err || DBH_ERR == err)	return(err);

		if(QUIT == err)		return(NOERROR) ;	/* Exit */
	}      /*   end of the for( ; ; )       */
}	/* Process() */
/*----------------------------------------------------------------*/
/* Display the Function (Fn:) options and get the option from the user */
static	int
ReadFunction()
{
	/* Display Fn: options */
#ifdef ENGLISH
	fomer("C(hange), I(nquire), E(xit)");
#else
	fomer("C(hanger), I(nterroger), F(in)");
#endif
	/* Read Fn: field to get the option */
	sr.nextfld = FN_FLD ;
	fomrf( (char *)&s_sth );
	ret(err_chk(&sr));	/* Check for PROFOM error */

	return(NOERROR) ;
}	/* ReadFunction() */
/*----------------------------------------------------------------*/
/* Process the user selected Fn: option */
static	int
ProcFunction()
{
	switch (s_sth.s_fn[0]) {
	case CHANGE  :			/* CHANGE */
		return( ChangeInvoice() ) ;
	case INQUIRE  :			/* Inquire Invoice */
		return( InquireInvoice() ) ;
	case EXITOPT  :			/* Exit */
		return( QUIT ) ;
	}  /*   end of the switch statement */

	return(NOERROR);
}	/* ProcFunction() */
/*-----------------------------------------------------------------------*/
/* Select the user given Record and Accept changes on that */
static	int
ChangeInvoice()
{
	int	err ;

	/* If the Current Period == 0 (i.e before yearly closing), Add or
	   Change is not allowed */
	if(pa_rec.pa_cur_period == 0) {
#ifdef ENGLISH
		DispError("Not Allowed Before Yearly Closing...");
#else
		DispError("Pas permis avant la fermeture annuelle...");
#endif
		return(NOERROR) ;
	}

	InitScreen() ;
	err = SelectInvoice(BROWSE) ;
	if( err == QUIT) return(NOERROR) ;
	if(NOERROR != err) return(err) ;

	for ( ; ; ){

		err = Confirm() ;
		if(PROFOM_ERR == err || DBH_ERR == err) return(err) ;
		if( (err < 0) || (err == EXIT) ) {
			roll_back(e_mesg) ;
			break ;
		}
		err = NextInvoice(FORWARD) ;
		if( err == QUIT ) break ;
		if(NOERROR != err) return(err) ;
	}

	return(NOERROR) ;
}	/* ChangeInvoice() */
/*-----------------------------------------------------------------------*/
/* Show the user given keys Invoice */
static	int
InquireInvoice()
{
	int	err ;

	err = SelectInvoice(BROWSE) ;
	if( err == QUIT ) return(NOERROR) ;
	if(NOERROR != err) return(err) ;

	for ( ; ; ){

		err = Confirm() ;
		if(PROFOM_ERR == err || DBH_ERR == err) return(err) ;
		if( (err < 0) || (err == EXIT) ) {
			roll_back(e_mesg) ;
			break ;
		}
		err = NextInvoice(FORWARD) ;
		if( err == QUIT ) break ;
		if(NOERROR != err) return(err) ;
	}

	return(NOERROR) ;
}	/* InquireInvoice() */
/*----------------------------------------------------------*/
/* Show the next or previous Invoice */
static	int
NextInvoice(direction)
int	direction ;
{
	int err;

	/* Check whether file is in seq. read mode */
	if(flg_start(APINVOICE) != direction) {
		/* Set the least part of the key to next possible key and
		   set the file to start */
		STRCPY(in_rec.in_supp_cd, s_sth.s_supp_cd) ;
		STRCPY(in_rec.in_invc_no, s_sth.s_invc_no) ;
		STRCPY(in_rec.in_tr_type, s_sth.s_tr_type) ;
		inc_str(in_rec.in_tr_type, (sizeof(in_rec.in_tr_type) - 1),
			direction) ;	/* Set to next possible string */
		flg_reset(APINVOICE);
	}
		
	for ( ;; ) {
		err = get_n_invc(&in_rec, BROWSE, 0, direction, e_mesg);
		if(ERROR == err)return(DBH_ERR) ;
		if(EFL == err) {
			seq_over(APINVOICE);
#ifdef ENGLISH
			fomen("No More Records....");
#else
			fomen("Plus de fiches....");
#endif
			get();
			flg_reset(APINVOICE);
			return(EXIT) ;
		}
		if((strcmp(in_rec.in_supp_cd, s_sth.s_supp_cd)) != 0){ 
			seq_over(APINVOICE);
#ifdef ENGLISH
			fomen("No More Records....");
#else
			fomen("Plus de fiches....");
#endif
			get() ;
			return(EXIT) ;
		}
		if( s_sth.s_cutoff != HV_LONG ) {
			if( in_rec.in_due_dt > s_sth.s_cutoff )
				continue ;
		}

		if( (in_rec.in_pmtcode[0] != REGULAR) &&
		    (in_rec.in_pmtcode[0] != OPEN) )
			continue ;

		if( ((strcmp(s_sth.s_tr_type, T_CRMEMO)) == 0) ||
		    ((strcmp(s_sth.s_tr_type, T_INVOICE)) == 0) ) {
			if( in_rec.in_disc_amt > -(DELTA_AMT) )
				continue ;
		}
		else if( in_rec.in_disc_amt <= DELTA_AMT )
				continue ;

		break ;
	}
	seq_over(APINVOICE);

	return( ShowInvoice() ) ;
}	/* NextInvoice() */
/*----------------------------------------------------------*/
/* Get the Invoice key and show the invoice */
static	int
SelectInvoice(md)
int	md ;	/* UPDATE or BROWSE. UPDATE locks the invoice */
{
	int	err ;

	for(; ;){
		err = ReadKey();
		if(err != NOERROR) return(err) ;

		STRCPY(in_rec.in_supp_cd, s_sth.s_supp_cd) ;
		STRCPY(in_rec.in_invc_no, s_sth.s_invc_no) ;
		STRCPY(in_rec.in_tr_type, "\0") ;
		flg_reset(APINVOICE);

		for(;;) {
			err = get_n_invc(&in_rec,md,0,FORWARD,e_mesg) ;
			if(EFL == err) {
				seq_over(APINVOICE);
#ifdef ENGLISH
				fomen("No More Records....");
#else
				fomen("Plus de fiches....");
#endif
				get();
				flg_reset(APINVOICE);
				return(QUIT) ;
			}
			if(ERROR == err) return(DBH_ERR) ;
			if(err < 0) {		/* UNDEF or LOCKED */
				seq_over(APINVOICE);
				fomer(e_mesg) ;
				get() ;
				continue ;
			}
			if((strcmp(in_rec.in_supp_cd, s_sth.s_supp_cd)) != 0){ 
				seq_over(APINVOICE);
#ifdef ENGLISH
				fomen("No More Records....");
#else
				fomen("Plus de fiches....");
#endif
				get() ;
				return(QUIT) ;
			}
			if( s_sth.s_invc_no[0] == '\0' ) {
				if( in_rec.in_due_dt > s_sth.s_cutoff )
					continue ;
			}
			else {					
				if( (strcmp(in_rec.in_invc_no, s_sth.s_invc_no)) != 0){
					seq_over(APINVOICE);
#ifdef ENGLISH
					fomen("No More Records....");
#else
					fomen("Plus de fiches....");
#endif
					get() ;
					return(QUIT) ;
				}
			}

			if( (in_rec.in_pmtcode[0] != REGULAR) &&
			    (in_rec.in_pmtcode[0] != OPEN) ) 
				continue ;

			if( ((strcmp(in_rec.in_tr_type, T_CRMEMO)) == 0) ||
		            ((strcmp(in_rec.in_tr_type, T_INVOICE)) == 0) ) {
				if( in_rec.in_disc_amt >= DELTA_AMT ) 
					continue ;
			}
			else if( in_rec.in_disc_amt <= DELTA_AMT )  
					continue ;
				
			break ;

		}
		seq_over(APINVOICE);
/***
		return( ShowInvoice() ) ;
***/
		break;
	}

	return( ShowInvoice() ) ;
}	/* SelectInvoice() */
/*----------------------------------------------------------------------*/
/* Get the invoice key from user. In ADD mode disable dup buffers, other
   modes enable dup buffers and show the current key as a default key */
static	int
ReadKey()
{
	int	i;
	char	supp_cd[sizeof(s_sth.s_supp_cd)];
	char	invc_no[sizeof(s_sth.s_invc_no)];

	fomca1(KEY_START,19,2) ;

	sr.nextfld = KEY_START;
	sr.endfld = KEY_START;
	fomud((char*)&s_sth);	/* Update Dup Buffers */

	/* Store fields to copy back when user gives ESC-F */
	STRCPY(supp_cd,s_sth.s_supp_cd) ;
	STRCPY(invc_no,s_sth.s_invc_no) ;

	s_sth.s_supp_cd[0] = LV_CHAR ;
	s_sth.s_invc_no[0] = LV_CHAR ;

#ifdef ENGLISH
	STRCPY(s_sth.s_mesg,"Press ESC-F to Go Back to Fn:");
#else
	STRCPY(s_sth.s_mesg,"Appuyer sur ESC-F pour retourner a Fn:");
#endif
	ShowMesg();

	i = ReadFields(KEY_START, KEY_END, Validate, WindowHelp, 0, ESC_F) ;
	if(PROFOM_ERR == i || DBH_ERR == i) return(i) ;
	if(RET_USER_ESC == i){
		/* copy back key fields */
		STRCPY(s_sth.s_supp_cd,supp_cd) ;
		STRCPY(s_sth.s_invc_no,invc_no) ;

		ret( WriteFields(KEY_START, KEY_END) ) ;

		s_sth.s_mesg[0] = HV_CHAR;
		ShowMesg();

		roll_back(e_mesg) ;	/* Release Locked Records */
		return(ERROR) ;
	}

	return(NOERROR);
}	/*  ReadKey() */
/*-----------------------------------------------------------------------*/
/* Move invoice details to Screen and dispaly the screen */
static	int
ShowInvoice()
{
	/* Copy Key */
	STRCPY(s_sth.s_supp_cd, in_rec.in_supp_cd) ;
	STRCPY(s_sth.s_invc_no, in_rec.in_invc_no) ;
	STRCPY(s_sth.s_tr_type, in_rec.in_tr_type) ;

	TransType = CheckTransType(in_rec.in_tr_type) ;

	/* Copy Data Fields */
	s_sth.s_fund       = in_rec.in_funds ;
	s_sth.s_po_no      = in_rec.in_po_no ;
	s_sth.s_period     = in_rec.in_period ;
	s_sth.s_invc_dt    = in_rec.in_invc_dt ;
	s_sth.s_due_dt     = in_rec.in_due_dt ;
	s_sth.s_type[0]    = in_rec.in_type[0] ;
	s_sth.s_tran_amt   = in_rec.in_amount ;
	s_sth.s_disc_per   = in_rec.in_disc_per;
	s_sth.s_disc_amt   = in_rec.in_disc_amt ;
	s_sth.s_pmtcode[0] = in_rec.in_pmtcode[0] ;
	s_sth.s_part_amt   = in_rec.in_part_amt ;
	s_sth.s_chq_no     = in_rec.in_chq_no ;
	STRCPY(s_sth.s_accno, in_rec.in_accno) ;
	STRCPY(s_sth.s_remarks, in_rec.in_remarks) ;

	/* MOve payment code description */
	CpPmntCdDesc() ;

	ret( WriteFields( KEY_START, END_FLD - 200) ) ;

	return(NOERROR) ;
}	/* ShowInvoice() */
/*-----------------------------------------------------------------------*/
/* Copy Payment code description */
static	int
CpPmntCdDesc()
{
	switch(s_sth.s_pmtcode[0]) {
	case	STOPPMT :
#ifdef ENGLISH
		STRCPY(s_sth.s_pmt_desc, "STOP") ;
#else
		STRCPY(s_sth.s_pmt_desc, "ARRET") ;
#endif
		break ;
	case	COMPLETE :
#ifdef ENGLISH
		STRCPY(s_sth.s_pmt_desc, "COMPLETE") ;
#else
		STRCPY(s_sth.s_pmt_desc, "COMPLET") ;
#endif
		break ;
	case	REL_HB :
#ifdef ENGLISH
		STRCPY(s_sth.s_pmt_desc, "Relse HB") ;
#else
		STRCPY(s_sth.s_pmt_desc, "Paie Ret") ;
#endif
		break ;
	case	PARTIAL :
		if(in_rec.in_chq_no == 0)
#ifdef ENGLISH
			STRCPY(s_sth.s_pmt_desc, "PARTIAL") ;
#else
			STRCPY(s_sth.s_pmt_desc, "PARTIEL") ;
#endif
		else
#ifdef ENGLISH
			STRCPY(s_sth.s_pmt_desc, "MANUAL") ;
#else
			STRCPY(s_sth.s_pmt_desc, "MANUEL") ;
#endif
		break ;
	default :
#ifdef ENGLISH
		STRCPY(s_sth.s_pmt_desc, "OPEN") ;
#else
		STRCPY(s_sth.s_pmt_desc, "OUVERT") ;
#endif
	}

	return(NOERROR) ;
}	/* CpPmntCdDesc() */
/*-----------------------------------------------------------------------*/
/* Take the confirmation from user for the Changes */
static	int
Confirm()
{
	int	err ;

	/* Options:
	   Change   - YEC
	   Inquiry  - YE
	*/

	for( ; ; ) {
		if (s_sth.s_fn[0] == CHANGE)
#ifdef ENGLISH
			err = GetOption("Y(es), C(ancel), E(xit)", "YCE");
#else
			err = GetOption("O(ui), A(nnuler), F(in)", "OAF");
#endif
		else
#ifdef ENGLISH
			err = GetOption("Y(es), E(xit)", "YE");
#else
			err = GetOption("O(ui), F(in)", "OF");
#endif

		if(err == PROFOM_ERR) return(err) ;

		switch(err) {
		case  YES :
		    if (s_sth.s_fn[0] == CHANGE) {

			if(err < 0) return(err) ;

			if(err == CANCEL) {
				/* Display the original record */
				ShowInvoice() ; 
				 /* Unlocking if recs not modified */ 
				roll_back(e_mesg); 
				return(NOERROR) ;
			}

			err=WriteRecords() ;
			if(err==NOERROR) return(NOERROR);
			if(err==LOCKED) {
				roll_back(e_mesg);
				STRCPY(in_rec.in_supp_cd, s_sth.s_supp_cd) ;
				STRCPY(in_rec.in_invc_no, s_sth.s_invc_no) ;
				STRCPY(in_rec.in_tr_type, "\0") ;
				flg_reset(APINVOICE);
				err = get_n_invc(&in_rec,UPDATE,0,FORWARD,e_mesg) ;
				continue ;
			}
			if(err < 0){
				fomen(e_mesg);
				get() ;
				if(err==UNDEF || err==LOCKED)
					continue ;
				return(DBH_ERR);
			}
					

		 }  /* end if */
    		if(err<0) break;
	    	return(YES) ;
		case  CANCEL :
#ifdef ENGLISH
		    err = GetOption("Confirm the Cancel (Y/N)?", "YN") ;
#else
		    err = GetOption("Confirmer l'annulation (O/N)?", "ON") ;
#endif
		    if(err == YES) return(CANCEL) ;
		    break ;
		case  EXITOPT   :
	   		 return(EXIT) ;
		}	/* switch err */

		if(err == PROFOM_ERR) return(err) ;
		if(err == DBH_ERR) return(err) ;
	}	/* for(; ; ) */
}	/* Confirm() */
/*-----------------------------------------------------------------------*/
/* Validation function() for Key and Data fields when PROFOM returns
  RET_VAL_CHK */
static	int
Validate()
{
	int	err ;

	switch(sr.curfld){
	case	SUPPCD_FLD	:	/* Supplier Cd: */
		err = CheckSupp(s_sth.s_supp_cd,BROWSE) ;
		if(DBH_ERR == err) return(err) ;
		if(err<0) {
			s_sth.s_supp_cd[0] = LV_CHAR ;
			return(ERROR) ;
		}
		if(supp_rec.s_type[0] != CONTRACT) {
#ifdef ENGLISH
			fomer("Supplier must be a contract supplier") ;
#else
			fomer("Fournisseur doit etre a contract") ;
#endif
			s_sth.s_supp_cd[0] = LV_CHAR ;
			return(ERROR) ;
		}
		fomer(supp_rec.s_name) ;
		break ;
	case	REFNO_FLD	:	/* Ref#: */
		if(s_sth.s_invc_no[0] == '\0') {
			sr.curfld += 50 ;
			s_sth.s_cutoff = LV_LONG ;
			return(ERROR) ;
		}
		break ;
	default :
#ifdef ENGLISH
		sprintf(e_mesg,"No Validity Check For Field#  %d",sr.curfld);
#else
		sprintf(e_mesg,"Pas de controle de validite pour le Champ#  %d",sr.curfld);
#endif
		fomen(e_mesg);
		get();
		return(ERROR) ;
	}	/* Switch sr.curfld */

	return(NOERROR) ;
}	/* Validate() */
/*----------------------------------------------------------------*/
/* Show Help Windows, if applicable, when user gives ESC-H in key
   and header fields */
static	int
WindowHelp()
{
	int	err ;

	switch(sr.curfld){
	case	SUPPCD_FLD	:	/* Supplier Cd: */
		err = supp_hlp(s_sth.s_supp_cd, 7, 13 );
		if(err == DBH_ERR) return(err) ;
		if(err >=0 ) redraw();
		if(err < 1) return(ERROR) ;

		err = CheckSupp(s_sth.s_supp_cd,BROWSE) ;
		if(DBH_ERR == err) return(err) ;
		if(err<0) {
			s_sth.s_supp_cd[0] = LV_CHAR ;
			return(ERROR) ;
		}
		if(supp_rec.s_type[0] != CONTRACT) {
#ifdef ENGLISH
			fomer("Supplier must be a contract supplier") ;
#else
			fomer("Fournisseur doit etre a contract") ;
#endif
			s_sth.s_supp_cd[0] = LV_CHAR ;
			return(ERROR) ;
		}
		break ;
	default :
#ifdef ENGLISH
		fomer("No Help Window For This Field");
#else
		fomer("Pas de fenetre d'assistance pour ce champ");
#endif
	}	/* Switch sr.curfld */

	return(NOERROR) ;
}	/* WindowHelp() */
/*-----------------------------------------------------------------------*/ 
/* Update the records and write to files */
static	int
WriteRecords()
{
	int	err;
	Invoice	pre_rec ;

	/* Reduce holdback in supplier */
	err = CheckSupp(s_sth.s_supp_cd,UPDATE) ;
	if( err < 0 ) {
		fomen(e_mesg) ;
		get();
		return(NOERROR) ;
	}
	if( ((strcmp(s_sth.s_tr_type, T_CRMEMO)) == 0) ||
	    ((strcmp(s_sth.s_tr_type, T_INVOICE)) == 0 ) ) 
		supp_rec.s_ytd_disc += in_rec.in_disc_amt ;
	else
		supp_rec.s_ytd_disc -= in_rec.in_disc_amt ;
	
	supp_rec.s_ytd_disc = D_Roundoff(supp_rec.s_ytd_disc);

	UpdateSummary() ;

	STRCPY(in_rec.in_supp_cd, s_sth.s_supp_cd) ;
	STRCPY(in_rec.in_invc_no, s_sth.s_invc_no) ;
	STRCPY(in_rec.in_tr_type, s_sth.s_tr_type) ;

	err = get_invc(&in_rec,UPDATE,0,e_mesg) ;
	if( UNDEF == err) {
#ifdef ENGLISH
		fomen("Record no longer exists") ;
#else
		fomen("Fiche n'existe plus") ;
#endif
		get();
		return(NOERROR) ;
	}
	else  if( err < 0 ) {
		fomen(e_mesg) ;
		get();
		return(NOERROR) ;
	}
	scpy((char *)&pre_rec,(char *)&in_rec,sizeof(Invoice)) ;

	in_rec.in_disc_per = in_rec.in_disc_amt = 0 ;
	in_rec.in_pmtcode[0] = OPEN ;
	in_rec.in_chq_no = in_rec.in_part_amt = 0 ;
	in_rec.in_accno[0] = '\0' ;

	err = put_invc(&in_rec, UPDATE, e_mesg) ;
	if(err != NOERROR) return( ShowError() ) ;

	err = put_supplier(&supp_rec, UPDATE, e_mesg) ;
	if(err != NOERROR) return( ShowError() ) ;

	err = rite_audit((char*)&s_sth, APINVOICE, UPDATE, (char*)&in_rec,
			(char*)&pre_rec, e_mesg);
	if(err==LOCKED) {
		DispError(e_mesg);
		roll_back(e_mesg);
		return(LOCKED);
	}

	if(err != NOERROR) return( ShowError() ) ;

	err = commit(e_mesg) ;
	if(err < 0) return( ShowError() ) ;

	return(NOERROR);
}	/* WriteRecords() */
/*-----------------------------------------------------------*/
/* Show the Updation error message */
static	int
ShowError()
{
#ifdef ENGLISH
	DispError("ERROR in Saving Records"); 
#else
	DispError("ERREUR en conservant les fiches");
#endif
	DispError(e_mesg);
	InitScreen() ;
	roll_back(e_mesg) ;	/* Unlock the locked Records */

	return(DBH_ERR);
}	/* ShowError() */
/*-----------------------------------------------------------*/
/* Update the Partition Summary Totals */
static	int
UpdateSummary()
{
	RelseHB.no_trans++ ;
	RelseHB.tot_amt += in_rec.in_disc_amt ;

	TotalsUpdated = 1 ;	/* Print Summary Reports, at the end */

	return(NOERROR) ;
}	/* UpdateSummary() */
/*-------------------------------------------------------------------------*/
/* Initialize Screen with High Values */
static	int
InitScreen()
{
	s_sth.s_cutoff	    = HV_LONG ;
	s_sth.s_tr_type[0]  = HV_CHAR ;
	s_sth.s_fund        = HV_SHORT ;
	s_sth.s_period      = HV_SHORT ;
	s_sth.s_po_no       = HV_LONG ;
	s_sth.s_invc_dt     = HV_LONG ;
	s_sth.s_due_dt      = HV_LONG ;
	s_sth.s_type[0]     = HV_CHAR ;
	s_sth.s_tran_amt    = HV_DOUBLE ;
	s_sth.s_disc_per    = HV_DOUBLE ;
	s_sth.s_disc_amt    = HV_DOUBLE ;
	s_sth.s_pmtcode[0]  = HV_CHAR ;
	s_sth.s_pmt_desc[0] = HV_CHAR ;
	s_sth.s_part_amt    = HV_DOUBLE ;
	s_sth.s_chq_no      = HV_LONG ;
	s_sth.s_accno[0]    = HV_CHAR ;
	s_sth.s_remarks[0]  = HV_CHAR ;

	ret(WriteFields(ST_FLD, END_FLD - 200)) ;

	return(NOERROR) ;
}	/* InitScreen() */
/*-------------------- E n d   O f   P r o g r a m ---------------------*/
