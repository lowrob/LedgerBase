/******************************************************************************
		Sourcename    : chqhisma.c
		System        : Budgetary Financial System.
		Subsystem     : APS 
		Module        : Cheque History File Maintenance 
		Created on    : 89-12-12
		Created  By   : K HARISH.
		Cobol sources : cp200---03

HISTORY:
 Date           Programmer     Description of modification
____/__/__      __________     ___________________________
1990/11/22	M. Cormier	Changed the Cash option to display the
				following sub-option line:

				"C(ash), N(ext Cheque), E(nd Session)"

				Where :

				C(ash)	- Flags the ch_status as 'C'
					- Reads the next Outstanding
					  cheque on file
					- Display on screen
					- Give same sub-option line

				N(ext Cheque)
					- Reads the next Outstanding
					  cheque on file
					- Display on screen
					- Give same sub-option line

				E(nd Session)
					- takes the user back to the 
					  function field

1990/11/22	M. Cormier	Modified the WriteSession() function so
				that the report record show a negative 
				net amount when a cheque status is 
				changed from Cashed to Outstanding.
1991/01/11	F.Tao		Fixed NextOutSt for proper exit.

L.Robichaud	1993/10/13	Pass new parameter to close_rep function for 
				a banner to print with 3000 family.
******************************************************************************/
#define MAIN
#define MAINFL		CHQHIST		/* main file used */

#include <stdio.h>
#include <reports.h>
#include <cfomstrc.h>

#define SYSTEM		"ACCOUNTS PAYABLE"
#define MOD_DATE	"23-JAN-90"
#define SCREEN_NAME	"chqhisma"
#define CHQHIST_MENU	"chqhismu"
#define ESCAPE		12	/* flag indicates discontinuation of entries */
#define RANDOM  	18
#define SEQUENTIAL	19
#define	COL_HDG_NO	0
#define	COL_HDG_YES	1
#define	HIGH		1
#define	LOW		-1
#define	CASHCHQFMT	3
#define HL_CHAR(VAL)	(VAL==HIGH) ? HV_CHAR : LV_CHAR
#define ESC_F		(sr.retcode==RET_USER_ESC && \
			(sr.escchar[0]=='F'||sr.escchar[0]=='f'))
#define ESC_H		(sr.retcode==RET_USER_ESC && \
			(sr.escchar[0]=='H'||sr.escchar[0]=='h'))

#define	NO_HLP_WIN	(sr.curfld!=PGM_FLD)
#define PROJECT		"chqhrpt"
#define PURGEFMT	3
#define FUND_DEFAULT	1

#define CHQMAINT	'1'
#define CASHENTRY	'2'
#define BANKSTAT	'3'
#define CHQPURGE	'4'

#define T_CHQMAINT	'M'
#define T_CASHENTRY	'C'
#define T_BANKSTAT	'B'
#define T_CHQPURGE	'P'
#define T_EXITOPT	'E'

#ifdef ENGLISH
#define	ADDREC	'A'
#define	NEXT	'N'
#define	PREV	'P'
#define INQUIRE	'I'
#define EXITOPT	'E'
#define EDIT	'E'
#define CANCEL	'C'
#define	YES	'Y'
#define	NO	'N'
#define OUTSTAND	'O'
#define CASH		'C'

#define AP_SYS		'A'
#else
#define	ADDREC	'R'
#define	NEXT	'S'
#define	PREV	'P'
#define INQUIRE	'I'
#define EXITOPT	'F'
#define EDIT	'M'
#define CANCEL	'A'
#define	YES	'O'
#define	NO	'N'
#define OUTSTAND	'N'
#define CASH		'E'

#define AP_SYS		'S'
#endif

#define PGM_FLD		100		/* Program Name field	*/
#define FN_FLD		400		/* Function field	*/
#define CHG_FLD		500		/* Editing field	*/

#define FUND_FLD	600		/* Fund No. field	*/
#define KEY_START 	600		/* Key starting field	*/

#define ACCNO_FLD	650		/* Account No. field	*/

#define CHQNO_FLD	700		/* Cheque No. field	*/
#define KEY_END  	700		/* Key ending field	*/

#define OPT_FLD		900		/* Menu option field	*/

#define DATE_FLD	900		/* Date   field		*/
#define BEGN_FLD	900		/* Beginning data field	*/

#define PERI_FLD	950		/* Period field		*/
#define NAME_FLD	1000		/* Supplier Name Field	*/
#define AMT_FLD		1100		/* Amount field		*/
#define SYS_FLD		1200		/* System field		*/

#define STA_FLD		1300		/* Status field		*/
#define LAST_FLD	1300		/* Last data field	*/

#define MSG_FLD		1400		/* Message line   field */
#define RESP_FLD	1500		/* Option response field */


/* chqhismu.sth - header for C structure generated by PROFOM EDITOR */

struct	hi_menu	{
	char	hm_progname[11];/* 100 program name */
	long	hm_rundt;	/* 300 system date */
	char	hm_option[2];	/* 900 option */
};

/* chqhisma.sth - header for C structure generated by PROFOM EDITOR */
struct	hi_struct	{
	char	s_progname[11];	/* 100 STRING XXXXXXXXXX */
	char	s_scrhdg[27];	/* 200 STRING XXXXXXXXXX */
	long	s_rundt;	/* 300 DATE YYYYFMMFDD */
	char	s_fn[2];	/* 400 STRING X */
	short	s_fld_no;	/* 500 NUMERIC 9 */
	short	s_fund;		/* 600 NUMERIC 999 */
	char	s_accno[19];	/* 650 bank account# */
	long	s_chq_no;	/* 700 NUMERIC 99999999 */
	long	s_date;		/* 900 DATE YYYYFMMFDD */
	short	s_period;	/* 950 NUMERIC 99 */
	char	s_name[49];	/* 1000 STRING */
	double	s_amount;	/* 1100 NUMERIC 99999999.99 */
	char	s_system[2];	/* 1200 STRING X */
	char	s_status[2];	/* 1300 STRING X */
	char	s_mesg[77];	/* 1400 STRING */
	char	s_resp[2];	/* 1500 STRING X */
};
static struct hi_struct	s_rec;		/* screen record */
static struct hi_menu		hm_rec;		/* screen record */
struct stat_rec 	sr;		/* profom status record */
static Gl_rec		gl_rec;
static Chq_hist	chqhist, oldchqhist;
Chq_hist	cheque, pre_rec;
Pa_rec		pa_rec;
Ctl_rec		ctl_rec;

static char	e_mesg[80];

static char	*CurrentScr;
char	chardate[11];
char	projname[50];
char	*arayptr[5];

static double	total_outstanding;
static int retval, pgcnt;	/* Global variable to store function values */
static char	 procflag;

/* Initialize profom fields, call entry procedures */
main( argc, argv )
int argc;
char *argv[];
{
	strncpy( SYS_NAME, SYSTEM, 50 ); /* Module name */
	strncpy( CHNG_DATE, MOD_DATE, 10 );/* Last date of change */
	
	proc_switch( argc,argv,MAINFL );/* process the switches */

	if( (retval=Initialize())<0 )	/* Initialize profom enviroment */
		exit(-1);
	retval = Process();	/* Interact with the user */
	CleanExit();
	exit(0);
}    /*  Main()   */

static	int
CleanExit()
{
	/* clear and exit the screen , close files & exit program */
	free_audit();	/* free memory allocated for writing audit rec */
	fomcs();
	fomrt();
	close_dbh();
	return(NOERROR);
}  /* CleanExit  */

static	int
Initialize()
{
	/* initialize the profom status variables */
	CurrentScr = (char*)&s_rec;
	STRCPY( sr.scrnam, NFM_PATH );
	strcat( sr.scrnam, SCREEN_NAME );
	STRCPY( sr.termnm, terminal );

	/* initialize the fields and the profom screen */
	if( FillScrHdg()<0 ) 			return(-1);
	if( FillKeyFields( LOW )<0 ) 		return(-1);
	if( FillField( HIGH )<0 ) 		return(-1);
	if( FillNonKeyFlds( HIGH )<0 ) 		return(-1);
	if( FillMesgRespFlds( HIGH )<0 ) 	return(-1);
	fomin( &sr );			/* initialize profom */
	fomcf(1,1);			/* Enable snap-screen option */

	return(NOERROR);
}   /*  Initialize()  */
/* Fill the screen heading fields: the program name and the date */
static	int
FillScrHdg()
{
	STRCPY( s_rec.s_progname, PROG_NAME );
	s_rec.s_rundt = get_date();
	return(NOERROR);
}   /*  FillScrHdg()   */
/* Fill the keyfields with high or low values */
static	int
FillKeyFields( value )
short value;
{
	s_rec.s_fund = value * HV_SHORT;
	s_rec.s_accno[0] = HL_CHAR( value );
	s_rec.s_chq_no = value * HV_LONG;

	return(NOERROR);
}   /* FillKeyfields()  */
/* Fill the field# field with high/low values */
static int
FillField( value )
short value;
{
	s_rec.s_fld_no = value * HV_SHORT;
	return(NOERROR);
}   /*  FillField()  */
/* Fill the non key fields with high/low values */
static int
FillNonKeyFlds( value )
short value;
{
	s_rec.s_date		= value * HV_LONG;
	s_rec.s_period		= HV_SHORT;  /* only used for bank statement */
	s_rec.s_name[0] 	= HL_CHAR( value );
	s_rec.s_amount		= value * HV_DOUBLE;
	s_rec.s_system[0] 	= HL_CHAR( value );
	s_rec.s_status[0] 	= HL_CHAR( value );
	return(NOERROR);
}  /*  FillNonKeyFlds()  */
/* Fill the message and response fields with high or low values */
static int
FillMesgRespFlds( value )
short value;
{
	s_rec.s_mesg[0] = HL_CHAR(value);
	s_rec.s_resp[0] = HL_CHAR(value);
	return(NOERROR);
}  /*  FillMesgRespFlds()  */
/*	Allow the user to choose one of the three options as below */
static int
SelectProc()
{
	char	c;

	CurrentScr = (char*)&hm_rec;
	STRCPY( sr.scrnam, NFM_PATH );
	strcat( sr.scrnam, CHQHIST_MENU );
	STRCPY(hm_rec.hm_progname,PROG_NAME);
	hm_rec.hm_rundt = get_date();
	hm_rec.hm_option[0] = LV_CHAR;

	for( ; ; ){
		sr.nextfld = OPT_FLD;
		fomrf( (char *)&hm_rec );
		c = hm_rec.hm_option[0];
		if( (c>'0' && c<'5') || c==EXITOPT )
			break;
	}
	switch( c ){
		case CHQMAINT:	procflag = T_CHQMAINT;	break;
		case CASHENTRY: procflag = T_CASHENTRY; break;
		case BANKSTAT:	procflag = T_BANKSTAT;	break;
		case CHQPURGE:	procflag = T_CHQPURGE;	break;
		case EXITOPT:	procflag = T_EXITOPT;	break;
	}
	if(procflag == T_CHQMAINT || procflag == T_BANKSTAT ||
	   procflag == T_CHQPURGE) {
		CurrentScr = (char*)&s_rec;
		STRCPY( sr.scrnam, NFM_PATH );
		strcat( sr.scrnam, SCREEN_NAME );
	}
	return(NOERROR);
}  /*  SelectProc()  */
/* Accept user's option and call the corresponding routine in a loop */
static int
Process()
{
	/* Get the parameter file record */
	if( get_param(&pa_rec,BROWSE,1,e_mesg)<1 ){
		fomen(e_mesg);
		get();
		return(-1);
	}

	mkdate(get_date(),chardate);

	for( ; ; ){
		/* Allow user to choose option */
		if( SelectProc()<0 )
			return(-1);

		switch( procflag ){
			case T_EXITOPT:
				return(NOERROR);
			case T_CHQMAINT:
				CHKACC(retval,BROWSE,e_mesg);
				if( InitReport(procflag)<0 )
					return(-1);
#ifdef ENGLISH
				STRCPY( s_rec.s_scrhdg,
					"CHEQUE HISTORY MAINTENANCE");
#else
				STRCPY( s_rec.s_scrhdg,
					" ENTRETIEN L'HIST CHEQUES ");
#endif
				retval = MaintProc();
				ClearScreen();
				rpclose();
				if (retval<0 )/* Cheque Purge process */
					return(-1);
				break;
			case T_CASHENTRY:
				CHKACC(retval,BROWSE,e_mesg);
				if( InitReport(procflag)<0 )
					return(-1);
				retval = CashMaint();
				rpclose();
				if(retval<0 ) /* Cash Cheque Entry   */
					return(ERROR);
				break;	
			case T_CHQPURGE:
				CHKACC(retval,P_DEL,e_mesg);
				if( InitReport(procflag)<0 )
					return(-1);
				s_rec.s_fn[0] = hm_rec.hm_option[0];
#ifdef ENGLISH
				STRCPY( s_rec.s_scrhdg,
					"       CHEQUE PURGE       ");
#else
				STRCPY( s_rec.s_scrhdg,
					"   ELIMINATION DE CHEQUES ");
#endif
				retval = PurgeProc();
				ClearScreen();
				rpclose();
				if (retval<0 )/* Cheque Purge process */
					return(-1);
				break;
			case T_BANKSTAT:
				CHKACC(retval,BROWSE,e_mesg);
				s_rec.s_fn[0] = hm_rec.hm_option[0];
#ifdef ENGLISH
				STRCPY( s_rec.s_scrhdg,
					"   RECONCILIATION FORM    ");
#else
				STRCPY( s_rec.s_scrhdg,
					" FORMUL CONCILIA BANCAIRE ");
#endif
				if (BankProc()<0 )/* Cheque Purge process */
					return(-1);
				ClearScreen();
				break;
		}
		if( retval<0 ){
			fomen(e_mesg);
			get();
		}
		if( retval==DBH_ERR )
			return(retval);
	}
}    /*  Process()   */

/*	Cheque History File Maintenance process */
static int
MaintProc()
{
	/* Initialize the key fields to zeros. Used if seq. search is made */
	s_rec.s_fund = LV_SHORT;
	s_rec.s_accno[0] = LV_CHAR;
	s_rec.s_chq_no = LV_LONG;
	if( (retval=WriteFields(KEY_START,KEY_END))<0 )
		return(retval);

	flg_reset(CHQHIST) ;		/* Required here, when you come here
					   after selecting Purge */

	for( ; ; ){
		if( ReadFunction()<0 ) return(-1);
		switch( s_rec.s_fn[0] ){
			case ADDREC:	/* add a record */
				CHKACC(retval,ADD,e_mesg);
				if( ClearScreen()<0 )	return(-1);
				retval = AddRecord();
				roll_back(e_mesg);
				if( retval<0 )
					return(-1);
				break;
			case NEXT:	/* show next record in sequence */
				CHKACC(retval,BROWSE,e_mesg);
				if( Inquiry(SEQUENTIAL,FORWARD)<0 ) return(-1);
				break;
			case PREV:	/* show prev record in sequence */
				CHKACC(retval,BROWSE,e_mesg);
				if( Inquiry(SEQUENTIAL,BACKWARD)<0 ) return(-1);
				break;
			case INQUIRE:	/* show selected record */
				CHKACC(retval,BROWSE,e_mesg);
				if( Inquiry(RANDOM,0)<0 ) return(-1);
				break;
			case OUTSTAND:	/* Change status of current record */
			case CASH:
				CHKACC(retval,UPDATE,e_mesg);
				retval = ChangeRecord();
				roll_back(e_mesg);
				if (retval == EFL) 
					break;
				if( retval<0 )
					return(-1);
				break;
				
			case EXITOPT:	/* exit */
				return(NOERROR);
			default:
				break;
		}
		if (retval == EFL || retval >= 0){
			continue;
		}
		else {
			fomen(e_mesg);
			get();
		}
/*		if( retval<0 ){
			fomen(e_mesg);
			get();
		}
		if( retval==DBH_ERR )
			return(retval);
*/
	}
}   /*   MaintProc()  */
static int
ReadFunction()	/* Display options at the bottom, and read entry */
{
#ifdef ENGLISH
	fomer("A(dd), O(utstanding), C(ashed), N(ext), P(rev), I(nquire), E(xit)");
#else
	fomer("R(ajouter), N(on-regle), E(ncaisse), S(uivant), P(recedent), I(nterroger), F(in)");
#endif
	sr.nextfld = FN_FLD;	/* Fn field number */
	fomrf( (char *)&s_rec );
	ret( err_chk(&sr) );
	return(NOERROR);
}    /*   ReadFunction   */
/* Add a cheque history record */
static int
AddRecord()
{
	if( SetDupBuffers( ACCNO_FLD, CHQNO_FLD, 0 )<0 )
		return(-1);

	if( SetDupBuffers( FUND_FLD, FUND_FLD, 2 )<0 )
		return(-1);

	/* Read key fields */
	if( (retval=RdKeyFlds())<0 )
		return(retval);
	if(retval==ESCAPE){
		if(ClearScreen()<0)	
			return(-1);
		return(retval);
	}
	
	s_rec.s_date = s_rec.s_rundt;
	if( SetDupBuffers( DATE_FLD, DATE_FLD, 2 )<0 )
		return(-1);

	/* Read the non key fields now */
	if( FillNonKeyFlds(LOW)<0 ) 
		return(-1);
	if( (retval=ReadFields(DATE_FLD,STA_FLD))<0 )
		return(retval);
	if(retval==ESCAPE){
		if(ClearScreen()<0)	return(-1);
		return(retval);
	}
	if( SetDupBuffers( DATE_FLD, DATE_FLD, 0 )<0 )
		return(-1);

	/* added by F.Tao, 01/28/91		*/
	/* add sub option (Yes,Edit,Cancel) for add mode		*/

	retval =  EditFlds();
	if (retval == ESCAPE) return(NOERROR);
	if(retval<0) return(retval);

	/* Write the record, in ADD mode, to the file */

	retval = WriteSession(ADD) ;
	if(retval<0) return(retval);

	return(NOERROR);

}  /*   AddRecord()   */
/* Read key fields */
static int
RdKeyFlds()
{
	if( FillKeyFields(LOW)<0 ) return(-1);
	default_fund();
	return ( ReadFields(FUND_FLD,CHQNO_FLD) );
}    /* RdKeyFlds()   */
static int
ReadFields(start,end)	/* read the given range of fields */
int start, end;		/* start and end profom field numbers */
{
	int retval;

	sr.nextfld = start;
	sr.endfld = end;
	for( ; ; ){	/* Do in a loop */
		fomrd( (char *)&s_rec );	/* Profom call */
		ret(err_chk(&sr));		/* Check for profom error */
		if( sr.retcode==RET_USER_ESC || sr.retcode==RET_VAL_CHK ){
		    if( sr.retcode==RET_USER_ESC ){
			if( sr.escchar[0]=='F' || sr.escchar[0]=='f' )
				return( ESCAPE );
			else if( sr.escchar[0]=='H' || sr.escchar[0]=='h' ){
				if( NO_HLP_WIN )
					continue;
			}
			else
				continue;
		    }
		    retval=Validate();
		    if(retval<0 || retval==ESCAPE)
			return(retval);
		    else
			continue;
		}
		break;
	}
	return(NOERROR);
}  /*  ReadFields()   */
static int
WriteFields( start,end )	/* write the given range of fields */
int start, end;			/* start & end profom field numbers */
{
	sr.nextfld = start;
	sr.endfld = end;
	fomwr( (char *)&s_rec );
	ret( err_chk(&sr) );
	return(NOERROR);
}  /*   WriteFields()   */
static int
ClearScreen()	/* clear the screen except fn field, screen hdg & key */
{
	if(FillKeyFields(LOW)<0 ) return(-1);
	if(FillField(HIGH)<0 ) return(-1);
	if(FillNonKeyFlds(HIGH)<0 ) return(-1);
	if(FillMesgRespFlds(HIGH)<0 ) return(-1);

	if( WriteFields(CHG_FLD,RESP_FLD)<0 ) return(-1);
	
	return(NOERROR);
}    /*   CleanScreen()   */
static int
Validate()	/* Validate the values entered by the user */
{
	int index;
	int save_nextfld, save_endfld;

	switch( sr.curfld ){
		case CHG_FLD:	/* field # for editing */
			if( sr.fillcode==FIL_OMITTED )	/* Nothing entered */
				return(ESCAPE);
			break;
		case FUND_FLD:	/* fund code: check by reading control rec */
			ctl_rec.fund = (short)s_rec.s_fund;
			index = get_ctl( &ctl_rec, BROWSE, 0, e_mesg );
			if( index==ERROR ){
				fomen(e_mesg); get();
				return(-1);
			}
			if( index!=NOERROR ){	/* record doesn't exist */
				fomer(e_mesg);
				s_rec.s_fund = LV_SHORT; 
			}
			else
				fomer( ctl_rec.desc );

			save_nextfld = sr.nextfld;
			save_endfld = sr.endfld;
			STRCPY(s_rec.s_accno,ctl_rec.bank1_acnt);
			if( SetDupBuffers( ACCNO_FLD, ACCNO_FLD, 2 )<0 )
				return(-1);
			s_rec.s_accno[0] = LV_CHAR ;
			sr.nextfld = save_nextfld ;
			sr.endfld = save_endfld ;
			
			break;
		case ACCNO_FLD:	/* bank account # */
			if(acnt_chk(s_rec.s_accno)==ERROR){
#ifdef ENGLISH
				fomer("Invalid Account number");
#else
				fomer("Numero de compte invalide");
#endif
				s_rec.s_accno[0]=LV_CHAR;
				break;
			}
			if( strcmp(s_rec.s_accno,ctl_rec.bank1_acnt) &&
				strcmp(s_rec.s_accno,ctl_rec.bank2_acnt) ){
#ifdef ENGLISH
				sprintf(e_mesg,"Bank1: %s, Bank2: %s",
						ctl_rec.bank1_acnt,
						ctl_rec.bank2_acnt );
#else
				sprintf(e_mesg,"Banque1: %s, Banque2: %s",
						ctl_rec.bank1_acnt,
						ctl_rec.bank2_acnt );
#endif
				fomer(e_mesg);
				s_rec.s_accno[0]=LV_CHAR;
				break;
			}
			if (s_rec.s_fn[0] == BANKSTAT ) {
				s_rec.s_date = pa_rec.pa_date;
				s_rec.s_period = pa_rec.pa_cur_period;
				if( SetDupBuffers( DATE_FLD, PERI_FLD, 1 )<0 )
					return(-1);
				s_rec.s_date = LV_LONG ;
				s_rec.s_period = LV_SHORT ;
				sr.nextfld = sr.curfld ;
				sr.endfld = PERI_FLD ;
			}
			break;
		case CHQNO_FLD:	/* cheque number */
			if( s_rec.s_chq_no<1 ){
#ifdef ENGLISH
				fomer("Invalid cheque number");
#else
				fomer("Numero de cheque invalide");
#endif
				s_rec.s_chq_no = LV_LONG;
				break;
			}
			chqhist.ch_funds = s_rec.s_fund;
			STRCPY( chqhist.ch_accno, s_rec.s_accno );
			chqhist.ch_chq_no = s_rec.s_chq_no;
			retval = get_chqhist(&chqhist,BROWSE,0,e_mesg);
			if( retval==ERROR ){
				fomen(e_mesg);
				get();
				return(retval);
			}
			if( s_rec.s_fn[0]==ADDREC ){
			    if( retval!=UNDEF ){
#ifdef ENGLISH
			      fomer("Record with given cheque# already exists");
#else
			      fomer("Fiche avec numero de cheque donne existe deja");
#endif
				s_rec.s_chq_no = LV_LONG;
				break;
			    }
			}
			else if( retval!=NOERROR ){
#ifdef ENGLISH
				fomer("Record with given key not found");
#else
				fomer("Fiche avec cle donnee pas retrouvee");
#endif
				s_rec.s_chq_no = LV_LONG;
				break;
			}
			break;
		case PERI_FLD:	/* period */
			if(s_rec.s_period > pa_rec.pa_cur_period) {
#ifdef ENGLISH
				fomer("Period Invalid or Not Open");
#else
				fomer("Periode invalide ou pas ouverte");
#endif
				s_rec.s_period = LV_SHORT;
			}
			break;
		case AMT_FLD:	/* Cheque amount */
			if(s_rec.s_amount<=0.0){
#ifdef ENGLISH
				fomer("Amount too small to be accepted");
#else
				fomer("Montant trop petit pour etre accepte");
#endif
				s_rec.s_amount = LV_DOUBLE ; 
			}
			else{
				s_rec.s_system[0] = AP_SYS;
				if( s_rec.s_fn[0]==ADDREC )
					s_rec.s_status[0] = OUTSTANDING;
			}
			break;
		case SYS_FLD:	/* System */
			if( s_rec.s_system[0]!=AP_SYS ){
#ifdef ENGLISH
				fomer("Enter A(PS)");
#else
				fomer("Entrer S(C/P)");
#endif
				s_rec.s_system[0]=LV_CHAR;
			}
			if( s_rec.s_fn[0]==ADDREC )
				s_rec.s_status[0] = OUTSTANDING;
			break;
		case STA_FLD:	/* Cheque status */
			if( s_rec.s_status[0]!=OUTSTANDING 
			 && s_rec.s_status[0]!=CASHED ){
#ifdef ENGLISH
				fomer("Status allowed: O(utstanding), C(ashed)");
#else
				fomer("Etats permis: N(on-regles), E(ncaisses)");
#endif
				s_rec.s_status[0]=LV_CHAR;
			}
			break;
		default:
#ifdef ENGLISH
			fomer("No validation for this field");
#else
			fomer("Pas de validation pour ce champ");
#endif
			break;
	}
	sr.nextfld = sr.curfld;
	return(NOERROR);
}    /*  Validate()   */
static int
EditFlds()	/* Ask if user wants to edit fields before saving */
{
	/* Go to field editing directly if in change mode */
	if( s_rec.s_fn[0]==CASH )
		if( FldEdit()<0 )
			return(-1);
	for( ; ; ){
#ifdef ENGLISH
		if(DisplayMessage( "Y(es), E(dit), C(ancel)")<0 ) 
#else
		if(DisplayMessage( "O(ui), M(odifier), A(nnuler)")<0 )
#endif
			return(-1);
		sr.nextfld = RESP_FLD;
		fomrf( (char *)&s_rec );
		ret( err_chk(&sr) );
		switch( s_rec.s_resp[0] ){
			case EDIT:	/* Edit the fields */
				if( (retval=FldEdit())<0 )
					return(retval);
				break;
			case CANCEL:	/* Cancel the session */
#ifdef ENGLISH
				if(DisplayMessage("Confirm the Cancel (Y/N)?")<0)
#else
				if(DisplayMessage("Confirmer l'annulation (O/N)?")<0)
#endif
					return(-1);
				sr.nextfld = RESP_FLD;	/* response field */
				fomrf( (char *)&s_rec );
				ret( err_chk(&sr) );
				if( s_rec.s_resp[0]==YES ){
					roll_back(e_mesg);
					if( HideMessage()<0 ) return(-1);
					return(ESCAPE);
				}
				break;
			case YES:
				if( HideMessage()<0 ) return(-1);
				return(NOERROR);
		}
	}
}    /*  EditFlds()   */
static int
DisplayMessage(mesg)	/* Display the given message in the message field */
char *mesg;
{
	STRCPY( s_rec.s_mesg, mesg );
	if( WriteFields(MSG_FLD,MSG_FLD)<0 )	return(-1);
	return(NOERROR);
}    /*    DisplayMessage()   */
static int
HideMessage()	/* Hide the message & response fields */
{
	if( FillMesgRespFlds(HIGH)<0 )	return(-1);
	if( WriteFields(MSG_FLD,RESP_FLD)<0 ) return(-1);
	return(NOERROR);
}     /*   HideMessage()    */
static int
HideFldNo()	/* Hide the 'Field#' field */
{
	if( FillField(HIGH)<0 )	return(-1);
	if( (WriteFields(CHG_FLD,CHG_FLD))<0 )
		return(-1);
	return(NOERROR);
}   /*   HideFldNo()    */
static int
FldEdit()	/* Read the field number and read corresponding field */
{
	int firstfld,lastfld;

	for( ; ; ){
		/* Read number of field to be changed */
		if( FillField(LOW)<0 )	return(-1);
#ifdef ENGLISH
		fomer("Enter RETURN to terminate Edit");
#else
		fomer("Appuyer sur RETURN pour terminer l'ajustement");
#endif
		if( (retval = ReadFields(CHG_FLD,CHG_FLD))<0 ) return(-1);
		if( retval==ESCAPE ){
			if( HideFldNo()<0 ) return(-1);
			break;
		}
		/* validate the field# entry */
		if( s_rec.s_fld_no < 1 || s_rec.s_fld_no > 5 ){
#ifdef ENGLISH
			fomen("Cannot access specified field");
#else
			fomen("Ne peut pas acceder au champ specifie");
#endif
			get();
			continue;
		}
		if( s_rec.s_fld_no==4 ){	/* system */
#ifdef ENGLISH
			fomen("Cannot change specified field");
#else
			fomen("Ne peut pas changer le champ specifie");
#endif
			get();
			continue;
		}
		switch(s_rec.s_fld_no){
			case 1: firstfld = lastfld = DATE_FLD;	/* cheque date */
				break;
			case 2: firstfld = lastfld = NAME_FLD;	/* name */
				break;
			case 3: firstfld = lastfld = AMT_FLD;	/* amount */
				break;
			case 5: firstfld = lastfld = STA_FLD; /* status */
				break;
			default:
				continue;
		}
		retval = ModifyField(firstfld, lastfld);
		if( retval<0 )	return(retval);
		if( retval==ESCAPE ){
			if( HideFldNo()<0 ) return(-1);
			break;
		}
	}
	return(NOERROR);
}    /*    FldEdit()   */
static int
ModifyField( firstfld, lastfld )	/* Read & change the specified fields */
int firstfld,lastfld;
{
	int i;

	for( i=firstfld; i<=lastfld; i+=100 ){
		fomca1( i,19,2);	/* enable dup buffers */
		fomca1( i,10,0);	/* disable escape flag */
	}
	sr.nextfld = firstfld;
	sr.endfld = lastfld;
	fomud( (char *)&s_rec);		/* Update dup buffers */
	switch(firstfld){
		case DATE_FLD:	/* cheque date */
			s_rec.s_date = LV_LONG;
			break;
		case NAME_FLD:	/* name of beneficiary */
			s_rec.s_name[0] = LV_CHAR;
			break;
		case AMT_FLD:	/* amount */
			s_rec.s_amount = LV_DOUBLE;
			break;
		case STA_FLD:	/* status */
			s_rec.s_status[0] = LV_CHAR;
			break;
		default:
			break;
	}
	retval = ReadFields( firstfld, lastfld );
	if( retval<0 || retval==ESCAPE )	return(retval);
	for( i=firstfld; i<=lastfld; i+=100 ){
		fomca1( i,19,0);	/* disable dup buffers */
		fomca1( i,10,1);	/* enable escape flag */
	}
	return(NOERROR);
}     /*    ModifyField()   */
static int
WriteSession(mode)	/* Write the cheque history record */
int	mode;		/* ADD, UPDATE, P_DEL */
{
	/* Copy screen contents to the file record if not DELETE mode */
	if( mode!=P_DEL ){
		chqhist.ch_funds = s_rec.s_fund;
		STRCPY( chqhist.ch_accno, s_rec.s_accno );
		chqhist.ch_chq_no = s_rec.s_chq_no;
		chqhist.ch_date = s_rec.s_date;
		chqhist.ch_net_amt = s_rec.s_amount;
		STRCPY(chqhist.ch_name,s_rec.s_name);
		chqhist.ch_sys[0] = s_rec.s_system[0];
		chqhist.ch_status[0] = s_rec.s_status[0];
	}
	/* Write the record with the given mode */
	retval = put_chqhist( &chqhist, mode, e_mesg );
	if( retval!=NOERROR ){
		fomen(e_mesg);get();
		roll_back(e_mesg);
		return(retval);
	}
/* Added by C.Burns Oct 07, 1991 */
	if( s_rec.s_fn[0] == ADDREC) 
		chqhist.ch_net_amt *= (-1);
/*********************************/

	if( oldchqhist.ch_status[0] == CASHED && 
	    chqhist.ch_status[0]    == OUTSTANDING ) 
		chqhist.ch_net_amt *= (-1);

	/* Write a report line about the written record */
	if( rpline(arayptr)<0 )
		return(-1);
	if( oldchqhist.ch_status[0] == CASHED && 
	    chqhist.ch_status[0]    == OUTSTANDING ) 
		chqhist.ch_net_amt *= (-1);

/* Added by C.Burns Oct 07, 1991 */
	if( s_rec.s_fn[0] == ADDREC) 
		chqhist.ch_net_amt *= (-1);
/*********************************/
	/* Commit the write to the database */
	if( commit(e_mesg)<0 ){
		fomen(e_mesg);
		get();
		return(-1);
	}
	return(NOERROR);
}   /*    WriteSession   */
static int
Inquiry( access, direction )	/* Screen inquiry, random/sequential */
int access, direction;		/* RANDOM, SEQUENTIAL accesses */
{
	int retval;

	/* If Random access, read the key of required record */
	if( access==RANDOM ){
		retval = GetRecord();	/* Read the key values */
		if( retval==UNDEF || retval==ESCAPE || retval==LOCKED )
			return( ESCAPE );
	}
	else{	/* access is sequential, so get next record from file */
		retval = GetNextRec( direction );	/* Get next rec */
		if(retval==EFL)
			return(NOERROR);
	}
	if( retval<0 ){	/* errors in reading */
		fomen(e_mesg);get();
		return(-1);
	}
	retval = DisplayRecord();	/* Display the records */
	if( retval<0 ) return(retval);

	return(NOERROR);
}     /*    Inquiry   */
static int
DisplayRecord()	/* Display the obtained record through profom screen */
{
	s_rec.s_date = chqhist.ch_date;
	s_rec.s_amount = chqhist.ch_net_amt;
	STRCPY( s_rec.s_name, chqhist.ch_name );
	s_rec.s_system[0] = chqhist.ch_sys[0];
	s_rec.s_status[0] = chqhist.ch_status[0];

	if( WriteFields(BEGN_FLD,LAST_FLD) < 0 )
		return(-1);
	return(NOERROR);
}   /*  DisplayRecord()    */
static int
GetNextRec(direction)	/* Read the next record in the specified direction */
int	direction;
{
	int retval;

	if( flg_start(CHQHIST)!=direction ){ 	/* file access mode changed */
		chqhist.ch_funds = s_rec.s_fund;
		STRCPY( chqhist.ch_accno, s_rec.s_accno );
		chqhist.ch_chq_no = s_rec.s_chq_no;
		if( direction==FORWARD )
			chqhist.ch_chq_no++;
		else
			chqhist.ch_chq_no--;

		flg_reset(CHQHIST);
	}
	/* Read the next record from cheque history file */
	if (s_rec.s_fn[0] == CASH)
	   retval = get_n_chqhist( &chqhist, UPDATE, 0, direction, e_mesg );
	else
	   retval = get_n_chqhist( &chqhist, BROWSE, 0, direction, e_mesg );
#ifndef	ORACLE
	seq_over( CHQHIST );
#endif
	if( retval==EFL ){
#ifdef ENGLISH
		fomen("No More Records....");
#else
		fomen("Plus de fiches....");
#endif
		get();
		flg_reset(CHQHIST);
		return(EFL);
	}
	if( retval!=NOERROR ){
		fomen(e_mesg);	get();
		return(retval);
	}
	/* Write the key fields on to the screen */
	s_rec.s_fund = chqhist.ch_funds;
	STRCPY( s_rec.s_accno, chqhist.ch_accno );
	s_rec.s_chq_no = chqhist.ch_chq_no;
	if( WriteFields(FUND_FLD,CHQNO_FLD)<0 )
		return(-1);
	return(NOERROR);
}    /*  GetNextRec()  */
static int
SetDupBuffers( firstfld, lastfld, value )
int	firstfld, lastfld;	/* field numbers range */
int	value;			/* ENABLE or DISABLE */
{
	int i;

	for( i=firstfld; i<=lastfld; i+=50 )
		fomca1( i, 19, value);
	sr.nextfld = firstfld;
	sr.endfld = lastfld;
	fomud( (char *)&s_rec );
	ret( err_chk(&sr) );

	return( 0 );
}     /*    SetDupBuffers()    */
static int
GetRecord()	/* Read the header key values, read rec */
{
	int retval;
	int mode;

	/* Set the mode depending on the Fn option */
	/* C/O for marking a cheque as cashed/outstanding */
	if( s_rec.s_fn[0]==CASH || s_rec.s_fn[0]==OUTSTAND )
		mode = UPDATE;
	else
		mode = BROWSE;

	/* Enable dup buffers and read key fields */
	if( SetDupBuffers( FUND_FLD, CHQNO_FLD, 2 )<0 )
		return(-1);
	s_rec.s_fund = LV_SHORT;
	s_rec.s_accno[0] = LV_CHAR;
	s_rec.s_chq_no = LV_LONG;
	if( (retval=ReadFields(FUND_FLD,CHQNO_FLD))<0 || retval==ESCAPE ) 
		return( retval );

	/* Fetch the record having the given key */
	chqhist.ch_funds = s_rec.s_fund;
	STRCPY( chqhist.ch_accno, s_rec.s_accno );
	chqhist.ch_chq_no = s_rec.s_chq_no;
	retval = get_chqhist( &chqhist, mode, 0, e_mesg );
	if( retval!=NOERROR ){
		fomer(e_mesg);
		get();
		return(retval);
	}
	return(NOERROR);
}
static int
ChangeRecord()	/* Change an existing record */
{
	int retval, err;

	/* Get the record & display it */
	retval = Inquiry( RANDOM, 0 );
	if( retval<0 )	return(retval);
	if( retval==ESCAPE )  return(NOERROR);

	/* Copy the record to another buffer, for writing audit */
	scpy( (char *)&oldchqhist, (char *)&chqhist, sizeof( Chq_hist ) );

	/* Change record status only if it is of different type */
	if( (s_rec.s_status[0]==OUTSTANDING && s_rec.s_fn[0]==OUTSTAND) ||
	    (s_rec.s_status[0]==CASHED && s_rec.s_fn[0]==CASH) ){
		roll_back(e_mesg);	/* release locked record */
		return(NOERROR);
	}
	
	/* Confirm the status change before writing & commiting the record */
	if (s_rec.s_fn[0] == CASH ) {
		err = CashCheque();
		if (err == EFL ) return (EFL);
		if (err < 0) return(-1);
	}
	else {
		for( ; ; ){
			
#ifdef ENGLISH
		if( DisplayMessage("Confirm (Y/N)?")<0 ) return(-1);
#else
		if( DisplayMessage("Confirmer (O/N)?")<0 ) return(-1);
#endif
			s_rec.s_resp[0] = LV_CHAR;
			if( ReadFields(RESP_FLD,RESP_FLD)<0 ) return(-1);
			if( s_rec.s_resp[0]!=YES && s_rec.s_resp[0]!=NO )
				continue;
			else
				break;
		}
		/* Not confirmed, return */
		if( s_rec.s_resp[0]==NO ){
			roll_back(e_mesg);	/* release locked record */
			return(HideMessage());
		}
		s_rec.s_status[0] = OUTSTANDING;

		if( (retval=WriteFields(STA_FLD,STA_FLD))<0 )
			return(retval);

		/* Write the updated record */
		if( WriteSession(UPDATE)<0 ) return(-1);

		if( HideMessage()<0 )
			return(-1);
	}	
	return(NOERROR);
}	    /*   ChangeRecord()	*/
/*									*/
/*      Routine to handle the case when the cheque status is to be      */
/*	  changed to CASH.						*/
static int
CashCheque()
{
	int	retval;

	for( ; ; ) {
#ifdef ENGLISH
	retval = GetOpt("C(ash), N(ext Cheque), E(nd Session)", "CNE");
#else
	retval = GetOpt("E(ncaisser), S(uivant), F(in de session)", "ESF");
#endif

		if (retval == PROFOM_ERR)  return(-1);

		switch(retval) {
		case	EXITOPT:
			roll_back(e_mesg);
			return(HideMessage());
		case	NEXT:
			retval = NextOutst();
			if (retval == EFL){
				s_rec.s_fn[0] = LV_CHAR;
				return(EFL);
			}
			else
			 	if (retval < 0)
					return(-1);
			break;
		case	CASH:
			s_rec.s_status[0] = CASHED;
			if ( (retval = WriteFields(STA_FLD,STA_FLD)) < 0)
				return(retval);

	/*  Write the updated record	*/
			scpy( (char *)&oldchqhist, (char *)&chqhist,
				 sizeof( Chq_hist ) );
			if (WriteSession(UPDATE) < 0)  return(-1);
			if (HideMessage() < 0) return(-1);
			retval = NextOutst();
			if (retval == EFL){
				s_rec.s_fn[0] = LV_CHAR;
				return(EFL);
			}
			else
			 	if (retval < 0)
					return(-1);
			break;
		}         /*   switch 	*/
	}	  /*  for  */
}	  /*   CashCheque()  */
/*									*/
/*      Routine to get the next outstanding cheque.                     */
static int
NextOutst()
{
int	retval;

	for( ; ; ) {
		retval = GetNextRec(FORWARD);
		if (retval == EFL) return(EFL);

		if (chqhist.ch_status[0] == OUTSTAND) {
			DisplayRecord();
			return(NOERROR);
		}
		else
			roll_back(e_mesg);   /* release lock */     
  	}  /*  for  */ 
}      /*  NextOutst()   */
/*									*/
/*	Purge all records not having Outstanding status 		*/
static int
PurgeProc()
{
	int	i;

	/* Hide the key fields */
	if( (retval=FillKeyFields(HIGH))<0 )
		return( retval );
	if( (retval=WriteFields(FUND_FLD,CHQNO_FLD)<0) )
		return( retval );

	/* Accept cutoff date: Records with earlier dates to be purged */
#ifdef ENGLISH
	fomer("Enter cutoff date");
#else
	fomer("Entrer la date de demarcation");
#endif
	sr.nextfld = DATE_FLD;
	fomrf( (char *)&s_rec );
	ret(err_chk(&sr));

#ifdef ENGLISH
	if( DisplayMessage("Confirm (Y/N)?")<0 )
#else
	if( DisplayMessage("Confirmer (O/N)?")<0 )
#endif
		return(-1);

	for( ; ; ){
		sr.nextfld = RESP_FLD;
		fomrf( (char *)&s_rec );
		ret(err_chk(&sr));
		if( s_rec.s_resp[0]==NO )
			return(NOERROR);
		if( s_rec.s_resp[0]==YES )
			break;
	}

	/* Initialize to the beginning of the file */
	chqhist.ch_funds = 0;
	chqhist.ch_accno[0] = LV_CHAR;
	chqhist.ch_chq_no = 0;
	flg_reset( CHQHIST );

	i = 0;		/* Counter indicating no. of records written */
	/* Get each record and delete it if it is cancelled or cashed */
	for( ; ; ){
		retval = get_n_chqhist(&chqhist,BROWSE,0,FORWARD,e_mesg);
		if( retval==EFL )
			break;
		if( retval!=NOERROR ){
			fomen(e_mesg);
			get();
			return(retval);
		}
		/* Delete the record if status is X(cancelled) or C(ashed) */
		if( chqhist.ch_date<s_rec.s_date && 
				chqhist.ch_status[0]!=OUTSTANDING ){
			retval = get_chqhist(&chqhist,UPDATE,0,e_mesg);
			if( retval<0 && retval!=LOCKED ){
				fomen(e_mesg);
				get();
				return(retval);
			}
			else if( retval==LOCKED ){
				chqhist.ch_chq_no++;
				continue;
			}
			i++;
			retval = put_chqhist(&chqhist,P_DEL,e_mesg);
			if( retval==ERROR ){
				fomen(e_mesg);
				get();
				return(retval);
			}
			/* write report line and audit */
			rpline(arayptr);
			
			/* commit after writing every 10 records */
			if( i%10 == 0 )
				if( commit(e_mesg)<0 )
					return(-1);
			chqhist.ch_chq_no++;
		}
	}
	/* Commit any records remaining after last commit */
	if( i%10 != 0 )
		if( commit(e_mesg)<0 )
			return(-1);
	seq_over(CHQHIST) ;
	if( i==0 ){
#ifdef ENGLISH
		fomer("No records to be purged. Press any key");
#else
		fomer("Pas de fiches a effacer. Appuyer sur une touche");
#endif
		get();
	}

	return(NOERROR);
}
/* 	Initialize report writer */
static int
InitReport(procflag)
char	procflag;
{
	int	Format;

	if( procflag==T_CHQPURGE )	/* purge process */
		Format = PURGEFMT; 
	else
		Format = CASHCHQFMT;

	if(procflag == T_CASHENTRY)
		arayptr[0] = (char *)&cheque;
	else
		arayptr[0] = (char *)&chqhist;

	arayptr[1] = (char *)&ctl_rec;
	arayptr[2] = (char *)NULL;

	STRCPY(projname, FMT_PATH);
	strcat(projname, PROJECT);
	retval = rpopen(projname,1,Format,2,"\0",PROG_NAME,chardate);
	if( retval<0 ){
		sprintf(e_mesg,"Rpopen error code: %d",retval);
		fomen(e_mesg);
		get();
		return(-1);
	}	
	if( (retval=rpChangetitle(1,pa_rec.pa_co_name))<0 ){
		sprintf(e_mesg,"Rp error: %d",retval);
		fomen(e_mesg);
		get();
		return(-1);
	}	
	if( procflag==T_CHQPURGE )	/* purge process */
#ifdef ENGLISH
		STRCPY(e_mesg,"LIST OF PURGED CHEQUES");
#else
		STRCPY(e_mesg,"LISTE DES CHEQUES EFFACES");
#endif
	else
#ifdef ENGLISH
		STRCPY(e_mesg,"LIST OF MODIFIED CHEQUES");
#else
		STRCPY(e_mesg,"LISTE DES CHEQUES MODIFIES");
#endif
	if( (retval=rpChangetitle(2,e_mesg))<0 ){
		sprintf(e_mesg,"Rp error: %d",retval);
		fomen(e_mesg);
		get();
		return(-1);
	}	

	return(NOERROR);
}
static int
GetOpt( msg, option )
       char *msg;
       char *option;
{
        int	j,  i;
	
        STRCPY( s_rec.s_mesg, msg );
	if( DisplayMessage(msg)<0 )
		return(-1);

	for ( ; ; ) {
		s_rec.s_resp[0] = LV_CHAR ;
		if ( ReadFields(RESP_FLD,RESP_FLD) < 0 ) return(-1);
                j = strlen(option);
		for ( i = 0; i < j; i++ ) 
			if ( s_rec.s_resp[0] == option[i ] )
                           break;
                if(i != j) break ;
#ifdef ENGLISH
                fomer( " Invalid Option." );
#else
                fomer( "Option invalide." );
#endif
	}
	if( HideMessage()<0 )
		return(-1);
 
	return( (int)(option[i])) ;
}
static int
BankProc()
{
	int	atleastonerecord = 0;


	s_rec.s_fund = LV_SHORT;
	s_rec.s_accno[0] = LV_CHAR;
	s_rec.s_chq_no = HV_LONG;
	s_rec.s_date = LV_LONG;
	s_rec.s_period = LV_SHORT;
	fomca1( FUND_FLD, 19, 2);
	default_fund();
	if( (retval=ReadFields(FUND_FLD,PERI_FLD))<0 )
		return(-1);
	if( retval==ESCAPE )
		return(NOERROR);

#ifdef ENGLISH
	if(DisplayMessage( "Confirm (Y/N)?")<0 ) 
#else
	if(DisplayMessage( "Confirmer (O/N)?")<0 )
#endif
		return(-1);
	sr.nextfld = RESP_FLD;
	fomrf( (char *)&s_rec );
	ret( err_chk(&sr) );
	
	if(s_rec.s_resp[0] == NO) return(NOERROR);

	fflush(stdout) ;

	gl_rec.funds = s_rec.s_fund;
	STRCPY( gl_rec.accno, s_rec.s_accno );
	gl_rec.reccod = 99;
	if( (retval=get_gl(&gl_rec,BROWSE,0,e_mesg))<0 ){
		fomen(e_mesg);
		get();
		if( retval==ERROR )
			return(retval);
		else
			return(NOERROR);
	}
	
	chqhist.ch_funds = s_rec.s_fund;
	STRCPY( chqhist.ch_accno, s_rec.s_accno );
	chqhist.ch_chq_no = 0;
	total_outstanding = 0.0;
	flg_reset( CHQHIST );

	if( InitPrinter()<0 )
		return(-1);
	for( ; ; ){
		retval = get_n_chqhist(&chqhist,BROWSE,0,FORWARD,e_mesg);
		if( retval==EFL || strcmp( chqhist.ch_accno,s_rec.s_accno )
				|| (chqhist.ch_funds!=s_rec.s_fund) ){
			retval=0;
			break;
		}
		else if( retval!=NOERROR ){
			fomen(e_mesg);
			get();
			break;
		}
		if( chqhist.ch_status[0]!=OUTSTANDING ||
				 chqhist.ch_date > s_rec.s_date)
			continue;
		if( (retval=PrintLine())<0 )
			return(-1);
		total_outstanding += chqhist.ch_net_amt;
		atleastonerecord = 1;
	}

	if( atleastonerecord ){
		prnt_line();
#ifdef ENGLISH
		mkln(2,"TOTAL",5);
#else
		mkln(2,"TOTAL",5);
#endif
		mkln(15," ",1);
		tedit( (char *)&total_outstanding,"______0_.__",
				line+cur_pos,R_DOUBLE );
		cur_pos += 11;
		prnt_line();
	}
	if( retval<0 ){
		close_rep(BANNER);
		return(retval);
	}

	retval = PrintSummary();
	close_rep(BANNER);
	if( retval<0 )
		return(retval);
	
#ifdef ENGLISH
	fomer("Reconciliation Form Printed.  Enter RETURN to Continue");
#else
	fomer("Forme de rapprochement imprime. Appuyer sur RETURN pour continuer");
#endif
	get();
	return(NOERROR);
}
static int
InitPrinter()
{
	/* always to printer */
	if(opn_prnt("P","\0",1,e_mesg,1)<0){
		fomen(e_mesg);
		return(-1);
	}
	LNSZ = 80;
	pgcnt = 0;
	linecnt = PGSIZE;
	return(NOERROR);
} 
static int
PrintLine() 
{ 
	/* if linecount has equalled or exceeded page size */
	if( linecnt >= PGSIZE ){		/* If it has */
		if( pgcnt )	/* if not the first page */
			if( rite_top()<0 ) 
				return( -1 );	/* form_feed */
		pgcnt++; 			/* increment page no */
		linecnt = 0;
		if( PrntHdg(COL_HDG_YES)<0 )	/* Print heading stuff */
			return(-1);
	}

	mkln(4," ",1);
	tedit( (char *)&chqhist.ch_chq_no,"______0_",line+cur_pos,R_LONG );
	cur_pos += 8;

	mkln(15," ",1);
	tedit( (char *)&chqhist.ch_net_amt,"_______0_.__",line+cur_pos,R_DOUBLE );
	cur_pos += 12;

	mkln(29," ",1);
	tedit( (char *)&chqhist.ch_date,"____/__/__",line+cur_pos,R_LONG );
	cur_pos += 10;

	mkln(42,chqhist.ch_name,38);

	return( prnt_line() );
}
static int
PrintSummary() 
{
	int	i,j;

	/* if linecount has equalled or exceeded page size */
	if( pgcnt )	/* if not the first page */
		if( rite_top()<0 ) 
			return( -1 );	/* form_feed */
	pgcnt++; 			/* increment page no */
	linecnt = 0;
	if( PrntHdg(COL_HDG_NO)<0 )	/* Print heading stuff */
		return(-1);

	prnt_line();
	prnt_line();
	prnt_line();
	prnt_line();

#ifdef ENGLISH
	mkln(2,"Bank Statement Balance:",23 );
#else
	mkln(2,"Balance du releve de banque:",28 );
#endif
	mkln(40, "$ _________.__",14 );
	prnt_line();
	prnt_line();

#ifdef ENGLISH
	mkln(2,"Less Outstanding Cheques:",25);
#else
	mkln(2,"Moins les cheques non-regles:",29);
#endif
	mkln(40, "$ ",2 );
	tedit((char *)&total_outstanding,"_______0_.__",line+cur_pos, R_DOUBLE);
	cur_pos+=12;
	prnt_line();
	prnt_line();

#ifdef ENGLISH
	mkln(2,"Subtotal:",9 );
#else
	mkln(2,"Sous-total:", 11 );
#endif
	mkln(40, "$ _________.__",14 );
	prnt_line();
	prnt_line();

#ifdef ENGLISH
	mkln(2,"Others:",7 );
#else
	mkln(2,"Autres:",7 );
#endif
	prnt_line();
	for( i=0; i<8; i++ ){
		mkln(2,"_________________________",25 );
		mkln(40, "$ _________.__",14 );
		prnt_line();
		prnt_line();
	}
	prnt_line();

#ifdef ENGLISH
	mkln(2,"Equals:",7 );
#else
	mkln(2,"Total:",6 );
#endif
	mkln(40, "$ _________.__",14 );
	prnt_line();
	prnt_line();

#ifdef ENGLISH
	mkln(2,"Computer Bank Acct Balance:",27 );
#else
	mkln(2,"Solde compte bque par ordinateur:",33 );
#endif
	prnt_line();
#ifdef ENGLISH
	sprintf( e_mesg, "%s Account# %s",gl_rec.desc, gl_rec.accno );
#else
	sprintf( e_mesg, "%s Compte# %s",gl_rec.desc, gl_rec.accno );
#endif
	mkln( 2, e_mesg, strlen(e_mesg) );
	mkln(40, "$ ",2 );

	/** reflect only transactions up to and including period entered **/
	for(j=s_rec.s_period;j<pa_rec.pa_cur_period;j++) {
		gl_rec.ytd -= gl_rec.currel[j];
	}

	tedit((char *)&gl_rec.ytd,"_______0_.__-",line+cur_pos, R_DOUBLE);
	cur_pos+=13;
	prnt_line();
	prnt_line();

#ifdef ENGLISH
	mkln(2,"Difference (If any):",20 );
#else
	mkln(2,"Difference (S'il y en a):",25 );
#endif
	mkln(40, "$ _________.__",14 );
	prnt_line();
	prnt_line();

	return( prnt_line() );
}
static int
PrntHdg(is_col_hdg)
int	is_col_hdg;
{
	int	offset;
#ifdef ENGLISH
	char	*p = "RECONCILIATION FORM" ;
	char	*q = "LIST OF OUTSTANDING CHEQUES";
#else
	char	*p = "FORMULAIRE DE CONCILIATION BANCAIRE" ;
	char	*q = "LISTE DES CHEQUES NON-REGLES";
#endif

	char	*r;
	long	dt;

	dt = get_date();

	mkln( 1, PROG_NAME, 10 );

	mkln(((LNSZ-strlen(pa_rec.pa_co_name)) / 2),pa_rec.pa_co_name, sizeof(pa_rec.pa_co_name));
#ifdef ENGLISH
	mkln( 63, "DATE: ", 6 );
#else
	mkln( 63, "DATE: ", 6 );
#endif
	tedit( (char *)&dt,"____/__/__",  line+cur_pos, R_LONG ); 
	cur_pos += 10;
	if(prnt_line() < 0) return(ERROR);
	if( is_col_hdg==COL_HDG_YES )
		r = q;
	else
		r = p;

	offset = ( LNSZ-strlen(r) )/2;
	mkln( offset, r, strlen(r) );
	if( prnt_line()<0 )	return(-1);

#ifdef ENGLISH
	mkln( 32, "AS OF ", 6 );
#else
	mkln( 29, "A PARTIR DE ", 12 );
#endif
	tedit( (char *)&s_rec.s_date,"____/__/__",  line+cur_pos, R_LONG ); 
	cur_pos += 10;

#ifdef ENGLISH
	mkln( 63, "PAGE: ", 6 );
#else
	mkln( 63, "PAGE: ", 6 );
#endif
	tedit( (char *)&pgcnt,"__0_",  line+cur_pos, R_INT ); 
	cur_pos += 4;
	if( prnt_line()<0 )	return(-1);
	if( prnt_line()<0 )	return(-1);

#ifdef ENGLISH
	sprintf(e_mesg,"Bank Account No.: %s",gl_rec.accno);
#else
	sprintf(e_mesg,"Numero de compte de banque: %s",gl_rec.accno);
#endif
	offset = ( LNSZ-strlen(e_mesg) )/2;
	mkln( offset, e_mesg, strlen(e_mesg) );
	if( prnt_line()<0 )	return(-1);
	if( prnt_line()<0 )	return(-1);

	if( is_col_hdg==COL_HDG_YES ){
#ifdef ENGLISH
		mkln( 6, "CHEQUE#", 7 );
		mkln( 21, "AMOUNT", 6 );
		mkln( 30, "CHEQ. DATE",10);
		mkln( 55, "SUPPLIER NAME",13);
#else
		mkln( 6, "#CHEQUE", 7 );
		mkln( 21, "MONTANT", 7 );
		mkln( 30, "DATE DU CHEQUE", 14);
		mkln( 55, "NOM DU FOURNISSEUR",18);
#endif
		if( prnt_line()<0 )	return(-1);
	}
	if( prnt_line()<0 )	return(-1);

	return(NOERROR);
}
default_fund()
{
	s_rec.s_fund = FUND_DEFAULT;
	if( (retval=WriteFields(FUND_FLD,CHQNO_FLD))<0 )
		return(retval);
	s_rec.s_fund = LV_SHORT;
}
	
/*-----------------------   End of program   ---------------------------*/
