/*-----------------------------------------------------------------------
Source Name: apinvc3.c
System     : Accounts Payables.
Created  On: 24 NOVEMBER 89.
Created  By: T AMARENDRA.

COBOL Source(s): cp030---07

DESCRIPTION:
	Program to maintain Open items

MODIFICATIONS:        

Programmer     YY/MM/DD       Description of modification
~~~~~~~~~~     ~~~~~~~~       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1990/12/18	F.Tao 	       Round up amounts before writing to file.

------------------------------------------------------------------------*/

#include <stdio.h>
#include <cfomstrc.h>
#include <bfs_defs.h>
#include <bfs_recs.h>
#include <apinvc.h>

/* User Interface define constants */
#ifdef ENGLISH
#define CHANGE		'C'
#define INQUIRE		'I'
#define NEXT		'N'
#define PREV		'P'
#define EXITOPT		'E'

#define	YES		'Y'
#define	EDIT		'E'
#define	CANCEL		'C'
#else
#define CHANGE		'C'
#define INQUIRE		'I'
#define NEXT		'S'
#define PREV		'P'
#define EXITOPT		'F'

#define	YES		'O'
#define	EDIT		'M'
#define	CANCEL		'A'
#endif

/* PROFOM Releted declarations */

#define	SCR_NAME	"apinvc3"	/* PROFOM screen Name */

/* PROFOM Screen STH file */

/* Field PROFOM numbers */

#define	ST_FLD		1100	/* Header Start Field */
#define	SCR_END_FLD	2600	/* Last Field of the screen */

/* HDR Fields */
#define	FN_FLD		500	/* Fn: */
#define	KEY_START	600	/* Supplier Cd: */
#define	KEY_END		800	/* Type: */
#define	SUPPCD_FLD	600	/* Supplier Cd: */
#define	REFNO_FLD	700	/* Ref#: */
#define	TRTYPE_FLD	800	/* Trans. Type: */
#define	CHG_FLD		900	/* Field: */
#define	INVCDT_FLD	1400	/* Ref date: */
#define	DUEDT_FLD	1500	/* Due Date: */
#define	DISCPER_FLD	1800	/* Disc% */
#define	DISCAMT_FLD	1900	/* Disc Amt: */
#define	PMNTCD_FLD	2000	/* Pmnt Code: */
#define	PMNTDESC_FLD	2050	/* (Pmtcode Description) */
#define	CHEQUENO_FLD	2200	/* Cheque#: */
#define	ACCTNO_FLD	2300	/* Bank Acct: */

/* Field Serial Numbers */
#define	INVC_DT		4
#define	DUE_DT		5
#define	DISC_PER	8
#define	DISC_AMT	9
#define	PMNT_CODE	10
#define	CHEQUE_NO	12
#define	BANK_ACCT	13
#define	REMARKS		14
#define	LAST_SNO	14

/* apinvc3.sth - header for C structure generated by PROFOM EDITOR */

struct	s_struct	{

	char	s_pgm[11];	/* STRING XXXXXXXXXX Field 100 */
	long	s_rundate;	/* DATE YYYYFMMFDD Field 300 */
	char	s_fn[2];	/* STRING X Field 500 */
	char	s_supp_cd[11];	/* STRING XXXXXXXXXX Field 600 */
	char	s_invc_no[16];	/* STRING XXXXXXXXXX Field 700 */
	char	s_tr_type[3];	/* STRING XX Field 800 */
	short	s_field;	/* NUMERIC 999 Field 900 */
	short	s_fund;		/* NUMERIC 999 Field 1100 */
	short	s_period;	/* NUMERIC 99 Field 1200 */
	long	s_po_no;	/* NUMERIC 999999 Field 1300 */
	long	s_invc_dt;	/* DATE YYYYFMMFDD Field 1400 */
	long	s_due_dt;	/* DATE YYYYFMMFDD Field 1500 */
	char	s_type[2];	/* STRING X Field 1600 */
	double	s_tran_amt;	/* NUMERIC S99F999F999.99 Field 1700 */
	char	s_per_pr[13] ;	/* STRING X[12] Field 1750 */
	double	s_disc_per;	/* NUMERIC 99.99 Field 1800 */
	char	s_amt_pr[13] ;	/* STRING X[12] Field 1850 */
	double	s_disc_amt;	/* NUMERIC S99F999F999.99 Field 1900 */
	char	s_pmtcode[2];	/* STRING X Field 2000 */
	char	s_pmt_desc[9] ;	/* STRING X[9] Field 2050 */
	double	s_part_amt;	/* NUMERIC S99F999F999.99 Field 2100 */
	long	s_chq_no;	/* NUMERIC 99999999 Field 2200 */
	char	s_accno[19] ;	/* STRING X[18] Field 2300 */
	char	s_remarks[21];	/* STRING X[24] Field 2400 */
	char	s_mesg[78];	/* STRING X[77] Field 2500 */
	char	s_resp[2];	/* STRING X Field 2600 */
};

static	struct	s_struct  s_sth;	/* PROFOM Screen Structure */

struct	stat_rec	sr ;

static	short	TransType ;
static	char chardate[11],projname[50],program[11],discfile[20];
static	int  logrec,outcntl,formno,code;
static  char *arayptr[5];
static	int first;

int	Validate(), WindowHelp() ;

double 	D_Roundoff();

/*------------------------------------------------------------------------*/

OpenItemMaintenance()
{
	int	err;

	err = Initialize() ;	/* Initialize Variables , DBH
	if(err == PROFOM_ERR || err == DBH_ERR) return(err) ;
						Environment and PROFOM */
	logrec = formno = 1;
	outcntl = 7;
	first = 0;

	mkdate(get_date(),chardate);
	STRCPY(projname,FMT_PATH); strcat(projname,"apinvc3");
	STRCPY(program,"APINVC3");
	STRCPY(discfile,"date_audit.dat");

	arayptr[0] = (char *) &in_rec;
	arayptr[1] = NULL;

	if(err == NOERROR) err = Process();	/* Initiate Process */

 	rpclose();

	if(err == PROFOM_ERR || err == DBH_ERR) return(err) ;

	return(NOERROR) ;

}	/* OpenItemMaintenance() */
/*-------------------------------------------------------------------*/
/* Initialize Variables and Screen etc. */
static	int
Initialize()
{
	int	err ;

	flg_reset(APINVOICE) ;
	/*
	*	Initialize Screen & Screen Varibles
	*/

	CurrentScr = (char*)&s_sth ;
	END_FLD	   = SCR_END_FLD ;

	/* move screen name to Profom status structure */
	STRCPY(sr.scrnam,NFM_PATH);
	strcat(sr.scrnam,SCR_NAME) ;

	STRCPY(s_sth.s_pgm,PROG_NAME);
	s_sth.s_rundate = get_date();	/* get Today's Date in YYYYMMDD format*/
	s_sth.s_fn[0]   = LV_CHAR ;
	s_sth.s_field   = HV_SHORT ;
	s_sth.s_mesg[0] = HV_CHAR ;
	s_sth.s_resp[0] = HV_CHAR ;

	/* Initialize Key Fields. So that, if user selectes 'N' option
	   immediately after invoking program, then he gets the first
	   record in the file */

	s_sth.s_supp_cd[0] = '\0' ;
	s_sth.s_invc_no[0] = '\0';
	s_sth.s_tr_type[0] = '\0' ;

	/* Move High Values to data fields and Display the screen */
	err = InitScreen() ;
	if(NOERROR != err) return(err) ;

	return(NOERROR) ;
}	/* Initialize() */
/*-------------------------------------------------------------------*/
/* Get Fn: from user and call corresponding function */
static	int
Process()
{
	int err;

	for( ; ; ){
		/* Get the Fn: option from the user */
		if((err = ReadFunction()) != NOERROR) return(err) ;

		err = ProcFunction() ;	/* Process Function */

		if(PROFOM_ERR == err || DBH_ERR == err)	return(err);
		if(NOACCESS == err) {
			fomen(e_mesg) ;
			get() ;
		}

		if(QUIT == err)		return(NOERROR) ;	/* Exit */
	}      /*   end of the for( ; ; )       */
}	/* Process() */
/*----------------------------------------------------------------*/
/* Display the Function (Fn:) options and get the option from the user */
static	int
ReadFunction()
{
	/* Display Fn: options */
#ifdef ENGLISH
	fomer("C(hange), I(nquire), N(ext), P(rev), E(xit)");
#else
	fomer("C(hanger), I(nterroger), S(uivant), P(recedent), F(in)");
#endif
	/* Read Fn: field to get the option */
	sr.nextfld = FN_FLD ;
	fomrf( (char *)&s_sth );
	ret(err_chk(&sr));	/* Check for PROFOM error */

	return(NOERROR) ;
}	/* ReadFunction() */
/*----------------------------------------------------------------*/
/* Process the user selected Fn: option */
static	int
ProcFunction()
{
	int	err ;

	switch (s_sth.s_fn[0]) {
	case CHANGE  :			/* CHANGE */
		CHKACC(err, UPDATE, e_mesg) ;
		return( ChangeInvoice() ) ;
	case INQUIRE  :			/* Inquire Invoice */
		CHKACC(err, BROWSE, e_mesg) ;
		return( InquireInvoice() ) ;
	case NEXT  :			/* Next Invoice */
		CHKACC(err, BROWSE, e_mesg) ;
		return( NextInvoice(FORWARD) ) ;
	case PREV  :			/* Previous Invoice */
		CHKACC(err, BROWSE, e_mesg) ;
		return( NextInvoice(BACKWARD) ) ;
	case EXITOPT  :			/* Exit */
		return( QUIT ) ;
	}  /*   end of the switch statement */

	if(err < 0) return(err) ;	/* Security ERROR */

	return(NOERROR);
}	/* ProcFunction() */
/*-----------------------------------------------------------------------*/
/* Select the user given Record and Accept changes on that */

ChangeInvoice()
{
	int	err ;

	/* If the Current Period == 0 (i.e before yearly closing), Add or
	   Change is not allowed */
	if(pa_rec.pa_cur_period == 0) {
#ifdef ENGLISH
		DispError("Not Allowed Before Yearly Closing...");
#else
		DispError("Pas permis avant la fermeture annuelle...");
#endif
		return(NOERROR) ;
	}

	err = SelectInvoice(UPDATE) ;
	if(NOERROR != err) return(err) ;

	if(in_rec.in_pmtcode[0] == COMPLETE) {
#ifdef ENGLISH
		DispError("Status is COMPLETE... Changes are not Allowed..");
#else
		DispError("Etat est COMPLET... Changements ne sont pas permis..");
#endif
		roll_back(e_mesg) ;	/* Unlock the locked Records */
		return(NOERROR) ;
	}

	err = CheckFund(in_rec.in_funds) ;
	if(NOERROR != err) return(err) ;

	err = ChangeFields() ;
	if(err < 0) return(err) ;

	err = Confirm() ;
	if(PROFOM_ERR == err || DBH_ERR == err) return(err) ;
	if(err < 0 || CANCEL == err) {
		if((err = ShowInvoice()) < 0) return(err) ;
		roll_back(e_mesg) ;	/* Unlock the locked Records */
	}

	return(NOERROR) ;
}	/* ChangeInvoice() */
/*-----------------------------------------------------------------------*/
/* Show the user given keys Invoice */

InquireInvoice()
{
	int	err ;

	err = SelectInvoice(BROWSE) ;
	if(NOERROR != err) return(err) ;
	s_sth.s_mesg[0] = HV_CHAR;
	ShowMesg();
	return(NOERROR) ;
}	/* InquireInvoice() */
/*----------------------------------------------------------*/
/* Show the next or previous Invoice */

NextInvoice(direction)
int	direction ;
{
	int err;

	/* Check whether file is in seq. read mode */
	if(flg_start(APINVOICE) != direction) {
		/* Set the least part of the key to next possible key and
		   set the file to start */
		STRCPY(in_rec.in_supp_cd, s_sth.s_supp_cd) ;
		STRCPY(in_rec.in_invc_no, s_sth.s_invc_no) ;
		STRCPY(in_rec.in_tr_type, s_sth.s_tr_type) ;
		inc_str(in_rec.in_tr_type, (sizeof(in_rec.in_tr_type) - 1),
			direction) ;	/* Set to next possible string */
		flg_reset(APINVOICE);
	}

	err = get_n_invc(&in_rec, BROWSE, 0, direction, e_mesg);
#ifndef	ORACLE
	seq_over(APINVOICE);
#endif
	if(ERROR == err)return(DBH_ERR) ;
	if(EFL == err) {
#ifdef ENGLISH
		fomen("No More Records....");
#else
		fomen("Plus de fiches....");
#endif
		get();
		flg_reset(APINVOICE);
		return(NOERROR) ;
	}

	return( ShowInvoice() ) ;
}	/* NextInvoice() */
/*----------------------------------------------------------*/
/* Get the Invoice key and show the invoice */

SelectInvoice(md)
int	md ;	/* UPDATE or BROWSE. UPDATE locks the invoice */
{
	int	err ;

	for(; ;){
		err = ReadKey();
		if(err != NOERROR) return(err) ;

		/* Get the record from database */
		err = GetInvoice(s_sth.s_supp_cd, s_sth.s_invc_no,
				s_sth.s_tr_type, md);
		if(ERROR == err) return(DBH_ERR) ;
		if(err < 0) {		/* UNDEF or LOCKED */
			fomer(e_mesg) ;
			get() ;
			continue ;
		}

		return( ShowInvoice() ) ;
	}
}	/* SelectInvoice() */
/*----------------------------------------------------------------------*/
/* Get the invoice key from user. Enable dup buffers and show the current
   key as a default key */

ReadKey()
{
	int	i;
	char	supp_cd[sizeof(s_sth.s_supp_cd)];
	char	invc_no[sizeof(s_sth.s_invc_no)];
	char	type[sizeof(s_sth.s_tr_type)];

	for(i = KEY_START ; i <= KEY_END ; i += 100)
		fomca1(i,19,1) ;

	sr.nextfld = KEY_START;
	sr.endfld = KEY_END;
	fomud((char*)&s_sth);	/* Update Dup Buffers */

	/* Store fields to copy back when user gives ESC-F */
	STRCPY(supp_cd,s_sth.s_supp_cd) ;
	STRCPY(invc_no,s_sth.s_invc_no) ;
	STRCPY(type,s_sth.s_tr_type) ;

	s_sth.s_supp_cd[0] = LV_CHAR ;
	s_sth.s_invc_no[0] = LV_CHAR ;
	s_sth.s_tr_type[0] = LV_CHAR ;

#ifdef ENGLISH
	STRCPY(s_sth.s_mesg,"Press ESC-F to Go Back to Fn:");
#else
	STRCPY(s_sth.s_mesg,"Appuyer sur ESC-F pour retourner a Fn:");
#endif
	ShowMesg();

	i = ReadFields(KEY_START, KEY_END, Validate, WindowHelp, 0, ESC_F) ;
	if(PROFOM_ERR == i || DBH_ERR == i) return(i) ;
	if(RET_USER_ESC == i){
		/* copy back key fields */
		STRCPY(s_sth.s_supp_cd,supp_cd) ;
		STRCPY(s_sth.s_invc_no,invc_no) ;
		STRCPY(s_sth.s_tr_type,type) ;

		ret( WriteFields(KEY_START, KEY_END) ) ;

		s_sth.s_mesg[0] = HV_CHAR;
		ShowMesg();

		roll_back(e_mesg) ;	/* Release Locked Records */
		return(ERROR) ;
	}

	return(NOERROR);
}	/*  ReadKey() */
/*-----------------------------------------------------------------------*/
/* Move invoice details to Screen and dispaly the screen */

ShowInvoice()
{
	int	err ;

	/* Copy Key */
	STRCPY(s_sth.s_supp_cd, in_rec.in_supp_cd) ;
	STRCPY(s_sth.s_invc_no, in_rec.in_invc_no) ;
	STRCPY(s_sth.s_tr_type, in_rec.in_tr_type) ;

	TransType = CheckTransType(in_rec.in_tr_type) ;

	/* Copy Data Fields */
	s_sth.s_fund       = in_rec.in_funds ;
	s_sth.s_po_no      = in_rec.in_po_no ;
	s_sth.s_period     = in_rec.in_period ;
	s_sth.s_invc_dt    = in_rec.in_invc_dt ;
	s_sth.s_due_dt     = in_rec.in_due_dt ;
	s_sth.s_type[0]    = in_rec.in_type[0] ;
	s_sth.s_tran_amt   = in_rec.in_amount ;
	s_sth.s_disc_per   = in_rec.in_disc_per;
	s_sth.s_disc_amt   = in_rec.in_disc_amt ;
	s_sth.s_pmtcode[0] = in_rec.in_pmtcode[0] ;
	s_sth.s_part_amt   = in_rec.in_part_amt ;
	s_sth.s_chq_no     = in_rec.in_chq_no ;
	STRCPY(s_sth.s_accno, in_rec.in_accno) ;
	STRCPY(s_sth.s_remarks, in_rec.in_remarks) ;

	/* MOve payment code description */
	CpPmntCdDesc() ;

	/* MOve Hold Back or Discount depending on Supplier Type */
	if(s_sth.s_fn[0] == NEXT || s_sth.s_fn[0] == PREV) {
		if(strcmp(s_sth.s_supp_cd, supp_rec.s_supp_cd) != 0) {
			/* Get the supplier record to know the type */
			err = CheckSupp(s_sth.s_supp_cd, BROWSE) ;
			if(err == DBH_ERR) return(err);

			/* If supplier not exists in file, consider it is
			   temporary and deleted */
			if(err < 0)
				supp_rec.s_type[0] = CONTRACT ;
		}
	}
	CpHBorDisc() ;

	ret( WriteFields( KEY_START, END_FLD - 200) ) ;

	return(NOERROR) ;
}	/* ShowInvoice() */
/*-----------------------------------------------------------------------*/
/* Copy Payment code description */

CpPmntCdDesc()
{
	switch(s_sth.s_pmtcode[0]) {
	case	STOPPMT :
#ifdef ENGLISH
		STRCPY(s_sth.s_pmt_desc, "STOP") ;
#else
		STRCPY(s_sth.s_pmt_desc, "ARRET") ;
#endif
		break ;
	case	COMPLETE :
#ifdef ENGLISH
		STRCPY(s_sth.s_pmt_desc, "COMPLETE") ;
#else
		STRCPY(s_sth.s_pmt_desc, "COMPLET") ;
#endif
		break ;
	case	REL_HB :
#ifdef ENGLISH
		STRCPY(s_sth.s_pmt_desc, "Relse HB") ;
#else
		STRCPY(s_sth.s_pmt_desc, "Paie Ret") ;
#endif
		break ;
	case	PARTIAL :
		if(in_rec.in_chq_no == 0)
#ifdef ENGLISH
			STRCPY(s_sth.s_pmt_desc, "PARTIAL") ;
		else
			STRCPY(s_sth.s_pmt_desc, "MANUAL") ;
#else
			STRCPY(s_sth.s_pmt_desc, "PARTIEL") ;
		else
			STRCPY(s_sth.s_pmt_desc, "MANUEL") ;
#endif
		break ;
	default :
#ifdef ENGLISH
		STRCPY(s_sth.s_pmt_desc, "OPEN") ;
#else
		STRCPY(s_sth.s_pmt_desc, "OUVERT") ;
#endif
	}

	return(NOERROR) ;
}	/* CpPmntCdDesc() */
/*-----------------------------------------------------------------------*/
/* Copy Hold Back or Discount */

CpHBorDisc()
{
	/* If the supplier is ordinary type supplier show as "Discount" else
	   show as "Hold Back". */

	if(supp_rec.s_type[0] == ORDINARY) {
#ifdef ENGLISH
		STRCPY(s_sth.s_per_pr, "Discount%  :");
		STRCPY(s_sth.s_amt_pr, "Disc Amount:");
#else
		STRCPY(s_sth.s_per_pr, "% de l'esc :");
		STRCPY(s_sth.s_amt_pr, "Mont. d'esc:");
#endif
	}
	else {
#ifdef ENGLISH
		STRCPY(s_sth.s_per_pr, "Hold Back% :");
		STRCPY(s_sth.s_amt_pr, "HB Amount  :");
#else
		STRCPY(s_sth.s_per_pr, "% du PR    :");
		STRCPY(s_sth.s_amt_pr, "Montant PR :");
#endif
	}
	return(NOERROR) ;
}	/* CpHBorDisc() */
/*-----------------------------------------------------------------------*/
/* Take the confirmation from user for the Changes */

Confirm()
{
	int	err ;

	/* Options:
	   Change   - YEC
	*/

	for( ; ; ) {
#ifdef ENGLISH
		err = GetOption("Y(es), E(dit), C(ancel)", "YEC");
#else
		err = GetOption("O(ui), M(odifier), A(nnuler)", "OMA");
#endif
		if(err == PROFOM_ERR) return(err) ;

		switch(err) {
		case  YES :
		    err = WriteRecords() ;
		    if(err==NOERROR) return(NOERROR);
		    if(err == ERROR) break ;
		    if(err == LOCKED) {
			err = CheckSupp(s_sth.s_supp_cd,UPDATE) ;
			if(DBH_ERR == err) return(err) ;
			if(err==LOCKED) continue;
			if(err<0) return(err);

			err = GetInvoice(s_sth.s_supp_cd, s_sth.s_invc_no,
				s_sth.s_tr_type, UPDATE);
			if(ERROR == err) return(DBH_ERR) ;
			if(err < 0) {		/* UNDEF or LOCKED */
				fomer(e_mesg) ;
				get() ;
				continue ;
			}
	   	    }
		    break ;
		case  EDIT  :
		    err = ChangeFields();
		    break ;
		case  CANCEL :
#ifdef ENGLISH
		    err = GetOption("Confirm the Cancel (Y/N)?", "YN") ;
#else
		    err = GetOption("Confirmer l'annulation (O/N)?", "ON") ;
#endif
		    if(err == YES) return(CANCEL) ;
		    break ;
		}	/* switch err */

		if(err == PROFOM_ERR) return(err) ;
		if(err == DBH_ERR) return(err) ;
	}	/* for(; ; ) */
}	/* Confirm() */
/*----------------------------------------------------------------------*/
/* Changing fields. Accept fld to be changed and read that fld */

ChangeFields()
{
	int	i;

	/* Change PROFOM logical field attributes */
	for(i = ST_FLD ; i <= END_FLD - 200  ; i += 100)
		fomca1(i,19,1); /* enabling Dup control */

	/* Set Dup Buffers */
	sr.nextfld = ST_FLD;
	sr.endfld = END_FLD - 200 ;
	fomud((char*)&s_sth);  /* Updating dup buffer */
	ret(err_chk(&sr));

	/* Get The Field to Be Modified */
#ifdef ENGLISH
	STRCPY(s_sth.s_mesg,"Enter RETURN to terminate Edit");
#else
	STRCPY(s_sth.s_mesg,"Appuyer sur RETURN pour terminer l'ajustement");
#endif
	ShowMesg() ;

	for( ; ; ) {
	    sr.nextfld = CHG_FLD ;
	    fomrf((char*)&s_sth);
	    ret(err_chk(&sr));

	    if(s_sth.s_field == 0) break ;

	    if(IsAllowed() == ERROR) continue ;

	    for( ; ; ) {
		i = ReadFld() ;
			/* Read Field */
		if(i == PROFOM_ERR) return(i) ;
		if(i == DBH_ERR) return(i) ;
		/* When Invoice date is changed make sure that due date is less
		   than that */
		if(s_sth.s_field == INVC_DT &&
				s_sth.s_due_dt < s_sth.s_invc_dt) {
			s_sth.s_field = DUE_DT ;
			continue ;
		}
		if(s_sth.s_field == BANK_ACCT) {
			/* Show the right justified acct# */
			sr.nextfld = ACCTNO_FLD ;
			fomwf((char*)&s_sth) ;
		}
		break ;
	    }
	}	/* for( ; ; ) */

	s_sth.s_field = HV_SHORT ;
	fomwf((char*)&s_sth);
	ret(err_chk(&sr));

	s_sth.s_mesg[0] = HV_CHAR;
	ShowMesg();

	return(NOERROR);
}	/* ChangeFields() */
/*-----------------------------------------------------------------------*/
/* Validate the selected field# for change */
static	int
IsAllowed()
{
	/* Validate  Field Number */
	if( s_sth.s_field < 1 || s_sth.s_field > LAST_SNO) return (ERROR) ;

	/* Only following fields are allowed to change */
	if(s_sth.s_field != INVC_DT &&
		s_sth.s_field != DUE_DT &&
		s_sth.s_field != DISC_PER &&
		s_sth.s_field != DISC_AMT &&
		s_sth.s_field != PMNT_CODE &&
		s_sth.s_field != CHEQUE_NO &&
		s_sth.s_field != BANK_ACCT &&
		s_sth.s_field != REMARKS) return(ERROR) ;

	/* Changing Discount Fields are allowed, only when pmnt code is Open,
	   Partial/Manual or Release HB */
	if( (s_sth.s_field == DISC_PER || s_sth.s_field == DISC_AMT) &&
		in_rec.in_pmtcode[0] != OPEN &&
		in_rec.in_pmtcode[0] != PARTIAL &&
		in_rec.in_pmtcode[0] != REL_HB) return(ERROR) ;

	/* Changing Payment code is allowed, only when it is Stop Payment or
	   Partial/Manual */
	if( s_sth.s_field == PMNT_CODE &&
		in_rec.in_pmtcode[0] != STOPPMT &&
		in_rec.in_pmtcode[0] != PARTIAL) return(ERROR) ;

	/* Changing Cheque# is allowed, only when it is not != 0 */
	if( s_sth.s_field == CHEQUE_NO && in_rec.in_chq_no == 0)
		return(ERROR) ;
	/* Changing Bank Account is allowed only when chq# not = zero */
	if( s_sth.s_field == BANK_ACCT && in_rec.in_chq_no == 0)
		return(ERROR) ;

	return(NOERROR) ;
}	/* IsAllowed() */
/*-----------------------------------------------------------------------*/
/* Read the user selected field in change mode */

ReadFld()
{
	int	err ;

	/* If the Field# is between Tran Amt & Disc Amt, always read upto
	   Disc Amt */
	if(s_sth.s_field >= DISC_PER && s_sth.s_field <= DISC_AMT) {
		return(ChangeTotal((int)s_sth.s_field)) ;
	}

	/* Set PROFOM nextfld */
	sr.nextfld = ST_FLD + (s_sth.s_field - 1) * 100 ;

	for( ; ; ) {
		fomrf((char*)&s_sth);
		ret(err_chk(&sr));

		if(sr.retcode == RET_VAL_CHK) {
			err = Validate() ;
			if(err == DBH_ERR) return(err) ;
			if(err == NOERROR) break;
			continue ;
		}
		if(sr.retcode == RET_USER_ESC){
			if(sr.escchar[0] == 'h' || sr.escchar[0] == 'H'){
				err = WindowHelp() ;
				if(DBH_ERR == err || PROFOM_ERR == err)
					return(err) ;
				if(err == NOERROR) break;
			}
			continue;
		}
		if(sr.retcode != RET_NO_ERROR) continue;
		break ;
	}

	return(NOERROR) ;
}	/* ReadFld() */
/*-----------------------------------------------------------------------*/
/* This function allows user to change Total Fields. When user selects any fld
   between Tran Amt & Disc Amt, this function reads that fld to Disc amt fld */
static	int
ChangeTotal(field)
int	field ;
{
	int	i ;

	/* break is not put, to fall thru */
	switch(field) {
	case DISC_PER:
		s_sth.s_disc_per = LV_DOUBLE ;
	default :
		s_sth.s_disc_amt = LV_DOUBLE ;
	}

	i = ReadFields((ST_FLD+(field-1)*100), (ST_FLD+(DISC_AMT-1)*100),
			Validate, WindowHelp,UPDATE,0) ;

	if(PROFOM_ERR == i || DBH_ERR == i) return(i) ;

	return(NOERROR) ;
}	/* ChangeTotal() */
/*----------------------------------------------------------------*/
/* Validation function() for Key and Data fields when PROFOM returns
  RET_VAL_CHK */

Validate()
{
	int	err, cur_fld, end_fld ;
	double	diff ;

	switch(sr.curfld){
	case	SUPPCD_FLD	:	/* Supplier Cd: */
		if(s_sth.s_fn[0] == CHANGE)
			err = CheckSupp(s_sth.s_supp_cd,UPDATE) ;
		else
			err = CheckSupp(s_sth.s_supp_cd,BROWSE) ;
		if(DBH_ERR == err) return(err) ;
		if(err<0) {
			s_sth.s_supp_cd[0] = LV_CHAR ;
			return(ERROR) ;
		}
		fomer(supp_rec.s_name) ;
		break ;
	case	REFNO_FLD	:	/* Ref#: */
		if(s_sth.s_invc_no[0] == '\0') {
#ifdef ENGLISH
			fomer("Invalid Ref#");
#else
			fomer("# de reference invalide");
#endif
			s_sth.s_invc_no[0] = LV_CHAR ;
			return(ERROR) ;
		}
		break ;
	case	TRTYPE_FLD	:	/* Trans. Type: */
		/* Check for validity of type */
		if((TransType = CheckTransType(s_sth.s_tr_type)) == ERROR) {
			s_sth.s_tr_type[0] = LV_CHAR ;
			return(ERROR) ;
		}
		break ;
	case	INVCDT_FLD	:	/* Invoice Date: */
		/* Invoice Date shouldn't be future date */
		if(s_sth.s_invc_dt > s_sth.s_rundate) {
#ifdef ENGLISH
			fomer("Date Can't be Future Date");
#else
			fomer("Date ne peut pas etre ulterieure");
#endif
			s_sth.s_invc_dt = LV_LONG ;
			return(ERROR) ;
		}
		break ;
	case	DUEDT_FLD	:	/* Due Date: */
		if(s_sth.s_due_dt < s_sth.s_invc_dt) {
#ifdef ENGLISH
			fomer("Trans date must be before Due Date");
#else
			fomer("Transaction doit etre avant la date de Echeance");
#endif
			s_sth.s_due_dt = LV_LONG;
			return(ERROR) ;
		}
		break ;
	case	DISCPER_FLD	:	/* Disc% */
		if(s_sth.s_disc_per < DELTA_AMT) break ;

		/* Else calculate the "Disc Amt" and dispaly it as a default */
		s_sth.s_disc_amt = s_sth.s_tran_amt * s_sth.s_disc_per / 100 ;

		sr.nextfld = DISCAMT_FLD;
		cur_fld = sr.curfld ;
		end_fld = sr.endfld ;
		sr.endfld  = sr.nextfld;
		fomud((char*)&s_sth) ;
		ret(err_chk(&sr)) ;
		s_sth.s_disc_amt = LV_DOUBLE ;
		sr.curfld  = cur_fld ;
		sr.endfld  = end_fld ;
		break ;
	case	DISCAMT_FLD	:	/* Disc Amt: */
		if(((TransType == INVOICE || TransType == CRMEMO) &&
			    (s_sth.s_disc_amt <= s_sth.s_tran_amt |
					 s_sth.s_disc_amt > DELTA_AMT)) ||
			((TransType == RETURN || TransType == DBMEMO) &&
			    (s_sth.s_disc_amt >= s_sth.s_tran_amt ||
					 s_sth.s_disc_amt < -DELTA_AMT))) {
#ifdef ENGLISH
			fomer("Should Be Less Than Transaction Amount");
#else
			fomer("Devrait etre moins que le montant de la transaction");
#endif
			s_sth.s_disc_amt = LV_DOUBLE ;
			return(ERROR) ;
		}
		/* User can change amount. Recalculate Disc% from Amount */
		s_sth.s_disc_per = s_sth.s_disc_amt * 100 / s_sth.s_tran_amt ;
		sr.curfld = DISCPER_FLD ;	/* To display Disc% */

		if(supp_rec.s_type[0] == CONTRACT) {
			diff = s_sth.s_tran_amt - s_sth.s_disc_amt ;
			if(in_rec.in_pmtcode[0] == OPEN &&
				diff > -(DELTA_AMT) && diff < DELTA_AMT)
				s_sth.s_pmtcode[0] = REL_HB ;
			else 
			if(in_rec.in_pmtcode[0] == REL_HB &&
				diff <= -(DELTA_AMT) || diff >= DELTA_AMT) {
				s_sth.s_pmtcode[0] = OPEN ;
				if(s_sth.s_part_amt <= -(DELTA_AMT) ||
					s_sth.s_part_amt >= DELTA_AMT) {
					s_sth.s_part_amt = 0 ;
					s_sth.s_chq_no = 0 ;
					s_sth.s_accno[0] = '\0' ;
				}
			}
			else
				break ;

			ret (WriteFields(PMNTCD_FLD, PMNTDESC_FLD) ) ;
		}
		break ;
	case	PMNTCD_FLD	:	/* Pmnt Code: */
		if(sr.fillcode == FIL_DUP) break ;
		if(s_sth.s_pmtcode[0] != OPEN) {
#ifdef ENGLISH
			fomer("Valid Code is O(pen)");
#else
			fomer("Code valable est O(uvert)");
#endif
			s_sth.s_pmtcode[0] = LV_CHAR ;
			return(ERROR) ;
		}
		CpPmntCdDesc() ;
		if(in_rec.in_pmtcode[0] != STOPPMT)
			if(s_sth.s_part_amt <= -(DELTA_AMT) ||
					s_sth.s_part_amt >= DELTA_AMT) {
				s_sth.s_part_amt = 0 ;
				s_sth.s_chq_no = 0 ;
				s_sth.s_accno[0] = '\0' ;
			}

		ret( WriteFields(PMNTDESC_FLD, ACCTNO_FLD) ) ;
		break ;
	case	CHEQUENO_FLD	:	/* Cheque#: */
		if(s_sth.s_chq_no <= 0) {
#ifdef ENGLISH
			fomer("Can't Be Zero");
#else
			fomer("Ne peut pas etre zero");
#endif
			s_sth.s_chq_no = LV_LONG ;
			return(ERROR) ;
		}
		break ;
	case	ACCTNO_FLD	:	/* Bank Acct# */
		if(acnt_chk(s_sth.s_accno) == ERROR) {
#ifdef ENGLISH
			fomer("Invalid Account Number");
#else
			fomer("Numero de compte invalide");
#endif
			s_sth.s_accno[0] = LV_CHAR ;
			return(ERROR) ;
		}
		/* Account# has to be One of the 2 Bank Accounts */
		if(strcmp(s_sth.s_accno,ctl_rec.bank1_acnt) &&
				strcmp(s_sth.s_accno,ctl_rec.bank2_acnt) ) {
#ifdef ENGLISH
			sprintf(e_mesg,
				"Valid Account Numbers.. BANK1: %s  BANK2: %s",
				ctl_rec.bank1_acnt, ctl_rec.bank2_acnt );
#else
			sprintf(e_mesg,
				"Numeros de comptes valables.. BANQUE1: %s  BANQUE2: %s",
				ctl_rec.bank1_acnt, ctl_rec.bank2_acnt );
#endif
			fomer(e_mesg) ;
			s_sth.s_accno[0] = LV_CHAR ;
			return(ERROR) ;
		}
		err = CheckGlAcnt(s_sth.s_fund,s_sth.s_accno,99,BROWSE) ;
		if(DBH_ERR == err) return(err) ;
		if(ERROR == err) {
			s_sth.s_accno[0] = LV_CHAR ;
			return(ERROR) ;
		}
		break ;
	default :
#ifdef ENGLISH
		sprintf(e_mesg,"No Validity Check For Field#  %d",sr.curfld);
#else
		sprintf(e_mesg,"Pas de controle de validite pour le Champ#  %d",sr.curfld);
#endif
		fomen(e_mesg);
		get();
		return(ERROR) ;
	}	/* Switch sr.curfld */

	return(NOERROR) ;
}	/* Validate() */
/*----------------------------------------------------------------*/
/* Show Help Windows, if applicable, when user gives ESC-H */

WindowHelp()
{
	int	err ;

	switch(sr.curfld){
	case	SUPPCD_FLD	:	/* Supplier Cd: */
		err = supp_hlp(s_sth.s_supp_cd, 7, 13 );
		if(err == DBH_ERR) return(err) ;
		if(err >=0 ) redraw();
		if(err < 1) return(ERROR) ;

		/* Lock the Supplier */
		if(s_sth.s_fn[0] == CHANGE)
			err = CheckSupp(s_sth.s_supp_cd,UPDATE) ;
		else
			err = CheckSupp(s_sth.s_supp_cd,BROWSE) ;
		if(DBH_ERR == err) return(err) ;
		if(err<0) {
			s_sth.s_supp_cd[0] = LV_CHAR ;
			return(ERROR) ;
		}
		break ;
	default :
#ifdef ENGLISH
		fomer("No Help Window For This Field");
#else
		fomer("Pas de fenetre d'assistance pour ce champ");
#endif
		return(ERROR) ;
	}	/* Switch sr.curfld */

	return(NOERROR) ;
}	/* WindowHelp() */
/*-----------------------------------------------------------------------*/ 
/* Update the records and write to files */

WriteRecords()
{
	int	err;
	Invoice	pre_rec ;

	scpy((char*)&pre_rec, (char*)&in_rec, sizeof(Invoice)) ;

	UpdateSummary() ;

	/* Update Supplier */
	if(supp_rec.s_type[0] == CONTRACT) {
		/* For contract supplier add HB amount to disc_amt. Later on
		   it will be deducted whenever HB is released */
		if(TransType == INVOICE || TransType == CRMEMO )
			supp_rec.s_ytd_disc +=
				s_sth.s_disc_amt - in_rec.in_disc_amt;
		else
			supp_rec.s_ytd_disc -=
				s_sth.s_disc_amt - in_rec.in_disc_amt;
		supp_rec.s_ytd_disc =  D_Roundoff(supp_rec.s_ytd_disc);
		err = put_supplier(&supp_rec, UPDATE, e_mesg) ;
		if(err != NOERROR) return( ShowError() );
	}
	
	InitInvoice() ;		/* Copy Changes to Invoice */
	err = put_invc(&in_rec, UPDATE, e_mesg) ;
	if(err != NOERROR) return( ShowError() ) ;

	err = rite_audit((char*)&s_sth, APINVOICE, UPDATE, (char*)&in_rec,
			(char*)&pre_rec, e_mesg);
	if(err==LOCKED) {
		DispError(e_mesg);
		roll_back(e_mesg);
		return(LOCKED);
	}

	if(err != NOERROR) return( ShowError() ) ;

	err = commit(e_mesg) ;
	if(err < 0) return( ShowError() ) ;

	if(pre_rec.in_due_dt != in_rec.in_due_dt) {
		if(first == 0) {
			err = rpopen(projname,logrec,formno,outcntl,discfile,
					program,chardate);
			if(err < 0){
				sprintf(e_mesg,"Rpopen code :%d \n",code);
				fomen(e_mesg);
				get();
				return(err);
			}

		 	rpChangetitle(1, pa_rec.pa_co_name); 
			first = 1;
		}
		in_rec.in_invc_dt = pre_rec.in_due_dt ;
		due_dt_report();
	}

	return(NOERROR);
}	/* WriteRecords() */
/*-----------------------------------------------------------*/
/* Show the Updation error message */
static	int
ShowError()
{
#ifdef ENGLISH
	DispError("ERROR in Saving Records"); 
#else
	DispError("ERREUR en conservant les fiches");
#endif
	DispError(e_mesg);
	InitScreen() ;
	roll_back(e_mesg) ;	/* Unlock the locked Records */

	return(DBH_ERR);
}	/* ShowError() */
/*-----------------------------------------------------------*/
/* Upadte the Partition Summary Totals */
static	int
UpdateSummary()
{
	double	diff ;

	diff = s_sth.s_disc_amt - in_rec.in_disc_amt ;

	diff = D_Roundoff(diff);

	/* If no change in discount amount, then return */
	if(diff > -(DELTA_AMT) && diff < DELTA_AMT) return(NOERROR) ;

	if(supp_rec.s_type[0] == ORDINARY) {
		DiscChanges.no_trans++ ;
		DiscChanges.tot_amt += diff ;
	}
	else {
		HBchanges.no_trans++ ;
		HBchanges.tot_amt += diff ;
	}
	DiscChanges.tot_amt     = D_Roundoff(DiscChanges.tot_amt);
	HBchanges.tot_amt 	= D_Roundoff( HBchanges.tot_amt);

	TotalsUpdated = 1 ;	/* Print Summary Reports at the end */

	return(NOERROR) ;
}	/* UpdateSummary() */
/*-----------------------------------------------------------*/
/* Move Screen Fields to Invoice */

InitInvoice()
{
	/* Copy Key */
	STRCPY(in_rec.in_supp_cd, s_sth.s_supp_cd) ;
	STRCPY(in_rec.in_invc_no, s_sth.s_invc_no) ;
	STRCPY(in_rec.in_tr_type, s_sth.s_tr_type) ;

	/* Copy Header Fields */
	in_rec.in_funds      = s_sth.s_fund ;
	in_rec.in_period     = s_sth.s_period ;
	in_rec.in_po_no      = s_sth.s_po_no ;
	in_rec.in_invc_dt    = s_sth.s_invc_dt ;
	in_rec.in_due_dt     = s_sth.s_due_dt ;
	in_rec.in_amount     = s_sth.s_tran_amt ;
	in_rec.in_amount     = D_Roundoff(in_rec.in_amount);
	in_rec.in_type[0]    = s_sth.s_type[0] ;
	in_rec.in_disc_per   = s_sth.s_disc_per ;
	in_rec.in_disc_amt   = s_sth.s_disc_amt ;
	in_rec.in_disc_amt   = D_Roundoff(in_rec.in_disc_amt);
	in_rec.in_pmtcode[0] = s_sth.s_pmtcode[0] ;
	in_rec.in_part_amt   = s_sth.s_part_amt ;
	in_rec.in_part_amt   = D_Roundoff(in_rec.in_part_amt);
	in_rec.in_chq_no     = s_sth.s_chq_no ;
	STRCPY(in_rec.in_accno, s_sth.s_accno) ;
	STRCPY(in_rec.in_remarks, s_sth.s_remarks) ;

	return(NOERROR) ;
}	/* InitInvoice() */
/*-------------------------------------------------------------------------*/
/* Initialize Screen with High Values */
static	int
InitScreen()
{
	s_sth.s_fund        = HV_SHORT ;
	s_sth.s_period      = HV_SHORT ;
	s_sth.s_po_no       = HV_LONG ;
	s_sth.s_invc_dt     = HV_LONG ;
	s_sth.s_due_dt      = HV_LONG ;
	s_sth.s_type[0]     = HV_CHAR ;
	s_sth.s_tran_amt    = HV_DOUBLE ;
	s_sth.s_per_pr[0]   = HV_CHAR ;
	s_sth.s_disc_per    = HV_DOUBLE ;
	s_sth.s_amt_pr[0]   = HV_CHAR ;
	s_sth.s_disc_amt    = HV_DOUBLE ;
	s_sth.s_pmtcode[0]  = HV_CHAR ;
	s_sth.s_pmt_desc[0] = HV_CHAR ;
	s_sth.s_part_amt    = HV_DOUBLE ;
	s_sth.s_chq_no      = HV_LONG ;
	s_sth.s_accno[0]    = HV_CHAR ;
	s_sth.s_remarks[0]  = HV_CHAR ;

	ret(WriteFields(ST_FLD, END_FLD - 200)) ;

	return(NOERROR) ;
}	/* InitScreen() */

due_dt_report()
{
	rpline(arayptr);
}
/*-------------------- E n d   O f   P r o g r a m ---------------------*/

