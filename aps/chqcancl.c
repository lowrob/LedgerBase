/*-----------------------------------------------------------------------
Source Name: chqcancl.c
System     : Accounts Payables.
Created  On: 13 DECEMBER 89.
Created  By: T AMARENDRA.

COBOL Source(s): cp170---01

DESCRIPTION:
	Cheque Cancellation Program.

MODIFICATIONS:        

Programmer     YY/MM/DD       Description of modification
J.Prescott     90/10/15       Add execute function to automatically call
			      Cheque Processing when cheque cancellation
			      is Finished.
peter ralph    90/11/23       right justify numeric supplier code
C.Leadbeater   90/11/27	      Removed to ability to enter a negative value 
			      for gross pmnt, discount taken, and net payment,
			      and automatically change the sign to minus if
			      RETURN or DBMEMO.
C.Leadbeater   90/12/18	      Added D_Roundoff() to round any double variables
			      used in calculations and written to files.
F.Tao 	       90/12/18       Right Justify Supplier Code.	
------------------------------------------------------------------------*/

#define	MAIN
#define MAINFL		CHEQUE		/* main file used */

#include <stdio.h>
#include <bfs_defs.h>
#include <bfs_recs.h>
#include <cfomstrc.h>

#define	SYSTEM		"ACCOUNTS PAYABLE"	/* Sub System Name */
#define	MOD_DATE	"18-DEC-90"		/* Program Last Modified */

#define CHEQPROC	"cheque"	/* execute cheque processing */

#define	DELTA_AMT	0.005	/* To Check float & double amounts for 0 */
#define	ESC_F		1	/* ESC-F is active */
#define CHEQUES		66	/* Used if Cheques Still Left to Print */

/*Transaction Types */
#ifdef ENGLISH
#define	INVOICE		"IN"
#define	RETURN		"RT"
#define	CRMEMO		"CM"
#define	DBMEMO		"DM"
#else
#define	INVOICE		"FC"
#define	RETURN		"RV"
#define	CRMEMO		"NC"
#define	DBMEMO		"ND"
#endif

/* User Interface define constants */
#ifdef ENGLISH
#define SELECT		'S'
#define EXITOPT		'E'

#define	ADDTRANS	'A'
#define	NEXTTRANS	'N'
#define	PREVTRANS	'P'
#define	YES		'Y'
#define	EDIT		'E'
#define	CANCEL		'C'
#else
#define SELECT		'C'
#define EXITOPT		'F'

#define	ADDTRANS	'R'
#define	NEXTTRANS	'S'
#define	PREVTRANS	'P'
#define	YES		'O'
#define	EDIT		'M'
#define	CANCEL		'A'
#endif
/* PROFOM Releted declarations */

#define	SCR_NAME	"chqcancl"	/* PROFOM screen Name */

/* PROFOM Screen STH file */

/* Field PROFOM numbers */

#define	FN_FLD		400	/* Fn: */
#define	KEY_START	500	/* Key Start Field */
#define	KEY_END		700	/* Key End Field */
#define	END_FLD		3500	/* Last Field of the screen */
#define	CHG_FLD		1000	/* Field#: */
#define	FUND_FLD	500	/* Fund#: */
#define	ACCT_FLD	600	/* Bank Acct#: */
#define	CHQNO_FLD	700	/* Cheque#: */
#define	CHQAMT_FLD	800	/* Cheque amt : */
#define	SUPPCD_FLD	900	/* Supplier Cd: */
#define	SUPPNAME_FLD	1100	/* Supplier Name: */
#define	POSTALCD_FLD	1500	/* Postal Code: */
#define	TRANREF_FLD	1600	/* Tran Ref#: */
#define	INV_START	1600	/* Tran Ref#: */
#define	TRTYPE_FLD	1700	/* Tran Type: */
#define	INVCDT_FLD	1800	/* Tran Date: */
#define	DUEDT_FLD	1900	/* Due Date: */
#define	PERIOD_FLD	2000	/* Period: */
#define	GRPMNT_FLD	2200	/* Gross Payment: */
#define	DISCTAKEN_FLD	2300	/* Disc Taken: */
#define	NETAMT_FLD	2400	/* Net Payment: */
#define	DISCAMT_FLD	2900	/* HB/Disc Amount: */
#define	TOTPR_FLD	3000	/* "TOTALS" Prompt */
#define	TOTDISC_FLD	3300	/* Total Disc Taken: */

/* Field Serial Numbers on Screen */

#define	TRANREF		1
#define	TRTYPE		2
#define	INVC_DT		3
#define	DUE_DT		4
#define	GROSS_PMNT	7
#define	DISC_TAKEN	8

/* chqcancl.sth - header for C structure generated by PROFOM EDITOR */

struct	s_struct	{

	char	s_pgm[11];	/* STRING XXXXXXXXXX Field 100 */
	long	s_rundate;	/* DATE YYYYFMMFDD Field 300 */
	char	s_fn[2];	/* STRING X Field 400 */
	short	s_fund;		/* NUMERIC 999 Field 500 */
	char	s_accno[19];	/* STRING X[18] Field 600 */
	long	s_chq_no;	/* NUMERIC 99999999 Field 700 */
	double	s_chq_amt;	/* NUMERIC 999F999F999.99 Field 800 */
	char	s_supp_cd[11];	/* STRING XXXXXXXXXX Field 900 */
	short	s_field;	/* NUMERIC 99 Field 1000 */
	char	s_name[49];	/* STRING X[49] Field 1100 */
	char	s_add1[31];	/* STRING X[30] Field 1200 */
	char	s_add2[31];	/* STRING X[30] Field 1300 */
	char	s_add3[31];	/* STRING X[30] Field 1400 */
	char	s_pc[11];	/* STRING X[7] Field 1500 */
	char	s_invc_no[16];	/* STRING X[10] Field 1600 */
	char	s_tr_type[3];	/* STRING X[2] Field 1700 */
	long	s_invc_dt;	/* DATE YYYYFMMFDD Field 1800 */
	long	s_due_dt;	/* DATE YYYYFMMFDD Field 1900 */
	short	s_period;	/* NUMERIC 99 Field 2000 */
	char	s_desc[21];	/* STRING X[20] Field 2100 */
	double	s_gr_pmnt;	/* NUMERIC 99F999F999.99 Field 2200 */
	double	s_disc_taken;	/* NUMERIC 99F999F999.99 Field 2300 */
	double	s_net_pmnt;	/* NUMERIC 99F999F999.99 Field 2400 */
	double	s_gr_amt;	/* NUMERIC S99F999F999.99 Field 2500 */
	char	s_per_pr[11];	/* STRING X[10] Field 2600 */
	double	s_disc_per;	/* NUMERIC 99.99 Field 2700 */
	char	s_disc_pr[11];	/* STRING X[10] Field 2800 */
	double	s_disc_amt;	/* NUMERIC S99F999F999.99 Field 2900 */
	char	s_tot_pr[2];	/* STRING X Field 3000 */
	short	s_no_trans;	/* NUMERIC 999 Field 3100 */
	double	s_tot_pmnt;	/* NUMERIC S99F999F999.99 Field 3200 */
	double	s_tot_disc;	/* NUMERIC S99F999F999.99 Field 3300 */
	char	s_mesg[78];	/* STRING X[77] Field 3400 */
	char	s_resp[2];	/* STRING X Field 3500 */
};


static	struct	s_struct  s_sth;	/* PROFOM Screen Structure */

static	struct  stat_rec  sr;		/* PROFOM status rec */

Pa_rec		pa_rec ;		/* Parameters Record */
Ctl_rec		ctl_rec ;		/* Fund/Control Record */
Supplier	supp_rec ;		/* Supplier */
Invoice		in_rec ;		/* Purchase Invoice */
Chq_rec		chq_rec ;		/* Cheque Record */
Chq_hist	chq_hst ;		/* Cheque History Record */
Gl_rec		gl_rec ;		/* G/L Account Record */

char 		e_mesg[100];		/* dbh will return err msg in this */

/*
*	Doubly linked list to maintain transactions under cheque.
*/

typedef	struct Trans {

	Invoice	tr_rec ;		/* Transaction Record */
	short	infile ;		/* Exists in file? */
	double	gr_pmnt ;		/* Gross Payment */
	double	disc_taken ;		/* Discount Taken */
	struct	Trans	*NextTrans ;	/* Ptr to Next Trans */
	struct	Trans	*PrevTrans ;	/* Ptr to Prev Trans */

}	Trans ;

static	Trans	*FirstTrans ;		/* Address of the First Trans */
static	Trans	*CurrTrans ;		/* Address of the Current Trans */
static	Trans	*LastTrans ;		/* Address of the Last Trans */

/* flag */
short	InvcExists ;
double	D_Roundoff();

/* define to see if execute() needs to be executed */
int	CancelledCheque;

/*------------------------------------------------------------------------*/

main(argc,argv)
int	argc;
char	*argv[];
{
	int	err, numprocess;

	if(argc < 2){
#ifdef  DEVELOP
		printf("MAIN ARGUMENTS ARE NOT PROPER\n");
		printf("Usage: %s {-tTerminal Name} {-dDist#} [{-sSwitches}]\n",
			argv[0]);
#endif
		exit(1);
	}

	err = Initialize(argc,argv) ;	/* Initialize Variables , DBH
						Environment and PROFOM */

#ifndef DOS
	numprocess = invcheck();	/* check if invoice entry in process */
	if(numprocess == ERROR){
		DispError("Error Occured Checking Active Process");
		close_dbh();
		exit(0);
	}
	if(numprocess > 0){
		DispError("Can Not Proceed, Invoice Entry In Process");
		close_dbh();
		exit(0);
	}
#endif
	CancelledCheque = 0;
	if(err == NOERROR) err = Process();	/* Initiate Process */

	CloseProcess() ;

	/* added to fix cheque cancellation problem if cheque run not done */
	if(CancelledCheque == 1) {
		err=execute(CHEQPROC,argc,argv);
		if(err<0) exit(1);
		redraw();
	}

	if(err != NOERROR)exit(1);
	exit(0);
}	/* main() */
/*-------------------------------------------------------------------*/
/* Initialize Variables, PROFOM, DBH etc. */

Initialize(argc, argv)
int	argc ;
char	*argv[] ;
{
	int	i ;

	/*
	*	Initialize DBH Environment
	*/
	strncpy(SYS_NAME,SYSTEM,50);	/* Sub system name */
	strncpy(CHNG_DATE,MOD_DATE,10);	/* Modification Date */

	proc_switch(argc, argv, MAINFL) ;	/* Process Switches */

	/*
	*	Initialize PROFOM & Menu Screen
	*/
	STRCPY(sr.termnm,terminal);	/* Copy Terminal Name */
	fomin(&sr);
	ret(err_chk(&sr)) ;		/* Check for PROFOM Error */
	fomcf(1,1);			/* Enable Snap screen option */

	/* move screen name to Profom status structure */
	STRCPY(sr.scrnam,NFM_PATH);
	strcat(sr.scrnam,SCR_NAME) ;

	/* Initialize SCR */
	STRCPY(s_sth.s_pgm,PROG_NAME);
	s_sth.s_rundate = get_date();	/* get Today's Date in YYYYMMDD format*/
	s_sth.s_field   = HV_SHORT ;
	s_sth.s_mesg[0] = HV_CHAR ;
	s_sth.s_resp[0] = HV_CHAR ;

	i = ClearScreen() ;	/* Clear the Screen */
	if(i < 0) return(i) ;

	/*
	*	Get The Parameter Record
	*/
	i = get_param(&pa_rec, BROWSE, 1, e_mesg) ;
	if(i == ERROR) {
		DispError(e_mesg);
		return(ERROR) ;
	}
	else if(i == UNDEF) {
#ifdef ENGLISH
		DispError("Parameters Are Not Setup..");
#else
		DispError("Parametres ne sont pas etablis..");
#endif
		return(ERROR) ;
	}

	/* Open Report File */
	i = OpenReport() ;
	if(i < 0) return(i) ;

	return(NOERROR) ;
}	/* Initialize() */
/*-------------------------------------------------------------------*/
/* Get Fn: from user and call corresponding function */

Process()
{
	int err;

	for( ; ; ){
		/* Get the Fn: from the user */
		if((err = ReadFn()) != NOERROR) return(err) ;

		err = ProcFn() ;	/* Process Fn */

		if(QUIT == err)		return(NOERROR) ;	/* Exit */
		if(NOACCESS == err) {
			fomen(e_mesg);
			get();
		}
		if(PROFOM_ERR == err)	return(PROFOM_ERR);  /* PROFOM ERROR */
		if(DBH_ERR == err) {
			DispError(e_mesg);
#ifdef ENGLISH
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"System Error... Iserror:",
				iserror, dberror, errno);
#else
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"Erreur du systeme... Iserror:",
				iserror, dberror, errno);
#endif
			DispError(e_mesg);
			return(DBH_ERR);	/* DBH ERROR */
		}
	}      /*   end of the for( ; ; )       */
}	/* Process() */
/*----------------------------------------------------------------*/
/* Close necessary files and environment before exiting program */

CloseProcess()
{
	CloseReport() ;

	/* Set terminal back to normal mode from PROFOM */
	fomcs();
	fomrt();

	close_dbh();	/* Close DBH(files) */

	return(NOERROR) ;
}	/* CloseProcess() */
/*----------------------------------------------------------------*/
/* Display the Options (Fn:) and get the Fn from the user */

ReadFn()
{
	/* Display options */
#ifdef ENGLISH
	fomer("S(elect), E(xit)");
#else
	fomer("C(hoisir), F(in)");
#endif
	/* Read Fn: field */
	sr.nextfld = FN_FLD ;
	fomrf( (char *)&s_sth );
	ret(err_chk(&sr));	/* Check for PROFOM error */

	return(NOERROR) ;
}	/* ReadFn() */
/*----------------------------------------------------------------*/
/* Process the user selected Fn */

ProcFn()
{
	int retval;

	switch (s_sth.s_fn[0]) {
	case SELECT  :			/* Select */
		CHKACC(retval,ADD,e_mesg);
		return( CancelProcess() ) ;
	case EXITOPT  :			/* Exit */
		return( QUIT ) ;
	}  /*   end of the switch statement */

	if(retval<0)
		return(retval);

	return(NOERROR);
}	/* ProcFn() */
/*-----------------------------------------------------------------------*/
/* Take the Cheque Keys for cancellation form the user */

CancelProcess()
{
	int	err ;

	/* If the Current Period == 0 (i.e before yearly closing), Add or
	   Change is not allowed */
	if(pa_rec.pa_cur_period == 0) {
#ifdef ENGLISH
		DispError("Not Allowed Before Yearly Closing...");
#else
		DispError("Pas permis avant la fermeture annuelle...");
#endif
		return(NOERROR) ;
	}

	err = ChkCheques();
	if(err ==  ERROR) return(err);
	if(err == CHEQUES) return(NOERROR);

	FirstTrans = NULL ;
	CurrTrans  = NULL ;
	LastTrans  = NULL ;

	err = ReadChequeKey() ;
	if(PROFOM_ERR == err || DBH_ERR == err) return(err) ;
	if(NOERROR != err) {
		roll_back(e_mesg) ;	/* Unlock the locked Records */
		return(err) ;
	}
	
	/* Initialize Totals */
	s_sth.s_tot_pr[0] = ' ' ;	/* To Display Prompt */

	s_sth.s_no_trans  = 0 ;
	s_sth.s_tot_pmnt = 0.0 ;
	s_sth.s_tot_disc = 0.0 ;
	ret (WriteFields(TOTPR_FLD, TOTDISC_FLD) );

	/* Get all the items(IN,CM,RT & DM etc.) under this cheque */
	err = ReadItems() ;
	if(PROFOM_ERR == err || DBH_ERR == err) return(err) ;
	if(err != NOERROR) {
		roll_back(e_mesg) ;	/* Unlock the locked Records */
		FreeList() ;
		ret( ClearScreen() ) ;		/* Clear the Screen */
		return(NOERROR) ;
	}

	err = UpdateFiles() ;
	if(PROFOM_ERR == err || DBH_ERR == err) return(err) ;

	return(NOERROR) ;
}	/* CancelProcess() */
/*----------------------------------------------------------------------*/
/* Check to see if there are Still Cheques Left to Print.		*/
/* If so cheque cancellation cannot be done.				*/
/*----------------------------------------------------------------------*/
ChkCheques()
{
	int	err;

	/* check to see if check exists with manual cheque number */
	STRCPY(chq_rec.c_supp_cd,"\0");
	chq_rec.c_funds = 0;
	chq_rec.c_chq_no = 0 ;
	STRCPY(chq_rec.c_invc_no, "\0");
	STRCPY(chq_rec.c_tr_type, "\0");
	flg_reset(CHEQUE);

	err = get_n_chq(&chq_rec,BROWSE,0,FORWARD,e_mesg);
	if(err != NOERROR) {
	 	if(err == EFL) {
			return(NOERROR);
		}
		DispError(e_mesg);
		return(ERROR);
	}
	if(chq_rec.c_cancelled[0] != YES) {
#ifdef ENGLISH
		DispError("Cannot Cancel Cheques.  Cheques Still to Process.");
#else
		DispError("Cheques ne peuvent pas etre annules.  Il reste des cheques a traiter.");
#endif
		return(CHEQUES);
	}

	return(NOERROR);
}
/*----------------------------------------------------------------------*/
/* Read the Cancellation Cheque key form user */

ReadChequeKey()
{
	int	i;

	i = ClearScreen() ;		/* Clear the Screen */
	if( i != NOERROR) return(i) ;

	for(i = KEY_START ; i <= KEY_END ; i += 100)
		fomca1(i,19,0) ;

	

#ifdef ENGLISH
	STRCPY(s_sth.s_mesg,"Press ESC-F to Go Back to Fn:");
#else
	STRCPY(s_sth.s_mesg,"Appuyer sur ESC-F pour retourner a Fn:");
#endif
	ShowMesg();

	for( ; ; ) {

		fomca1(FUND_FLD,19,2);
		s_sth.s_fund = 1;
		WriteFields(FUND_FLD,FUND_FLD);
		InitChqKey();

		i = ReadFields(KEY_START, KEY_END, ESC_F) ;
		if(PROFOM_ERR == i || DBH_ERR == i) return(i) ;
		if(RET_USER_ESC == i){
			InitChqKey() ;
			ret( WriteFields(KEY_START, POSTALCD_FLD) ) ;
			s_sth.s_mesg[0] = HV_CHAR;
			ShowMesg();
			return(ERROR) ;
		}

		/* Check whether this cheque is existing in History */
		chq_hst.ch_funds = s_sth.s_fund ;
		STRCPY(chq_hst.ch_accno, s_sth.s_accno) ;
		chq_hst.ch_chq_no = s_sth.s_chq_no ;
		i = get_chqhist(&chq_hst, BROWSE, 0, e_mesg) ;
		if(i == ERROR) return(DBH_ERR) ;
		if(i < 0) {
			fomen(e_mesg);
			get() ;
			continue ;
		}
	
		if(chq_hst.ch_status[0] == CASHED) {
			fomer("Cannot Cancel a Cashed Cheque"); 
			continue;
		}
		if(chq_hst.ch_status[0] == CANCELLED) {
			fomer("Cheque Already Cancelled"); 
			continue;
		}

		break ;
	}

	/* Show the Cheque Amount */
	s_sth.s_chq_amt = chq_hst.ch_net_amt ;
	ret( WriteFields(CHQAMT_FLD, CHQAMT_FLD)) ;

	/* Read Supplier Code */
	i = ReadFields(SUPPCD_FLD, SUPPCD_FLD, ESC_F) ;
	if(PROFOM_ERR == i || DBH_ERR == i) return(i) ;
	if(RET_USER_ESC == i){
		InitChqKey() ;
		ret( WriteFields(KEY_START, POSTALCD_FLD) ) ;
		s_sth.s_mesg[0] = HV_CHAR;
		ShowMesg();
		return(ERROR) ;
	}

	return(NOERROR);
}	/*  ReadChequeKey() */
/*-----------------------------------------------------------------------*/
/* Get all the items under cheuqe */

ReadItems()
{
	int	err ;

	for( ; ; ) {
		/* Clear the Current Transaction Details */
		InitInvcKey(HV_CHAR) ;
		InitDataFields(HV_CHAR, HV_SHORT, HV_LONG) ;
		InitPmntFields(HV_DOUBLE) ;
		s_sth.s_mesg[0] = HV_CHAR;
		ret ( WriteFields( TRANREF_FLD, END_FLD - 100) ) ;

		err = ReadInvcKey() ;

		if(err == CANCEL) continue ;	/* Cancelled or Invalid */

		/* else NOERROR (Confirmed the Key) or RET_USER_ESC (ESC-F) */

		if(err == NOERROR)	/* Confirmed the Invoice Key */
			err = ReadDetails() ;


		/* When the current trans is confirmed, go for the next. 
		   Termination is by ESC_F */
		if(err == NOERROR) continue ;

		if(err == RET_USER_ESC || err == CANCEL) {
			if(LastTrans != NULL)
				ShowTrans(LastTrans) ;
			else {
				/* Clear the Current Transaction Details */
				InitInvcKey(HV_CHAR) ;
				InitDataFields(HV_CHAR, HV_SHORT, HV_LONG) ;
				InitPmntFields(HV_DOUBLE) ;
				s_sth.s_mesg[0] = HV_CHAR;
				ret (WriteFields(TRANREF_FLD, END_FLD - 100)) ;
			}
#ifdef ENGLISH
			err = Confirm("CHEQUE: Y(es), A(dd Trans), N(ext Trans), P(rev Trans), C(ancel Entry)",
				"YANPC", 0, 0);
#else
			err = Confirm("CHEQUE: O(ui), R(ajouter), S(uivant), P(recedent), A(nnuler entree)",
				"ORSPA", 0, 0);
#endif
		}

		if(err == ADDTRANS) continue ;	/* More Invoices */

		if(err == YES) {
			if(MatchTotals() == NOERROR) return(NOERROR) ;
			continue ;
		}
		return(err) ; /* Could be PROFOM_ERR, DBH_ERR or CANCEL Trans */
	}
}	/* ReadItems() */
/*----------------------------------------------------------------------*/
/* Get the Invoice key form user */

ReadInvcKey()
{
	int	i;

	for(i = TRANREF_FLD ; i <= TRTYPE_FLD ; i += 100)
		fomca1(i,19,0) ;

#ifdef ENGLISH
	STRCPY(s_sth.s_mesg,"Press ESC-F to Go Back to Sub-Options");
#else
	STRCPY(s_sth.s_mesg,"Appuyer sur ESC-F pour retourner aux sous-options");
#endif
	ShowMesg();

	InitInvcKey(LV_CHAR) ;

	i = ReadFields(TRANREF_FLD, TRTYPE_FLD, ESC_F) ;
	if(i != NOERROR) return(i) ;  /* PROFOM_ERR, DBH_ERR or RET_USER_ESC */

	/* Confirm the Key */
#ifdef ENGLISH
	i = Confirm("TRANS KEY: Y(es), E(dit), C(ancel)", "YEC",
#else
	i = Confirm("CLE TRANS: O(ui), M(odifier), A(nnuler)", "OMA",
#endif
			TRANREF, TRTYPE);
	if(i != YES) return(i) ;	/* PROFOM_ERR, DBH_ERR or CANCEL */

	/* Check Whether Same key is already given */
	i = IsGiven() ;
	if(i != NOERROR) return(CANCEL) ;	/* ERROR if exists */
	
	/* Get The Invoice */
	i = GetInvoice(s_sth.s_supp_cd, s_sth.s_invc_no,
						s_sth.s_tr_type, BROWSE);
	if(i < 0 && i != UNDEF) {
		DispError(e_mesg) ;
		return(DBH_ERR);
	}
	if(i == UNDEF)
		InvcExists = 0 ;
	else {
		if(s_sth.s_fund != in_rec.in_funds) {
#ifdef ENGLISH
			DispError("Invoice Exists... But doesn't belong to this Fund");
#else
			DispError("Facture existe... Mais n'appartient pas a ce fond");
#endif
			return(CANCEL) ;
		}
		InvcExists = 1 ;
	}

	return(NOERROR);
}	/*  ReadInvcKey() */
/*-----------------------------------------------------------------------*/
/* Read the Invoice Details form User */

ReadDetails()
{
	int	i;
	int	st_fld ;

	for(i = INVCDT_FLD ; i <= NETAMT_FLD ; i += 100)
		fomca1(i,19,0) ;

#ifdef ENGLISH
	STRCPY(s_sth.s_mesg,"Press ESC-F to Go Back to Sub-Options");
#else
	STRCPY(s_sth.s_mesg,"Appuyer sur ESC-F pour retourner aux sous-options");
#endif
	ShowMesg();

	if(InvcExists) {
		i = DisplayInvoice() ;
		if(i < 0) return(i) ;
		st_fld = GRPMNT_FLD ;
	}
	else {
		InitDataFields(LV_CHAR, LV_SHORT, LV_LONG) ;
		st_fld = INVCDT_FLD ;
	}

	InitPmntFields(LV_DOUBLE) ;

	i = ReadFields(st_fld, NETAMT_FLD, ESC_F) ;
	if(i != NOERROR) return(i) ;  /* PROFOM_ERR, DBH_ERR or RET_USER_ESC */

	/* Confirm the Invoice Deatils */
	if(InvcExists)
		st_fld = GROSS_PMNT ;
	else
		st_fld = INVC_DT ;
#ifdef ENGLISH
	i = Confirm("TRANSACTION: Y(es), E(dit), C(ancel)", "YEC",
#else
	i = Confirm("TRANSACTION: O(ui), M(odifier), A(nnuler)", "OMA",
#endif
			st_fld, DISC_TAKEN);
	if(i != YES) return(i);

		/*   If the transaction type is a RETURN or a DEBIT MEMO, 
		     convert the value to a negative.  (CL)              */
	
	if(  (strcmp(s_sth.s_tr_type,RETURN)==0)  ||
	     (strcmp(s_sth.s_tr_type,DBMEMO)==0)  ) { 
		s_sth.s_gr_pmnt 	*= -1;
		s_sth.s_disc_taken 	*= -1;
		s_sth.s_net_pmnt 	*= -1;
	}

	i = CopyToList() ;
	if(i != NOERROR) return(i) ;

	i = AccumTotals() ;
	if(i != NOERROR) return(i) ;

	return(NOERROR) ;
}	/*  ReadDetails() */
/*-----------------------------------------------------------------------*/
/* Check whether current Invoice is alraedy exists in Linked List */

IsGiven()
{
	Trans	*tempptr ;

	for( tempptr = FirstTrans ; tempptr != NULL ;
				tempptr = tempptr->NextTrans ) {
		if(strcmp(s_sth.s_invc_no, tempptr->tr_rec.in_invc_no) == 0 &&
		    strcmp(s_sth.s_tr_type, tempptr->tr_rec.in_tr_type) == 0) {

#ifdef ENGLISH
			DispError("This Transaction Is Already Given");
#else
			DispError("Cette transaction est deja donnee");
#endif
			return(ERROR) ;
		}
	}

	return(NOERROR) ;
}	/* IsGiven() */
/*-----------------------------------------------------------------------*/
/* Display the Invoice Details */

DisplayInvoice()
{
	s_sth.s_invc_dt = in_rec.in_invc_dt ;
	s_sth.s_due_dt  = in_rec.in_due_dt ;
	s_sth.s_period  = in_rec.in_period ;
	STRCPY(s_sth.s_desc, in_rec.in_remarks) ;
	s_sth.s_gr_amt = in_rec.in_amount ;
	s_sth.s_disc_per = in_rec.in_disc_per ;
	s_sth.s_disc_amt = in_rec.in_disc_amt ;

	CpHBorDisc() ;

	ret( WriteFields(TRANREF_FLD, DISCAMT_FLD) );

	return(NOERROR) ;
}	/* DisplayInvoice() */
/*-----------------------------------------------------------------------*/
/* Copy the Current Invoice information to Linked List */

CopyToList()
{
	int	err ;

	/* Allocate Memory */
	if(MakeFreshTrans() != NOERROR) return(DBH_ERR) ;

	/* Copy Current Transaction to List */
	if(InvcExists) {
		CurrTrans->infile = 1 ;

		scpy((char*)&CurrTrans->tr_rec,(char*)&in_rec,sizeof(Invoice));
	}
	else {
		CurrTrans->infile = 0 ;

		STRCPY(CurrTrans->tr_rec.in_supp_cd, s_sth.s_supp_cd) ;
		STRCPY(CurrTrans->tr_rec.in_invc_no, s_sth.s_invc_no) ;
		STRCPY(CurrTrans->tr_rec.in_tr_type, s_sth.s_tr_type) ;

		CurrTrans->tr_rec.in_funds   = s_sth.s_fund ;
		CurrTrans->tr_rec.in_period  = s_sth.s_period ;
		CurrTrans->tr_rec.in_invc_dt = s_sth.s_invc_dt ;
		CurrTrans->tr_rec.in_due_dt  = s_sth.s_due_dt ;

		STRCPY(CurrTrans->tr_rec.in_remarks, s_sth.s_desc) ;

		CurrTrans->tr_rec.in_accno[0] = '\0';
		CurrTrans->tr_rec.in_type[0] = 'D';  /* Not Known what to put */
		CurrTrans->tr_rec.in_pmtcode[0] = OPEN ;	/* open */

		CurrTrans->tr_rec.in_po_no      = 0 ;
		CurrTrans->tr_rec.in_chq_no     = 0 ;
		CurrTrans->tr_rec.in_disc_per   = 0 ;
		CurrTrans->tr_rec.in_disc_amt   = 0 ;
		CurrTrans->tr_rec.in_amount     = 0 ;
		CurrTrans->tr_rec.in_gsttax     = 0 ;
		CurrTrans->tr_rec.in_psttax     = 0 ;
		CurrTrans->tr_rec.in_part_amt   = 0 ;
	}

	CurrTrans->gr_pmnt    = s_sth.s_gr_pmnt ;
	CurrTrans->disc_taken = s_sth.s_disc_taken ;

	return(NOERROR) ;
}	/* CopyToList() */
/*-----------------------------------------------------------------------*/
/*  Accumulate Gross Totals and Display */

AccumTotals()
{
	s_sth.s_no_trans++ ;
	s_sth.s_tot_pmnt += s_sth.s_gr_pmnt ;
	s_sth.s_tot_disc += s_sth.s_disc_taken ;

	ret( WriteFields(TOTPR_FLD+100, TOTDISC_FLD) );
	return(NOERROR) ;
}	/* AccumTotals() */
/*-----------------------------------------------------------------------*/
/* Take the confirmation from user for the keys */

Confirm(msg, options, from, to)
char	*msg ;
char	*options ;
int	from ;
int	to ;
{
	int	err ;

	for( ; ; ) {
		err = GetOption(msg, options) ;

		switch(err) {
		case  ADDTRANS :
			return(ADDTRANS) ;
		case  NEXTTRANS :
			if(CurrTrans == LastTrans) {
#ifdef ENGLISH
				fomer("No More Transactions....") ;
#else
				fomer("Plus de transactions....") ;
#endif
				continue ;
			}
			CurrTrans = CurrTrans->NextTrans ;
			err = ShowTrans(CurrTrans) ;
			break ;
		case  PREVTRANS :
			if(CurrTrans == FirstTrans) {
#ifdef ENGLISH
				fomer("No More Transactions....") ;
#else
				fomer("Plus de transactions....") ;
#endif
				continue ;
			}
			CurrTrans = CurrTrans->PrevTrans ;
			err = ShowTrans(CurrTrans) ;
			break ;
		case  YES :
			return(YES) ;
		case  EDIT  :
			err = ChangeFields(from, to);
			break ;
		case  CANCEL :
#ifdef ENGLISH
			err = GetOption("Confirm the Cancel (Y/N)?", "YN") ;
#else
			err = GetOption("Confirmer l'annulation (O/N)?", "ON") ;
#endif
			if(err == YES) return(CANCEL) ;
			break ;
		}	/* switch err */

		if(err == PROFOM_ERR) return(err) ;
		if(err == DBH_ERR) return(err) ;
	}	/* for(; ; ) */
}	/* Confirm() */
/*----------------------------------------------------------------------*/
/* Changing fields. Accept fld to be changed and read that fld */

ChangeFields(from, to)
int	from,		/* From Fld Sno */
	to ;		/* To fld Sno */
{
	int	i;
	int	st_fld, end_fld ;

	st_fld = INV_START + (from - 1) * 100 ;
	end_fld = INV_START + (to - 1) * 100 ;
	/* Change PROFOM logical field attributes */
	for(i = st_fld ; i <= end_fld ; i += 100)
		fomca1(i,19,2); /* enabling Dup control */

	/* Set Dup Buffers */
	sr.nextfld = st_fld ;
	sr.endfld = end_fld ;
	fomud((char*)&s_sth);  /* Updating dup buffer */
	ret(err_chk(&sr));

#ifdef ENGLISH
	STRCPY(s_sth.s_mesg,"Enter RETURN to terminate Edit");
#else
	STRCPY(s_sth.s_mesg,"Appuyer sur RETURN pour terminer l'ajustement");
#endif
	ShowMesg() ;

	/* Get The Field to Be Modified */
	for( ; ; ) {
	    sr.nextfld = CHG_FLD ;
	    fomrf((char*)&s_sth);
	    ret(err_chk(&sr));

	    if(s_sth.s_field == 0) break ;

	    /* Validate  Field Number */
	    if( s_sth.s_field < from || s_sth.s_field > to) continue ;

	    for( ; ; ) {
		i = ReadFld() ;		/* Read Field */
		if(i == PROFOM_ERR || i == DBH_ERR) return(i) ;

		/* When Invoice date is changed make sure that due date is less
		   than that */
		if(s_sth.s_field == INVC_DT &&
				s_sth.s_due_dt < s_sth.s_invc_dt) {
			s_sth.s_field = DUE_DT ;
			continue ;
		}
		break ;
	    }
	}	/* for( ; ; ) */

	s_sth.s_field = HV_SHORT ;
	fomwf((char*)&s_sth);
	ret(err_chk(&sr));

	s_sth.s_mesg[0] = HV_CHAR;
	ShowMesg();

	return(NOERROR);
}	/* ChangeFields() */
/*-----------------------------------------------------------------------*/
/* Read the user selected field in change mode */

ReadFld()
{
	int	err ;

	if(s_sth.s_field == GROSS_PMNT || s_sth.s_field == DISC_TAKEN) 
		return ( ChangeTotal() ) ;

	/* Set PROFOM nextfld */
	sr.nextfld = TRANREF_FLD + (s_sth.s_field - 1) * 100 ;

	for( ; ; ) {
		fomrf((char*)&s_sth);
		ret(err_chk(&sr));

		if(sr.retcode == RET_VAL_CHK) {
			err = Validate() ;
			if(err == DBH_ERR) return(err) ;
			if(err == NOERROR) break;
			continue ;
		}
		if(sr.retcode != RET_NO_ERROR) continue;
		break ;
	}

	return(NOERROR) ;
}	/* ReadFld() */
/*-----------------------------------------------------------------------*/
/* When user select Gross Pmnt or Disc Taken Field, this function reads that
   fld to Net amt amount */

ChangeTotal()
{
	int	i ;

	/* break is not put, to fall thru */
	switch(s_sth.s_field) {
	case GROSS_PMNT:
		s_sth.s_gr_pmnt    = LV_DOUBLE ;
	default :
		s_sth.s_disc_taken = LV_DOUBLE ;
	}

	i = ReadFields((TRANREF_FLD+(s_sth.s_field-1)*100), NETAMT_FLD, 0) ;
	if(PROFOM_ERR == i || DBH_ERR == i) return(i) ;

	return(NOERROR) ;
}	/* ChangeTotal() */
/*-----------------------------------------------------------------------*/
/* Display the Current Transaction in the list */

ShowTrans(transptr)
Trans	*transptr ;
{
	STRCPY(s_sth.s_invc_no, transptr->tr_rec.in_invc_no) ;
	STRCPY(s_sth.s_tr_type, transptr->tr_rec.in_tr_type) ;

	s_sth.s_period  = transptr->tr_rec.in_period  ;
	s_sth.s_invc_dt = transptr->tr_rec.in_invc_dt ;
	s_sth.s_due_dt  = transptr->tr_rec.in_due_dt ;

	STRCPY(s_sth.s_desc, transptr->tr_rec.in_remarks) ;

	s_sth.s_gr_pmnt    = transptr->gr_pmnt ;
	s_sth.s_disc_taken = transptr->disc_taken ;
	s_sth.s_net_pmnt   = transptr->gr_pmnt - transptr->disc_taken ;

	if(transptr->infile == 1) {
		s_sth.s_gr_amt   = transptr->tr_rec.in_amount ;
		s_sth.s_disc_per = transptr->tr_rec.in_disc_per ;
		s_sth.s_disc_amt = transptr->tr_rec.in_disc_amt ;

		CpHBorDisc() ;
	}
	else {
		s_sth.s_gr_amt     = HV_DOUBLE ;
		s_sth.s_disc_per   = HV_DOUBLE  ;
		s_sth.s_disc_amt   = HV_DOUBLE ;

		s_sth.s_per_pr[0]  =  HV_CHAR ;
		s_sth.s_disc_pr[0] =  HV_CHAR ;
	}

	ret( WriteFields(TRANREF_FLD, DISCAMT_FLD) );

	return(NOERROR) ;
}	/* ShowTrans() */
/*------------------------------------------------------------*/
/* Total of all the transactions should be equal to user given chq amount */

MatchTotals()
{
	double	diff ;

	diff = s_sth.s_chq_amt - (s_sth.s_tot_pmnt - s_sth.s_tot_disc) ;

	if(diff < -(DELTA_AMT) || diff > DELTA_AMT) {
#ifdef ENGLISH
		DispError("Invalid Cheque....   Cheque Amount Discrepancy");
#else
		DispError("Cheque invalide.... Divergence entre les montants de cheque");
#endif
		return(ERROR) ;
	}

	return(NOERROR) ;
}	/* MatchTotals() */
/*------------------------------------------------------------*/
/* Read the Temporary invoice records and update files */

UpdateFiles()
{
	int	i, err ;
	int	mode ;

	/* If no transactions are entered, then nothing to update */
	if(FirstTrans == NULL) {
		roll_back(e_mesg);
		return(NOERROR) ;
	}

	err = PrintSubHdg() ;	/* Print Supplier name as a sub heading */
	if(err < 0) return(ShowError()) ;

	i = 0 ;
	for(CurrTrans = FirstTrans ; CurrTrans != NULL ;
					CurrTrans = CurrTrans->NextTrans) {
		if(CurrTrans->infile == 1) {
			/* Get the Invoice Record */
			err = GetInvoice(CurrTrans->tr_rec.in_supp_cd,
					CurrTrans->tr_rec.in_invc_no,
					CurrTrans->tr_rec.in_tr_type, UPDATE) ;
			if(err < 0) return(ShowError()) ;

			/* Not Partial or Manual Payment */
			if(in_rec.in_pmtcode[0] != PARTIAL)
				in_rec.in_pmtcode[0] = OPEN ;

			mode = UPDATE ;
		}
		else {
			scpy((char*)&in_rec, (char*)&CurrTrans->tr_rec,
				sizeof(Invoice));
			mode = ADD ;
		}

		/* Subtract the gross payment, disc taken from invoice. Because
		   for INVOICE and CRMEMO amounts will be -ve and for others +ve
		   in Invoice rec. Whereas here these are entered as +ve */
		
		in_rec.in_amount   -= CurrTrans->gr_pmnt ;
		in_rec.in_disc_amt -= CurrTrans->disc_taken ;
		in_rec.in_disc_per  = in_rec.in_disc_amt * 100 /
						in_rec.in_amount ;
		
		in_rec.in_amount = D_Roundoff(in_rec.in_amount); 
		in_rec.in_disc_amt = D_Roundoff(in_rec.in_disc_amt); 

		err = put_invc(&in_rec, mode, e_mesg) ;
		if(err < 0) return(ShowError()) ;

		CreatChqRecord() ;

		err = PrintPayment() ;
		if(err < 0) return(ShowError()) ;

		/* Add the Cheque Record */

		chq_rec.c_disc_taken = D_Roundoff(chq_rec.c_disc_taken); 
		chq_rec.c_gr_amt = D_Roundoff(chq_rec.c_gr_amt);    
	
		err = put_chq(&chq_rec, ADD, e_mesg) ;
		if(err < 0) return(ShowError()) ;

		/* Update The Supplier */
		/* Gross Payment & Discount Taken are stored as +ve for INVOICE,
		   because its amounts are stored as -ve. So subtracting from
		   balance physically increases it */

		supp_rec.s_balance -= CurrTrans->gr_pmnt ;
		if(supp_rec.s_type[0] == CONTRACT)
			supp_rec.s_ytd_disc -= CurrTrans->disc_taken ;

		/* Commit the records for every 25 records */

		i++ ;
		if(i % 25 == 0) {
			
			supp_rec.s_ytd_disc = D_Roundoff(supp_rec.s_ytd_disc); 
			supp_rec.s_balance = D_Roundoff(supp_rec.s_balance); 
			
			err = put_supplier(&supp_rec, UPDATE, e_mesg) ;
			if(err < 0) return(ShowError()) ;

			err = commit(e_mesg) ;
			if(err < 0) return(ShowError()) ;
			/* Commit() will release the lock on supplier record
			   also. So, lock the record agian */
			err = CheckSupp(supp_rec.s_supp_cd, UPDATE) ;
			if(err < 0) return(ShowError());
		}
	}
	supp_rec.s_ytd_disc = D_Roundoff(supp_rec.s_ytd_disc); 
	supp_rec.s_balance = D_Roundoff(supp_rec.s_balance); 

	err = put_supplier(&supp_rec, UPDATE, e_mesg) ;
	if(err < 0) return(ShowError()) ;

	err = commit(e_mesg) ;
	if(err < 0) return(ShowError()) ;

	err = PrintChqTotals() ;
	if(err < 0) return(ShowError()) ;

	FreeList() ;

	CancelledCheque = 1;
	return(NOERROR) ;
}	/* UpdateFiles() */
/*-----------------------------------------------------------*/
/* Create a cheque record */

CreatChqRecord()
{
	STRCPY(chq_rec.c_supp_cd, s_sth.s_supp_cd) ;
	chq_rec.c_funds    = s_sth.s_fund ;
	chq_rec.c_chq_no   = s_sth.s_chq_no ;
	STRCPY(chq_rec.c_accno,s_sth.s_accno);

	STRCPY(chq_rec.c_invc_no, CurrTrans->tr_rec.in_invc_no) ;
	STRCPY(chq_rec.c_tr_type, CurrTrans->tr_rec.in_tr_type) ;

	chq_rec.c_chq_type[0]      = REGULAR ;
	chq_rec.c_cancelled[0] = YES ;
	chq_rec.c_cp_chq_no     = 0 ;
	chq_rec.c_invc_dt      = CurrTrans->tr_rec.in_invc_dt ;
	chq_rec.c_due_dt       = CurrTrans->tr_rec.in_due_dt ;
	chq_rec.c_period       = CurrTrans->tr_rec.in_period ;
	chq_rec.c_disc_per     = CurrTrans->tr_rec.in_disc_per ;
	chq_rec.c_in_amt       = CurrTrans->tr_rec.in_amount ;

	/* Reverse the Cheque amount */
	chq_rec.c_disc_taken   = CurrTrans->disc_taken * -1 ;
	chq_rec.c_gr_amt       = CurrTrans->gr_pmnt * -1 ;

	return(NOERROR) ;
}	/* CreatChqRecord() */
/*-----------------------------------------------------------*/
/* Show the Updation error message */
static	int
ShowError()
{
#ifdef ENGLISH
	DispError("ERROR in Cheque Cancellation Process"); 
#else
	DispError("ERREUR dans le processus d'annulation de cheque");
#endif
	DispError(e_mesg);
	roll_back(e_mesg) ;	/* Unlock the locked Records */

	FreeList() ;		/* Free Linked List */

	return(DBH_ERR);
}	/* ShowError() */
/*------------------------------------------------------------*/
/* Read the PROFOM Screen for a given Range of fields */

ReadFields(st_fld, end_fld, esc_f)
int	st_fld ;
int	end_fld ;
int	esc_f ;		/* Is ESC_F active? */
{
	int	err ;

	sr.nextfld = st_fld ;

	for( ; ;){
		sr.endfld  = end_fld ;

		fomrd( (char*)&s_sth );
		ret(err_chk(&sr));
		if(sr.retcode == RET_VAL_CHK){
			err = Validate() ;
			if(DBH_ERR == err || PROFOM_ERR == err) return(err);
			sr.nextfld = sr.curfld ;
			continue;
		}
		if(sr.retcode == RET_USER_ESC){
			if(esc_f &&
			    (sr.escchar[0] == 'f' || sr.escchar[0] == 'F') )
				return(RET_USER_ESC) ;
			if(sr.escchar[0] == 'h' || sr.escchar[0] == 'H'){
				err = WindowHelp() ;
				if(DBH_ERR == err || PROFOM_ERR == err)
					return(err) ;
			}
			sr.nextfld = sr.curfld ;
			continue;
		}
		/* else RET_NO_ERROR */
		break;
	}

	return(NOERROR) ;
}	/* ReadFields() */
/*----------------------------------------------------------------*/
/* Validation function() for Data fields when PROFOM returns RET_VAL_CHK */

Validate()
{
	int	err ;
	int	curfld, endfld ;

	switch(sr.curfld){
	case	FUND_FLD	:	/* Fund: */
		err = CheckFund(s_sth.s_fund) ;
		if(DBH_ERR == err) return(err) ;
		if(ERROR == err) {
			s_sth.s_fund = LV_SHORT ;
			return(ERROR) ;
		}
		fomer(ctl_rec.desc) ;
		/* Move Bank1 Account as a default account */
		curfld = sr.curfld ;
		endfld = sr.endfld ;

		fomca1(ACCT_FLD, 19, 2) ;	/* Enable Dup Buffers */
		sr.nextfld = ACCT_FLD ;
		sr.endfld  = ACCT_FLD ;
		STRCPY(s_sth.s_accno, ctl_rec.bank1_acnt) ;
		fomud((char*)&s_sth) ;
		ret(err_chk(&sr)) ;
		s_sth.s_accno[0] = LV_CHAR ;
		break ;
	case	ACCT_FLD	:	/* Bank Acct#: */
		if(acnt_chk(s_sth.s_accno) == ERROR) {
#ifdef ENGLISH
			fomer("Invalid Account Number");
#else
			fomer("Numero de compte invalide");
#endif
			s_sth.s_accno[0] = LV_CHAR ;
			return(ERROR) ;
		}
		/* Account# has to be One of the 2 Bank Accounts */
		if(strcmp(s_sth.s_accno,ctl_rec.bank1_acnt) &&
				strcmp(s_sth.s_accno,ctl_rec.bank2_acnt) ) {
#ifdef ENGLISH
			sprintf(e_mesg,
				"Valid Account Numbers.. BANK1: %s  BANK2: %s",
				ctl_rec.bank1_acnt, ctl_rec.bank2_acnt );
#else
			sprintf(e_mesg,
				"Numeros de comptes valables.. BANQUE1: %s  BANQUE2: %s",
				ctl_rec.bank1_acnt, ctl_rec.bank2_acnt );
#endif
			fomer(e_mesg) ;
			s_sth.s_accno[0] = LV_CHAR ;
			return(ERROR) ;
		}
		err = CheckGlAcnt(s_sth.s_accno) ;
		if(DBH_ERR == err) return(err) ;
		if(ERROR == err) {
			s_sth.s_accno[0] = LV_CHAR ;
			return(ERROR) ;
		}
		break ;
	case	CHQNO_FLD	:	/* Cheque#: */
		if(s_sth.s_chq_no <= 0) {
#ifdef ENGLISH
			fomer("Can't Be Zero");
#else
			fomer("Ne peut pas etre zero");
#endif
			s_sth.s_chq_no = LV_LONG ;
			return(ERROR) ;
		}
		break ;
	case	SUPPCD_FLD	:		 /* Supplier Cd: */
		Right_Justify_Numeric(s_sth.s_supp_cd,
					sizeof(s_sth.s_supp_cd)-1);
		if (WriteFields(SUPPCD_FLD, SUPPCD_FLD) < 0) return (ERROR) ;
		err = CheckSupp(s_sth.s_supp_cd,UPDATE) ;
		if(DBH_ERR == err) return(err) ;
		if(ERROR == err) {
			s_sth.s_supp_cd[0] = LV_CHAR ;
			return(ERROR) ;
		}
		err = DisplayAddress() ;
		if(NOERROR != err) return(err) ;
		break ;
	case	TRANREF_FLD	:	/* Tran Ref#: */
		if(s_sth.s_invc_no[0] == '\0') {
#ifdef ENGLISH
			fomer("Invalid Ref#");
#else
			fomer("# de reference invalide");
#endif
			s_sth.s_invc_no[0] = LV_CHAR ;
			return(ERROR) ;
		}
		break ;
	case	TRTYPE_FLD	:	/* Tran Type: */
		if(CheckTransType(s_sth.s_tr_type) == ERROR) {
			s_sth.s_tr_type[0] = LV_CHAR ;
			return(ERROR) ;
		}
		break ;
	case	INVCDT_FLD	:	/* Trans Date */
		if(s_sth.s_invc_dt > s_sth.s_rundate) {
#ifdef ENGLISH
			fomer("Can't Be Future Date");
#else
			fomer("Ne peut pas etre une date ulterieure");
#endif
			s_sth.s_invc_dt = LV_LONG ;
			return(ERROR) ;
		}
		break ;
	case	DUEDT_FLD	:	/* Due Date */
		if(s_sth.s_due_dt < s_sth.s_invc_dt) {
#ifdef ENGLISH
			fomer("Due Date Can't Be Before Trans Date");
#else
			fomer("Date d'echeance ne peut pas etre avant la date de transaction");
#endif
			s_sth.s_due_dt = LV_LONG ;
			return(ERROR) ;
		}
		break ;
	case	PERIOD_FLD	:	/* Period */
		if(s_sth.s_period < 1 || s_sth.s_period > pa_rec.pa_no_periods){
#ifdef ENGLISH
			fomer("Invalid Period");
#else
			fomer("Periode invalide");
#endif
			s_sth.s_period = LV_SHORT ;
			return(ERROR);
		}
		break ;
	case	GRPMNT_FLD	:	/* Gross Payment */
		/* Should Not be Zero */
		if(s_sth.s_gr_pmnt > -(DELTA_AMT) &&
				s_sth.s_gr_pmnt < DELTA_AMT) {
#ifdef ENGLISH
			fomer("Can't Be Zero");
#else
			fomer("Ne peut pas etre zero");
#endif
			s_sth.s_gr_pmnt = LV_DOUBLE ;
			return(ERROR) ;
		}
		break ;
	case	DISCTAKEN_FLD	:	/* Disc Taken: */
		/* For contract Suppliers Discount taken should be zero */
		if(supp_rec.s_type[0] == CONTRACT &&
				(s_sth.s_disc_taken < -(DELTA_AMT) ||
				s_sth.s_disc_taken > DELTA_AMT)) {
#ifdef ENGLISH
			fomer("Discount Taken Should be Zero for Contract Suppliers");
#else
			fomer("Escompte prise devrait etre zero pour le fournisseur contractuel");
#endif
			s_sth.s_disc_taken = LV_DOUBLE ;
			return(ERROR) ;
		}
		s_sth.s_net_pmnt = s_sth.s_gr_pmnt - s_sth.s_disc_taken ;
		break ;
	default :
#ifdef ENGLISH
		sprintf(e_mesg,"No Validity Check For Field#  %d",sr.curfld);
#else
		sprintf(e_mesg,"Pas de controle de validite pour le Champ#  %d",sr.curfld);
#endif
		fomen(e_mesg);
		get();
		return(ERROR) ;
	}	/* Switch sr.curfld */

	return(NOERROR) ;
}	/* Validate() */
/*----------------------------------------------------------------*/
/* Show Help Windows, if applicable, when user gives ESC-H */

WindowHelp()
{
	int	err ;

	switch(sr.curfld){
	case	SUPPCD_FLD	:	/* Supplier Cd: */
		err = supp_hlp(s_sth.s_supp_cd, 7, 13 );
		if(err == DBH_ERR) return(err) ;
		if(err >=0 ) redraw();
		if(err < 1) return(ERROR) ;

		/* Lock the Supplier */
		err = CheckSupp(s_sth.s_supp_cd,UPDATE) ;
		if(DBH_ERR == err) return(err) ;
		if(ERROR == err) {
			s_sth.s_supp_cd[0] = LV_CHAR ;
			return(ERROR) ;
		}
		err = DisplayAddress() ;
		if(NOERROR != err) return(err) ;
		break ;
	default :
#ifdef ENGLISH
		fomer("No Help Window For This Field");
#else
		fomer("Pas de fenetre d'assistance pour ce champ");
#endif
		return(ERROR) ;
	}	/* Switch sr.curfld */

	return(NOERROR) ;
}	/* WindowHelp() */
/*-------------------------------------------------------------------------*/
/* Display the supplier Name and Address */

DisplayAddress()
{
	int	curfld, endfld ;

	curfld = sr.curfld ;
	endfld = sr.endfld ;

	STRCPY(s_sth.s_name, supp_rec.s_name) ;
	STRCPY(s_sth.s_add1, supp_rec.s_add1) ;
	STRCPY(s_sth.s_add2, supp_rec.s_add2) ;
	STRCPY(s_sth.s_add3, supp_rec.s_add3) ;
	STRCPY(s_sth.s_pc  , supp_rec.s_pc  ) ;

	ret( WriteFields( SUPPNAME_FLD, POSTALCD_FLD) ) ;

	sr.curfld = curfld ;
	sr.endfld = endfld ;
	
	return(NOERROR) ;
}	/* DisplayAddress() */
/*----------------------------------------------------------------*/
/* Check given Transaction type */

CheckTransType(tr_type)
char	*tr_type ;
{
	if( strcmp(tr_type,INVOICE) && strcmp(tr_type,RETURN) &&
			strcmp(tr_type,CRMEMO) && strcmp(tr_type,DBMEMO) ) {
#ifdef ENGLISH
		sprintf(e_mesg,
"Valid Types are %s(Invoice), %s(Return), %s(Credit Memo), %s(Debit Memo)",
INVOICE, RETURN, CRMEMO, DBMEMO) ;
#else
		sprintf(e_mesg,
"Genre valables sont %s(Facture), %s(Renvoi), %s(Note de credit), %s(Note de debit)",
INVOICE, RETURN, CRMEMO, DBMEMO) ;
#endif
		fomer(e_mesg) ;
		return(ERROR) ;
	}

	return(NOERROR) ;
}	/* CheckTransType() */
/*-------------------------------------------------------------------------*/
/* Move high values to screen data fields and write on screen */

ClearScreen()
{
	InitChqKey() ;
	InitInvcKey(HV_CHAR) ;
	InitDataFields(HV_CHAR, HV_SHORT, HV_LONG) ;
	InitPmntFields(HV_DOUBLE) ;

	s_sth.s_tot_pr[0]  =  HV_CHAR ;

	s_sth.s_no_trans = HV_SHORT ;
	s_sth.s_tot_pmnt = HV_DOUBLE ;
	s_sth.s_tot_disc = HV_DOUBLE ;

	ret( WriteFields(SUPPNAME_FLD, END_FLD-200) );

	return(NOERROR);
}	/* ClearScreen() */
/*-------------------------------------------------------------------------*/
/* Move LVs to Cheque key fields */

InitChqKey()
{
	s_sth.s_fund       = LV_SHORT ;
	s_sth.s_accno[0]   = LV_CHAR ;
	s_sth.s_chq_no     = LV_LONG ;
	s_sth.s_chq_amt    = LV_DOUBLE ;
	s_sth.s_supp_cd[0] = LV_CHAR ;

	s_sth.s_name[0] = HV_CHAR ;
	s_sth.s_add1[0] = HV_CHAR ;
	s_sth.s_add2[0] = HV_CHAR ;
	s_sth.s_add3[0] = HV_CHAR ;
	s_sth.s_pc[0]   = HV_CHAR ;

	return(NOERROR) ;
}	/* InitChqKey() */
/*-------------------------------------------------------------------------*/
/* MOve Low/High values to Invoice Key fields */

InitInvcKey( t_char )
char	t_char ;
{
	s_sth.s_invc_no[0] = t_char ;
	s_sth.s_tr_type[0] = t_char ;

	return(NOERROR) ;
}	/* InitInvcKey() */
/*-------------------------------------------------------------------------*/
/* MOve Low/High values to Invoice data fields */

InitDataFields(t_char, t_short, t_long)
char	t_char ;
short	t_short ;
long	t_long ;
{
	s_sth.s_invc_dt    = t_long ;
	s_sth.s_due_dt     = t_long ;
	s_sth.s_period     = t_short ;
	s_sth.s_desc[0]    = t_char ;

	if(t_short == HV_SHORT) {
		s_sth.s_gr_amt     = HV_DOUBLE ;
		s_sth.s_disc_per   = HV_DOUBLE  ;
		s_sth.s_disc_amt   = HV_DOUBLE ;

		s_sth.s_per_pr[0]  =  HV_CHAR ;
		s_sth.s_disc_pr[0] =  HV_CHAR ;
	}

	return(NOERROR) ;
}	/* InitDataFields() */
/*-------------------------------------------------------------------------*/
/* MOve Low/High values to Invoice data fields */

InitPmntFields(t_double)
double	t_double ;
{
	s_sth.s_gr_pmnt    = t_double ;
	s_sth.s_disc_taken = t_double ;
	s_sth.s_net_pmnt   = t_double ;

	return(NOERROR) ;
}	/* InitPmntFields() */
/*-----------------------------------------------------------------------*/
/* Copy Hold Back or Discount */

CpHBorDisc()
{
	/* If the supplier is ordinary type supplier show as "Discount" else
	   show as "Hold Back". */

	if(supp_rec.s_type[0] == ORDINARY) {
#ifdef ENGLISH
		STRCPY(s_sth.s_per_pr,  "Discount %");
		STRCPY(s_sth.s_disc_pr, "Disc Amnt:");
#else
		STRCPY(s_sth.s_per_pr,  "% Escompte");
		STRCPY(s_sth.s_disc_pr, "Mont esc:");
#endif
	}
	else {
#ifdef ENGLISH
		STRCPY(s_sth.s_per_pr,  "Hold Back%");
		STRCPY(s_sth.s_disc_pr, "HB Amount:");
#else
		STRCPY(s_sth.s_per_pr,  "% du PR");
		STRCPY(s_sth.s_disc_pr, "Mont PR:");
#endif
	}

	return(NOERROR) ;
}	/* CpHBorDisc() */
/*------------------------------------------------------------------------*/
/* Write fields on Screen for a given Range */

WriteFields(st_fld, end_fld)
int	st_fld ;
int	end_fld ;
{
	sr.nextfld = st_fld ;
	sr.endfld  = end_fld ;

	fomwr( (char*)&s_sth ) ;
	ret(err_chk(&sr));

	return(NOERROR) ;
}	/* WriteFields() */
/*-----------------------------------------------------------------------*/
/* Display message and get the option */

GetOption(msg,options)
char	*msg ;
char	*options ;
{
	int	i, j ;

	STRCPY(s_sth.s_mesg, msg);
	ShowMesg() ;

	sr.nextfld = END_FLD ;
	for( ; ; ) {
		fomrf( (char*)&s_sth ) ;
		ret(err_chk(&sr)) ;

		j = strlen(options) ;
		for( i = 0 ; i < j ; i++)
			if(s_sth.s_resp[0] == options[i]) break ;
		if(i != j) break ;	/* Valid Option Selected */
#ifdef ENGLISH
		fomer("Invalid Option..");
#else
		fomer("Option invalide..");
#endif
	}
	s_sth.s_mesg[0] = HV_CHAR;
	s_sth.s_resp[0] = HV_CHAR;

	ret( WriteFields((END_FLD - 100), END_FLD) );

	return((int)(options[i])) ;
}	/* GetOption() */
/*-------------------------------------------------------------------------*/
/* Copy the given message to SCR message line, display it and seek
   user response */

DispError(s)    /* show ERROR and wait */
char	*s;
{
	STRCPY(s_sth.s_mesg, s);
	ShowMesg();
#ifdef ENGLISH
	fomen("Press any key to continue");
#else
	fomen("Appuyer sur une touche pour continuer");
#endif
	get();
	s_sth.s_mesg[0] = HV_CHAR;
	ShowMesg();

	return(NOERROR);
}	/* DispError() */
/*-------------------------------------------------------------------------*/
/* Write the Message Field */

ShowMesg()  /* shows or clears message field */
{
	sr.nextfld = END_FLD - 100;
	fomwf( (char*)&s_sth ) ;

	return(NOERROR) ;
}	/* ShowMesg() */
/*----------------------------------------------------------------*/
/* Check the given Suppliers availability in file */

CheckSupp(supp_cd,mode)
char	*supp_cd ;
int	mode ;
{
	int	err ;
	Right_Justify_Numeric(supp_rec.s_supp_cd,
				(sizeof(supp_rec.s_supp_cd)-1));
	STRCPY(supp_rec.s_supp_cd, supp_cd) ;
	err = get_supplier(&supp_rec, mode, 0, e_mesg) ;
	if(ERROR == err) return(DBH_ERR) ;
	if(err < 0) {
		fomer(e_mesg) ;
		return(ERROR) ;
	}

	return(NOERROR) ;
}	/* CheckSupp() */
/*----------------------------------------------------------------*/
/* Check the given funds availability in file */

CheckFund(fund)
short	fund ;
{
	int	err ;

	ctl_rec.fund = fund ;

	err = get_ctl(&ctl_rec, BROWSE, 0, e_mesg) ;
	if(ERROR == err) return(DBH_ERR);
	if(err < 0) {
		fomer(e_mesg) ;
		return(ERROR) ;
	}
	return(NOERROR) ;
}	/* CheckFund() */
/*----------------------------------------------------------------*/
/* Check Whether Account# is existing */

CheckGlAcnt(accno)
char	*accno ;
{
	int	err ;

	gl_rec.funds = s_sth.s_fund ;
	STRCPY(gl_rec.accno, accno) ;
	gl_rec.reccod = 99 ;

	err = get_gl(&gl_rec, BROWSE, 0, e_mesg) ;
	if(ERROR == err) return(DBH_ERR);
	if(err < 0) {
		fomer(e_mesg) ;
		return(ERROR) ;
	}
	return(NOERROR) ;
}	/* CheckGlAcnt() */
/*-----------------------------------------------------------------------*/ 
/* Copy the key fields to Invoice record and get the record from data base */

GetInvoice(supp_cd, invc_no, tr_type, md)
char	*supp_cd ;
char	*invc_no ;
char	*tr_type ;	/* Type IN, CM, CM & RT */
int	md;		/* BROWSE or UPDATE */
{
	STRCPY(in_rec.in_supp_cd, supp_cd) ;
	STRCPY(in_rec.in_invc_no, invc_no) ;
	STRCPY(in_rec.in_tr_type, tr_type) ;

	return(get_invc(&in_rec, md, 0, e_mesg));
}	/* GetInvoice() */

/*------------------------------------------------------------*/
/*
*	Allocate next node in linked list to add next transaction.
*/

MakeFreshTrans()
{
	Trans	*tempptr ;

	tempptr= (Trans *)malloc((unsigned)sizeof(Trans)) ;

	if( tempptr == NULL ){
#ifdef ENGLISH
		DispError("MEMORY ALLOCATION ERROR...");
#else
		DispError("ERREUR D'ALLOCATION A LA MEMOIRE...");
#endif
		return(ERROR);
	}
	tempptr->NextTrans = NULL ;

	if( LastTrans == NULL) {	/* No node is allocated Yet */
		tempptr->PrevTrans = NULL ;
		FirstTrans = tempptr ;
	}
	else {				/* Not a first node in list */
		LastTrans->NextTrans = tempptr ;
		tempptr->PrevTrans = LastTrans ;
	}

	CurrTrans = tempptr ;
	LastTrans = tempptr ;

	return(NOERROR);
}	/* MakeFreshTrans() */
/*-----------------------------------------------------------------------*/
/* Free the memory Allocated for Linked List */

FreeList()
{
	for( ; FirstTrans != NULL ; ) {
		CurrTrans = FirstTrans ;
		FirstTrans = CurrTrans->NextTrans ;
		free((char*)CurrTrans) ;
	}

	FirstTrans = NULL ;
	CurrTrans  = NULL ;
	LastTrans  = NULL ;

	return(NOERROR) ;
}	/* FreeList() */
/*-------------------- E n d   O f   P r o g r a m ---------------------*/
