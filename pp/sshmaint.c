/*-----------------------------------------------------------------------
Source Name: sshmaint.c
System     : Scheduling.
Created  On: 17th July 91.
Created  By: J. Prescott.

DESCRIPTION:
	Program to maintain students study halls for day/semester.
	Validate options are Add, Change, Delete, Inquire, Next, Prev.

MODIFICATIONS:        

Programmer     YY/MM/DD       Description of modification
------------------------------------------------------------------------*/
#define	MAIN		/* Main program. This is to declare Switches */
#define MAINFL		HALLASGN		/* main file used */

#define	SYSTEM		"Scheduling"	/* Sub System Name */
#define	MOD_DATE	"17-JULY-91"		/* Progran Last Modified */

#include <stdio.h>
#include <cfomstrc.h>
#include <sb_defs.h>
#include <sb_recs.h>

/* User Interface define constants */
#ifdef ENGLISH
#define ADDREC		'A'
#define CHANGE		'C'
#define DELETE		'D'
#define INQUIRE		'I'
#define EXITOPT		'E'
#define	NEXT		'N'
#define	PREV		'P'

#define	YES		'Y'
#define NO		'N'
#define	LINEEDIT	'L'
#define SCREENEDIT	'S'
#define	CANCEL		'C'

#else
#define ADDREC		'R'
#define CHANGE		'C'
#define DELETE		'E'
#define INQUIRE		'I'
#define EXITOPT		'F'
#define	NEXT		'S'
#define	PREV		'P'

#define	YES		'O'
#define NO		'N'
#define	LINEEDIT	'L'
#define SCREENEDIT	'S'
#define	CANCEL		'A'

#endif

/* PROFOM Releted declarations */

#define	SCR_NAME	"sshmaint"	/* PROFOM screen Name */

#define	PAGESIZE	40		/* No of Items */
#define MAX_DAYS	10

/* PROFOM Screen STH file */

/* Field PROFOM numbers */

#define	HDR_ST_FLD	1000	/* Header Start Field */
#define	HDR_END_FLD	1500	/* Header End Field */
#define	ITEM_ST_FLD	2600	/* Item 1 Start Field */
#define	END_FLD		6700	/* Last Field of the screen */
#define	STEP		100	/* NO of fields diff. between 2 items */

/* HDR Fields */
#define	FN_FLD		500	/* Fn: */
#define	KEY_START	600	/* Student ID */
#define	KEY_END		700	/* Section */
#define	CHG_FLD		800	/* Field: */
#define STUD_FLD	1000	/* Student name */

/* sshmaint.sth - header for C structure generated by PROFOM EDITOR */

typedef	struct	{	/* Start Fld 2600, Endfld 6500 and Step 100 */

	char	s_assign[2];	/* 2600 STRING X */
}	S_item ;

typedef struct	{

	char	s_pgname[11];	/* 100 STRING X(10) */
	long	s_rundate;	/* 300 DATE YYYYFMMFDD */
	char	s_school[41];	/* 400 STRING X(40) */
	char	s_fn[2];	/* 500 STRING X */
	char	s_stud_id[13];	/* 600 STRING X(12) */
	short	s_section;	/* 700 NUMERIC 99 */
	short	s_field;	/* 800 NUMERIC 99 */

	char	s_stud_nm[31];	/* 1000 STRING X(30) */
	char	s_grlevel[3];	/* 1100 STRING XX */
	char	s_room[6];	/* 1200 STRING XXXXX */
	char	s_teacher[11];	/* 1300 STRING XXXXXXXXXX */
	char	s_tname[26];	/* 1400 STRING X(25) */
	char	s_dummy[2]; 	/* 1500 STRING X */
	short	s_days[MAX_DAYS];	/* 1600 - 2500 NUMERIC 99 */
	S_item	s_items[PAGESIZE] ;	/* Start Fld 2600, End Fld 6500  */

	char	s_mesg[78];	/* 6600 STRING X(76) */
	char	s_resp[2];	/* 6700 STRING X */
} s_struct;

static	s_struct  s_sth,image;	/* PROFOM Screen Structure */
static	struct  stat_rec  sr;		/* PROFOM status rec */

static	char 	e_mesg[100];  		/* dbh will return err msg in this */

static	Schl_rec	schl_rec;
static	Shift		shift;
static	Student		student;
static	Hallhdr		hallhdr;
static	Halldtl		halldtl;
static	Teacher		teacher;
static	Hallasgn	hallasgn, pre_hallasgn;

static	Aud_rec		aud_rec;

int	KeyAndHdrValidation(), ItemsValidation() ;
int	HdrAndKeyWindowHelp();
int	Argc;
char	**Argv;

int TOTAL_SEM;
int TOTAL_DAYS;
char NOTTAKEN[5];

void	free() ;
char	*malloc() ;
long	power();

main(argc,argv)
int argc;
char *argv[];
{
	int 	retval;

	/* These two are passed to execute() when it is called */
	Argc = argc;
	Argv = argv;

	retval = Initialize(argc,argv);	/* Initialization routine */

	if (retval == NOERROR) retval = Process();

	CloseRtn();			/* return to menu */
	if (retval != NOERROR) exit(-1);
	exit(0);
}

/*-------------------------------------------------------------------*/
/* Initialize PROFOM */

Initialize(argc, argv)
int	argc ;
char	*argv[] ;
{
	int	err ;

	/*
	*	Initialize DBH Environment
	*/
	strncpy(SYS_NAME,SYSTEM,50);	/* Sub system name */
	strncpy(CHNG_DATE,MOD_DATE,10);	/* Modification Date */

	proc_switch(argc, argv, MAINFL) ; 	/* Process Switches */

	/*
	*	Initialize PROFOM & Screen
	*/
	strcpy(sr.termnm,terminal);	/* Copy Terminal Name */
	fomin(&sr);
	ret(err_chk(&sr)) ;		/* Check for PROFOM Error */
	fomcf(1,1);			/* Enable Snap screen option */

	strcpy(schl_rec.schl_cd, schl_no) ;
	err = get_school(&schl_rec, BROWSE, 0, e_mesg) ;
	if(err == ERROR) {
		fomen(e_mesg);
		get() ;
		return(ERROR);
	}
	if(err == UNDEF) {
		fomen(NOSCHOOL);
		get();
		return(ERROR);
	} 

	err = InitScreen() ;		/* Initialize Screen */
	if(NOERROR != err) return(err) ;

	return(NOERROR) ;
}	/* Initialize() */

/*--------------------------------------------------------------------------*/
/* Close nessary files and environment before exiting program               */

CloseRtn() 
{
	/* Set terminal back to normal mode from PROFOM */
	fomcs();
	fomrt();

	close_dbh();	/* Close files */

	return(NOERROR);
}	/* CloseRtn() */
/*----------------------------------------------------------------*/
/* Initialize screen before going to process options */

InitScreen()
{
	int	err ;

	/* move screen name to Profom status structure */
	strcpy(sr.scrnam,NFM_PATH);
	strcat(sr.scrnam,SCR_NAME) ;

	strcpy(s_sth.s_pgname,PROG_NAME);

	strcpy( s_sth.s_school, schl_rec.schl_name ) ; 
	CenterSchool(s_sth.s_school);

	s_sth.s_rundate = get_date();	/* get Today's Date in YYYYMMDD format*/
	s_sth.s_field = HV_SHORT ;
	s_sth.s_mesg[0] = HV_CHAR ;
	s_sth.s_resp[0] = HV_CHAR ;

	/* Initialize Key Fields. So that, if user selectes 'N' option
	   immediately after invoking program, then he gets the first
	   record in the file */

	s_sth.s_stud_id[0] = '\0';
	s_sth.s_section = 0 ;

	/* Move High Values to data fields and Display the screen */
	err = ClearScreen() ;
	if(NOERROR != err) return(err) ;

	return(NOERROR) ;
}	/* InitScreen() */

/*-------------------------------------------------------------------*/
/* Get Option from user and call corresponding function */

Process()
{
	int err;

	for( ; ; ){

		/* Get the Fn: option from the user */
		if((err = ReadFunction()) != NOERROR) return(err) ;

		err = ProcFunction() ;	/* Process Function */

		if(QUIT == err)		return(NOERROR) ;    /* Exit */
		if(NOACCESS == err)	fomen(e_mesg);	     /* security */
		if(PROFOM_ERR == err)	return(PROFOM_ERR);  /* PROFOM ERROR */
		if(DBH_ERR == err) {
			DispError((char *)&s_sth,e_mesg);
#ifdef ENGLISH
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"System Error... Iserror:",
				iserror, dberror, errno);
#else
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"Erreur du systeme... Iserror:",
				iserror, dberror, errno);
#endif
			DispError((char *)&s_sth,e_mesg);
			return(DBH_ERR); /* DBH ERROR */
		}
	}      /*   end of the for( ; ; )       */
}	/* Process() */
/*----------------------------------------------------------------*/
/* Display the Function (Fn:) options and get the option from the user */

ReadFunction()
{
	/* Display Fn: options */
#ifdef ENGLISH
	fomer("A(dd), C(hange), I(nquire), N(ext), P(rev), E(xit)");
#else
	fomer("R(ajouter), C(hanger), I(nterroger), S(uivant), P(recedent), F(in)");
#endif
	/* Read Fn: field to get the option */
	sr.nextfld = FN_FLD ;
	fomrf( (char *)&s_sth );
	ret(err_chk(&sr));	/* Check for PROFOM error */

	return(NOERROR) ;
}	/* ReadFunction() */
/*----------------------------------------------------------------*/
/* Process the user selected Fn: option */

ProcFunction()
{
	int retval;

	switch (s_sth.s_fn[0]) {
	case ADDREC  :			/* ADD */
		CHKACC(retval,ADD,e_mesg);
		return( Add() ) ;
	case CHANGE  :			/* CHANGE */
		CHKACC(retval,UPDATE,e_mesg);
		return( Change() ) ;
	case DELETE  :			/* CHANGE */
		CHKACC(retval,UPDATE,e_mesg);
		return( Delete() ) ;
	case INQUIRE  :			/* Inquire */
		CHKACC(retval,BROWSE,e_mesg);
		return( Inquire() ) ;
	case NEXT  :			/* Next */
		CHKACC(retval,BROWSE,e_mesg);
		return( Next(FORWARD) ) ;
	case PREV  :			/* Previous */
		CHKACC(retval,BROWSE,e_mesg);
		return( Next(BACKWARD) ) ;
	case EXITOPT  :			/* Exit */
		return( QUIT ) ;
	}  /*   end of the switch statement */

	return(retval);
}	/* ProcFunction() */
/*----------------------------------------------------------------------*/
/* Adding.  Get the unique Key, accept details and update the files */
Add()
{
	int	err ;

	err = ReadKey();
	if(err != NOERROR) return(err) ;

	/* Clear The Screen */
	err = ClearScreen();
	if(err != NOERROR) return(err) ;

	if((err = ShowScrHdr(ADD)) < 0) return(err);

	err = GetDetails() ;
	if(PROFOM_ERR == err || DBH_ERR == err) return(err) ;
	if(err < 0 || CANCEL == err) {
		roll_back(e_mesg) ;	/* Unlock the locked Records */
		return(ClearScreen()) ;	/* Clear the Screen */
	}

	return(NOERROR);
}	/* Add() */
/*-----------------------------------------------------------------------*/
/* Change. Students Study halls and update the files if a day/semester   */
/* is changed to NO delete record.			  		 */
/*-----------------------------------------------------------------------*/
Change()
{
	int	err ;

	for( ; ; ) {
		err = SelectRecord() ;
		if(NOERROR != err) break; ;

		for( ; ; ) {
			err = ConfirmItems() ;
			if(err != YES) {
				roll_back(e_mesg);
				break;
			}

			err = WriteRecords(UPDATE) ;
			if(err==NOERROR) break;
			if(err==LOCKED) {
				roll_back(e_mesg) ;
				continue;
			}
			if (err < 0) {
				roll_back(e_mesg);
				return(err) ;
			}
		}
	}

	return(NOERROR) ;
}	/* Change() */
/*-----------------------------------------------------------------------*/
/* Delete. Student Study Hall Records.  */
/*-----------------------------------------------------------------------*/
Delete()
{
	int	err ;

	for( ; ; ) {
		err = SelectRecord() ;
		if(NOERROR != err) break; ;

		for( ; ; ) {
			err = ConfirmItems() ;
			if(err != YES) {
				roll_back(e_mesg);
				break;
			}

			err = WriteRecords(P_DEL) ;
			if(err==NOERROR) break;
			if(err==LOCKED) {
				roll_back(e_mesg) ;
				continue;
			}
			if (err < 0) {
				roll_back(e_mesg);
				return(err) ;
			}
		}
	}

	return(NOERROR) ;
}	/* Delete() */
/*-----------------------------------------------------------------------*/
/* Show Student Student halls base on users input */
Inquire()
{
	int	err ;

	err = SelectRecord() ;
	if(NOERROR != err) return(err) ;

	return(NOERROR) ;
}	/* Inquire() */
/*----------------------------------------------------------*/
/* Show the next or previous Students Study halls */

Next(direction)
int	direction ;
{
	int err;

	/* Contrary to most Next/Previous programs a flg_reset() must */
	/* always be done here because to show the assignment information */
	/* it must also read this file so the record pointer must be reset */

	strcpy(hallasgn.hall_sid,student.s_seqno);
	hallasgn.hall_sect = s_sth.s_section ;
	if (direction == FORWARD) {
		hallasgn.hall_sect++;
		hallasgn.hall_asgn_day = 0;
	}
	else {
		hallasgn.hall_sect--;
		hallasgn.hall_asgn_day = 99;
	}
	flg_reset(HALLASGN);

	err = get_n_hallasgn(&hallasgn, BROWSE, 0, direction, e_mesg);
#ifndef ORACLE
	seq_over(HALLASGN);
#endif
	if(ERROR == err)return(DBH_ERR) ;
	if(EFL == err) {
		fomen(NOMORE);
		get();
		flg_reset(HALLASGN);
		return(NOERROR) ;
	}

	if((err = GetHdrData(BROWSE))<0) return(err);;

	err = ShowScrHdr(BROWSE);
	if(err == NOERROR) {
		err = ShowAsgnInfo();
	}
	return( err ) ;
}	/* Next() */
/*------------------------------------------------------------*/
/* Read the Header Information to display on the screen       */
/*------------------------------------------------------------*/
GetHdrData(mode)
{
	int	retval;

	if(mode != ADD) {
		/* get student record for name */
		strcpy(student.s_seqno,hallasgn.hall_sid);
		retval = get_student(&student,BROWSE,0,e_mesg);
		if(retval < 0) {
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}
	}

	/* get student hall header record */
	if(mode == ADD) {
		hallhdr.hh_sect = s_sth.s_section;
	}
	else {
		hallhdr.hh_sect = hallasgn.hall_sect;
	}
	retval = get_hallhdr(&hallhdr,BROWSE,0,e_mesg);
	if(retval < 0) {
		DispError((char *)&s_sth,e_mesg);
		return(retval);
	}

	/* get shift record */
	shift.shft_no = hallhdr.hh_shift;
	retval = get_shift(&shift,BROWSE,0,e_mesg);
	if(retval < 0) {
		DispError((char *)&s_sth,e_mesg);
		return(retval);
	}

	/* set number of semesters for school and number of */
	/* days for shift */
	if(schl_rec.s_nosems == 7) {
		TOTAL_SEM = 4;
	} 
	else {
		TOTAL_SEM = 2;
	}
	TOTAL_DAYS = shift.shft_days;
	if(TOTAL_SEM == 4) 
		strcpy(NOTTAKEN,"NNNN");
	else 
		strcpy(NOTTAKEN,"NN  ");
	return(NOERROR);
}
/*------------------------------------------------------------*/
/* Read the Assignment Details from the User */
/*------------------------------------------------------------*/
GetDetails()
{
	int	i ;
	int	err;

	if((err = GetHdrData(ADD))<0) return(err);;

	i = AddItems();
	if(NOERROR != i) return(i) ;

	for( ; ; ) {
		i = ConfirmItems() ;
		if(i != YES) break;

		i = WriteRecords(ADD) ;
		if(i < 0) {
			if(i == LOCKED) continue;
		}
		break;
	}
	if(i != NOERROR) return(i);
	return(NOERROR) ;
}	/* GetDetails() */
/*----------------------------------------------------------*/
/* Get the key and show the record */
SelectRecord()
{
	int	err ;

	for(; ;){
		err = ReadKey();
		if(err != NOERROR) return(err) ;

		err = GetHallAssgn();
		if(ERROR == err) return(DBH_ERR) ;
		if(err < 0) {		/* UNDEF or LOCKED */
			DispError((char *)&s_sth,e_mesg);
			get() ;
			continue ;
		}

		if((err = GetHdrData(BROWSE))<0) return(err);;

		err = ShowScrHdr(BROWSE);
		if(err == NOERROR) {
			err = ShowAsgnInfo();
		}
		return( err ) ;
	}
}	/* SelectRecord() */
/*-----------------------------------------------------------------------*/ 
/*Get Student Study Hall Assignment record for a given student and section */
/*-----------------------------------------------------------------------*/ 
GetHallAssgn()
{
	strcpy(hallasgn.hall_sid,student.s_seqno);
	hallasgn.hall_sect = s_sth.s_section ;

	return(get_hallasgn(&hallasgn, BROWSE, 1, e_mesg));
}
/*----------------------------------------------------------------------*/
/* Get the Student Study Hall key from user. In ADD mode disable dup buffers, */
/* other modes enable dup buffers and show the current key as a default key */
ReadKey()
{
	int	i;
	char	hold_sid[13];
	short	hold_sect;
	
	/* In Add mode turn off dup control for key fields.
	   Other modes reverse it */
	if(s_sth.s_fn[0] == ADDREC){	/* ADD */
		SetDupBuffers(KEY_START,KEY_END,0); /* Off Dup Control */
	}
	else {
		SetDupBuffers(KEY_START,KEY_END,2);
	}

#ifdef ENGLISH
	strcpy(s_sth.s_mesg,"Press ESC-F to Go Back to Fn:");
#else
	strcpy(s_sth.s_mesg,"Appuyer sur ESC-F pour retourner a Fn:");
#endif
	DispMesgFld((char *)&s_sth);

	strcpy(hold_sid,s_sth.s_stud_id);
	hold_sect = s_sth.s_section;

	InitKeys() ;

	i = ReadFields((char *)&s_sth,KEY_START, KEY_END,
		KeyAndHdrValidation, HdrAndKeyWindowHelp,1) ;
	if(PROFOM_ERR == i || DBH_ERR == i) return(i) ;
	if(RET_USER_ESC == i){
		strcpy(s_sth.s_stud_id,hold_sid);
		s_sth.s_section = hold_sect;
		
		ret( WriteFields((char *)&s_sth,KEY_START, KEY_END) ) ;

		s_sth.s_mesg[0] = HV_CHAR;
		DispMesgFld((char *)&s_sth);

		return(RET_USER_ESC) ;
	}

	return(NOERROR);
}	/*  ReadKey() */
/*-----------------------------------------------------------------------*/ 
/* Check to see if record is to be added, changed or deleted .		 */
/*-----------------------------------------------------------------------*/ 
WriteRecords(mode)
int mode;
{
	int	err;
	int	i;
	int	md;
	int	retval;
	char	sem_code[5];

	for(i=0; i<TOTAL_DAYS; i++) {
		if(SetupSemestCode(i,sem_code)<0) {
			roll_back(e_mesg);
			return(ERROR);
		}

		sprintf(e_mesg,"i: %d  sem_code: %s",i,sem_code);
		fomer(e_mesg); get();

		if((mode == ADD || mode == P_DEL) && 
				strcmp(sem_code,NOTTAKEN)==0) {
			continue;
		}

		if(mode != ADD) {
			CopyScrtoHdr();
			hallasgn.hall_asgn_day = i+1;

			retval = get_hallasgn(&hallasgn,UPDATE,0,e_mesg);
			if(retval < 0) {
				if(retval != UNDEF) {
					DispError((char *)&s_sth,e_mesg);
					roll_back(e_mesg);
					return(retval);
				}
			}

			if(mode == UPDATE) {
	  		    if(retval != UNDEF) {

				if(strcmp(hallasgn.hall_semest,sem_code)==0) {
					continue;
				}

				scpy((char *)&pre_hallasgn,(char *)&hallasgn,
						sizeof(hallasgn));

				if(strcmp(sem_code,NOTTAKEN)==0) {
					md = P_DEL;
				}
				else {
					md = UPDATE;
				}
			    }
			    else { /* retval == UNDEF */
				if(strcmp(sem_code,NOTTAKEN)==0) {
					continue; /* nothing to write */
				}
				else {
					md = ADD;
				}
			    }
			}
		}

		if(mode != UPDATE) {
			md = mode;
		}

		if(md != P_DEL) {
			CopyScrtoHdr();
			hallasgn.hall_asgn_day = i + 1;
			strcpy(hallasgn.hall_semest,sem_code);
		}

		retval = UpdateAsgnFile(md);
		if(retval < 0) {
			return(retval);
		}
	}
	return(NOERROR);
}	/* WriteRecords() */
/*-----------------------------------------------------------------------*/ 
/* Update Assignment File */
/*-----------------------------------------------------------------------*/ 
UpdateAsgnFile(mode)
int	mode;
{
	int	retval, err;
 
	retval = put_hallasgn(&hallasgn,mode,e_mesg);
	if(retval < 0) {
		DispError((char *)&s_sth,e_mesg);
		roll_back(e_mesg);
		return(retval);
	}

	if(mode != ADD) {
		err = rite_audit((char*)&s_sth,HALLASGN,mode,(char*)&hallasgn,
			(char*)&pre_hallasgn,e_mesg);
		if(err==LOCKED) {
			DispError((char *)&s_sth,e_mesg);
			roll_back(e_mesg) ;
			return(LOCKED) ;
		}
		if(err < 0 ){
#ifdef	ENGLISH
			DispError((char *)&s_sth,"ERROR in Saving Records"); 
#else
			DispError((char *)&s_sth,
					"ERREUR en conservant les fiches");
#endif
			DispError((char *)&s_sth,e_mesg);
			roll_back(e_mesg);
			return(err);
		}
	}

	err = commit(e_mesg) ;
	if(err < 0) {
#ifdef ENGLISH
		DispError((char *)&s_sth,"ERROR in Saving Records"); 
#else
		DispError((char *)&s_sth,"ERREUR en conservant les fiches");
#endif
		DispError((char *)&s_sth,e_mesg);
		roll_back(e_mesg);
		return(err);
	}

	return(NOERROR);
}
/*------------------------------------------------------------*/
/* Read Item Details from the User */
AddItems()
{
	int	i, j;
	int	retval ;

	s_sth.s_dummy[0] = ' ';
	/* fill in days across top */
	for(i=0;i<TOTAL_DAYS;i++) {
		s_sth.s_days[i] = i+1;
	}

	/* set defaults to NO */
	for(i=0;i<TOTAL_SEM;i++) {
		for(j=0;j<TOTAL_DAYS;j++) {
			s_sth.s_items[(i*10)+j].s_assign[0] = NO; ;
		}
	}

	ret( WriteFields((char *)&s_sth,HDR_END_FLD, (END_FLD - 200)) );

	for(i=0;i<TOTAL_SEM;i++) {
		for(j=0;j<TOTAL_DAYS;j++) {
			retval = ReadItem((i * 10) + j,ADD) ;
			if(retval == RET_USER_ESC) break;
		}
		if(retval == RET_USER_ESC) break;
	}

	return(NOERROR) ;
}	/* AddItems() */
/*------------------------------------------------------------*/
/* Read details of given item# */
/*------------------------------------------------------------*/
ReadItem(item_no,mode)
int	item_no ;
int	mode ;
{
	int	i;
	int	st_fld ;
	int	end_fld ;
	int	esc_f;

	/* make copy screen every time field changed in case user */
	/* presses ESC-F */
	scpy((char*)&image,(char*)&s_sth, sizeof(s_sth));

#ifdef ENGLISH
	strcpy(s_sth.s_mesg,"Press ESC-F to Terminate");
#else
	strcpy(s_sth.s_mesg,"Appuyer sur ESC-F pour terminer");
#endif
	DispMesgFld((char *)&s_sth);

	st_fld  = ITEM_ST_FLD + (STEP * item_no) ;
	end_fld = st_fld + STEP - 100 ;

	SetDupBuffers(st_fld,end_fld,1); 

	/* Initialize Reading Item with Low values */
	InitItem(item_no, LV_CHAR) ;

	i = ReadFields((char *)&s_sth,st_fld,end_fld,ItemsValidation,
		(int (*)())NULL,1) ;
	if(PROFOM_ERR == i || DBH_ERR == i) return(i) ;
	if(RET_USER_ESC == i) {
		/* When user gives ESC-F while changing fields, assumption is
		* he completed his changes, and remaining fields are same as
		* old. But, at this point STH will be having low values in the 
		* remaining fields. So move the old values form the linked list.
		*/

		i = CopyBack((char *)&s_sth,(char *)&image,sr.curfld, END_FLD);
		if(i == PROFOM_ERR) return(i);

		return(RET_USER_ESC) ;
	}

	return(NOERROR) ;
}	/* ReadItem() */
/*----------------------------------------------------------------*/
/* Set Duplication buffers for fields 				  */
SetDupBuffers( firstfld, lastfld, value )
int	firstfld, lastfld;	/* field numbers range */
int	value;			/* ENABLE or DISABLE */
{
	int i ;

	for( i=firstfld; i<=lastfld; i+=100 )
		fomca1( i, 19, value);
	if( value==0 )
		return(0);
	sr.nextfld = firstfld;
	sr.endfld = lastfld;
	fomud( (char *)&s_sth );
	ret( err_chk(&sr) );

	return( 0 );
}
/*----------------------------------------------------------------*/
/* Validation function() for Key and Header fields when PROFOM returns
  RET_VAL_CHK */

KeyAndHdrValidation()
{
	int	save_nextfld, save_endfld ;
	int	retval;

	switch(sr.curfld){
	case	KEY_START	:	/* student id */
		strcpy(student.s_id,s_sth.s_stud_id);
		Right_Justify_Numeric(student.s_id,sizeof(student.s_id)-1);

		retval = get_student( &student,BROWSE,1,e_mesg ); 
		if(retval < 0) {
			DispError((char *)&s_sth,e_mesg);
			s_sth.s_stud_id[0] = LV_CHAR;	
			return(ERROR);
		}
		else {
			strcpy(s_sth.s_stud_nm,student.s_name);
			ret(WriteFields((char *)&s_sth,STUD_FLD,STUD_FLD));
		}
		break;
	case	KEY_END:
		hallhdr.hh_sect = s_sth.s_section;
		retval = get_hallhdr(&hallhdr,BROWSE,0,e_mesg);
		if(retval < 0) {
			fomer(NOFIELD);
			s_sth.s_section = LV_SHORT;
			return(ERROR);
		}
		strcpy(hallasgn.hall_sid,student.s_seqno);
		hallasgn.hall_sect = s_sth.s_section;
		retval=get_hallasgn(&hallasgn,BROWSE,1,e_mesg);
		if(s_sth.s_fn[0] == ADDREC) {
			if(retval != UNDEF) {
			      fomer("Student Already Assigned to This Section");
				s_sth.s_section = LV_SHORT;
				return(ERROR);
			}
		}
		else {
			if(retval < 0) {
			 fomer("Student Has Not Been Assigned to This Section");
				s_sth.s_section = LV_SHORT;
				return(ERROR);
			}
		}
		break;
	default :
#ifdef ENGLISH
		sprintf(e_mesg,"No Validity Check For Field#  %d",sr.curfld);
#else
		sprintf(e_mesg,"Pas de controle de validite pour le Champ#  %d",sr.curfld);
#endif
		fomen(e_mesg);
		get();
		return(ERROR) ;
	}	/* Switch sr.curfld */

	return(NOERROR) ;
}	/* KeyAndHdrValidation() */
/*----------------------------------------------------------------*/
/* Validation function() for Item fields when PROFOM returns RET_VAL_CHK */

ItemsValidation()
{
	int	item_no;
	int	retval;
	short	seats_aval;

	item_no = (sr.curfld - ITEM_ST_FLD) / STEP;

	if(s_sth.s_items[item_no].s_assign[0] != YES &&
	   s_sth.s_items[item_no].s_assign[0] != NO) {
		fomer(YORN);
	   	s_sth.s_items[item_no].s_assign[0] = LV_CHAR;
		return(ERROR);
	}
	if(s_sth.s_items[item_no].s_assign[0] == YES) {
		retval = CalcAvalSeats(item_no,&seats_aval);
		if(retval < 0) {
			return(retval);
		}
		if(seats_aval <= 0) {
#ifdef ENGLISH
			fomer("No Seat Available for This Day/Semester");
#else
			fomer("No Seat Available for This Day/Semester");
#endif
	   		s_sth.s_items[item_no].s_assign[0] = LV_CHAR;
			return(ERROR);
		}
	}
	return(NOERROR) ;
}	/* ItemsValidation() */
/*----------------------------------------------------------------*/
/* Calculate Avaliable seats for a given day/semester to see if   */
/* it is full or not.						  */
/*----------------------------------------------------------------*/
CalcAvalSeats(item_no,seats_remaining) 
int	item_no;
short	*seats_remaining;	
{
	int	retval;

	/* zero based addressing must add 1 */
	halldtl.hd_sect = s_sth.s_section;
	halldtl.hd_sem = (item_no / 10) + 1;
	halldtl.hd_day = (item_no % 10) + 1;

	retval = get_halldtl(&halldtl,BROWSE,0,e_mesg);
	if(retval < 0) {
		DispError((char *)&s_sth,e_mesg);
		return(retval);
	}

	*seats_remaining = halldtl.hd_beg_seats;

	hallasgn.hall_sect = halldtl.hd_sect;
	hallasgn.hall_asgn_day = halldtl.hd_day;
	hallasgn.hall_sid[0] = '\0';
	flg_reset(HALLASGN);
	for( ; ; ) {
		retval = get_n_hallasgn(&hallasgn,BROWSE,2,FORWARD,e_mesg);
		if(retval < 0) {
			if(retval == EFL) break;
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}

		if(hallasgn.hall_sect > halldtl.hd_sect) break;
		if(hallasgn.hall_asgn_day != halldtl.hd_day) {
			continue;
		}

		if(hallasgn.hall_semest[item_no/100] == YES) {
			*seats_remaining -= 1;
		}
	}	
	return(NOERROR);
}
/*----------------------------------------------------------------*/
/* Show Help Windows, if applicable, when user gives ESC-H in key
   and header fields */

HdrAndKeyWindowHelp()
{
	int	retval ;

	switch(sr.curfld){
	case KEY_START:
		retval = student_hlp(s_sth.s_stud_id,s_sth.s_stud_nm,7, 13);
		if(retval == DBH_ERR) return(retval);
		if(retval >= 0) redraw();
		if(retval == 0) break;

		strcpy(student.s_id,s_sth.s_stud_id);
		retval = get_student(&student,BROWSE,1,e_mesg);
		if(retval < 0) {
			DispError((char *)&s_sth,e_mesg);
			s_sth.s_stud_id[0] = LV_CHAR;
		}
		else {
			strcpy(s_sth.s_stud_nm,student.s_name);
			ret(WriteFields((char *)&s_sth,STUD_FLD,STUD_FLD));
		}
		break;
	case KEY_END:
		if(s_sth.s_fn[0] == ADDREC) {
			retval = hallhdr_hlp(&s_sth.s_section,7, 13);
			if(retval == DBH_ERR) return(retval);
			if(retval >= 0) redraw();
			if(retval == 0) break;

			hallhdr.hh_sect = s_sth.s_section;
			retval = get_hallhdr(&hallhdr,BROWSE,0,e_mesg);
			if(retval < 0) {
				s_sth.s_section = LV_SHORT;
				return(ERROR);
			}
		}
		else {
			retval = hallasgn_hlp(student.s_seqno,
					&s_sth.s_section,7, 13);
			if(retval == DBH_ERR) return(retval);
			if(retval >= 0) redraw();
		}
		break;
	default :
		fomer(NOHELP);
	}	/* Switch sr.curfld */

	return(NOERROR) ;
}	/* HdrAndKeyWindowHelp() */
/*-----------------------------------------------------------------------*/
/* Take the confirmation from user for the header part */

ConfirmItems()
{
	int	err ;

	/* Options:
	   Add      - YALSNPC
	   Change   - YALSNPC
	   Delete   - YC
	*/

	for( ; ; ) {
	    switch(s_sth.s_fn[0]) {
	    case  ADDREC :		/* Add */
#ifdef ENGLISH
		err = GetOption((char *)&s_sth,
		"Y(es), S(creen Edit), L(ine edit), C(ancel)"
		,"YASLC");
#else
		err = GetOption((char *)&s_sth,
		"O(ui), S(creen edit), L(ine edit), A(nnul)"
		,"ORSLA");
#endif
		break ;
	    case  CHANGE :		/* Change */
#ifdef ENGLISH
		err = GetOption((char *)&s_sth,
		"Y(es), S(creen edit), L(ine edit), C(ancel)","YSLC");
#else
		err = GetOption((char *)&s_sth,
		"O(ui), S(creen edit), L(ine edit), A(nnul)","OSLA");
#endif
		break ;
	    case  DELETE :		/* Delete */
#ifdef ENGLISH
		err = GetOption((char *)&s_sth,"Y(es), C(ancel)","YC");
#else
		err = GetOption((char *)&s_sth,"O(ui), A(nnul)","OA");
#endif
		break ;
	    }
	    if(err == PROFOM_ERR) return(err) ;

	    switch(err) {
	    case  YES  :
		return(YES);
	    case  SCREENEDIT:
		err = ScreenEdit();
		break;
	    case  LINEEDIT  :
		err = ChangeFields();
		break ;
	    case  CANCEL :
#ifdef ENGLISH
		err = GetOption((char *)&s_sth,
				"Confirm the Cancel (Y/N)?", "YN") ;
#else
		err = GetOption((char *)&s_sth,
				"Confirmer l'annulation (O/N)?", "ON") ;
#endif
		if(err == YES) return(CANCEL) ;
		break ;
	    }	/* switch err */

	    if(err == PROFOM_ERR) return(err) ;
	    if(err == DBH_ERR) return(err) ;
	}	/* for(; ; ) */
}	/* ConfirmItems() */
/*---------------------------------------------------------------------*/
/*                                                                       */
/* Change screen.  Allows editing of the entire screen of information	 */
/*	starting at field number one.					 */

ScreenEdit()
{
     	int i, j;
	int retval;

	for(i=0;i<TOTAL_SEM;i++) {
		for(j=0;j<TOTAL_DAYS;j++) {
			retval = ReadItem((i * 10) + j,UPDATE) ;
			if(retval == RET_USER_ESC) break;
		}
		if(retval == RET_USER_ESC) break;
	}

     	s_sth.s_mesg[0] = HV_CHAR ;
     	DispMesgFld((char *)&s_sth);

	if(SetDupBuffers(ITEM_ST_FLD, END_FLD-200,0)<0) return(PROFOM_ERR);

	return(NOERROR);
}	/* ScreenEdit() */
/*-----------------------------------------------------------------------*/
/*                                                                       */
/* Changing fields. Accept fld to be changed and read that fld 		 */
ChangeFields()
{
	int retval;
	int row, col;
	int item_no;

	SetDupBuffers(ITEM_ST_FLD, END_FLD - 200, 2);

	/* Get The Field to Be Modified */
#ifdef	ENGLISH
	strcpy(s_sth.s_mesg,"Enter RETURN to Terminate Edit");
#else
	strcpy(s_sth.s_mesg,"Appuyer sur RETURN pour terminer l'ajustement");
#endif
	DispMesgFld((char *)&s_sth); ;
        
     	for (; ;) {
		s_sth.s_field = LV_SHORT;
		retval = ReadFields((char *)&s_sth,CHG_FLD,CHG_FLD,
			(int (*)())NULL,(int (*)())NULL, 1);

		if (retval < 0) return(-1);
		if (retval == RET_USER_ESC) break;	/* User enter ESC-F */

       		if (s_sth.s_field == 0 ) break;  /* Finished changing fields */

		/* Subtract 1 because of zero based addressing */
		/* Fields numbered 11 - 19, 21 - 29, 31 - 39, 41 - 49 */
		if(s_sth.s_field < 100) {
			row = (s_sth.s_field / 10) - 1;
			col = (s_sth.s_field % 10) - 1;
			if(row > TOTAL_SEM-1 || col > TOTAL_DAYS-1 || row < 1) {
				continue;
			}
		}
		else {	/* Fields numbered 110, 210, 310, 410 */
			row = (s_sth.s_field / 100) - 1;
			col = (s_sth.s_field % 100) - 1;
			if(row > TOTAL_SEM-1 || col > TOTAL_DAYS-1 || row < 1) {
				continue;
			}
		}

		item_no = (row * 10) + col;

		retval = ReadItem(item_no,UPDATE);
		if(retval != NOERROR) {
			return(retval);
		}
	}

     	s_sth.s_field = HV_SHORT ;
	if ( WriteFields((char *)&s_sth,CHG_FLD, CHG_FLD) < 0 ) return(-1);

     	s_sth.s_mesg[0] = HV_CHAR ;
     	DispMesgFld((char *)&s_sth);

	if(SetDupBuffers(HDR_ST_FLD, HDR_END_FLD, 0)<0) return(PROFOM_ERR);

	return(NOERROR);
}	/* ChangeFields() */
/*-----------------------------------------------------------*/
/* Move Header to Screen Hdr Fields */
ShowScrHdr(mode)
int	mode;
{
	int	retval;

	if(mode != ADD) {
		strcpy(s_sth.s_stud_id, student.s_id);
		s_sth.s_section = hallasgn.hall_sect;
	}
	strcpy(s_sth.s_stud_nm, student.s_name);
	strcpy(s_sth.s_grlevel, hallhdr.hh_glevel);
	strcpy(s_sth.s_room, hallhdr.hh_rm);
	strcpy(s_sth.s_teacher, hallhdr.hh_tid);

	strcpy(teacher.tid,hallhdr.hh_tid);
	retval = get_teacher( &teacher,BROWSE,0,e_mesg ); 
	if(retval < 0) {
		DispError((char *)&s_sth,e_mesg);
		return(retval);
	}

	ret( WriteFields((char *)&s_sth, KEY_START, HDR_END_FLD) ) ;

	return(NOERROR) ;
}	/* ShowScrHdr() */
/*-----------------------------------------------------------*/
/* Get and Display Assignment Information		     */
/*-----------------------------------------------------------*/
ShowAsgnInfo()
{
	int	retval;
	int	i,j;


	s_sth.s_dummy[0] = ' ';
	/* fill in days across top */
	for(i=0;i<TOTAL_DAYS;i++) {
		s_sth.s_days[i] = i+1;
	}

	/* Set all values to NO then change to YES if applicable */
	for(i=0;i<TOTAL_SEM;i++) {
		for(j=0;j<TOTAL_DAYS;j++) {
			s_sth.s_items[(i*10)+j].s_assign[0] = NO;
		}
	}

	strcpy(hallasgn.hall_sid, student.s_seqno);
	hallasgn.hall_sect = s_sth.s_section;
	hallasgn.hall_asgn_day = 0;
	flg_reset(HALLASGN);

	for( ; ; ) {
		retval = get_n_hallasgn(&hallasgn,BROWSE,0,FORWARD,e_mesg);
		if(retval < 0) {
			if(retval == EFL) break;
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}
		if(hallasgn.hall_sect != s_sth.s_section) break;

		if(strcmp(hallasgn.hall_sid,student.s_seqno) != 0) break;

		/* minus one for Zero based addressing */
		/* setup Assigned days */
		ConvertSem(hallasgn.hall_asgn_day-1);

	}
	seq_over(HALLASGN);

	ret( WriteFields((char *)&s_sth, HDR_END_FLD, END_FLD - 200) ) ;
	return(NOERROR);
}
/*-------------------------------------------------------------------------
move the appropriate semester Y/N answers from the file to the screen 
-------------------------------------------------------------------------*/
ConvertSem(day)
short	day;
{
	/* semester 1 */
	s_sth.s_items[(0*10)+day].s_assign[0]=hallasgn.hall_semest[0]; 
	/* semester 2 */
	s_sth.s_items[(1*10)+day].s_assign[0]=hallasgn.hall_semest[1]; 

	if(schl_rec.s_nosems == 7){ /* setup semesters 3 and 4 */
		/* semester 3 */
		s_sth.s_items[(2*10)+day].s_assign[0]=hallasgn.hall_semest[2]; 
		/* semester 4 */
		s_sth.s_items[(3*10)+day].s_assign[0]=hallasgn.hall_semest[3]; 
	}

	return(NOERROR);
}
/*-----------------------------------------------------------*/
/* Move Screen Hdr Fields to Header Record*/
/*-----------------------------------------------------------*/
CopyScrtoHdr()
{
	strcpy(hallasgn.hall_sid,student.s_seqno);
	hallasgn.hall_sect = s_sth.s_section;

	return(NOERROR) ;
}	/* CopyScrtoHdr() */
/*-----------------------------------------------------------*/
/* Setup Semester Y/N answers to Write to Assignment File    */
/*-----------------------------------------------------------*/
SetupSemestCode(day,sem_code)
int	day;
char	*sem_code;
{
	int	i;

	strcpy(sem_code,"    ");
	for(i=0;i<TOTAL_SEM;i++) {
		sem_code[i] = s_sth.s_items[(i*10)+day].s_assign[0];
	}
	sem_code[5] = '\0';

	return(NOERROR);
}
/*------------------------------------------------------------------------*/
/* Move High values to all data fields and clear the screen */

ClearScreen()
{
	int	i;

	/* Move High Values to Hedaer part */
	InitHdr(HV_CHAR, HV_SHORT) ;

	s_sth.s_dummy[0] = HV_CHAR ;

	for(i = 0 ; i < MAX_DAYS ; i++)
		s_sth.s_days[i] = HV_SHORT;

	/* Move High Values to All items */
	for(i = 0 ; i < PAGESIZE ; i++)
		InitItem(i, HV_CHAR) ;

	ret( WriteFields((char *)&s_sth,HDR_ST_FLD, (END_FLD - 200)) );

	return(NOERROR);
}	/* ClearScreen() */
/*-------------------------------------------------------------------------*/
/* Initialize Screen Keys with Low 					   */
/*-------------------------------------------------------------------------*/
InitKeys()
{
	s_sth.s_stud_id[0] = LV_CHAR;
	s_sth.s_section = LV_SHORT;

	return(NOERROR);
}
/*-------------------------------------------------------------------------*/
/* Initialize Screen Header with either Low or High Values */

InitHdr( t_char, t_short )
char	t_char ;
short	t_short ;
{
	s_sth.s_stud_nm[0] = t_char;
	s_sth.s_grlevel[0] = t_char;
	s_sth.s_room[0] = t_char;
	s_sth.s_teacher[0] = t_char;
	s_sth.s_tname[0] = t_char;

	return(NOERROR) ;
}	/* InitHdr() */
/*-------------------------------------------------------------------------*/
/* Initialize Given screen item with either Low values or High values */

InitItem(item_no, t_char)
int	item_no ;
char	t_char ;
{
	s_sth.s_items[item_no].s_assign[0] = t_char ;

	return(NOERROR) ;
}	/* Inititem() */

/*-------------------- E n d   O f   P r o g r a m ---------------------*/
