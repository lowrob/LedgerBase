/*-----------------------------------------------------------------------
Source Name: dlyatt.c
System     : Attendance.
Created  On: 6th Aug. 91.
Created  By: J. Prescott.

DESCRIPTION:
	Program To input Students Daily Attendance.

MODIFICATIONS:        

Programmer     YY/MM/DD       Description of modification
------------------------------------------------------------------------*/
#define	MAIN		/* Main program. This is to declare Switches */
#define MAINFL		DAILYATT		/* main file used */

#define	SYSTEM		"Attendance"	/* Sub System Name */
#define	MOD_DATE	"6-AUG-91"		/* Progran Last Modified */

#include <stdio.h>
#include <cfomstrc.h>
#include <sb_defs.h>
#include <sb_recs.h>

/* User Interface define constants */
#ifdef ENGLISH
#define ADDREC		'A'
#define CHANGE		'C'
#define DELETE		'D'
#define INQUIRE		'I'
#define EXITOPT		'E'
#define	NEXTPAGE	'N'
#define	PREVPAGE	'P'

#define	YES		'Y'
#define NO		'N'
#define	LINEEDIT	'L'
#define SCREENEDIT	'S'
#define	CANCEL		'C'

#define	ALL		'A'
#define INACTIVE	'I'
#define TRANSFERED	'T'
#else
#define ADDREC		'R'
#define CHANGE		'C'
#define DELETE		'E'
#define INQUIRE		'I'
#define EXITOPT		'F'
#define	NEXTPAGE	'S'
#define	PREVPAGE	'P'

#define	YES		'O'
#define NO		'N'
#define	LINEEDIT	'L'
#define SCREENEDIT	'S'
#define	CANCEL		'A'

#define	ALL		'A'
#define INACTIVE	'I'
#define TRANSFERED	'T'
#endif

#define INVALID		10

/* PROFOM Releted declarations */

#define	SCR_NAME	"dlyatt"	/* PROFOM screen Name */

#define	PAGESIZE	10		/* No of Items */

/* PROFOM Screen STH file */

/* Field PROFOM numbers */

#define	HDR_ST_FLD	700	/* Header Start Field */
#define	HDR_END_FLD	1800	/* Header End Field */
#define	ITEM_ST_FLD	2200	/* Item 1 Start Field */
#define ITEM_DISP_FLD	1900	/* Item Display Start Field */
#define	END_FLD		6300	/* Last Field of the screen */
#define	STEP		400	/* NO of fields diff. between 2 items */

#define	CHG_FLD		500	/* Field: */
#define TRAN_DT_FLD	700	/* Transaction Date: */
#define SHIFT_FLD	800	/* Shift: */
#define INACT_FLD	900	/* Inactive/Transfered: */
#define ST_HMRM_FLD	1200	/* Starting Homeroom: */
#define EN_HMRM_FLD	1600	/* Ending Homeroom: */
#define ST_GLEVEL_FLD	1300	/* Starting Grade Level: */
#define EN_GLEVEL_FLD	1700	/* Ending Grade Level: */
#define STUD_FLD	1800	/* Student name */

#define ATTCODE_FLD	300	/* offset of item in line */

/* Header Field numbers for line edit */
#define TRAN_DT_NO	1
#define SHIFT_NO	2
#define INACTIVE_NO	3
#define ST_HMRM_GL_NO	4
#define EN_HMRM_GL_NO	5
#define STUD_NM_NO	6

#define MAX_HDR_NO	6

/* dlyatt.sth - header for C structure generated by PROFOM EDITOR */

typedef	struct	{	/* Start Fld 2200, Endfld 6100 and Step 400 */

	char	s_stud_id[13];	/* 2200 STRING X(12) */
	char	s_stud_nm[31];	/* 2300 STRING X(30) */
	char	s_stud_stat[2]; /* 2400 STRING X(12) */
	char	s_att_code[2];	/* 2500 STRING X(12) */
}	S_item ;

typedef struct	{

	char	s_pgname[11];	/* 100 STRING X(10) */
	long	s_rundate;	/* 300 DATE YYYYFMMFDD */
	char	s_school[41];	/* 400 STRING X(40) */
	short	s_field;	/* 500 NUMERIC 99 */

	short	s_tran_dt;	/* 700 NUMERIC 99F99 */
	char	s_shift[2];	/* 800 STRING X */
	char	s_inactive[2];  /* 900 STRING X */
	char	s_st_txt[12];	/* 1000 STRING X(11) */
	char	s_st_col[2];	/* 1100 STRING X */
	char	s_st_hmrm[6];	/* 1200 STRING XXXXX */
	char	s_st_glevel[3];	/* 1300 STRING XX */
	char	s_en_txt[12];	/* 1400 STRING X(11) */
	char	s_en_col[2];	/* 1500 STRING X */
	char	s_en_hmrm[6];	/* 1600 STRING XXXXX */
	char	s_en_glevel[3];	/* 1700 STRING XX */
	char	s_stud_nm[31];	/* 1800 STRING X(30) */
	char	s_dummy[2];	/* 1900 STRING XXXXX */
	char	s_day[4];	/* 2000 STRING XXX */
	short	s_page;		/* 2100 NUMERIC 99 */

	S_item	s_items[PAGESIZE] ;	/* Start Fld 2200, End Fld 6100  */

	char	s_mesg[78];	/* 6600 STRING X(77) */
	char	s_resp[2];	/* 6700 STRING X */
} s_struct;

static	s_struct  s_sth,image;	/* PROFOM Screen Structure */
static	struct  stat_rec  sr;		/* PROFOM status rec */

static	char 	e_mesg[100];  		/* dbh will return err msg in this */

static	Schl_rec	schl_rec;

static	Dattcode	dattcode;
static	Student		student;
static	Dailyatt	dailyatt, pre_dailyatt;
static	Calendar	calendar;
static	Homeroom	homeroom;
static  Glevel		glevel;
static	Shift		shift;
static	Schtype		schltype;

int	KeyAndHdrValidation(), ItemsValidation() ;
int	HdrAndKeyWindowHelp(), ItemsWindowHelp() ;
int	Argc;
char	**Argv;

typedef struct Page {
	S_item	Items[PAGESIZE] ;	/* Items Information */
	struct	Page	*PrevPage ;	/* ptr to previous page */
	struct	Page	*NextPage ;	/* ptr to next page */
	short	NoItems;		/* number of Items on the page */
	short	Pageno;			/* Page number */
}	Page;

static	Page	*FirstPage,		/* Address of First Page */
		*CurPage,		/* Address of Current Page */
		*StudLast,		/* Address of Curr. record last page */
		*LastPage;		/* Address of Last Page of Memory
					   Allocated */

void	free() ;
char	*malloc() ;

static	short	num_shifts;		/* number of shifts used by school */

main(argc,argv)
int argc;
char *argv[];
{
	int 	retval;

	/* These two are passed to execute() when it is called */
	Argc = argc;
	Argv = argv;

	retval = Initialize(argc,argv);	/* Initialization routine */

	if (retval == NOERROR) retval = InputAttn();

	CloseRtn();			/* return to menu */
	if (retval != NOERROR) exit(-1);
	exit(0);
}

/*-------------------------------------------------------------------*/
/* Initialize PROFOM */

Initialize(argc, argv)
int	argc ;
char	*argv[] ;
{
	int	err ;

	/*
	*	Initialize DBH Environment
	*/
	strncpy(SYS_NAME,SYSTEM,50);	/* Sub system name */
	strncpy(CHNG_DATE,MOD_DATE,10);	/* Modification Date */

	proc_switch(argc, argv, MAINFL) ; 	/* Process Switches */

	/*
	*	Initialize PROFOM & Screen
	*/
	strcpy(sr.termnm,terminal);	/* Copy Terminal Name */
	fomin(&sr);
	ret(err_chk(&sr)) ;		/* Check for PROFOM Error */
	fomcf(1,1);			/* Enable Snap screen option */

	strcpy(schl_rec.schl_cd, schl_no) ;
	err = get_school(&schl_rec, BROWSE, 0, e_mesg) ;
	if(err == ERROR) {
		fomen(e_mesg);
		get() ;
		return(ERROR);
	}
	if(err == UNDEF) {
#ifdef ENGLISH
		fomen("School is Not Setup ..");
#else
		fomen("Ecole n'est pas configuree .. ");
#endif
		get();
		return(ERROR);
	} 

	if(schl_rec.da_flg[0] != YES) {
		fomer(NOMODULE);
		get();
		return(ERROR);
	}

	err = InitScreen() ;		/* Initialize Screen */
	if(NOERROR != err) return(err) ;

	FirstPage = NULL;
	LastPage = NULL;

	return(NOERROR) ;
}	/* Initialize() */

/*--------------------------------------------------------------------------*/
/* Close nessary files and environment before exiting program               */
static
CloseRtn() 
{
	/* Free the linked list for the end */
	for( ;LastPage != FirstPage ; ) {
		LastPage = LastPage->PrevPage;
		free((char *)LastPage->NextPage);
		LastPage->NextPage = NULL;
	}
	if(FirstPage != NULL) {
		free((char *)FirstPage);
	}

	FirstPage = LastPage = NULL;

	/* Set terminal back to normal mode from PROFOM */
	fomcs();
	fomrt();

	close_dbh();	/* Close files */

	return(NOERROR);
}	/* CloseRtn() */
/*----------------------------------------------------------------*/
/* Initialize screen before going to process options */
static
InitScreen()
{
	int	err ;

	/* move screen name to Profom status structure */
	strcpy(sr.scrnam,NFM_PATH);
	strcat(sr.scrnam,SCR_NAME) ;

	strcpy(s_sth.s_pgname,PROG_NAME);

	strcpy( s_sth.s_school, schl_rec.schl_name ) ; 
	CenterSchool(s_sth.s_school);

	s_sth.s_rundate = get_date();	/* get Today's Date in YYYYMMDD format*/
	s_sth.s_field = HV_SHORT ;
	s_sth.s_mesg[0] = HV_CHAR ;
	s_sth.s_resp[0] = HV_CHAR ;

	/* Move High Values to data fields and Display the screen */
	err = ClearScreen() ;
	if(NOERROR != err) return(err) ;

	return(NOERROR) ;
}	/* InitScreen() */
/*--------------------------------------------------------------*/
/* This rountine Gets the Header Information from the user and  */
/* Prompts for Conformation. Then Calls routines to build the   */
/* list of students, show the students on the screen, confirm   */
/* the students, and write the updated students to the daily    */
/* attendance file.						*/
/*--------------------------------------------------------------*/
InputAttn()
{
	int	retval;

	if((num_shifts = ChkNoShifts())<0)
		return(-1);
	if(num_shifts > 1)
		s_sth.s_shift[0] = ALL;
	s_sth.s_inactive[0] = YES;

	if(SetDupBuffers(HDR_ST_FLD, HDR_END_FLD,1)<0) return(PROFOM_ERR);
	
	InitHdr(LV_CHAR,LV_SHORT);

	retval=ReadFields((char *)&s_sth,HDR_ST_FLD,HDR_END_FLD,
			KeyAndHdrValidation,HdrAndKeyWindowHelp,0) ;
	if(retval == PROFOM_ERR || retval == DBH_ERR) return(retval);

	retval = ConfirmOptions();
	if(retval == YES) {
		if((retval = CreateList())<0) return(retval);	
		if((retval = ShowItems(CurPage)) < 0) return(retval);
		for( ; ; ) {
			retval = ConfirmItems();
			if(retval == YES) {
				if((retval=ProcItemUpdates())<0) {
					if(retval == LOCKED) continue;
					return(retval);
				}
			}
			break;
		}
	}
	return(NOERROR);
}	/* InputAttn() */
/*----------------------------------------------------------------*/
/* Confirm the header information. The can accept the information */
/* edit the information, or cancel the option and go the the menu */
/*----------------------------------------------------------------*/
ConfirmOptions()
{
	int err;

	/* Options:
		YSLC
	*/

	for( ; ; ) {
#ifdef ENGLISH
		err = GetOption((char *)&s_sth,
		"Y(es), S(creen Edit), L(ine edit), C(ancel)"
		,"YASLC");
#else
		err = GetOption((char *)&s_sth,
		"O(ui), S(creen edit), L(ine edit), A(nnul)"
		,"ORSLA");
#endif

	    switch(err) {
	    case  YES  :
		return(YES);
	    case  SCREENEDIT:
		err = ScreenEditHdr();
		break;
	    case  LINEEDIT  :
		err = ChangeHdrFields();
		break ;
	    case  CANCEL :
#ifdef ENGLISH
		err = GetOption((char *)&s_sth,
				"Confirm the Cancel (Y/N)?", "YN") ;
#else
		err = GetOption((char *)&s_sth,
				"Confirmer l'annulation (O/N)?", "ON") ;
#endif
		if(err == YES) return(CANCEL) ;
		break ;
	    }	/* switch err */

	    if(err == PROFOM_ERR) break;
	    if(err == DBH_ERR) break;
	}	/* for(; ; ) */
	if(err == PROFOM_ERR) return(err) ;
	if(err == DBH_ERR) return(err) ;

	return(NOERROR);
}	/* ConfirmOptions() */
/*------------------------------------------------------------*/
/* Allows the user to edit all the fields in the header.      */
/*------------------------------------------------------------*/
ScreenEditHdr()
{
	int	retval;

	/* make copy of screen incase user presses ESC-F */
	scpy((char *)&image,(char *)&s_sth,sizeof(s_sth));

#ifdef ENGLISH
	strcpy(s_sth.s_mesg,"Press ESC-F to Terminate");
#else
	strcpy(s_sth.s_mesg,"Appuyer sur ESC-F pour terminer");
#endif
	DispMesgFld((char *)&s_sth);

	if(SetDupBuffers(HDR_ST_FLD, HDR_END_FLD,1)<0) return(PROFOM_ERR);


	InitHdr(LV_CHAR,LV_SHORT);

	retval=ReadFields((char *)&s_sth,HDR_ST_FLD,HDR_END_FLD,
			KeyAndHdrValidation,HdrAndKeyWindowHelp,1) ;
	if(retval == PROFOM_ERR || retval == DBH_ERR) return(retval);
	if(retval == RET_USER_ESC) {
		/* When user gives ESC-F while changing fields, assumption is
		* he completed his changes, and remaining fields are same as
		* old. But, at this point STH will be having low values in the 
		* remaining fields. So move the old values from the linked list.
		*/

		retval=CopyBack((char *)&s_sth,(char *)&image,
				sr.curfld,HDR_END_FLD);
		if(retval == PROFOM_ERR) return(retval);

		return(RET_USER_ESC) ;
	}

     	s_sth.s_mesg[0] = HV_CHAR ;
     	DispMesgFld((char *)&s_sth);

	if(SetDupBuffers(HDR_ST_FLD, HDR_END_FLD,0)<0) return(PROFOM_ERR);
	
	return(NOERROR);
}	/* ScreenEditHdr() */
/*------------------------------------------------------------*/
/* Prompts the user for a field to edit the allows the user to */
/* edit that field if it is a valid field number.	       */
/*------------------------------------------------------------*/
ChangeHdrFields()
{
	int retval;
	int fld_no;

	SetDupBuffers(HDR_ST_FLD, HDR_END_FLD, 1);

	/* Get The Field to Be Modified */
#ifdef	ENGLISH
	strcpy(s_sth.s_mesg,"Enter RETURN to Terminate Edit");
#else
	strcpy(s_sth.s_mesg,"Appuyer sur RETURN pour terminer l'ajustement");
#endif
	DispMesgFld((char *)&s_sth); ;
        
     	for (; ;) {
		s_sth.s_field = LV_SHORT;
		retval = ReadFields((char *)&s_sth,CHG_FLD,CHG_FLD,
			(int (*)())NULL,(int (*)())NULL, 1);

		if (retval < 0) return(-1);
		if (retval == RET_USER_ESC) break;	/* User enter ESC-F */

       		if (s_sth.s_field == 0 ) break;  /* Finished changing fields */

		if(SW1 && (s_sth.s_field == ST_HMRM_GL_NO ||
		   s_sth.s_field == EN_HMRM_GL_NO)) {
				continue;
		}

		if(s_sth.s_field > MAX_HDR_NO) continue;

		/* make copy of screen incase user presses ESC-F */
		scpy((char *)&image,(char *)&s_sth,sizeof(s_sth));
		
		switch(s_sth.s_field) {
		case TRAN_DT_NO:
			fld_no = TRAN_DT_FLD;
			break;
		case SHIFT_NO:
			fld_no = SHIFT_FLD;
			break;
		case INACTIVE_NO:
			fld_no = INACT_FLD;
			break;
		case ST_HMRM_GL_NO:
			if(SW2) {
				fld_no = ST_HMRM_FLD;
			}
			else {
				fld_no = ST_GLEVEL_FLD;
			}
			break;
		case EN_HMRM_GL_NO:
			if(SW2) {
				fld_no = EN_HMRM_FLD;
			}
			else {
				fld_no = EN_GLEVEL_FLD;
			}
			break;
		case STUD_NM_NO:
			fld_no = STUD_FLD;
			break;
		}

		if(fld_no == SHIFT_FLD && num_shifts == 1)
			continue;

		retval=ReadFields((char *)&s_sth,fld_no,fld_no,
			KeyAndHdrValidation,HdrAndKeyWindowHelp,1) ;
		if(retval == PROFOM_ERR || retval == DBH_ERR) return(retval);
		if(retval == RET_USER_ESC) {
 		/* When user gives ESC-F while changing fields, assumption is
		* he completed his changes, and remaining fields are same as
		* old. But, at this point STH will be having low values in the 
		* remaining fields. So move the old values from the linked list.
		*/
			retval=CopyBack((char *)&s_sth,(char *)&image,sr.curfld,
				HDR_END_FLD);
			if(retval == PROFOM_ERR) return(retval);
		}
	}

	 s_sth.s_field = HV_SHORT;
	if ( WriteFields((char *)&s_sth,CHG_FLD, CHG_FLD) < 0 ) return(-1);

     	s_sth.s_mesg[0] = HV_CHAR ;
     	DispMesgFld((char *)&s_sth);

	if(SetDupBuffers(HDR_ST_FLD, HDR_END_FLD, 0)<0) return(PROFOM_ERR);

	return(NOERROR);
}	/* ChangeHdrFields() */
/*------------------------------------------------------------*/
/* This routine builds the link list of students base on the  */
/* information entered in the header.                         */
/*------------------------------------------------------------*/
CreateList() 
{
	int	retval;
	int	key_no;
	int	i;

	StudLast = CurPage = NULL;
	i = 0;

	if(SW1) {
		strcpy(student.s_name,s_sth.s_stud_nm);
		key_no = 2;
	}
	else if(SW2) {
		strcpy(student.s_hmrm,s_sth.s_st_hmrm);
		strcpy(student.s_name,s_sth.s_stud_nm);
		key_no = 3;
	}
	else {
		strcpy(student.s_glevel_cd,s_sth.s_st_glevel);
		strcpy(student.s_name,s_sth.s_stud_nm);
		key_no = 4;
	}

	flg_reset(STUDENT);

	for( ; ; ) {
		retval = get_n_student(&student,BROWSE,key_no,FORWARD,e_mesg);
		if(retval < 0) {
			if(retval == EFL) break;
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}

		if(s_sth.s_shift[0] != ALL && s_sth.s_shift[0] != HV_CHAR) {
	 	   if(student.s_shift_no != atoi(s_sth.s_shift))
			continue;
		}

		if(s_sth.s_inactive[0] == NO && 
		  (student.s_active[0] == INACTIVE || 
		   student.s_active[0] == TRANSFERED)) {
			continue;
		}

		if(SW2) {
			if(strcmp(student.s_hmrm,s_sth.s_en_hmrm)>0 &&
			   s_sth.s_en_hmrm[0] != '\0') {
				break;
			}
		}
		if(SW3) {
			if(strcmp(student.s_glevel_cd,s_sth.s_en_glevel)>0 &&
			   s_sth.s_en_glevel[0] != '\0') {
				break;
			}
		}

		if(PAGESIZE == i) i = 0;
		if(i == 0) {
			if((retval = MakeFreshPage()) < 0) return(retval);
		}

		strcpy(CurPage->Items[i].s_stud_id,student.s_id);
		strcpy(CurPage->Items[i].s_stud_nm,student.s_name);
		if(student.s_active[0] != '\0') {
			strcpy(CurPage->Items[i].s_stud_stat,student.s_active);
		}
		else {
			CurPage->Items[i].s_stud_stat[0] = HV_CHAR;
		}

		strcpy(dailyatt.datt_sid,student.s_seqno);
		dailyatt.datt_mth = s_sth.s_tran_dt / 100;
		dailyatt.datt_day = s_sth.s_tran_dt % 100;

		retval = get_dailyatt(&dailyatt,BROWSE,0,e_mesg) ;
		if(retval < 0 && retval != UNDEF) {
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}
		if(retval != UNDEF) {
			strcpy(CurPage->Items[i].s_att_code,dailyatt.datt_cd);
		}

		CurPage->NoItems++;
		i++;
	}
	seq_over(STUDENT);

	if(StudLast != NULL) {
		CurPage = FirstPage;
	}

	return(NOERROR);
}	/* CreateList() */

/*-----------------------------------------------------------------------*/
/*	Get the next node in linked list to add invoice items. If the
*	(Cur. invc last page) = (Last Page in linked List) or no
*	nodes in list, allocate node and add to linked list
*/

MakeFreshPage()
{
	Page	*tempptr ;

	/* If, no node is allocated yet or Current invoice used all the nodes,
	   then allocate new node */

	if( LastPage == NULL || StudLast == LastPage ){
		tempptr= (Page *)malloc((unsigned)sizeof(Page)) ;

		if( tempptr == NULL ){
			DispError((char*)&s_sth,MEMERR);
			return(ERROR);
		}
		tempptr->NextPage = NULL ;

		if( LastPage == NULL ){	/* No node is allocated Yet */
			tempptr->PrevPage = NULL ;
			tempptr->Pageno = 1 ;
			FirstPage = tempptr ;
		}
		else {				/* Not a first node in list */
			tempptr->Pageno = LastPage->Pageno + 1 ;
			LastPage->NextPage = tempptr ;
			tempptr->PrevPage = LastPage ;
		}
		LastPage = tempptr ;
	}

	if(StudLast == NULL)
		StudLast = FirstPage ;
	else
		StudLast = StudLast->NextPage ;

	StudLast->NoItems = 0 ;
	CurPage = StudLast ;

	return(NOERROR);
}	/* MakeFreshPage() */
/*------------------------------------------------------------*/
/* Show all the items on the current page 		      */
ShowItems(pageptr)
Page	*pageptr ;
{
	int	i ;

	get_day();

	if(pageptr != NULL) {
		/* Copy the items to screen */
		scpy((char*)s_sth.s_items, (char*)pageptr->Items,
			(pageptr->NoItems * sizeof(S_item)) );

		s_sth.s_page   = pageptr->Pageno ;

		s_sth.s_dummy[0] = ' ' ;

		i = pageptr->NoItems ;
	}
	else {
		s_sth.s_page = HV_SHORT ;
		s_sth.s_dummy[0] = HV_CHAR ;
		i = 0 ;
	}

	/* Move High Values to remaining Items */
	for( ; i < PAGESIZE ; i++ )
		InitItem(i, HV_CHAR) ;

	ret( WriteFields((char *)&s_sth, ITEM_DISP_FLD, (END_FLD - 200)) );

	return(NOERROR) ;
}	/* ShowItems() */
/*---------------------------------------------------------------*/
/* take the date entered on the screen and get the corresponding */
/* day's name. i.e MON, TUE, etc.				 */
/*---------------------------------------------------------------*/
get_day()
{
	long	julian;
	int	remain;
	long	long_date;
	int	st_month;
	int	end_month;	
	int	year;

	st_month = (schl_rec.s_stdate / 100) % 100;
	end_month = (schl_rec.s_enddate / 100) % 100;

	if(s_sth.s_tran_dt / 100 >= st_month && s_sth.s_tran_dt / 100 <= 12) {
		year = schl_rec.s_stdate / 10000;
	}
	else {
		year = schl_rec.s_enddate / 10000;
	}

	long_date = (10000 * year) + s_sth.s_tran_dt ;

	julian = days(long_date);
	remain = julian % 7;
	switch(remain) {
	case	0 :
		strcpy(s_sth.s_day,"SUN");
		break;
	case	1 :
		strcpy(s_sth.s_day,"MON");
		break;
	case	2 :
		strcpy(s_sth.s_day,"TUE");
		break;
	case	3 :
		strcpy(s_sth.s_day,"WED");
		break;
	case	4 :
		strcpy(s_sth.s_day,"THU");
		break;
	case	5 :
		strcpy(s_sth.s_day,"FRI");
		break;
	case	6 :
		strcpy(s_sth.s_day,"SAT");
		break;
	}    /*  switch remain   */

	return(NOERROR);
}	/* get_day() */
/*-----------------------------------------------------------------------*/ 
/* Process all the items in the linked list and write any changes to the */
/* daily attendance file.						 */
/*-----------------------------------------------------------------------*/ 
ProcItemUpdates()
{
	Page	*temppage;
	int	i;
	int	retval;
	int	mode;

	if(StudLast != NULL) {
		for(temppage=FirstPage; temppage!=NULL;
		    temppage=temppage->NextPage) {
			for(i =0; i< temppage->NoItems; i++) {
				mode = CheckUpdateMode(temppage,i);
				if(mode < 0) {
					roll_back(e_mesg);
					return(mode);
				}
				if(mode == NOOP) {
					roll_back(e_mesg);
					continue;
				}

				retval = WriteRecords(temppage,i,mode);
				if(retval < 0) {
					if(retval == LOCKED) return(LOCKED);
					break;
				}
			}
			if(temppage == StudLast) break;
		}
	}
	return(NOERROR);
}
/*-----------------------------------------------------------------------*/ 
/* Check the see if record should be written in ADD, UPDATE, or P_DEL mode */
/*-----------------------------------------------------------------------*/ 
CheckUpdateMode(temppage,item_no)
Page	*temppage;
int	item_no;
{
	int	retval;
	int	mode;

	/* Get student for their s_seqno */
	strcpy(student.s_id,temppage->Items[item_no].s_stud_id);
	retval = get_student(&student,BROWSE,1,e_mesg);
	if(retval < 0) {	
		DispError((char *)&s_sth,e_mesg);
		return(retval);
	}

	strcpy(dailyatt.datt_sid,student.s_seqno);
	dailyatt.datt_mth = s_sth.s_tran_dt / 100;
	dailyatt.datt_day = s_sth.s_tran_dt % 100;

	/* blank out code because if UNDEF it retains old value */
	dailyatt.datt_cd[0] = '\0';

	retval = get_dailyatt(&dailyatt,UPDATE,0,e_mesg) ;
	if(retval < 0 && retval != UNDEF) {
		DispError((char *)&s_sth,e_mesg);
		return(retval);
	}

	if(retval == UNDEF) {
		if(temppage->Items[item_no].s_att_code[0] == '\0') 
			mode = NOOP;
		else
			mode = ADD;
	}
	else {
		if(temppage->Items[item_no].s_att_code[0]==dailyatt.datt_cd[0])
			mode = NOOP;
		else if(temppage->Items[item_no].s_att_code[0] == '\0' || 
		       		temppage->Items[item_no].s_att_code[0] == ' ') 
			mode = P_DEL;
		else 
			mode = UPDATE;
	}
	return(mode);
}
/*-----------------------------------------------------------------------*/ 
/* Write the Daily attendance record to the file.	  	         */
/*-----------------------------------------------------------------------*/ 
WriteRecords(temppage,item_no,mode)
Page	*temppage;
int	item_no;
int	mode;
{
	int	retval;

	if(mode != ADD) {
		scpy((char *)&pre_dailyatt,(char *)&dailyatt,
			sizeof(pre_dailyatt));
	}

	strcpy(dailyatt.datt_sid,student.s_seqno);
	dailyatt.datt_mth = s_sth.s_tran_dt / 100;
	dailyatt.datt_day = s_sth.s_tran_dt % 100;
	strcpy(dailyatt.datt_cd,temppage->Items[item_no].s_att_code);
	dailyatt.datt_ampm[0] = '\0';
	dailyatt.datt_time = 0;

	sprintf(e_mesg,"%s  %s  %s",dailyatt.datt_sid,student.s_name,
						dailyatt.datt_cd);
	fomce();
	fomen(e_mesg);

	retval = put_dailyatt(&dailyatt,mode,e_mesg) ;
	if(retval < 0) {
		DispError((char *)&s_sth,e_mesg);
		roll_back(e_mesg);
		return(retval);
	}


	if(mode != ADD) {
		retval = rite_audit((char*)&s_sth,DAILYATT,mode,(char*)&dailyatt,
			(char*)&pre_dailyatt,e_mesg);
		if(retval==LOCKED) {
			DispError((char *)&s_sth,e_mesg);
			roll_back(e_mesg) ;
			return(LOCKED) ;
		}
		if(retval < 0 ){
			DispError((char *)&s_sth,BADSAVE); 
			DispError((char *)&s_sth,e_mesg);
			roll_back(e_mesg);
			return(retval);
		}
	}

	retval = commit(e_mesg) ;
	if(retval < 0) {
		DispError((char *)&s_sth,BADSAVE); 
		DispError((char *)&s_sth,e_mesg);
		roll_back(e_mesg);
		return(retval);
	}
	return(NOERROR);
}
/*------------------------------------------------------------*/
/* Read details of given item# */
/*------------------------------------------------------------*/
ReadItem(item_no,mode)
int	item_no ;
int	mode ;
{
	int	i;
	int	st_fld ;
	int	end_fld ;

#ifdef ENGLISH
	strcpy(s_sth.s_mesg,"Press ESC-F to Terminate");
#else
	strcpy(s_sth.s_mesg,"Appuyer sur ESC-F pour terminer");
#endif
	DispMesgFld((char *)&s_sth);

	st_fld  = ITEM_ST_FLD + (STEP * item_no) + ATTCODE_FLD;
	end_fld = st_fld ;

	i = ReadFields((char *)&s_sth,st_fld,end_fld,ItemsValidation,
		ItemsWindowHelp,1) ;
	if(PROFOM_ERR == i || DBH_ERR == i) return(i) ;
	if(RET_USER_ESC == i) {
		/* When user gives ESC-F while changing fields, assumption is
		* he completed his changes, and remaining fields are same as
		* old. But, at this point STH will be having low values in the 
		* remaining fields. So move the old values form the linked list.
		*/

		i = CopyBack((char *)&s_sth,(char *)&image,sr.curfld, END_FLD);
		if(i == PROFOM_ERR) return(i);

		return(RET_USER_ESC) ;
	}

	return(NOERROR) ;
}	/* ReadItem() */
/*----------------------------------------------------------------*/
/* Set Duplication buffers for fields 				  */
SetDupBuffers( firstfld, lastfld, value )
int	firstfld, lastfld;	/* field numbers range */
int	value;			/* ENABLE or DISABLE */
{
	int i ;

	for( i=firstfld; i<=lastfld; i+=100 )
		fomca1( i, 19, value);
	if( value==0 )
		return(0);
	sr.nextfld = firstfld;
	sr.endfld = lastfld;
	fomud( (char *)&s_sth );
	ret( err_chk(&sr) );

	return( 0 );
}
/*----------------------------------------------------------------*/
/* Validation function() for Key and Header fields when PROFOM returns
  RET_VAL_CHK */

static
KeyAndHdrValidation()
{
	int	retval;

	switch(sr.curfld){
	case TRAN_DT_FLD:
		if((s_sth.s_tran_dt/100) > 12 || (s_sth.s_tran_dt/100) < 1) {
			fomer("Not A Valid School Date For Any School Type");
			s_sth.s_tran_dt = LV_SHORT;
			return(ERROR);
		}
		if((s_sth.s_tran_dt%100) > 31 || (s_sth.s_tran_dt%100) < 1) {
			fomer("Not A Valid School Date For Any School Type");
			s_sth.s_tran_dt = LV_SHORT;
			return(ERROR);
		}
                if(s_sth.s_tran_dt > (schl_rec.s_enddate % 10000) &&
		   s_sth.s_tran_dt < (schl_rec.s_stdate % 10000) ||
		   s_sth.s_tran_dt == 0) {
			retval = ERROR;
		}
		else {
			retval = CheckCalendar();
		}
		if(retval < 0) {
			fomer("Not A Valid School Date For Any School Type");
			s_sth.s_tran_dt = LV_SHORT;
			return(ERROR);
		}
		break;
	case SHIFT_FLD:
		if(s_sth.s_shift[0] != ALL) {
			shift.shft_no = atoi(s_sth.s_shift) ;
			retval = get_shift(&shift,BROWSE,0,e_mesg);	
			if(retval < 0) {
				fomer("Not a Valid Shift");
				s_sth.s_shift[0] = LV_CHAR;
				return(ERROR);
			}
		}
		break;	
	case INACT_FLD:
		if(s_sth.s_inactive[0] != YES && s_sth.s_inactive[0] != NO) {
			fomer(YORN);
			s_sth.s_inactive[0] = LV_CHAR;
			return(ERROR);
		}
		break;	
	case ST_HMRM_FLD:
		if(s_sth.s_st_hmrm[0] !='\0') {
			Right_Justify_Numeric(s_sth.s_st_hmrm,
					sizeof(s_sth.s_st_hmrm)-1);
			strcpy(homeroom.hr_code,s_sth.s_st_hmrm);
			retval = get_homeroom(&homeroom,BROWSE,0,e_mesg);
			if(retval < 0) {
				fomer("Not a Valid Homeroom");
				s_sth.s_st_hmrm[0] = LV_CHAR;
				return(ERROR);
			}
		}
		else {
			sr.curfld += 100;
		}
		break;	
	case EN_HMRM_FLD:
		if(s_sth.s_en_hmrm[0] != '\0') {
			Right_Justify_Numeric(s_sth.s_en_hmrm,
					sizeof(s_sth.s_en_hmrm)-1);
			strcpy(homeroom.hr_code,s_sth.s_en_hmrm);
			retval = get_homeroom(&homeroom,BROWSE,0,e_mesg);
			if(retval < 0) {
				fomer("Not a Valid Homeroom");
				s_sth.s_en_hmrm[0] = LV_CHAR;
				return(ERROR);
			}
			if(strcmp(s_sth.s_st_hmrm,s_sth.s_en_hmrm) > 0) {
				fomer("Ending Homeroom cannot be greater than Starting Homeroom");
				s_sth.s_en_hmrm[0] = LV_CHAR;
				return(ERROR);
			}
		}
		else {
			sr.curfld += 100;
		}
		break;	
	case ST_GLEVEL_FLD:
		if(s_sth.s_st_glevel[0] != '\0') {
			Right_Justify_Numeric(s_sth.s_st_glevel,
					sizeof(s_sth.s_st_glevel)-1);
			strcpy(glevel.glv_code,s_sth.s_st_glevel);
			retval = get_glevel(&glevel,BROWSE,0,e_mesg);
			if(retval < 0) {
				fomer("Not a Valid Grade Level");	
				s_sth.s_st_glevel[0] = LV_CHAR;
			}
		}
		else {
			sr.curfld += 100;
		}
		break;	
	case EN_GLEVEL_FLD:
		if(s_sth.s_en_glevel[0] != '\0') {
			Right_Justify_Numeric(s_sth.s_en_glevel,
					sizeof(s_sth.s_en_glevel)-1);
			strcpy(glevel.glv_code,s_sth.s_en_glevel);
			retval = get_glevel(&glevel,BROWSE,0,e_mesg);
			if(retval < 0) {
				fomer("Not a Valid Grade Level");	
				s_sth.s_en_glevel[0] = LV_CHAR;
			}
			if(strcmp(s_sth.s_st_glevel,s_sth.s_en_glevel) > 0) {
				fomer("Ending Grade Level cannot be greater than Starting Grade Level");
				s_sth.s_en_glevel[0] = LV_CHAR;
				return(ERROR);
			}
		}
		else {
			sr.curfld += 100;
		}
		break;	
	case STUD_FLD:
		if(s_sth.s_stud_nm[0] == '\0') {
			sr.curfld += 100;
		}
		break;	
	default :
#ifdef ENGLISH
		sprintf(e_mesg,"No Validity Check For Field#  %d",sr.curfld);
#else
		sprintf(e_mesg,"Pas de controle de validite pour le Champ#  %d",sr.curfld);
#endif
		fomen(e_mesg);
		get();
		return(ERROR) ;
	}	/* Switch sr.curfld */

	return(NOERROR) ;
}	/* KeyAndHdrValidation() */

/*----------------------------------------------------------------*/
/* Check the school calendar to see if the date entered is a      */
/* valid school day						  */
/*----------------------------------------------------------------*/
CheckCalendar()
{
	int	retval;

	schltype.st_code[0] = '\0';

	flg_reset(SCHTYPE);
	for(; ;) {
		retval = get_n_schtype(&schltype,BROWSE,0,FORWARD,e_mesg);
		if(retval < 0) {
			if(retval == EFL) break;
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}
			
		strcpy(calendar.cal_schtype,schltype.st_code);
		calendar.cal_month = s_sth.s_tran_dt / 100;
		calendar.cal_day = s_sth.s_tran_dt % 100;
		retval = get_calendar(&calendar,BROWSE,0,e_mesg);
		if(retval < 0) {
			if(retval == UNDEF) {
				retval = NOERROR;
				break;
			}
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}

		if(calendar.cal_code[0] == 'B' || calendar.cal_code[0] == 'E' ||
 		   calendar.cal_code[0] == 'A' || calendar.cal_code[0] == 'P'){
			break;
		}
	}

	return(retval);
}
/*----------------------------------------------------------------*/
/* Validation function() for Item fields when PROFOM returns RET_VAL_CHK */
ItemsValidation()
{
	int retval;
	int	item_no;

	item_no = (sr.curfld - ITEM_ST_FLD - ATTCODE_FLD) / STEP;

	if(s_sth.s_items[item_no].s_att_code[0] == '\0') {
		sr.curfld+=100;
		return(NOERROR);
	}

	if(s_sth.s_items[item_no].s_att_code[0] == schl_rec.s_entrycd[0] ||
	   s_sth.s_items[item_no].s_att_code[0] == schl_rec.s_leftcd[0] ||
	   s_sth.s_items[item_no].s_att_code[0] == schl_rec.s_hicode[0]) {
		fomer("Code Cannot be the Entry Code, Left Code, or HI Code");
		s_sth.s_items[item_no].s_att_code[0] = LV_CHAR;
		return(ERROR);
	}

	strcpy(dattcode.datt_cd,s_sth.s_items[item_no].s_att_code);
	retval = get_dattcode(&dattcode,BROWSE,0,e_mesg);
	if(retval < 0) {
		fomer("Not a Valid Attendance Code");
		s_sth.s_items[item_no].s_att_code[0] = LV_CHAR;
		return(ERROR);
	}

	if((calendar.cal_code[0] == 'A' || calendar.cal_code[0] == 'P') &&
	    dattcode.datt_abs > .5) {
		fomer("School Only in Session for Half a Day");
		s_sth.s_items[item_no].s_att_code[0] = LV_CHAR;
		return(ERROR);
	}
			
	return(NOERROR) ;
}	/* ItemsValidation() */
/*----------------------------------------------------------------*/
/* Show Help Windows, if applicable, when user gives ESC-H in key
   and header fields */

HdrAndKeyWindowHelp()
{
	int	retval ;
	short	temp_shift;

	switch(sr.curfld){
	case SHIFT_FLD:
		retval = shift_hlp(&temp_shift,7, 13);
		if(retval == DBH_ERR) return(retval);
		if(retval >= 0) redraw();
		sprintf(s_sth.s_shift,"%d",temp_shift);
		break;
	case ST_HMRM_FLD:
		retval = homeroom_hlp(s_sth.s_st_hmrm,7, 13);
		if(retval == DBH_ERR) return(retval);
		if(retval >= 0) redraw();
		break;
	case EN_HMRM_FLD:
		retval = homeroom_hlp(s_sth.s_en_hmrm,7, 13);
		if(retval == DBH_ERR) return(retval);
		if(retval >= 0) redraw();
		if(strcmp(s_sth.s_st_hmrm,s_sth.s_en_hmrm) > 0) {
			fomer("Ending Homeroom cannot be greater than Starting Homeroom");
			s_sth.s_en_hmrm[0] = LV_CHAR;
			return(ERROR);
		}
		break;
	case ST_GLEVEL_FLD:
		retval = glevel_hlp(s_sth.s_st_glevel,7, 13);
		if(retval == DBH_ERR) return(retval);
		if(retval >= 0) redraw();
		break;
	case EN_GLEVEL_FLD:
		retval = glevel_hlp(s_sth.s_en_glevel,7, 13);
		if(retval == DBH_ERR) return(retval);
		if(retval >= 0) redraw();
		if(strcmp(s_sth.s_st_glevel,s_sth.s_en_glevel) > 0) {
			fomer("Ending Grade Level cannot be greater than Starting Grade Level");
			s_sth.s_en_glevel[0] = LV_CHAR;
			return(ERROR);
		}
		break;
	default :
#ifdef ENGLISH
		fomer("No Help Window For This Field");
#else
		fomer("Pas de fenetre d'assistance pour ce champ");
#endif
	}	/* Switch sr.curfld */

	return(NOERROR) ;
}	/* HdrAndKeyWindowHelp() */
/*-----------------------------------------------------------------------*/
/* Items Help Window */
ItemsWindowHelp()
{
	int	item_no;
	int	retval;
	char	type[2];

	item_no = (sr.curfld - ITEM_ST_FLD - ATTCODE_FLD) / STEP;

	retval = dattcd_hlp(s_sth.s_items[item_no].s_att_code,type,7, 13);
	if(retval == DBH_ERR) return(retval);
	if(retval >= 0) redraw();
	if(retval == 0) return(NOERROR);

	if(s_sth.s_items[item_no].s_att_code[0] == schl_rec.s_entrycd[0] ||
	   s_sth.s_items[item_no].s_att_code[0] == schl_rec.s_leftcd[0] ||
	   s_sth.s_items[item_no].s_att_code[0] == schl_rec.s_hicode[0]) {
		fomer("Code Cannot be the Entry Code, Left Code, or HI Code");
		s_sth.s_items[item_no].s_att_code[0] = LV_CHAR;
		return(ERROR);
	}

	strcpy(dattcode.datt_cd,s_sth.s_items[item_no].s_att_code);
	retval = get_dattcode(&dattcode,BROWSE,0,e_mesg);
	if(retval < 0) {
		fomer("Not a Valid Attendance Code");
		s_sth.s_items[item_no].s_att_code[0] = LV_CHAR;
		return(ERROR);
	}
	
	if((calendar.cal_code[0] == 'A' || calendar.cal_code[0] == 'P') &&
	    dattcode.datt_abs > .5) {
		fomer("School Only in Session for Half a Day");
		s_sth.s_items[item_no].s_att_code[0] = LV_CHAR;
		return(ERROR);
	}

	return(NOERROR);
}	/* ItemsWindowHelp() */
/*-----------------------------------------------------------------------*/
/* Take the confirmation from user for the items part of the screen */

ConfirmItems()
{
	int	err ;

	/* Options:
	     YSLNPC
	*/

	for( ; ; ) {
#ifdef ENGLISH
		err = GetOption((char *)&s_sth,
		"Y(es), S(creen Edit), L(ine edit), N(ext), P(rev), C(ancel)"
		,"YSLNPC");
#else
		err = GetOption((char *)&s_sth,
		"O(ui), S(creen edit), L(ine edit), S(uiv), P(rec), A(nnul)"
		,"OSLA");
#endif

	    switch(err) {
	    case  YES  :
		return(YES);
	    case  SCREENEDIT:
		err = ScreenEdit();
		break;
	    case  LINEEDIT  :
		err = ChangeFields();
		break ;
	    case  NEXTPAGE:
		if(CurPage == StudLast || StudLast == NULL) {
#ifdef ENGLISH
			fomer("No More Pages....");
#else
			fomer("Plus de pages....");
#endif
			continue;
		}
		CurPage = CurPage->NextPage ;
		err = ShowItems(CurPage);
		break;
	    case  PREVPAGE:
		if(StudLast == NULL || CurPage == FirstPage) {
#ifdef ENGLISH
			fomer("No More Pages....");
#else
			fomer("Plus de pages....");
#endif
			continue;
		}
		CurPage = CurPage->PrevPage ;
		err = ShowItems(CurPage);
		break;
	    case  CANCEL :
#ifdef ENGLISH
		err = GetOption((char *)&s_sth,
				"Confirm the Cancel (Y/N)?", "YN") ;
#else
		err = GetOption((char *)&s_sth,
				"Confirmer l'annulation (O/N)?", "ON") ;
#endif
		if(err == YES) return(CANCEL) ;
		break ;
	    }	/* switch err */

	    if(err == PROFOM_ERR) return(err) ;
	    if(err == DBH_ERR) return(err) ;
	}	/* for(; ; ) */
}	/* ConfirmItems() */
/*---------------------------------------------------------------------*/
/* Change screen.  Allows editing of all the students on the screen    */
/*---------------------------------------------------------------------*/
ScreenEdit()
{
     	int i;
	int retval;

	/* make copy of screen incase user presses ESC-F */
	scpy((char *)&image,(char *)&s_sth,sizeof(s_sth));

#ifdef ENGLISH
	strcpy(s_sth.s_mesg,"Press ESC-F to Terminate");
#else
	strcpy(s_sth.s_mesg,"Appuyer sur ESC-F pour terminer");
#endif
	DispMesgFld((char *)&s_sth);

	if(SetDupBuffers(ITEM_ST_FLD, END_FLD - 200,1)<0) return(PROFOM_ERR);

	for(i=0;i < PAGESIZE; i++) {
		retval = ValidateStudent(i);
		if(retval < 0) return(retval);
	}

	retval=ReadFields((char *)&s_sth,ITEM_ST_FLD,END_FLD - 200,
			ItemsValidation,ItemsWindowHelp,1) ;
	if(retval == PROFOM_ERR || retval == DBH_ERR) return(retval);
	if(retval == RET_USER_ESC) {
		/* When user gives ESC-F while changing fields, assumption is
		* he completed his changes, and remaining fields are same as
		* old. But, at this point STH will be having low values in the 
		* remaining fields. So move the old values form the linked list.
		*/

		retval=CopyBack((char *)&s_sth,(char *)&image,
				sr.curfld,END_FLD - 200);
		if(retval == PROFOM_ERR) return(retval);

		return(RET_USER_ESC) ;
	}

	scpy((char *)&CurPage->Items,(char *)&s_sth.s_items,
			sizeof(CurPage->Items));

     	s_sth.s_mesg[0] = HV_CHAR ;
     	DispMesgFld((char *)&s_sth);

	if(SetDupBuffers(ITEM_ST_FLD, END_FLD-200,0)<0) return(PROFOM_ERR);

	return(NOERROR);
}	/* ScreenEdit() */
/*-----------------------------------------------------------------------*/
/* Changing fields. Accept fld of the student to be changed and read     */
/* that fld.		 */
ChangeFields()
{
	int retval;

	/* make copy screen every time field changed in case user */
	/* presses ESC-F */
	scpy((char*)&image,(char*)&s_sth, sizeof(s_sth));

	SetDupBuffers(ITEM_ST_FLD, END_FLD - 200, 1);

	/* Get The Field to Be Modified */
#ifdef	ENGLISH
	strcpy(s_sth.s_mesg,"Enter RETURN to Terminate Edit");
#else
	strcpy(s_sth.s_mesg,"Appuyer sur RETURN pour terminer l'ajustement");
#endif
	DispMesgFld((char *)&s_sth); ;
        
     	for (; ;) {
		s_sth.s_field = LV_SHORT;
		retval = ReadFields((char *)&s_sth,CHG_FLD,CHG_FLD,
			(int (*)())NULL,(int (*)())NULL, 1);

		if (retval < 0) return(-1);
		if (retval == RET_USER_ESC) break;	/* User enter ESC-F */

       		if (s_sth.s_field == 0 ) break;  /* Finished changing fields */

		retval = ValidateStudent(s_sth.s_field - 1);
		if(retval < 0) return(retval);
		if(retval == INVALID) continue;

		retval = ReadItem(s_sth.s_field - 1,UPDATE);
		if(retval != NOERROR) {
			return(retval);
		}
		strcpy(CurPage->Items[s_sth.s_field-1].s_att_code,
			s_sth.s_items[s_sth.s_field-1].s_att_code);

		/* reset dup buffers so if user edits same fields again */
		/* the last value valid value entered will be the default */
		SetDupBuffers(ITEM_ST_FLD, END_FLD - 200, 1);

		/* make copy screen every time field changed in case user */
		/* presses ESC-F */
		scpy((char*)&image,(char*)&s_sth, sizeof(s_sth));
	}

     	s_sth.s_field = HV_SHORT ;
	if ( WriteFields((char *)&s_sth,CHG_FLD, CHG_FLD) < 0 ) return(-1);

     	s_sth.s_mesg[0] = HV_CHAR ;
     	DispMesgFld((char *)&s_sth);

	if(SetDupBuffers(HDR_ST_FLD, HDR_END_FLD, 0)<0) return(PROFOM_ERR);

	return(NOERROR);
}	/* ChangeFields() */
/*-----------------------------------------------------------*/
/* Validate each student to make sure the date is valid for  */
/* that student and that the student is not transered or     */
/* inactive.						     */
/*-----------------------------------------------------------*/
ValidateStudent(item_no)
int	item_no;
{
	int	retval;

	strcpy(student.s_id,s_sth.s_items[item_no].s_stud_id);
	retval = get_student(&student,BROWSE,1,e_mesg);
	if(retval < 0) {	
		DispError((char *)&s_sth,e_mesg);
		return(retval);
	}

	if(s_sth.s_items[item_no].s_att_code[0] == schl_rec.s_entrycd[0] ||
	   s_sth.s_items[item_no].s_att_code[0] == schl_rec.s_leftcd[0] ||
	   s_sth.s_items[item_no].s_att_code[0] == schl_rec.s_hicode[0]) {
		return(INVALID);
	}

	strcpy(glevel.glv_code,student.s_glevel_cd);
	retval = get_glevel(&glevel,BROWSE,0,e_mesg);
	if(retval < 0) {
		return(retval);
	}
	strcpy(calendar.cal_schtype,glevel.glv_stype);
	calendar.cal_month = s_sth.s_tran_dt / 100;
	calendar.cal_day = s_sth.s_tran_dt % 100;
	retval = get_calendar(&calendar,BROWSE,0,e_mesg);
	if(retval < 0 && retval != UNDEF) {
		return(retval);
	}

	if(calendar.cal_code[0] == 'H' || calendar.cal_code[0] == 'S' ||
	   calendar.cal_code[0] == 'D') {
		sprintf(e_mesg,"%d/%d  %s",calendar.cal_month,calendar.cal_day,
				calendar.cal_code);
		fomer(e_mesg);
		return(INVALID);
	}

	s_sth.s_items[item_no].s_att_code[0] = LV_CHAR;

	return(NOERROR);
}	/* ValidateStudent() */
/*------------------------------------------------------------------------*/
/* Move High values to all data fields and clear the screen */

ClearScreen()
{
	int	i;

	/* Move High Values to Hedaer part */
	InitHdr(HV_CHAR, HV_SHORT) ;

	s_sth.s_dummy[0] = HV_CHAR ;
	s_sth.s_page = HV_SHORT;

	s_sth.s_day[0] = HV_CHAR;
	/* Move High Values to All items */
	for(i = 0 ; i < PAGESIZE ; i++)
		InitItem(i, HV_CHAR) ;

	ret( WriteFields((char *)&s_sth,HDR_ST_FLD, (END_FLD - 200)) );

	return(NOERROR);
}	/* ClearScreen() */
/*-------------------------------------------------------------------------*/
/* Initialize Screen Header with either Low or High Values */

InitHdr( t_char, t_short )
char	t_char ;
short	t_short ;
{
	s_sth.s_tran_dt = t_short;
	s_sth.s_inactive[0] = t_char;

	if(num_shifts > 1)
		s_sth.s_shift[0] = LV_CHAR;
	else
		s_sth.s_shift[0] = HV_CHAR;

	if(SW1) {
		s_sth.s_st_txt[0] = HV_CHAR;
		s_sth.s_st_col[0] = HV_CHAR;
		s_sth.s_st_hmrm[0] = HV_CHAR;
		s_sth.s_st_glevel[0] = HV_CHAR;
		s_sth.s_en_txt[0] = HV_CHAR;
		s_sth.s_en_col[0] = HV_CHAR;
		s_sth.s_en_hmrm[0] = HV_CHAR;
		s_sth.s_en_glevel[0] = HV_CHAR;
	}
	else if(SW2) {
		if(t_char != HV_CHAR) {
			strcpy(s_sth.s_st_txt,"Homeroom");
		}
		else {
			s_sth.s_st_txt[0] = t_char;
		}
		s_sth.s_st_col[0] = ':';
		s_sth.s_st_hmrm[0] = t_char;
		s_sth.s_st_glevel[0] = HV_CHAR;
		if(t_char != HV_CHAR) {
			strcpy(s_sth.s_en_txt,"Homeroom");
		}
		else {
			s_sth.s_en_txt[0] = t_char;
		}
		s_sth.s_en_col[0] = ':';
		s_sth.s_en_hmrm[0] = t_char;
		s_sth.s_en_glevel[0] = HV_CHAR;
	}
	else {
		if(t_char != HV_CHAR) {
			strcpy(s_sth.s_st_txt,"Grade Level");
		}
		else {
			s_sth.s_st_txt[0] = t_char;
		}
		s_sth.s_st_col[0] = ':';
		s_sth.s_st_hmrm[0] = HV_CHAR;
		s_sth.s_st_glevel[0] = t_char;
		if(t_char != HV_CHAR) {
			strcpy(s_sth.s_en_txt,"Grade Level");
		}
		else {
			s_sth.s_en_txt[0] = t_char;
		}
		s_sth.s_en_col[0] = ':';
		s_sth.s_en_hmrm[0] = HV_CHAR;
		s_sth.s_en_glevel[0] = t_char;
	}
	s_sth.s_stud_nm[0] = t_char;

	return(NOERROR) ;
}	/* InitHdr() */
/*-------------------------------------------------------------------------*/
/* Initialize Given screen item with either Low values or High values */
static
InitItem(item_no, t_char)
int	item_no ;
char	t_char ;
{
	s_sth.s_items[item_no].s_stud_id[0] = t_char ;
	s_sth.s_items[item_no].s_stud_nm[0] = t_char ;
	s_sth.s_items[item_no].s_stud_stat[0] = t_char ;
	s_sth.s_items[item_no].s_att_code[0] = t_char ;

	return(NOERROR) ;
}	/* Inititem() */
/* -------------------------------------------------------------------------*/
/* Reads the shift file backwards to find the highest shift number on file  */
static
int
ChkNoShifts()
{
	int retval;
		
	shift.shft_no = HV_SHORT;
	flg_reset(SHIFT);

	retval = get_n_shift(&shift,BROWSE,0,BACKWARD,e_mesg);
	
	if (retval != NOERROR) {
		fomen(e_mesg);
		get();
		return(ERROR);
	}
	return(shift.shft_no);
}
/*-------------------- E n d   O f   P r o g r a m ---------------------*/
