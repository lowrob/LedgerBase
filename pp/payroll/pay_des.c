/*-----------------------------------------------------------------------
Source Name: Pay_des.c
System     : Cheque Pre-processing
Created  On: October 18, 1991.
Created  By: Eugene Roy.

DESCRIPTION:
	Program to De-Select the employee selected for payment.

MODIFICATIONS:        

Programmer     YY/MM/DD       Description of modification
~~~~~~~~~~     ~~~~~~~~       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
------------------------------------------------------------------------*/

#define	MAIN

#include <stdio.h>
#include <cfomstrc.h>
#include <bfs_defs.h>
#include <bfs_pp.h>

#define	SYSTEM		"CHEQUE PRE-PROCESSING"	/* Sub System Name */
#define	MOD_DATE	"18-OCT-91"		/* Program Last Modified */

#define	ESC_F		1	/* ESC-F is active */

/* User Interface define constants */
#ifdef ENGLISH
#define DESELECT	'D'
#define EXITOPT		'E'

#define	YES		'Y'
#define	EDIT		'E'
#define	CANCEL		'C'
#else
#define DESELECT	'R'
#define EXITOPT		'F'

#define	YES		'O'
#define	EDIT		'M'
#define	CANCEL		'A'
#endif
/* PROFOM Releted declarations */

#define	SCR_NAME	"pay_des"	/* PROFOM screen Name */

/* PROFOM Screen STH file */

/* Field PROFOM numbers */

#define	OPTION_FLD	1100	/* Option: */
#define	KEY_START	400	/* Key Start Field */
#define	KEY_END		400	/* Key Start Field */
#define	END_FLD		1300	/* Last Field of the screen */
#define	EMP_FLD		400	/* Employee Cd: */
#define	EMPNAME_FLD	500	/* Employee Name: */
#define	POSTALCD_FLD	1000	/* Postal Code: */

/* deselect.sth - header for C structure generated by PROFOM EDITOR */

struct	s_struct	{

	char	s_pgm[11];	/* STRING XXXXXXXXXX Field 100 */
	long	s_rundate;	/* DATE YYYYFMMFDD Field 300 */
	char	s_emp[13];	/* STRING XXXXXXXXXX Field 400 */
	char	s_name[31];	/* STRING X[30] Field 500 */
	char	s_add1[31];	/* STRING X[30] Field 600 */
	char	s_add2[31];	/* STRING X[30] Field 700 */
	char	s_add3[31];	/* STRING X[30] Field 800 */
	char	s_add4[31];	/* STRING X[30] Field 900 */
	char	s_pc[11];	/* STRING X[7] Field 1000 */
	char	s_option[2];	/* STRING X Field 1100 */
	char	s_mesg[78];	/* STRING X[77] Field 1200 */
	char	s_resp[2];	/* STRING X Field 1300 */
};

static	struct	s_struct  s_sth;	/* PROFOM Screen Structure */

static	struct  	stat_rec  sr;	/* PROFOM status rec */

Emp	emp_rec;	/* Employee file	*/
Time		time_rec;	/* Time	*/
Pay_earn	pp_earn;	/* Pay Period Earnings File	*/
Pp_ben		pp_ben;		/* Pay Period benefit file	*/
Pay_ded		pp_ded;		/* Pay Period deduction file	*/
Pay_garn	pp_garn;	/* Pay Period garnishment file	*/
Pay_loan	pp_loan;	/* Pay Period garnishment file	*/
Jr_ent		jr_ent;		/* Journal Entry File		*/

char 		e_mesg[100];	/* dbh will return err msg in this */

int	Validate(), WindowHelp() ;
double	D_Roundoff();

/*------------------------------------------------------------------------*/

main(argc,argv)
int	argc;
char	*argv[];
{
	int	err;

	if(argc < 2){
#ifdef  DEVELOP
		printf("MAIN ARGUMENTS ARE NOT PROPER\n");
		printf("Usage: %s {-tTerminal Name} {-dDist#} [{-sSwitches}]\n",
			argv[0]);
#endif
		exit(1);
	}

	err = Initialize(argc,argv) ;	/* Initialize Variables , DBH
						Environment and PROFOM */
	if(err == NOERROR) err = Process();	/* Initiate Process */

	CloseProcess() ;

	if(err != NOERROR)exit(1);
	exit(0);
}	/* main() */
/*-------------------------------------------------------------------*/
/* Initialize Variables, PROFOM, DBH etc. */

Initialize(argc, argv)
int	argc ;
char	*argv[] ;
{
	int	i ;

	/*
	*	Initialize DBH Environment
	*/
	strncpy(SYS_NAME,SYSTEM,50);	/* Sub system name */
	strncpy(CHNG_DATE,MOD_DATE,10);	/* Modification Date */

	proc_switch(argc, argv, CHEQUE) ;	/* Process Switches */

	/*
	*	Initialize PROFOM & Menu Screen
	*/
	STRCPY(sr.termnm,terminal);	/* Copy Terminal Name */
	fomin(&sr);
	ret(err_chk(&sr)) ;		/* Check for PROFOM Error */
	fomcf(1,1);			/* Enable Snap screen option */

	/* move screen name to Profom status structure */
	STRCPY(sr.scrnam,NFM_PATH);
	strcat(sr.scrnam,SCR_NAME) ;

	/* Initialize SCR */
	STRCPY(s_sth.s_pgm,PROG_NAME);
	s_sth.s_rundate = get_date();	/* get Today's Date in YYYYMMDD format*/
	s_sth.s_mesg[0] = HV_CHAR ;
	s_sth.s_resp[0] = HV_CHAR ;

	MoveLVs() ;

	ret(WriteFields((char*)&s_sth,EMP_FLD, END_FLD) );

	return(NOERROR) ;
}	/* Initialize() */
/*-------------------------------------------------------------------*/
/* Get Option: from user and call corresponding function */

Process()
{
	int err;

	for( ; ; ){
		/* Get the Option: from the user */
		if((err = ReadOption()) != NOERROR) return(err) ;

		err = ProcOption() ;	/* Process Option */

		if(QUIT == err)		return(NOERROR) ;	/* Exit */
		if(NOACCESS == err)	fomen(e_mesg);
		if(PROFOM_ERR == err)	return(PROFOM_ERR);  /* PROFOM ERROR */
		if(DBH_ERR == err) {
			DispError((char *)&s_sth,e_mesg);
#ifdef ENGLISH
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"System Error... Iserror:",
				iserror, dberror, errno);
#else
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"Erreur du systeme... Iserror:",
				iserror, dberror, errno);
#endif
			DispError((char *)&s_sth,e_mesg);
			return(DBH_ERR);	/* DBH ERROR */
		}
	}      /*   end of the for( ; ; )       */
}	/* Process() */
/*----------------------------------------------------------------*/
/* Close necessary files and environment before exiting program */

CloseProcess()
{
	/* Set terminal back to normal mode from PROFOM */
	fomcs();
	fomrt();

	close_dbh();	/* Close DBH(files) */

	return(NOERROR) ;
}	/* CloseProcess() */
/*----------------------------------------------------------------*/
/* Display the Options (Option:) and get the option from the user */

ReadOption()
{
	/* Display options */
#ifdef ENGLISH
	fomer("D(e-Select), E(xit)");
#else
	fomer("R(etrait), F(in)");
#endif
	/* Read Option: field */
	sr.nextfld = OPTION_FLD ;
	fomrf( (char *)&s_sth );
	ret(err_chk(&sr));	/* Check for PROFOM error */

	return(NOERROR) ;
}	/* ReadOption() */
/*----------------------------------------------------------------*/
/* Process the user selected option */

ProcOption()
{
	int retval;

	switch (s_sth.s_option[0]) {
	case DESELECT  :		/* De-Select */
		CHKACC(retval,P_DEL,e_mesg);
		return( DeSelectProcess() ) ;
	case EXITOPT  :			/* Exit */
		return( QUIT ) ;
	}  /*   end of the switch statement */

	if(retval<0) 
		return(retval);

	return(NOERROR);
}	/* ProcOption() */
/*-----------------------------------------------------------------------*/
/* Take the Keys for de-selection from the user. When he confirms it
   do the de-selection */

DeSelectProcess()
{
	int	err ;

	/* If the Current Period == 0 (i.e before yearly closing), Add or
	   Change is not allowed */

	err = GetItemKey() ;
	if(PROFOM_ERR == err || DBH_ERR == err) return(err) ;
	if(NOERROR != err) {
		MoveLVs() ;
		ret( WriteFields((char *)&s_sth,KEY_START, POSTALCD_FLD) ) ;
		roll_back(e_mesg) ;	/* Unlock the locked Records */
		return(err) ;
	}

	err = Des_Emp() ;
	if(NOERROR != err) {
		roll_back(e_mesg) ;
		return(err) ;
	}

	return(NOERROR) ;
}	/* DeSelectProcess() */
/*----------------------------------------------------------------------*/
/* Get the De-selection key from user */

GetItemKey()
{
	int	i;

	for(i = KEY_START ; i <= KEY_END ; i += 100)
		fomca1(i,19,0) ;

#ifdef ENGLISH
	STRCPY(s_sth.s_mesg,"Press ESC-F to Go Back to Fn:");
#else
	STRCPY(s_sth.s_mesg,"Appuyer sur ESC-F pour retourner a Fn:");
#endif
	DispMesgFld((char *)&s_sth);

	MoveLVs() ;

	i = ReadFields((char *)&s_sth,KEY_START, KEY_END, Validate,WindowHelp,1) ;
	if(PROFOM_ERR == i || DBH_ERR == i) return(i) ;
	if(RET_USER_ESC == i){
		s_sth.s_mesg[0] = HV_CHAR;
	DispMesgFld((char *)&s_sth);
		return(ERROR) ;
	}

	i = Confirm() ;		/* Confirm the Selection */
	if(i != YES) return(i) ;

	return(NOERROR);
}	/*  GetItemKey() */
/*-----------------------------------------------------------------------*/
/* Take the confirmation from user for the keys */

Confirm()
{
	int	err ;

	for( ; ; ) {
#ifdef ENGLISH
		err = GetOption((char *)&s_sth,"Y(es), E(dit), C(ancel)", "YEC");
#else
		err = GetOption((char *)&s_sth,"O(ui), M(odifier), A(nnuler)", "OMA");
#endif
		if(err == PROFOM_ERR) return(err) ;

		switch(err) {
		case  YES :
		    return(YES) ;
		case  EDIT  :
		    err = ChangeItemKey();
		    break ;
		case  CANCEL :
#ifdef ENGLISH
		    err = GetOption((char *)&s_sth,"Confirm the Cancel (Y/N)?", "YN") ;
#else
		    err = GetOption((char *)&s_sth,"Confirmer l'annulation (O/N)?", "ON") ;
#endif
		    if(err == YES) return(CANCEL) ;
		    break ;
		}	/* switch err */

		if(err == PROFOM_ERR) return(err) ;
		if(err == DBH_ERR) return(err) ;
	}	/* for(; ; ) */
}	/* Confirm() */
/*----------------------------------------------------------------------*/
/* Changing user given keys */

ChangeItemKey()
{
	int	i;

	for(i = KEY_START ; i <= KEY_END ; i += 100)
		fomca1(i,19,2) ;

	sr.nextfld = KEY_START ;
	sr.endfld  = KEY_END ;
	fomud((char*)&s_sth) ;
	ret(err_chk(&sr));

	MoveLVs() ;

	i = ReadFields((char *)&s_sth,KEY_START, KEY_END,Validate,WindowHelp,1) ;
	if(i < 0) return(i) ;

	return(NOERROR);
}	/* ChangeItemKey() */
/*----------------------------------------------------------------*/
/* Validation function() for Data fields when PROFOM returns RET_VAL_CHK */

Validate()
{
	int	err ;
	int	save_nextfld, save_endfld;

	switch(sr.curfld){
	case	EMP_FLD	:	/* Employee #: */
		err = CheckEmp(s_sth.s_emp,UPDATE) ;
		if(DBH_ERR == err) return(err) ;
		if(ERROR == err) {
			s_sth.s_emp[0] = LV_CHAR ;
			return(ERROR) ;
		}
		err = DisplayAddress() ;
		if(NOERROR != err) return(err) ;
		
		break ;
	default :
#ifdef ENGLISH
		sprintf(e_mesg,"No Validity Check For Field#  %d",sr.curfld);
#else
		sprintf(e_mesg,"Pas de controle de validite pour le Champ#  %d",sr.curfld);
#endif
		fomen(e_mesg);
		get();
		return(ERROR) ;
	}	/* Switch sr.curfld */

	return(NOERROR) ;
}	/* Validate() */
/*----------------------------------------------------------------*/
/* Show Help Windows, if applicable, when user gives ESC-H */

WindowHelp()
{
	int	err ;

/*
	switch(sr.curfld){
	case	EMP_FLD	:
		err = emp_hlp(s_sth.s_emp, 7, 13 );
		if(err == DBH_ERR) return(err) ;
		if(err >=0 ) redraw();
		if(err < 1) return(ERROR) ;

		err = CheckEmp(s_sth.s_emp,UPDATE) ;
		if(DBH_ERR == err) return(err) ;
		if(ERROR == err) {
			s_sth.s_emp[0] = LV_CHAR ;
			return(ERROR) ;
		}
		err = DisplayAddress() ;
		if(NOERROR != err) return(err) ;
		break ;
	default :
#ifdef ENGLISH
		fomer("No Help Window For This Field");
#else
		fomer("Pas de fenetre d'assistance pour ce champ");
#endif
		return(ERROR) ;
	}

*/
	return(NOERROR) ;
}	/* WindowHelp() */
/*-------------------------------------------------------------------------*/
/* Display the employee Name and Address */

DisplayAddress()
{
	int	curfld, endfld ;

	curfld = sr.curfld ;
	endfld = sr.endfld ;

	strcpy(s_sth.s_name,emp_rec.em_first_name);
	strcat(s_sth.s_name,", ");
	strcat(s_sth.s_name,emp_rec.em_last_name);
	STRCPY(s_sth.s_add1, emp_rec.em_add1) ;
	STRCPY(s_sth.s_add2, emp_rec.em_add2) ;
	STRCPY(s_sth.s_add3, emp_rec.em_add3) ;
	STRCPY(s_sth.s_add4, emp_rec.em_add4) ;
	STRCPY(s_sth.s_pc  , emp_rec.em_pc  ) ;

	ret( WriteFields((char *)&s_sth, EMPNAME_FLD, POSTALCD_FLD)) ;

	sr.curfld = curfld ;
	sr.endfld = endfld ;
	
	return(NOERROR) ;
}	/* DisplayAddress() */
/*-------------------------------------------------------------------------*/
/* MOve low values to screen data fields */

MoveLVs()
{
	s_sth.s_emp[0] = LV_CHAR ;

	s_sth.s_name[0] = LV_CHAR ;
	s_sth.s_add1[0] = LV_CHAR ;
	s_sth.s_add2[0] = LV_CHAR ;
	s_sth.s_add3[0] = LV_CHAR ;
	s_sth.s_add4[0] = LV_CHAR ;
	s_sth.s_pc[0]   = LV_CHAR ;

	return(NOERROR) ;
}	/* MoveLVs()() */
/*----------------------------------------------------------------*/
/* Check the given Employee availability in file */

CheckEmp(emp,mode)
char	*emp ;
int	mode ;
{
	int	err ;
	Right_Justify_Numeric(emp,(sizeof(emp_rec.em_numb)-1));
	STRCPY(emp_rec.em_numb,emp) ;
	err = get_employee(&emp_rec, mode, 0, e_mesg) ;
	if(err < 0) {
		DispError((char *)&s_sth,e_mesg) ;
		return(ERROR) ;
	}

	return(NOERROR) ;
}	/* CheckEmp() */
/*----------------------------------------------------------------*/
/*  Deselect employee's selected for payment			*/

Des_Emp()
{
	int	err ;

	strcpy(pp_earn.pe_numb,s_sth.s_emp) ;
	pp_earn.pe_pp = 0;
	pp_earn.pe_date = 0;
	flg_reset(PP_EARN);

	for( ; ; ){
		err = get_n_pp_earn(&pp_earn,UPDATE, 0, FORWARD, e_mesg) ;
		if(err < 0) {
			if(err == EFL) break;
			DispError((char *)&s_sth,e_mesg) ;
			roll_back(e_mesg);
			return(ERROR) ;
		}
		if(strcmp(pp_earn.pe_numb, s_sth.s_emp) != 0)
			break;
		err = put_pp_earn(&pp_earn,P_DEL,e_mesg) ;
		if(err < 0) {
			DispError((char *)&s_sth,e_mesg);
			roll_back(e_mesg);
			return(err);
		}

		err = commit(e_mesg) ;
		if(err < 0) {
			DispError((char *)&s_sth,e_mesg);
			roll_back(e_mesg);
			return(err);
		}
	}
	seq_over(PP_EARN);

	strcpy(pp_ben.pb_numb,s_sth.s_emp) ;
	pp_ben.pb_pp = 0;
	pp_ben.pb_date = 0;
	pp_ben.pb_code[0] = '\0';
	pp_ben.pb_fund = 0;
	pp_ben.pb_acct[0] = '\0';
	flg_reset(PP_BEN);

	for( ; ; ){
		err = get_n_pp_ben(&pp_ben,UPDATE, 0, FORWARD, e_mesg) ;
		if(err < 0) {
			if(err == EFL) break;
			DispError((char *)&s_sth,e_mesg) ;
			roll_back(e_mesg);
			return(ERROR) ;
		}
		if(strcmp(pp_ben.pb_numb, s_sth.s_emp) != 0)
			break;
		err = put_pp_ben(&pp_ben,P_DEL,e_mesg) ;
		if(err < 0) {
			DispError((char *)&s_sth,e_mesg);
			roll_back(e_mesg);
			return(err);
		}
		err = commit(e_mesg) ;
		if(err < 0) {
			DispError((char *)&s_sth,e_mesg);
			roll_back(e_mesg);
			return(err);
		}
	}
	seq_over(PP_BEN);

	strcpy(pp_ded.pd_numb,s_sth.s_emp);
	pp_ded.pd_pp = 0;
	pp_ded.pd_date = 0;
	pp_ded.pd_code[0] = '\0';
	pp_ded.pd_group[0] = '\0';
	pp_ded.pd_fund = 0;
	pp_ded.pd_acct[0] = '\0';
	flg_reset(PP_DED);

	for( ; ;){
		err = get_n_pp_ded(&pp_ded,UPDATE,0,FORWARD,e_mesg);

		if(err < 0) {
			if(err == EFL) break;
			DispError((char *)&s_sth,e_mesg) ;
			roll_back(e_mesg);
			return(ERROR) ;
		}
		if(strcmp(pp_ded.pd_numb,s_sth.s_emp) != 0)
			break;

		err = put_pp_ded(&pp_ded,P_DEL,e_mesg);	
		if(err < 0) {
		 	DispError((char *)&s_sth,e_mesg);
			roll_back(e_mesg);
		  	return(ERROR);
		}
		err = commit(e_mesg) ;
		if(err < 0) {
			DispError((char *)&s_sth,e_mesg);
			roll_back(e_mesg);
			return(err);
		}
	}
	seq_over(PP_DED);

	strcpy(pp_loan.pc_numb,s_sth.s_emp);
	pp_loan.pc_pp = 0;
	pp_loan.pc_date = 0;
	pp_loan.pc_code[0] = '\0';
	pp_loan.pc_seq = 0;
	pp_loan.pc_fund = 0;
	pp_loan.pc_acct[0] = '\0';
	flg_reset(PP_LOAN);

	for( ; ;){
		err = get_n_pp_loan(&pp_loan,UPDATE,0,FORWARD,e_mesg);
		if(err < 0) {
			if(err == EFL) break;
			DispError((char *)&s_sth,e_mesg) ;
			roll_back(e_mesg);
			return(ERROR) ;
		}
		if(strcmp(pp_loan.pc_numb,s_sth.s_emp) != 0)
			break;

		err = put_pp_loan(&pp_loan,P_DEL,e_mesg);	
		if(err < 0) {
		 	DispError((char *)&s_sth,e_mesg);
			roll_back(e_mesg);
		  	return(ERROR);
		}

		err = commit(e_mesg) ;
		if(err < 0) {
			DispError((char *)&s_sth,e_mesg);
			roll_back(e_mesg);
			return(err);
		}
	}
	seq_over(PP_LOAN);

	strcpy(pp_garn.pg_numb,s_sth.s_emp);
	pp_garn.pg_pp = 0;
	pp_garn.pg_date = 0;
	pp_garn.pg_pr_cd = 0;
	pp_garn.pg_seq = 0;
	pp_garn.pg_fund = 0;
	pp_garn.pg_acct[0] = '\0';
	flg_reset(PP_GARN);

	for( ; ;){
		err = get_n_pp_garn(&pp_garn,UPDATE,0,FORWARD,e_mesg);
		if(err < 0) {
			if(err == EFL) break;
			DispError((char *)&s_sth,e_mesg) ;
			roll_back(e_mesg);
			return(ERROR) ;
		}
		if(strcmp(pp_garn.pg_numb,s_sth.s_emp) != 0)
			break;

		err = put_pp_garn(&pp_garn,P_DEL,e_mesg);
		if(err < 0) {
		 	DispError((char *)&s_sth,e_mesg);
			roll_back(e_mesg);
		  	return(ERROR);
		}
		err = commit(e_mesg) ;
		if(err < 0) {
			DispError((char *)&s_sth,e_mesg);
			roll_back(e_mesg);
			return(err);
		}

	}
	seq_over(PP_GARN);

	strcpy(jr_ent.jr_emp_numb,s_sth.s_emp);
	jr_ent.jr_code[0] = '\0';
	jr_ent.jr_fund = 0;
	jr_ent.jr_no = 0;
	flg_reset(JR_ENT);

	for( ; ;){
		err = get_n_jr_ent(&jr_ent,UPDATE,1,FORWARD,e_mesg);
		if(err < 0) {
			if(err == EFL) break;
			DispError((char *)&s_sth,e_mesg) ;
			roll_back(e_mesg);
			return(ERROR) ;
		}
		if(strcmp(jr_ent.jr_emp_numb,s_sth.s_emp) != 0)
			break;

		err = put_jr_ent(&jr_ent,P_DEL,e_mesg);	
		if(err < 0) {
		 	DispError((char *)&s_sth,e_mesg);
			roll_back(e_mesg);
		  	return(ERROR);
		}

		err = commit(e_mesg) ;
		if(err < 0) {
			DispError((char *)&s_sth,e_mesg);
			roll_back(e_mesg);
			return(err);
		}
	}
	seq_over(JR_ENT);

	return(NOERROR);
}
/*-------------------- E n d   O f   P r o g r a m ---------------------*/
