/*----------------------------------------------------------------------
Source Name: benadj.c  
System     : PP
Module     : Payroll/Personel
Created On : Oct. 28, 1991
Created By : Sheldon Floyd

DESCRIPTION:

	This program allows changes made to the employee benefits before
	calculating deductions.

MODIFICATIONS:        

Programmer     	YY/MM/DD       	Description of modification
~~~~~~~~~~     	~~~~~~~~       	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
------------------------------------------------------------------------*/

#define	MAIN	
#define	MAINFL		DEDUCTION

#include <stdio.h>
#include <ctype.h>
#include <cfomstrc.h>
#include <repdef.h>
#include <bfs_defs.h>
#include <bfs_pp.h>
#include <bfs_com.h>
#include <pp_msgs.h>

#define MOD_DATE	"29-OCT-91"
#define SYSTEM   	"PAYROLL/PERSONEL"

#define	SCRNM1		"benadj"
#define	PRGNM		"benadj"

#define	ALLOC_ERROR	-19
#define	MAX_KEYS	12

#ifdef ENGLISH

#define NEXT		'N'
#define EDITITEMS	'E'
#define INQREC		'I'
#define REACTIVATE	'R'
#define PREV		'P'
#define END 		'E'
#define ACTIVE		"ACT"
#define INACTIVE	"DEL"
#define	CHGREC		'C'
#define EXIT		'E'
#define NEXTREC		'N'
#define PREVREC		'P'
#define ITEMEDIT	'I'
#define YES		'Y'
#define NO		'N'
#define	LINEEDIT	'L'
#define	SCREDIT		'S'

#define	FIRST_SCR	'1'
#define	SECOND_SCR	'2'
#define	CANCEL		'C'
#define	ALL		'A' 
#define EARNED		'E'

#else		/* if FRENCH */

#define NEXT		'N'
#define EDITITEMS	'E'
#define INQREC		'I'
#define REACTIVATE	'R'
#define PREV		'P'
#define END 		'E'
#define ACTIVE		"ACT"
#define INACTIVE	"DEL"
#define	CHGREC		'C'
#define EXIT		'E'
#define NEXTREC		'N'
#define PREVREC		'P'
#define ITEMEDIT	'I'
#define YES		'O'
#define NO		'N'
#define	LINEEDIT	'M'
#define	SCREDIT		'C'
#define	FIRST_SCR	'1'
#define	SECOND_SCR	'2'
#define	CANCEL		'A'
#define	ALL		'T' 
#define EARNED		'E'

#endif


#define STEP		400
#define	NO_ITEMS	11

/*-------------------- screen 1 information -------------------------*/

/* repcd1.sth - header for C structure generated by PROFOM EDITOR */
typedef struct{
	char	s_bencd[7];	/* benefit code */
	char	s_bdesc[31];	/* benefit description */
	double	s_amount;	/* benefit amount */
	char	s_status[4];	/* status */
	} S1_item;

typedef struct{
	long	s_sysdate;	/* 300 system date */
	char	s_ftn[2];	/* 400 fucntion */
	char	s_empcd[13];	/* 500 employee code */
	short	s_field;	/* 600 field: */
	char	s_name[31];	/* 800 employee name */
	char	s_empstat[2];	/* 900 employee status */
	short	s_page;		/* 1000 line number 1 */
	char	s_dummy1[4];	/* 1200 dummy field 1 */
	char	s_dummy2[2];	/* 1300 dummy field 2 */
	S1_item	s_bens[NO_ITEMS];/*1400 - 5700 benefit information */
	char	s_mesg[78];	/* 5800 message line */
	char	s_opt[2];	/* 5900 message option line */
	} s1_struct;

#define FTN_FLD1	400	/* function field */
#define EMPCD_FLD	500	/* employee code field */
#define	CHG_FLD 	600	/* field: prompt */
#define NAME_FLD	800	/* employee name field */

#define ESTAT_FLD	900	/* employee status field */
#define PAGE_FLD	1000	/* page number field */

#define STITEM		1400	/* start item field */
#define ENDITEM		5700 	/* end item field */
#define STAMOUNT	1600	/* start amount field */

#define	MESG_FLD1	5800	/* message field */
#define	OPT_FLD1	5900	/* option field */

static	Pp_ben		payben;		/* pay period benefit file */
static	Pay_earn	payearn;	/* pay period earnings fiel */
static  Jr_ent		jrent;		/* journal entry file */
static	Aud_pay		audpay;		/* audit file */
static  Emp		emprec;		/* employee file */
static	Barg_unit	barg_unit;	/* bargaining unit file */
static	Benefit		ben;		/* benefit file */
static  Pay_per		payper;		/* pay period file */

struct stat_rec	sr;
s1_struct	s_sth, tmp_sth;

char	e_mesg[80];

/* link list node for holding one page of entries */

typedef	struct 	 pgofitems{

	struct 	 pgofitems *prevptr;	/* pointer to previous entry */
	int	 lines_entered;		/* no of lines entered */
	S1_item  fields[NO_ITEMS];	/* array of lines per page */
	double   pr_amount[NO_ITEMS];	/* array of old totals */
	struct	 pgofitems *nextptr;	/* pointer to next entry */

}	Page;

typedef struct{		/* structure to record current page & line of entry */
	short	page;
	short	line;
}	Counter;

static int totalitemsadded;		/* total items added in add session */
static Page	*headptr,*tempptr, 
		*tailptr,*itemptr; 	/* to maintain list */

static Counter	current;		/* Forcurrent line & page of item */
int line_no;

char	txt_buff[80];	
char	txt_buff2[80];	
int	first_time = 0;
double	new_total, old_total;
int	esc_flg;
long	temp_date;
short	temp_pp;
double	D_Rountoff();

static	int	Validate();
static	int	WindowHelp();

/*-------------------------------------------------------------------*/

main(argc,argv)
int argc;
char *argv[];
{
	
	strncpy(SYS_NAME,SYSTEM,50);		/* Sub system name */
	strncpy(CHNG_DATE,MOD_DATE,10);		/* Modification Date */
	proc_switch(argc, argv, MAINFL) ; 	/* Process Switches */

	strcpy(sr.termnm,terminal);	/* Copy Terminal Name */
	
	if (Initialize()<0)
		exit(-1);		/* Initialization routine */

	if (Benadj() < 0){ 		/* maintenance processing */
		Close();
		exit(-1);
	}

	Close();			/* return to menu */
	exit(NOERROR);

} /* end of main */

/*-------------------------------------------------------------------*/
/* Reset information */

static
Close()
{
	/* Set terminal back to normal mode from PROFOM */
	FreeList();
	fomcs();
	fomrt();
	close_dbh();			/* Close files */
	close_rep();

	return(NOERROR);
}

/*-------------------------------------------------------------------*/
/* Initialize PROFOM  and Screens*/

static
Initialize()
{

	if(InitProfom()<0) { 			/* Initialize PROFOM */
		fomcs();
		fomrt();
		return(-1);
	}	
	if(InitScreens()<0) { 
		fomcs();
		fomrt();
		return(-1);
	}	

	return(NOERROR);
}
/*-------------------------------------------------------------------*/
/* Initialize PROFOM */
static
InitProfom()
{
	fomin(&sr);		/* Check for Error */
	ret( err_chk(&sr) );

	fomcf(1,1);		/* Enable Print screen option */
	return(NOERROR);

}	/* InitProfom() */
/*----------------------------------------------------------------*/
/* Initialize screens before going to process options */
static
InitScreens()
{
	int i; 

	strcpy(sr.scrnam,NFM_PATH);
	strcat(sr.scrnam,SCRNM1) ;

	s_sth.s_sysdate = get_date();	
	s_sth.s_field = HV_SHORT ;

	s_sth.s_empcd[0] = HV_CHAR;
	s_sth.s_name[0] = HV_CHAR;
	s_sth.s_ftn[0] = HV_CHAR;
	s_sth.s_page = HV_SHORT;

	s_sth.s_dummy1[0] = HV_CHAR;
	s_sth.s_dummy2[0] = HV_CHAR;
	s_sth.s_empstat[0] = HV_CHAR;

	for(i=0;i<NO_ITEMS;i++){
		s_sth.s_bens[i].s_bencd[0] = HV_CHAR;
		s_sth.s_bens[i].s_bdesc[0] = HV_CHAR;
		s_sth.s_bens[i].s_amount = HV_DOUBLE;
		s_sth.s_bens[i].s_status[0] = HV_CHAR;
	}
	
	s_sth.s_mesg[0] = HV_CHAR;
	s_sth.s_opt[0] = HV_CHAR;
	if(WriteFields((char*)&s_sth,FTN_FLD1,OPT_FLD1)<0) return(-1);

	return(NOERROR);

}	/* InitScreens() */
/*-------------------------------------------------------------------
process maintenance selections and make changes to file
-------------------------------------------------------------------*/
static
Benadj() 
{
	int retval;
	payearn.pe_numb[0] = '\0';
	payearn.pe_date = LV_LONG;
	payearn.pe_pp = LV_SHORT;
	flg_reset(PP_EARN);

	for(;;){
#ifdef ENGLISH
		fomen("C(hange), I(nquire), N(ext), P(rev), E(xit)");
#else
		fomen("C(hange), I(nquire), N(ext), P(rev), E(xit)");
#endif

		s_sth.s_ftn[0] = LV_CHAR;

		/* read the screen fields */
		retval = ReadFields((char*)&s_sth,FTN_FLD1,FTN_FLD1,Validate,
							WindowHelp,1);
		if(retval == RET_USER_ESC) continue;
		if(retval <0) return(-1);

		if(s_sth.s_ftn[0] == EXIT) break;

		current.page = 0;
		retval = ClearScreen();
		if(retval < 0) return(retval);
		current.line = NO_ITEMS;

		if(s_sth.s_ftn[0] == CHGREC || s_sth.s_ftn[0] == INQREC){
			retval = ReadFields((char*)&s_sth,EMPCD_FLD,EMPCD_FLD,
				Validate,WindowHelp,1);
			if(retval < 0) return(retval);
			if(retval == RET_USER_ESC) continue;
		}

		retval = DisplayRec();
		if(retval < 0) return(retval);

		if(s_sth.s_ftn[0] == CHGREC){
			esc_flg = 0;
			retval = ChangeScreen();
			if(retval < 0) return(retval);
			esc_flg = 1;
		}

		if(s_sth.s_ftn[0] == INQREC){
			retval = InquireRec();
			if(retval < 0) return(retval);
			if(retval==CANCEL) continue;
		}

		if(s_sth.s_ftn[0] != CHGREC) continue;

		retval=ReadOption();		
		if(retval<0) return(retval);
		if(retval==CANCEL) continue;

		retval = UpdateFiles();
		if(retval < 0) return(retval);
	}

	return(NOERROR);
}
/*-----------------------------------------------------------------------*/
/* allows the user to inquire on both screens of information		 */
InquireRec()
{
	int retval;

	for( ; ; ) {
#ifdef	ENGLISH
		retval = GetOpt("Y(es), N(ext), P(rev)", "YNP");
#else	
		retval = GetOpt("Y(es), N(ext), P(rev)", "YNP");
#endif

	 	if(retval == YES) break;

		if(retval == NEXTREC){
			if(tempptr && tempptr->nextptr){
				tempptr = tempptr->nextptr;
				current.page ++;
				if(ShowPage()<0 ) return(-1);
			}
			else{
				fomer(LASTPG);
			}
		}

		if(retval == PREVREC){
			if(tempptr && tempptr->prevptr){
				tempptr = tempptr->prevptr;
				current.page --;
				if(ShowPage()<0 ) return(-1);
			}
			else{
				fomer(FIRSTPG);
			}
		}
	}

	return(CANCEL);
}
/*-------------------------------------------------------------------*/
static
Page *PageAllocated()	/* Allocate memory for 1 page of items on screen */
{
	return( (Page *)(malloc((unsigned)sizeof( Page ))) );
}
/*-----------------------------------------------------------------------*/
/* display record contents for all options but add			 */
DisplayRec()
{
	int	retval, i;
	char	prev_cd[sizeof(payben.pb_code)];

	old_total = 0;

	strcpy(barg_unit.b_code,emprec.em_barg);
	barg_unit.b_date = get_date();
	flg_reset(BARG);

	retval = get_n_barg(&barg_unit,BROWSE,0,BACKWARD,e_mesg);
	if(retval == EFL ||
		strcmp(barg_unit.b_code, emprec.em_barg) != 0){
		sprintf(e_mesg,"Bargaining Unit does no exist: %s",
			emprec.em_barg);
  		DispError((char *)&s_sth,e_mesg);
		return(NOERROR);
	}
	if(retval < 0){
  		DispError((char *)&s_sth,e_mesg);
  		return(ERROR);
	}
	seq_over(BARG);

	strcpy(s_sth.s_dummy1,"   ");
	strcpy(s_sth.s_dummy2," ");
	retval = WriteFields((char *)&s_sth,PAGE_FLD,STITEM - 100);
	if(retval < 0) return(retval);

	if(s_sth.s_ftn[0] == NEXTREC){
		if(first_time != 0){
			inc_str(payearn.pe_numb,sizeof(payearn.pe_numb)-1,
				FORWARD);
			flg_reset(PP_EARN);
		}
		first_time = 1;
		retval = get_n_pp_earn(&payearn,BROWSE,0,FORWARD,e_mesg);
		if(retval == EFL){
			fomen(NOMORE);
			get();
			return(NOERROR);
		}
		if(retval < 0){
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}
	}

	if(s_sth.s_ftn[0] == PREVREC){
		if(first_time != 0){
			inc_str(payearn.pe_numb,sizeof(payearn.pe_numb)-1,
				BACKWARD);
			flg_reset(PP_EARN);
		}
		first_time = 1;
		retval = get_n_pp_earn(&payearn,BROWSE,0,BACKWARD,e_mesg);
		if(retval == EFL){
			fomen(NOMORE);

			get();
			return(NOERROR);
		}

		if(retval < 0){
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}
	}

	if(s_sth.s_ftn[0] != NEXTREC && s_sth.s_ftn[0] != PREVREC){
	 	strcpy(payearn.pe_numb,s_sth.s_empcd);
		payearn.pe_pp = 0;
		flg_reset(PP_EARN);
		retval = get_n_pp_earn(&payearn,BROWSE,0,FORWARD,e_mesg);

		if(retval == EFL || strcmp(payearn.pe_numb, s_sth.s_empcd) != 0)
			return(NOERROR);

		if(retval < 0){
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}
	}

	strcpy(s_sth.s_empcd,payearn.pe_numb);
	strcpy(emprec.em_numb,payearn.pe_numb);

	retval = get_employee(&emprec,BROWSE,0,e_mesg);
	if(retval < 0){
		DispError((char *)&s_sth,e_mesg);
		return(retval);
	}
	strcpy(e_mesg,emprec.em_last_name);
	strcat(e_mesg,", ");
	strcat(e_mesg,emprec.em_first_name);
	strcat(e_mesg," ");
	strcat(e_mesg,emprec.em_mid_name);

	strncpy(s_sth.s_name,e_mesg,30);
	strcpy(s_sth.s_empstat,emprec.em_status);

	WriteFields((char *)&s_sth,EMPCD_FLD,ESTAT_FLD);

	FreeList();
	totalitemsadded = 0;

	headptr = tailptr = tempptr = NULL;

	current.page = 1;
	s_sth.s_page = current.page;
	line_no = 1;
	strcpy(payben.pb_numb,emprec.em_numb);
	payben.pb_pp = 0;
	payben.pb_date = 0;
	payben.pb_code[0] = '\0';
	flg_reset(PP_BEN);

	for(;;){
		retval = get_n_pp_ben(&payben,BROWSE,1,FORWARD,e_mesg);
		if(retval == EFL) break;
		if(retval < 0){
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}
		if(strcmp(payben.pb_numb,s_sth.s_empcd)!=0) break;

		if(strcmp(payben.pb_code,prev_cd)==0){
			tempptr->fields[current.line-1].s_amount+=
				payben.pb_amount;
			tempptr->pr_amount[current.line-1] += payben.pb_amount;
			old_total += payben.pb_amount;
			continue;
		}

		strcpy(prev_cd,payben.pb_code);

		current.line = line_no % NO_ITEMS;

		if( current.line==0 ) current.line = NO_ITEMS;
		if( current.line==1 ){	/* New page to be formed */
		
			/* Allocate memory for page */
			
			tempptr=PageAllocated();

			if( tempptr==NULL ){

				fomen(MEMERR);
				get();
				return(-1);
			}

			tempptr->lines_entered = 0;
			if( line_no==1 ){			/* First item */
				headptr = tailptr = tempptr;
				tempptr->nextptr = tempptr->prevptr = NULL;
			}
			else{
				tailptr->nextptr = tempptr;
				tempptr->prevptr = tailptr;
				tempptr->nextptr = NULL;
				tailptr = tempptr;
			}
		}

		strcpy(ben.bn_code,payben.pb_code);
		strcpy(ben.bn_pp_code,barg_unit.b_pp_code);

		retval = get_benefit(&ben,BROWSE,0,e_mesg);
		if(retval < 0){
			DispError((char *)&s_sth,e_mesg);
			if(retval != UNDEF) return(retval);
		}
		if(retval == UNDEF){
			strcpy(ben.bn_desc,"             ");
		}

  		strcpy(tempptr->fields[current.line-1].s_status, ACTIVE);
		strcpy(tempptr->fields[current.line-1].s_bdesc,ben.bn_desc);
		strcpy(tempptr->fields[current.line-1].s_bencd,payben.pb_code);
		tempptr->fields[current.line-1].s_amount = payben.pb_amount;
		tempptr->pr_amount[current.line-1] = payben.pb_amount;
		old_total += payben.pb_amount;

		tempptr->lines_entered++;
		totalitemsadded ++; 
		line_no++;
	}
	seq_over(PP_BEN);

	itemptr = tempptr;
	tempptr = headptr;

	for(i=0;i<NO_ITEMS;i++){
		if(tempptr->fields[i].s_bencd[0] == HV_CHAR) break;
		if(tempptr->fields[i].s_bencd[0] == LV_CHAR) break;
		if(tempptr->fields[i].s_bencd[0] == '\0') break;

  		strcpy(s_sth.s_bens[i].s_status,	
 			tempptr->fields[i].s_status);
		strcpy(s_sth.s_bens[i].s_bdesc,tempptr->fields[i].s_bdesc);
		strcpy(s_sth.s_bens[i].s_bencd,tempptr->fields[i].s_bencd);
		s_sth.s_bens[i].s_amount = tempptr->fields[i].s_amount;
	}

	WriteFields((char *)&s_sth,PAGE_FLD,ENDITEM);

	SetDupBuffers(STITEM,ENDITEM,1);

	return(NOERROR);
}
/*-----------------------------------------------------------------------*/
/* update changes to the deduction file					 */
UpdateFiles()
{
	int retval, i;

	new_total = 0;
	tempptr = headptr;	/* initialize tempptr to beginning of list */

	for(;;){	
	
		/* to write the items in file */

		if(tempptr==NULL) break;

		for( i=1; i <= NO_ITEMS; i++){ /* for each line on page */

			if(tempptr->fields[i-1].s_bencd[0]==HV_CHAR)
				break;

			if(i > tempptr->lines_entered) break;

			retval = WriteItem(i-1);
			if(retval < 0) return(-1);

			new_total += tempptr->fields[i-1].s_amount;
		}   /* end inner for loop */

		tempptr = tempptr->nextptr;

	}  /* end outer for loop */

	strcpy(payearn.pe_numb,s_sth.s_empcd);
	payearn.pe_pp = temp_pp;
	payearn.pe_date = temp_date;

	payearn.pe_date = LV_LONG;
	payearn.pe_pp = LV_SHORT;
	flg_reset(PP_EARN);

	retval = get_n_pp_earn(&payearn,UPDATE,0,FORWARD,e_mesg);
	if(retval < 0){
		DispError((char *)&s_sth,e_mesg);
		if(retval == UNDEF) return(NOERROR);
		return(retval);
	}
	
	payearn.pe_ben += (new_total - old_total);
	payearn.pe_net += (new_total - old_total);

	retval = put_pp_earn(&payearn,UPDATE,e_mesg);
	if(retval < 0){
		DispError((char *)&s_sth,e_mesg);
		return(retval);
	}

	retval = commit(e_mesg);
	if(retval < 0) return(retval);

	return(NOERROR);
}

/*-----------------------------------------------------------------------*/
/* write items to file							 */
WriteItem(item_no)
int item_no;
{
	int retval;

	strcpy(payben.pb_numb,s_sth.s_empcd);
	payben.pb_code[0] = '\0';
	payben.pb_acct[0] = '\0';
	payben.pb_pp = 0;
	flg_reset(PP_BEN);

	for(;;){
		retval = get_n_pp_ben(&payben,UPDATE,1,FORWARD,e_mesg);
		if(retval == EFL) break;
		if(retval < 0){
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}
	
		if(strcmp(s_sth.s_empcd,payben.pb_numb)!=0) break;
		if(strcmp(payben.pb_code,tempptr->fields[item_no].s_bencd)!=0)
			continue;
	
		payben.pb_amount =(payben.pb_amount/tempptr->pr_amount[item_no])
			 * (tempptr->fields[item_no].s_amount);
		payben.pb_amount = D_Roundoff(payben.pb_amount);

		retval = put_pp_ben(&payben,UPDATE,e_mesg);
		if(retval < 0) return(retval);

		retval = commit(e_mesg);
		if(retval < 0) return(retval);

		temp_pp = payben.pb_pp;
		temp_date = payben.pb_date;
		inc_str(payben.pb_acct,sizeof(payben.pb_acct)-1,FORWARD);

		strcpy(jrent.jr_code,tempptr->fields[item_no].s_bencd);
		strcpy(jrent.jr_emp_numb,s_sth.s_empcd);
		jrent.jr_fund = payben.pb_fund;
		strcpy(jrent.jr_acct,payben.pb_acct);
		retval = get_jr_ent(&jrent,UPDATE,1,e_mesg);
		if(retval < 0){
			DispError((char *)&s_sth,e_mesg);
			if(retval == UNDEF) continue;
			return(retval);
		}

		jrent.jr_amount = payben.pb_amount;

		retval = put_jr_ent(&jrent,UPDATE,e_mesg);
		if(retval < 0) return(retval);

		retval = commit(e_mesg);
		if(retval < 0) return(retval);
	}
	seq_over(PP_BEN);

	strcpy(audpay.aud_emp,s_sth.s_empcd);
	strcpy(audpay.aud_code,tempptr->fields[item_no].s_bencd);
	retval = get_aud_pay(&audpay,UPDATE,0,e_mesg);
	if(retval < 0 && retval != UNDEF){
		DispError((char *)&s_sth,e_mesg);
		return(retval);
	}

	strcpy(audpay.aud_flag,EARNED);
	audpay.aud_old_amnt = tempptr->pr_amount[item_no];
	audpay.aud_new_amnt = tempptr->fields[item_no].s_amount;

	if(retval == UNDEF){
		retval = put_aud_pay(&audpay,ADD,e_mesg);
	}
	else{
		retval = put_aud_pay(&audpay,UPDATE,e_mesg);
	}
	if(retval < 0) return(retval);

	retval = commit(e_mesg);
	if(retval < 0) return(retval);

	return(NOERROR);
}
/*-----------------------------------------------------------------------*/
/* Validate flds when PROFOM returns RET_VAL_CHK    			 */
static
Validate()	
{
	int	retval;

	switch(sr.curfld){

	case	FTN_FLD1:
		if(s_sth.s_ftn[0] == '\0'){
			s_sth.s_ftn[0] = LV_CHAR;
			return(-1);
		}

		if(s_sth.s_ftn[0] == CHGREC) break;
		if(s_sth.s_ftn[0] == INQREC) break;
		if(s_sth.s_ftn[0] == NEXTREC) break;
		if(s_sth.s_ftn[0] == PREVREC) break;
		if(s_sth.s_ftn[0] == EXIT){
			break;
		}

#ifdef ENGLISH
		fomen("Must Be C, I, N, P, or E");
#else
		fomen("Must Be C, I, N, P, or E");
#endif
		s_sth.s_ftn[0] = LV_CHAR;
		return(-1);

	case	EMPCD_FLD:
		Right_Justify_Numeric(s_sth.s_empcd,
			sizeof(emprec.em_numb)-1);
		if(s_sth.s_empcd[0] == '\0'){
			s_sth.s_empcd[0] = LV_CHAR;
			return(-1);
		}

		strcpy(emprec.em_numb,s_sth.s_empcd);
		retval = get_employee(&emprec,BROWSE,0,e_mesg);
		if(retval == UNDEF){
			fomen(NOKEY);
			s_sth.s_empcd[0] = LV_CHAR;
			return(-1);
		}
		
		if(retval < 0){
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}

		strcpy(e_mesg,emprec.em_last_name);
		strcat(e_mesg,", ");
		strcat(e_mesg,emprec.em_first_name);
		strcat(e_mesg," ");
		strcat(e_mesg,emprec.em_mid_name);

		strncpy(s_sth.s_name,e_mesg,30);
		retval = WriteFields((char *)&s_sth,NAME_FLD,NAME_FLD);
		if(retval < 0) return(retval);
		break;

	default:
		break;
	}/* end switch */	

	return(NOERROR);

}	/* Validate() */
/*-----------------------------------------------------------------------*/
/*                                                                       */
/*  Display help window for applicable fields                            */
static
WindowHelp()
{
	int	err, retval;

	switch(sr.curfld){
	case EMPCD_FLD:
		err = emp_hlp(s_sth.s_empcd,7,13);
		if(err < 0) return(err);
		redraw();

		if(s_sth.s_empcd[0] == '\0'){
			s_sth.s_empcd[0] = LV_CHAR;
			return(-1);
		}
		strcpy(emprec.em_numb,s_sth.s_empcd);
		retval = get_employee(&emprec,BROWSE,0,e_mesg);
		if(retval < 0){
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}

		strcpy(e_mesg,emprec.em_last_name);
		strcat(e_mesg,", ");
		strcat(e_mesg,emprec.em_first_name);
		strcat(e_mesg," ");
		strcat(e_mesg,emprec.em_mid_name);

		strncpy(s_sth.s_name,e_mesg,30);
		strcpy(s_sth.s_empstat,emprec.em_status);
		retval = WriteFields((char *)&s_sth,NAME_FLD,ESTAT_FLD);
		if(retval < 0) return(retval);
		break;

	default:
		fomen(NOHELP);
		break;
	}
	sr.nextfld = sr.curfld ;
	return(NOERROR) ;

}	/* WindowHelp() */
/*-----------------------------------------------------------------------*/
/* Display the confirmation message at the bottom of the screen, take the
   option from user and call necessary functions */
/*-----------------------------------------------------------------------*/
static
ReadOption()
{
	int	retval;

	for( ; ; ) {

#ifdef	ENGLISH
		retval = GetOpt("Y(es), S(creen edit), L(ine edit), N(ext), P(rev), C(ancel)", "YSLNPC");
#else	
		retval = GetOpt("Y(es), S(creen edit), L(ine edit), N(ext), P(rev), C(ancel)", "YSLNPC");
#endif

		switch(retval) {	/* process the option */
		case  YES :
			s_sth.s_mesg[0] = HV_CHAR;
			sr.nextfld = MESG_FLD1; 
			fomwf((char *)&s_sth);
	
			return(YES);	

		case  SCREDIT :
			retval = ChangeScreen();
			if(retval < 0) return(retval);
			break;

		case  LINEEDIT:
			for(;;){
				s_sth.s_field = LV_SHORT;
				retval = ReadFields((char *)&s_sth,CHG_FLD,
					CHG_FLD,Validate,WindowHelp,1);

				if(retval < 0) return(retval);
				if(s_sth.s_field <0 || s_sth.s_field > 11)
					 continue;

				if(s_sth.s_field == 0 || retval == RET_USER_ESC)
 					break;

				retval = LineChange(s_sth.s_field);
				if(retval < 0) return(retval);
			}
			s_sth.s_field = HV_SHORT;
			retval = WriteFields((char *)&s_sth,CHG_FLD,CHG_FLD);
			if(retval < 0) return(retval);
			break;

		case NEXT:	/* Display the next page of items */

			if(tempptr && tempptr->nextptr){
				tempptr = tempptr->nextptr;
				current.page ++;
				if(ShowPage()<0 ) return(-1);
			}
			else{
				fomer(LASTPG);
			}

			break;
		
		case PREV:	/* Display the prev page of items */

			if(tempptr && tempptr->prevptr){
				tempptr = tempptr->prevptr;
				current.page --;
				if(ShowPage()<0 ) return(-1);
			}
			else{
				fomer(FIRSTPG);
			}
			break;

		case  CANCEL:
#ifdef	ENGLISH
			retval = GetOpt("Confirm The Cancel (Y/N)?", "YN");
#else	
			retval = GetOpt("Confirmer l'annulation (O/N)?", "ON");
#endif
			if ( retval == YES ) 
				return( CANCEL );
			break ;

		}/* switch */

		if(retval < 0) return(retval);

	}	/* for(;;) */
}	
/*-------------------------------------------------------------------*/
ClearScreen()
{
	int retval;
	
	s_sth.s_empcd[0] = HV_CHAR;
	s_sth.s_name[0] = HV_CHAR;
	s_sth.s_empstat[0] = HV_CHAR;
	s_sth.s_page = HV_SHORT;

	s_sth.s_dummy1[0] = HV_CHAR;
	s_sth.s_dummy2[0] = HV_CHAR;

	retval = WriteFields((char *)&s_sth,EMPCD_FLD,PAGE_FLD);
	if(retval < 0) return(retval);

	retval = ClearItemLines();
	if(retval < 0) return(retval);

	return(NOERROR);
}
/*-------------------------------------------------------------------
Fill the item array with high values
-------------------------------------------------------------------*/
ClearItemLines()
{
	int 	j;
	int	retval;

	s_sth.s_page = HV_SHORT;

	for( j=0; j < NO_ITEMS; j++ ){
		s_sth.s_bens[j].s_bencd[0] = HV_CHAR;
		s_sth.s_bens[j].s_amount = HV_DOUBLE;
		s_sth.s_bens[j].s_bdesc[0] = HV_CHAR;
		s_sth.s_bens[j].s_status[0] = HV_CHAR;
	}

	retval = WriteFields((char*)&s_sth,STITEM, ENDITEM);
	if(retval < 0) return(-1);

	return(NOERROR);
}
/*-----------------------------------------------------------------------*/
/*                                                                       */
/* Display message and get the option */
static
GetOpt( msg, option )
       char *msg;
       char *option;
{
        int	j,  i;
	
        strcpy( s_sth.s_mesg, msg );
	sr.nextfld = MESG_FLD1; 
	fomwf((char *)&s_sth);

	for ( ; ; ) {
		s_sth.s_opt[0] = LV_CHAR ;
		if ( ReadFields((char*)&s_sth, OPT_FLD1, OPT_FLD1, Validate,
						WindowHelp, 0) < 0 ) 
			return(-1);

                j = strlen(option);
		for ( i = 0; i < j; i++ ) 
			if ( s_sth.s_opt[0] == option[i] )
                           break;
                if(i != j) break ;
                fomer(INVOPT);
	}
        s_sth.s_mesg[0] = HV_CHAR ;
        s_sth.s_opt[0] = HV_CHAR ;
	if ( WriteFields((char*)&s_sth,MESG_FLD1,OPT_FLD1) < 0 ) 
		return(-1);
 
        return( (int)(option[i])) ;
}
/*-------------------------------------------------------------------
Change item fields 
-------------------------------------------------------------------*/
ChangeScreen()
{
	int	retval;
	int	i;

	tempptr = headptr;
	current.page = 1;
	current.line = 1;

	if(tempptr == NULL) return(UNDEF);

	if(ShowPage()<0) return(-1);

	fomen(ITMMSG);

	for(;;){

		for(i=0; i<NO_ITEMS; i++){

			/* no changes if item inactive or non-existant */

			if(i >= tempptr->lines_entered)
				return(NOERROR);

			if(strcmp(tempptr->fields[i].s_status,INACTIVE)==0 )
				continue;

			retval = LineChange(i+1);
			if(retval < 0) return(-1);

			if(retval == EXIT) return(NOERROR);
		}

		/* next page */

		if(tempptr && tempptr->nextptr){
			tempptr = tempptr->nextptr;
			current.page ++;
			if(ShowPage()<0 ) return(-1);
		}
		else{
			return(NOERROR);
		}

	} /* end for loop */
}
/*-------------------------------------------------------------------*/
/* change items in line						     */
ChangeItems()
{
	int retval;

	for(;;){
		scpy((char*)&tmp_sth, (char*)&s_sth, sizeof(s_sth));
		SetDupBuffers(EMPCD_FLD, ESTAT_FLD, 1);

		strcpy(s_sth.s_mesg, FLDPROMPT);
		DispMesgFld((char*)&s_sth);

		s_sth.s_field = LV_SHORT;
		retval = ReadFields((char*)&s_sth, CHG_FLD, CHG_FLD,
			Validate, WindowHelp, 1);
		if (retval < 0) return(-1);

		if (retval == RET_USER_ESC) break;  /* User enters ESC-F */
       		if (s_sth.s_field == 0 ) break;   /* Finished changing */

		s_sth.s_mesg[0] = HV_CHAR ;
		DispMesgFld((char*)&s_sth);

		retval = LineChange(s_sth.s_field);
		if(retval < 0) return(retval);
	}

	s_sth.s_field = HV_SHORT;
	WriteFields((char *)&s_sth,CHG_FLD,CHG_FLD);

	return(retval);
}
/*-------------------------------------------------------------------
Read new values at given line 
-------------------------------------------------------------------*/
LineChange( line )	
int line;
{
	int 	retval, st_fld, end_fld;

	if(!tempptr) return(NOERROR);	/* if no pages, return */

	if(strcmp(tempptr->fields[line].s_status, INACTIVE) == 0){
		fomer(NOTACT);
		get();
		return(NOERROR);
	}

	if( line > tempptr->lines_entered )
		return(NOERROR);

	scpy((char*)&tmp_sth,(char*)&s_sth,sizeof(s_sth));

	/* course code field */

	st_fld = STAMOUNT + ((line-1)*STEP);
	end_fld = st_fld;

	SetDupBuffers(st_fld, end_fld, 1);

	s_sth.s_bens[line-1].s_amount = LV_DOUBLE;

	retval = ReadFields((char*)&s_sth, st_fld, 
			end_fld, Validate, WindowHelp,esc_flg);

	if(retval == RET_USER_ESC) retval = EXIT;
	if(retval<0)	return(retval);

	if(retval == EXIT){ 
		CopyBack((char*)&s_sth, (char*)&tmp_sth,sr.curfld,
			end_fld);
		return(retval);
	}
	
	strcpy(s_sth.s_bens[line-1].s_status, ACTIVE);

	tempptr->fields[line-1].s_amount = 
		    s_sth.s_bens[line-1].s_amount;
	strncpy(tempptr->fields[line-1].s_status,
		    s_sth.s_bens[line-1].s_status, 4);

	/* Display Changes After Edit is complete */
	if( WriteFields((char*)&s_sth, st_fld, end_fld + 100) < 0)
		return(-1);

	return(NOERROR);
}
/*-------------------------------------------------------------------
Free the linked list
-------------------------------------------------------------------*/
static
FreeList()	
{
	int 	i;

	/* clear the screen items from linked list */

	for(tempptr = headptr;tempptr;tempptr = tempptr->nextptr){

		for( i=0; i <= NO_ITEMS; i++) {
			if(i >= tempptr->lines_entered) break;
			tempptr->fields[i].s_bencd[0] = HV_CHAR;
		}
	}

	for( tempptr=tailptr; tempptr; tempptr=tailptr ){
		tailptr=tailptr->prevptr;
		free((char *)tempptr );
	}

	headptr = NULL;

	return(NOERROR);
}
/*-------------------------------------------------------------------*/
/* Dump contents of node pointed to by tempptr onto screen */
ShowPage()	
{
	/* transfer data to screen structure */
	if( ListToScreen()<0 ) return(-1);
	
	/* display on screen */
	if( WriteFields((char*)&s_sth,STITEM,ENDITEM)<0) 
		return(-1);
	
	/* Paginate properly */
	s_sth.s_page = current.page;
	WriteFields((char *)&s_sth,PAGE_FLD,PAGE_FLD);

	return(0);
}
/*-------------------------------------------------------------------
copy contents of *tempptr to screen (items part) 
-------------------------------------------------------------------*/
ListToScreen()	
{
	short i;

	if(tempptr==NULL) return(-1);

	/* for group already made */
	for( i=0; i < tempptr->lines_entered; i++){ 

		strcpy(s_sth.s_bens[i].s_bencd, 
			tempptr->fields[i].s_bencd);
		s_sth.s_bens[i].s_amount = 
			tempptr->fields[i].s_amount; 
		strcpy(s_sth.s_bens[i].s_bdesc,
		    	tempptr->fields[i].s_bdesc);
		strcpy(s_sth.s_bens[i].s_status,
			tempptr->fields[i].s_status);
	}
	
	/* clear other lines */

	for(i=tempptr->lines_entered; i < NO_ITEMS; i++){
		s_sth.s_bens[i].s_bencd[0] = HV_CHAR;
		s_sth.s_bens[i].s_amount= HV_DOUBLE;
		s_sth.s_bens[i].s_bdesc[0] = HV_CHAR;
		s_sth.s_bens[i].s_status[0]  = HV_CHAR;
	}

	return(NOERROR);
}
/*-------------------------------------------------------------------
Add a new node to the linked list
-------------------------------------------------------------------*/
MakeFreshPage()	
{
	tempptr=PageAllocated();

	if( tempptr==NULL ){

		fomen(MEMERR);
		get();
		return(ALLOC_ERROR);
	}

	if( tailptr == NULL ){	/* If not a single node in the list yet */
		headptr=tailptr=tempptr;
		tempptr->prevptr = NULL;
		tempptr->nextptr = NULL;
	}
	else{			/* if at least one node exists */
		tailptr->lines_entered = current.line;
		tailptr->nextptr = tempptr;
		tempptr->prevptr = tailptr;
		tempptr->nextptr = NULL;
		tailptr = tempptr;
	}
	tempptr->lines_entered = 0;

	if(ClearItemLines()<0 ) return(-1);

	if(WriteFields((char*)&s_sth,STITEM,ENDITEM)<0 )
		return(-1);

	return(NOERROR);
}
/*-----------------------------------------------------------------------*/
MoveLows()
{
	int i;

	for(i=0;i<NO_ITEMS;i++){
		s_sth.s_bens[i].s_amount = LV_DOUBLE;
	}

	return(NOERROR);
}
/*-----------------------------------------------------------------------*/
SetDupBuffers(stfld, endfld, value)
int	stfld, endfld, value;
{
	int	i;

	for(i = stfld; i <= endfld; i += 100){

		fomca1(i, 19, value);
		fomca1(i, 10, value);
	}

	sr.nextfld = stfld;
	sr.endfld = endfld;
	fomud((char*)&s_sth );

	return(NOERROR);
}
/*------------------    END OF FILE   ------------------------*/
