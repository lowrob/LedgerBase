/*-----------------------------------------------------------------------------
		Sourcename    : chqcan.c
		System        : Personel Payroll System.
		Subsystem     : PP 
		Module        : Cheque Cancellation 
		Created on    : 91-11-08
		Created  By   : Sheldon Floyd

HISTORY:
 Date           Programmer     Description of modification
____/__/__      __________     ___________________________

1992/09/16	Andre Cormier	Add Right_Justify to employee number in 
				validation routine.

1992/09/18	Andre Cormier	Change status of cheque history file instead
			        of physically deleting the record.

1992/09/18	Andre Cormier	Write time record from time history if any 
				existed before with a status of active.

-----------------------------------------------------------------------------*/
#define MAIN
#define MAINFL		CHQHIST		/* main file used */

#include <bfs_pp.h>
#include <stdio.h>
#include <reports.h>
#include <cfomstrc.h>
#include <pp_msgs.h>
#include <repdef.h>

#define SYSTEM		"PERSONEL PAYROLL"
#define MOD_DATE	"23-JAN-90"
#define SCREEN_NAME	"chqcan"
#define RANDOM  	18
#define SEQUENTIAL	19
#define	COL_HDG_NO	0
#define	COL_HDG_YES	1
#define	HIGH		1
#define	LOW		-1
#define	CASHCHQFMT	3
#define HL_CHAR(VAL)	(VAL==HIGH) ? HV_CHAR : LV_CHAR

#define	NO_HLP_WIN	(sr.curfld!=PGM_FLD)
#define PURGEFMT	3
#define FUND_DEFAULT	1

#define CHQMAINT	'1'
#define CASHENTRY	'2'
#define BANKSTAT	'3'
#define CHQPURGE	'4'

#define T_CHQMAINT	'M'
#define T_CASHENTRY	'C'
#define T_CHQPURGE	'P'
#define T_EXITOPT	'E'

#ifdef ENGLISH

#define INQUIRE	'I'
#define NEXT	'N'
#define PREV	'P'
#define EXITOPT	'E'
#define	YES	'Y'
#define CANCEL	'C'
#define SELECT	'S'
#define SCREDIT	'S'
#define	NO	'N'
#define AP_SYS	'A'

#else

#define NEXT	'N'
#define PREV	'P'
#define INQUIRE	'I'
#define EXITOPT	'F'
#define	YES	'O'
#define CANCEL	'C'
#define SELECT	'S'
#define SCREDIT	'S'
#define	NO	'N'
#define AP_SYS	'S'

#endif

#define DATE_FLD	300		/* system date field */
#define	FN_FLD		400		/* function field */
#define FUND_FLD	500		/* fund field */
#define	BANK_FLD	600		/* bank account field */

#define	CHQ_FLD		700 		/* cheque number field */
#define EMP_FLD		800		/* employee number field */
#define	AMT_FLD		900		/* cheque amount field */
#define NAME_FLD	1000		/* employee name field */

#define	ADD1_FLD	1100		/* address line 1 field */
#define	ADD2_FLD	1200		/* address line 2 field */
#define	ADD3_FLD	1300		/* address line 3 field */
#define CODE_FLD	1400		/* postal/ zip code field */

#define MSG_FLD		1500		/* Message line   field */
#define RESP_FLD	1600		/* Option response field */



/* chqhisinq.sth - header for C structure generated by PROFOM EDITOR */
typedef struct	{
	long	s_rundt;	/* 300 system date */
	char	s_fn[2];	/* 400 function */
	short	s_fund;		/* 500 fund number */
	char	s_bank[19];	/* 600 bank account # */
	long	s_chq;		/* 700 cheque number */
	char	s_empcd[13];	/* 800 employee number */
	double	s_chq_amt;	/* 900 cheque amount */
	char	s_name[49];	/* 1000 employee name */
	char	s_add1[31];	/* 1100 address line 1 */
	char	s_add2[31];	/* 1200 address line 2 */
	char	s_add3[31];	/* 1300 address line 3 */
	char	s_pozip[11];	/* 1400 postal code zip code */
	char	s_mesg[78];	/* 1400 message line */
	char	s_resp[2];	/* 1500 response line */
}	hi_struct;
static hi_struct	s_sth, image;	/* screen record */
struct stat_rec 	sr;		/* profom status record */
static Gl_rec		gl_rec;
static Chq_hist	chqhist;
static Pa_rec		pa_rec;
static Ctl_rec		ctl_rec;
static Emp		emp;		/* employee file */
static Time		time_rec;
static Time_his		time_his;
static Chq_reg		chq_reg;
static Man_chq		man_chq;
static Jrh_ent		jrh_ent;
static Emp_garn		emp_garn;
static Emp_earn		empearn;
static Emp_bh		empbh;	
static Emp_dh		empdh;	
static Emp_ins		empins;	
static Emp_gr_his	empgh;	
static Emp_ln_his	emplh;	
static Tr_item		tr_item;
static Tr_hdr		tr_hdr;
static Emp_loan		emp_loan;

char	e_mesg[80];

char	chardate[11];
char	projname[50];
char	*arayptr[5];

static int pgcnt;	/* Global variable to store function values */
static char	 procflag;
static int	first_time = 0;
static short	item_no;
static short	bank_item_no;

static long	tmp_seq_no;
static int	Validate();
static int	WindowHelp();
static double total_deductions, bank_amt;
static double tot_credits;
double D_Roundoff();
char	outside_emp[13];
long	outside_date;
long	outside_cheque;
short	outside_fund;
char	outside_bank[19];

static	int	PG_SIZE;
static	char	discfile[15];	/* for storing output name */

/*---------------------------------------------------------------------------*/
/* Initialize profom fields, call entry procedures */
main( argc, argv )
int argc;
char *argv[];
{
	int retval;

	strncpy( SYS_NAME, SYSTEM, 50 ); /* Module name */
	strncpy( CHNG_DATE, MOD_DATE, 10 );/* Last date of change */
	
	proc_switch( argc,argv,MAINFL );/* process the switches */

	if( (retval=Initialize())<0 )	/* Initialize profom enviroment */
		exit(-1);
	retval = Process();	/* Interact with the user */
	CleanExit();
	exit(retval);

}    /*  Main()   */
/*---------------------------------------------------------------------------*/
static	int
CleanExit()
{
	/* clear and exit the screen , close files & exit program */
	free_audit();	/* free memory allocated for writing audit rec */
	fomcs();
	fomrt();
	close_dbh();

	return(NOERROR);
}  /* CleanExit  */
/*---------------------------------------------------------------------------*/
static	int
Initialize()
{
	/* initialize the profom status variables */
	strcpy( sr.scrnam, NFM_PATH );
	strcat( sr.scrnam, SCREEN_NAME );
	strcpy( sr.termnm, terminal );

	/* initialize the fields and the profom screen */
	if( FillScrHdg()<0 ) 			return(-1);
	if( FillKeyFields( LOW )<0 ) 		return(-1);
	fomin( &sr );			/* initialize profom */
	fomcf(1,1);			/* Enable snap-screen option */


	return(NOERROR);
}   /*  Initialize()  */
/*---------------------------------------------------------------------------*/
/* Fill the screen heading fields: the program name and the date */
static	int
FillScrHdg()
{
	s_sth.s_rundt = get_date();
	return(NOERROR);
}   /*  FillScrHdg()   */
/*---------------------------------------------------------------------------*/
/* Fill the keyfields with high or low values */
static	int
FillKeyFields( value )
short value;
{
	s_sth.s_fund = value * HV_SHORT;

	return(NOERROR);
}   /* FillKeyfields()  */
/*-----------------------------------------------------------------*/
static
InitPrinter1()

{
	char	resp[2] ;
	char	discfile[15] ;

	/* Always to Printer */
	STRCPY(resp,"P");
	discfile[0]= '\0';
	PG_SIZE = 60;

	if( opn_prnt( resp, discfile, 1, e_mesg, 1 /* spool */)<0 ){
		return(REPORT_ERR);
	}
	pgcnt = 0;		/* Page count is zero */
	LNSZ = 132;		/* line size in no. of chars */
	linecnt = PG_SIZE;	/* Page size in no. of lines */

	return(NOERROR) ;
}
/*---------------------------------------------------------------------------*/
/* Accept user's option and call the corresponding routine in a loop */
static int
Process()
{
	int retval;

	/* Get the parameter file record */
	if( get_param(&pa_rec,BROWSE,1,e_mesg)<1 ){
		fomen(e_mesg);
		get();
		return(-1);
	}
	s_sth.s_empcd[0] = HV_CHAR;
	s_sth.s_fund = HV_SHORT;
	s_sth.s_bank[0] = HV_CHAR;
	s_sth.s_chq = HV_LONG;

	s_sth.s_chq_amt = HV_DOUBLE;
	s_sth.s_name[0] = HV_CHAR;
	s_sth.s_add1[0] = HV_CHAR;
	s_sth.s_add2[0] = HV_CHAR;

	s_sth.s_add3[0] = HV_CHAR;
	s_sth.s_pozip[0] = HV_CHAR;
	s_sth.s_mesg[0] = HV_CHAR;
	s_sth.s_resp[0] = HV_CHAR;
	retval = WriteFields((char *)&s_sth,FUND_FLD,RESP_FLD);
	if(retval < 0) return(retval);

	mkdate(get_date(),chardate);

	for( ; ; ){
#ifdef ENGLISH
		fomen("S(elect), E(xit)");
#else
		fomen("S(elect), E(xit)");
#endif
		/* Allow user to choose option */
		s_sth.s_fn[0] = LV_CHAR;
		
		retval = ReadFields((char *)&s_sth,FN_FLD,FN_FLD,Validate,
			WindowHelp,0);
		if(retval < 0) return(retval);

		if(s_sth.s_fn[0] == EXITOPT) break;

		if(s_sth.s_fn[0] == SELECT){
			retval = CanCheque();
			if(retval < 0) return(retval);
		}
	}

	return(NOERROR);
}    /*  Process()   */
/*---------------------------------------------------------------------------*/
/* process cheque cancellation						     */
CanCheque()
{
	int retval;

	if(InitPrinter1()<0){
		return(-1);
	}
	s_sth.s_fund = LV_SHORT;
	s_sth.s_bank[0] = LV_CHAR;
	s_sth.s_chq = LV_LONG;
	s_sth.s_empcd[0] = LV_CHAR;
	
	retval = ReadFields((char *)&s_sth,FUND_FLD,EMP_FLD,Validate,
		WindowHelp,1);
	if(retval == RET_USER_ESC) return(NOERROR);
	if(retval < 0) return(retval);

	strcpy(emp.em_numb,s_sth.s_empcd);
	retval = get_employee(&emp,BROWSE,0,e_mesg);
	if(retval < 0){
		DispError((char *)&s_sth,e_mesg);
		return(retval);
	}

	chqhist.ch_funds = s_sth.s_fund;
	chqhist.ch_chq_no = s_sth.s_chq;
	strcpy(chqhist.ch_accno,s_sth.s_bank);
	retval = get_chqhist(&chqhist,UPDATE,0,e_mesg);
	if(retval < 0){
		DispError((char *)&s_sth,e_mesg);
		return(retval);
	}

	strcpy(e_mesg,emp.em_first_name);
	strcat(e_mesg," ");
	strcat(e_mesg,emp.em_last_name);
	strncpy(s_sth.s_name,e_mesg,48);
	
	s_sth.s_chq_amt = chqhist.ch_net_amt;
	strcpy(s_sth.s_add1,emp.em_add1);
	strcpy(s_sth.s_add2,emp.em_add2);
	strcpy(s_sth.s_add3,emp.em_add3);
	strcpy(s_sth.s_pozip,emp.em_pc);

	retval = WriteFields((char *)&s_sth,AMT_FLD,CODE_FLD);
	if(retval < 0) return(retval);

	retval = GetSubOpt();
	if(retval < 0) return(retval);

	close_rep();
	return(NOERROR);
}
/*---------------------------------------------------------------------------*/
/* display sub-option line and get response 				     */
GetSubOpt()
{
	int retval;
	
	for(;;){
#ifdef ENGLISH
		strcpy(s_sth.s_mesg,"Y(es), S(creen edit), C(ancel)");
#else
		strcpy(s_sth.s_mesg,"Y(es), S(creen edit), C(ancel)");
#endif

	  	retval = WriteFields((char *)&s_sth,MSG_FLD,MSG_FLD);
		if(retval < 0) return(retval);

		s_sth.s_resp[0] = LV_CHAR;
		retval = ReadFields((char *)&s_sth,RESP_FLD,RESP_FLD,
			Validate,WindowHelp,0);
		if(retval < 0) return(retval);

		if(s_sth.s_resp[0] == SCREDIT){
			s_sth.s_mesg[0] = HV_CHAR;
			s_sth.s_resp[0] = HV_CHAR;
	  		retval = WriteFields((char *)&s_sth,MSG_FLD,MSG_FLD);
			if(retval < 0) return(retval);
			retval = ChangeScreen();
			if(retval < 0) return(retval);
		}

		if(s_sth.s_resp[0] == YES){
			s_sth.s_mesg[0] = HV_CHAR;
			s_sth.s_resp[0] = HV_CHAR;
	  		retval = WriteFields((char *)&s_sth,MSG_FLD,MSG_FLD);
			if(retval < 0) return(retval);
			retval = UpdateFiles();
			if(retval < 0) return(retval);
			break;
		}

		if(s_sth.s_resp[0] == CANCEL){
#ifdef ENGLISH
			strcpy(s_sth.s_mesg,"Confirm The Cancel (Y/N)");
#else
			strcpy(s_sth.s_mesg,"Confirm The Cancel (Y/N)");
#endif
			retval = WriteFields((char *)&s_sth,MSG_FLD,MSG_FLD);
			if(retval < 0) return(retval);
		
			s_sth.s_resp[0] = LV_CHAR;
			retval = ReadFields((char *)&s_sth,RESP_FLD,RESP_FLD,
				Validate,WindowHelp,0);
			if(retval < 0) return(retval);

			if(s_sth.s_resp[0] == NO) continue;
			s_sth.s_mesg[0] = HV_CHAR;
			s_sth.s_resp[0] = HV_CHAR;
	  		retval = WriteFields((char *)&s_sth,MSG_FLD,MSG_FLD);
			if(retval < 0) return(retval);
			break;
		}
	}

	return(NOERROR);
}
/*---------------------------------------------------------------------------*/
/* update cheque information on file					     */
UpdateFiles()
{
	int retval;
	int	prntno;
	char	devname[30];

	retval = CancelChqHis();
	if(retval < 0) return(retval);

	retval = WriteTime();
	if(retval < 0)	return(retval);

	strcpy(outside_emp,s_sth.s_empcd);
	outside_fund = s_sth.s_fund;
	outside_date = chqhist.ch_date;
	outside_cheque = s_sth.s_chq;
	strcpy(outside_bank,s_sth.s_bank);
	
	/* Printer option */
	prntno = 01;
	retval = get_prn_fd(prntno,devname);
	if(retval < 0){

#ifdef ENGLISH
		strcpy(s_sth.s_mesg,"Given Printer# NOT Found in Terminal/Printer ");
		strcat(s_sth.s_mesg,"Maintenance File");
#else
		strcpy(s_sth.s_mesg,"#d'imprimante donne pas retrouve dans le Dossier d'entretien");
		strcat(s_sth.s_mesg," du term/imprimante");
#endif
		return(-1);
	}
#ifdef ENGLISH
	STRCPY(s_sth.s_mesg, "Generating and Printing the JOURNAL LISTING") ;
#else
	STRCPY(s_sth.s_mesg, "Engendre et imprime la LISTE DE JOURNAL ") ;
#endif
	DispMesgFld((char *)&s_sth);
	fflush(stdout) ;

	retval = jrhlist(1);
	if(retval < 0) return(retval);

	for( ; ; ){
		strcpy(e_mesg,"cat jrhlist.dat > ");
		strcat(e_mesg,devname);
		system(e_mesg);
		strcpy(e_mesg,"echo  > ");
		strcat(e_mesg,devname);
		system(e_mesg);
	
		for( ; ; ) {
#ifdef ENGLISH
       		 	retval = GetOption((char *)&s_sth, "Reprint JOURNAL LISTING (Y/N)?","YN") ;
#else
       		 	retval = GetOption((char *)&s_sth, "Re-imprimer le LISTE DE JOURNAL (O/N)?","ON") ;
#endif
			if(retval == YES || retval == NO) 
				break ;
		}
		if(retval == NO) break;
	}


	retval = MakeRegister();
	if(retval < 0) return(retval);

	retval = UpdtGl();
	if(retval < 0) return(retval);

	retval = UpdtEmpFiles();
	if(retval < 0) return(retval);

	return(NOERROR);
}
/*----------------------------------------------------------------*/
/* delete the cheque history file				  */
CancelChqHis()
{
	int retval;

/*	chqhist.ch_funds = s_sth.s_fund;
	chqhist.ch_chq_no = s_sth.s_chq;
	strcpy(chqhist.ch_accno,s_sth.s_bank);
	retval = get_chqhist(&chqhist,UPDATE,0,e_mesg);
	if(retval < 0){
		DispError((char *)&s_sth,e_mesg);
		return(retval);
	} */

	/*strcpy(chqhist.ch_status,"X"); */
	chqhist.ch_status[0] = 'X'; 
	retval = put_chqhist(&chqhist,UPDATE,e_mesg);
	if(retval < 0){
		DispError((char *)&s_sth,e_mesg);
		return(retval);
	}

	retval = commit(e_mesg);
	if(retval < 0) return(retval);

	return(NOERROR);
}
/*---------------------------------------------------------------------------*/
/* Write time entry if there was any					     */
WriteTime()
{
	int retval, i;

	strcpy(time_his.tmh_numb,s_sth.s_empcd);
	time_his.tmh_date = chqhist.ch_date;
	time_his.tmh_no = 0;
	time_his.tmh_year = 0;
	flg_reset(TIME_HIS);

	for(;;) {
		retval = get_n_time_his(&time_his,BROWSE,0,FORWARD,e_mesg);
		if(retval != NOERROR) {
			if(retval == EFL)	break;
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}

		if(strcmp(time_his.tmh_numb,s_sth.s_empcd) != 0)	break;
		if(time_his.tmh_date != chqhist.ch_date)	break;
			
		strcpy(time_rec.tm_numb,time_his.tmh_numb);
		time_rec.tm_date = time_his.tmh_date;
		time_rec.tm_no = time_his.tmh_no;
		time_rec.tm_pp = time_his.tmh_pp;
		time_rec.tm_week = time_his.tmh_week;
		time_rec.tm_fund = time_his.tmh_fund;
		strcpy(time_rec.tm_adj,time_his.tmh_adj);
		strcpy(time_rec.tm_class,time_his.tmh_class);
		strcpy(time_rec.tm_earn,time_his.tmh_earn);
		strcpy(time_rec.tm_trans,time_his.tmh_trans);
		strcpy(time_rec.tm_exp,time_his.tmh_exp);
		for(i=0;i<7;i++) {
			time_rec.tm_units[i] = time_his.tmh_units[i];
			time_rec.tm_att[i][0] = '\0';
		}
		time_rec.tm_tot_amt = time_his.tmh_tot_amt;
		time_rec.tm_cost = time_his.tmh_cost;
		time_rec.tm_teach[0] = '\0';
		strcpy(time_rec.tm_comment,time_his.tmh_comment);
		strcpy(time_rec.tm_stat,"ACT");
		time_rec.tm_year = time_his.tmh_year;

		retval = put_ptime(&time_rec,ADD,e_mesg);
		if(retval < 0){
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}

		retval = put_time_his(&time_his,P_DEL,e_mesg);
		if(retval < 0){
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}
		retval = commit(e_mesg);
		if(retval < 0) return(retval);
		time_his.tmh_no++;
		flg_reset(TIME_HIS);
	}

	return(NOERROR);
}
/*---------------------------------------------------------------------------*/
/* create the check register file and call the function to print it	     */
MakeRegister()
{
	int retval;
	int	prntno;
	char	devname[30];

	unlink_file(CHQ_REG);

	chq_reg.cr_numb = chqhist.ch_chq_no;
	chq_reg.cr_date = chqhist.ch_date;
	strcpy(chq_reg.cr_emp_numb,emp.em_numb);
	strcpy(chq_reg.cr_status,"X");
	chq_reg.cr_amount = D_Roundoff(chqhist.ch_net_amt);

	retval = put_chq_reg(&chq_reg,ADD,e_mesg);
	if(retval < 0){
		DispError((char *)&s_sth,e_mesg);
		return(retval);
	}

	retval = commit(e_mesg);
	if(retval < 0) return(retval);

	/* Printer option */
	prntno = 01;
	retval = get_prn_fd(prntno,devname);
	if(retval < 0){

#ifdef ENGLISH
		strcpy(s_sth.s_mesg,"Given Printer# NOT Found in Terminal/Printer ");
		strcat(s_sth.s_mesg,"Maintenance File");
#else
		strcpy(s_sth.s_mesg,"#d'imprimante donne pas retrouve dans le Dossier d'entretien");
		strcat(s_sth.s_mesg," du term/imprimante");
#endif
		return(-1);
	}

#ifdef ENGLISH
	STRCPY(s_sth.s_mesg, "Generating and Printing the CHEQUE REGISTER") ;
#else
	STRCPY(s_sth.s_mesg, "Engendre et imprime le REGISTRE DES CHEQUES") ;
#endif
	DispMesgFld((char *)&s_sth);
	fflush(stdout) ;

	retval = cheqreg(1);
	if(retval < 0) return(retval);

	for( ; ; ){
		strcpy(e_mesg,"cat cheqreg.dat > ");
		strcat(e_mesg,devname);
		system(e_mesg);
		strcpy(e_mesg,"echo  > ");
		strcat(e_mesg,devname);
		system(e_mesg);

		for( ; ; ) {
#ifdef ENGLISH
       		 	retval = GetOption((char *)&s_sth, "Reprint CHEQUE REGISTER (Y/N)?","YN") ;
#else
       		 	retval = GetOption((char *)&s_sth, "Re-imprimer le REGISTRE DES CHEQUES (O/N)?","ON") ;
#endif
			if(retval == YES || retval == NO) 
				break ;
		}
		if(retval == NO) break;
	}

	unlink_file(CHQ_REG);

	return(NOERROR);
}
/*---------------------------------------------------------------------------*/
/* delete employee related records					     */
UpdtEmpFiles()
{
	int retval;

	strcpy(empearn.en_numb,s_sth.s_empcd);
	empearn.en_date = 0;
	empearn.en_pp = 0;
	empearn.en_week = 0;
	flg_reset(EMP_EARN);

	for(;;){
		retval = get_n_emp_earn(&empearn,UPDATE,0,FORWARD,e_mesg);
		if(retval == EFL) break;
		if(retval < 0){
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}

		if(strcmp(empearn.en_numb,s_sth.s_empcd)!=0) break;
		if(empearn.en_date != chqhist.ch_date) continue;

		retval = put_emp_earn(&empearn,P_DEL,e_mesg);
		if(retval < 0){
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}

		retval = commit(e_mesg);
		if(retval < 0) return(retval);

		empearn.en_week++;
		flg_reset(EMP_EARN);
	}
	seq_over(EMP_EARN);

	strcpy(empins.in_numb,s_sth.s_empcd);
	empins.in_pp = 0;
	empins.in_date = 0;
	flg_reset(EMP_INS);

	for(;;){
		retval = get_n_emp_ins(&empins,UPDATE,0,FORWARD,e_mesg);
		if(retval == EFL) break;
		if(retval < 0){
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}

		if(strcmp(empins.in_numb,s_sth.s_empcd)!=0) break;
		if(empins.in_date != chqhist.ch_date) continue;

		retval = put_emp_ins(&empins,P_DEL,e_mesg);
		if(retval < 0){
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}

		retval = commit(e_mesg);
		if(retval < 0) return(retval);

		empins.in_date++;
		flg_reset(EMP_INS);
	}
	seq_over(EMP_INS);

	strcpy(empbh.ebh_numb,s_sth.s_empcd);
	empbh.ebh_pp = 0;
	empbh.ebh_date = 0;
	empbh.ebh_code[0] = '\0';
	flg_reset(EMP_BEN_HIS);

	for(;;){
		retval = get_n_emp_bhis(&empbh,UPDATE,0,FORWARD,e_mesg);
		if(retval == EFL) break;
		if(retval < 0){
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}

		if(strcmp(empbh.ebh_numb,s_sth.s_empcd)!=0) break;
		if(empbh.ebh_date != chqhist.ch_date) continue;

		retval = put_emp_bhis(&empbh,P_DEL,e_mesg);
		if(retval < 0){
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}

		retval = commit(e_mesg);
		if(retval < 0) return(retval);

		inc_str(empbh.ebh_code,sizeof(empbh.ebh_code)-1,FORWARD);
		flg_reset(EMP_BEN_HIS);
	}
	seq_over(EMP_BEN_HIS);

	strcpy(empdh.edh_numb,s_sth.s_empcd);
	empdh.edh_pp = 0;
	empdh.edh_date = 0;
	empdh.edh_code[0] = '\0';
	empdh.edh_group[0] = '\0';
	flg_reset(EMP_DED_HIS);

	for(;;){
		retval = get_n_emp_dhis(&empdh,UPDATE,0,FORWARD,e_mesg);
		if(retval == EFL) break;
		if(retval < 0){
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}

		if(strcmp(empdh.edh_numb,s_sth.s_empcd)!=0) break;
		if(empdh.edh_date != chqhist.ch_date) continue;

		retval = put_emp_dhis(&empdh,P_DEL,e_mesg);
		if(retval < 0){
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}

		retval = commit(e_mesg);
		if(retval < 0) return(retval);

		inc_str(empdh.edh_group,sizeof(empdh.edh_group)-1,FORWARD);
		flg_reset(EMP_DED_HIS);
	}
	seq_over(EMP_DED_HIS);

	strcpy(empgh.egh_numb,s_sth.s_empcd);
	empgh.egh_pp = 0;
	empgh.egh_date = 0;
	empgh.egh_pr_cd = 0;
	empgh.egh_seq = 0;
	flg_reset(EMP_GARN_HIS);

	for(;;){
		retval = get_n_emp_ghis(&empgh,UPDATE,0,FORWARD,e_mesg);
		if(retval == EFL) break;
		if(retval < 0){
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}

		if(strcmp(empgh.egh_numb,s_sth.s_empcd)!=0) break;
		if(empgh.egh_date != chqhist.ch_date) continue;

		strcpy(emp_garn.eg_numb, emp.em_numb);
		emp_garn.eg_pr_cd = empgh.egh_pr_cd;
		emp_garn.eg_seq = empgh.egh_seq;

		retval = get_emp_garn(&emp_garn, UPDATE, 0, e_mesg);
		if(retval < 0){
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}
		emp_garn.eg_amnt_out += empgh.egh_amount;
		
		retval = put_emp_garn(&emp_garn,UPDATE,e_mesg);
		if(retval < 0){
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}
		
		retval = put_emp_ghis(&empgh,P_DEL,e_mesg);
		if(retval < 0){
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}

		retval = commit(e_mesg);
		if(retval < 0) return(retval);

		empgh.egh_seq++;
		flg_reset(EMP_GARN_HIS);
	}
	seq_over(EMP_GARN_HIS);

	strcpy(emplh.elh_numb,s_sth.s_empcd);
	emplh.elh_code[0] = '\0';
	emplh.elh_seq = 0;
	flg_reset(EMP_LOAN_HIS);

	for(;;){
		retval = get_n_emp_lhis(&emplh,UPDATE,0,FORWARD,e_mesg);
		if(retval == EFL) break;
		if(retval < 0){
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}

		if(strcmp(emplh.elh_numb,s_sth.s_empcd)!=0) break;
		if(emplh.elh_date != chqhist.ch_date) continue;


		strcpy(emp_loan.el_numb,emp.em_numb);
		strcpy(emp_loan.el_code,emplh.elh_code);
		emp_loan.el_seq = emplh.elh_seq;

		retval = get_emp_loan(&emp_loan,UPDATE,0,e_mesg);
		if(retval < 0){
			DispError((char *)&s_sth,e_mesg) ;
		  	return(ERROR);
		}
		emp_loan.el_amnt_out = D_Roundoff(emp_loan.el_amnt_out + 
				 emplh.elh_amount);
		emp_loan.el_pp_num_el += emp_loan.el_pp_num_el;
		
		retval = put_emp_loan(&emp_loan,UPDATE,e_mesg) ;
		if(retval < 0) {
			DispError((char *)&s_sth,e_mesg) ;
			roll_back(e_mesg);
			return(retval);
		}

		retval = put_emp_lhis(&emplh,P_DEL,e_mesg);
		if(retval < 0){
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}

		retval = commit(e_mesg);
		if(retval < 0) return(retval);

		emplh.elh_seq++;
		flg_reset(EMP_LOAN_HIS);
	}
	seq_over(EMP_LOAN_HIS);

	return(NOERROR);
}
/*---------------------------------------------------------------------------*/
/* change screen fields							     */
ChangeScreen()
{
	int retval;
	
	SetDupBuffers(FUND_FLD,EMP_FLD,1);

	s_sth.s_fund = LV_SHORT;
	s_sth.s_bank[0] = LV_CHAR;
	s_sth.s_chq = LV_LONG;
	s_sth.s_empcd[0] = LV_CHAR;
	
	retval = ReadFields((char *)&s_sth,FUND_FLD,EMP_FLD,
				Validate,WindowHelp,1);
	if(retval < 0) return(retval);
	if(retval == RET_USER_ESC){
		retval=CopyBack((char *)&s_sth,(char *)&image,FUND_FLD,EMP_FLD);
		if(retval < 0) return(retval);
	}

	strcpy(emp.em_numb,s_sth.s_empcd);
	retval = get_employee(&emp,BROWSE,0,e_mesg);
	if(retval < 0){
		DispError((char *)&s_sth,e_mesg);
		return(retval);
	}

	chqhist.ch_funds = s_sth.s_fund;
	chqhist.ch_chq_no = s_sth.s_chq;
	strcpy(chqhist.ch_accno,s_sth.s_bank);
	retval = get_chqhist(&chqhist,UPDATE,0,e_mesg);
	if(retval < 0){
		DispError((char *)&s_sth,e_mesg);
		return(retval);
	}

	strcpy(e_mesg,emp.em_first_name);
	strcat(e_mesg," ");
	strcat(e_mesg,emp.em_last_name);
	strncpy(s_sth.s_name,e_mesg,48);
	
	s_sth.s_chq_amt = chqhist.ch_net_amt;
	strcpy(s_sth.s_add1,emp.em_add1);
	strcpy(s_sth.s_add2,emp.em_add2);
	strcpy(s_sth.s_add3,emp.em_add3);
	strcpy(s_sth.s_pozip,emp.em_pc);

	retval = WriteFields((char *)&s_sth,AMT_FLD,CODE_FLD);
	if(retval < 0) return(retval);

	return(NOERROR);
}
/*---------------------------------------------------------------------------*/
Validate()	/* Validate the values entered by the user */
{
	int index, retval;
	int save_nextfld, save_endfld;

	switch( sr.curfld ){
		case FN_FLD:
			if(s_sth.s_fn[0] == '\0'){
				s_sth.s_fn[0] = LV_CHAR;
				return(-1);
			}
			
			if(s_sth.s_fn[0] == EXITOPT)
				break;
			if(s_sth.s_fn[0] == SELECT) 
				break;
			
#ifdef ENGLISH
			fomen("Must Be S or E");
#else
			fomen("Must Be S or E");
#endif
			s_sth.s_fn[0] = LV_CHAR;
			return(-1);
			
		case FUND_FLD:
			ctl_rec.fund = (short)s_sth.s_fund;
			index = get_ctl( &ctl_rec, BROWSE, 0, e_mesg );
			if( index==UNDEF ){
				fomen(NOKEY);
				s_sth.s_fund = LV_SHORT; 
				return(-1);
			}
			if( index < 0){
				fomen(e_mesg);
				s_sth.s_fund = LV_SHORT; 
				return(-1);
			}

			save_nextfld = sr.nextfld;
			save_endfld = sr.endfld;
			strcpy(s_sth.s_bank,ctl_rec.bank1_acnt);
			s_sth.s_bank[0] = LV_CHAR ;
			sr.nextfld = save_nextfld ;
			sr.endfld = save_endfld ;
			break;

		case BANK_FLD:	/* bank account # */
			if(acnt_chk(s_sth.s_bank)==ERROR){
#ifdef ENGLISH
				fomen("Invalid Account number");
#else
				fomen("Numero de compte invalide");
#endif
				s_sth.s_bank[0]=LV_CHAR;
				return(-1);
			}
			if( strcmp(s_sth.s_bank,ctl_rec.bank1_acnt)!=0 &&
				strcmp(s_sth.s_bank,ctl_rec.bank2_acnt)!=0 ){
#ifdef ENGLISH
				sprintf(e_mesg,"Bank1: %s, Bank2: %s",
						ctl_rec.bank1_acnt,
						ctl_rec.bank2_acnt );
#else
				sprintf(e_mesg,"Banque1: %s, Banque2: %s",
						ctl_rec.bank1_acnt,
						ctl_rec.bank2_acnt );
#endif
				fomen(e_mesg);
				s_sth.s_bank[0]=LV_CHAR;
				return(-1);
			}
			break;

		case CHQ_FLD:	/* cheque number */
			if( s_sth.s_chq<1 ){
#ifdef ENGLISH
				fomen("Invalid cheque number");
#else
				fomen("Numero de cheque invalide");
#endif
				s_sth.s_chq = LV_LONG;
				return(-1);
			}
			chqhist.ch_funds = s_sth.s_fund;
			strcpy(chqhist.ch_accno,s_sth.s_bank);
			chqhist.ch_chq_no = s_sth.s_chq;
			retval = get_chqhist(&chqhist,UPDATE,0,e_mesg);
			if( retval==ERROR ){
				fomen(e_mesg);
				get();
				return(retval);
			}
			else if( retval!=NOERROR ){
				fomen(NOKEY);
				s_sth.s_chq = LV_LONG;
				s_sth.s_fund = LV_SHORT;
				s_sth.s_bank[0] = LV_CHAR;
				sr.curfld -= 200;
				return(-1);
			}

			if(chqhist.ch_status[0] != 'O'){
#ifdef ENGLISH
				fomen("Cheque Not Outstanding");
#else
				fomen("Cheque Not Outstanding");
#endif
				s_sth.s_chq = LV_LONG;
				s_sth.s_fund = LV_SHORT;
				s_sth.s_bank[0] = LV_CHAR;
				sr.curfld -= 200;
			}

			if(chqhist.ch_sys[0] != 'P'){
#ifdef ENGLISH
				fomen("Cheque is Not From The Payroll System");
#else
				fomen("Cheque is Not From The Payroll System");
#endif
				s_sth.s_chq = LV_LONG;
				s_sth.s_fund = LV_SHORT;
				s_sth.s_bank[0] = LV_CHAR;
				sr.curfld -= 200;
			}
			break;

		case EMP_FLD:
			if(s_sth.s_empcd[0] == '\0'){
				s_sth.s_empcd[0] = LV_CHAR;
				return(-1);
			}


			Right_Justify_Numeric(s_sth.s_empcd
					,(sizeof(emp.em_numb)-1));

			strcpy(emp.em_numb,s_sth.s_empcd);
			retval = get_employee(&emp,BROWSE,0,e_mesg);
			if(retval == UNDEF){
				fomen(NOKEY);
				s_sth.s_empcd[0] = LV_CHAR;
				return(-1);
			}

			if(retval < 0){
				DispError((char *)&s_sth,e_mesg);
				return(retval);
			}
			break;

		case RESP_FLD:
			if(s_sth.s_resp[0] == YES) break;
			if(s_sth.s_resp[0] == CANCEL) break;
			if(s_sth.s_resp[0] == SCREDIT) break;

			fomen(INVOPT);
			s_sth.s_resp[0] = LV_CHAR;
			return(-1);

		default:
#ifdef ENGLISH
			fomen("No validation for this field");
#else
			fomen("Pas de validation pour ce champ");
#endif
			break;
	}
	sr.nextfld = sr.curfld;
	return(NOERROR);
}    /*  Validate()   */
/*---------------------------------------------------------------------------*/
SetDupBuffers( firstfld, lastfld, value )
int	firstfld, lastfld;	/* field numbers range */
int	value;			/* ENABLE or DISABLE */
{
	int i;

	for( i=firstfld; i<=lastfld; i+=50 )
		fomca1( i, 19, value);
	sr.nextfld = firstfld;
	sr.endfld = lastfld;
	fomud( (char *)&s_sth );
	ret( err_chk(&sr) );

	return( 0 );
}     /*    SetDupBuffers()    */
/*---------------------------------------------------------------------------*/
/* help window for screen fields					     */
WindowHelp()
{
	int retval;
	short reccod;

	switch(sr.curfld){
	case BANK_FLD:
		retval = gl_hlp(s_sth.s_fund,s_sth.s_bank,&reccod,7,13);
		if(retval < 0) return(retval);
		redraw();
		break;

	case EMP_FLD:
		retval = emp_hlp(s_sth.s_empcd,7,13);
		if(retval < 0) return(retval);
		redraw();
		break;

	default:
		fomen(NOHELP);
		break;
	}

	return(NOERROR);
}

/*-----------------------------------------------------------------------*/ 
UpdtGl()
{
	int retval, err;
	char	prev_acct[19];
	double	tot_amt, bank_amount, tot_db;
	short	prev_fund;
	double	dbcr_amt;

#ifdef ENGLISH
	STRCPY(s_sth.s_mesg, "Updating GL Master File, PLEASE WAIT");
#else
	STRCPY(s_sth.s_mesg, "Le GL est en train de faire les mises a jour, ATTENDEZ S.V.P.");
#endif
	DispMesgFld((char *)&s_sth);
	fflush(stdout) ;

	prev_acct[0] = '\0';
	prev_fund = 0;

	bank_amount = 0;
	tot_db = 0;
	dbcr_amt = 0;
	item_no = 1;

	if((retval = WriteTrHdr(s_sth.s_fund,
				0.00))< 0 ) return(retval);
	tmp_seq_no = tr_hdr.th_seq_no;

	for( ; ; ){
		tot_amt = 0;

		strcpy(jrh_ent.jrh_emp_numb,s_sth.s_empcd);
		jrh_ent.jrh_date = chqhist.ch_date;
		jrh_ent.jrh_fund = prev_fund;
		strcpy(jrh_ent.jrh_acct,prev_acct);

		flg_reset(JRH_ENT);

		for( ; ; ) {
			err = get_n_jrh_ent(&jrh_ent,BROWSE,1,FORWARD,e_mesg) ;
			if(err == EFL) break;
			if( err < 0) {
				DispError((char *)&s_sth,e_mesg) ;
				return(err) ;
			}

			if(strcmp(jrh_ent.jrh_emp_numb,s_sth.s_empcd) != 0 ||
			   jrh_ent.jrh_date != chqhist.ch_date)
				break;

			if(jrh_ent.jrh_cheque != s_sth.s_chq)
				continue; 

			if(prev_acct[0] == '\0'){
				strcpy(prev_acct, jrh_ent.jrh_acct);
				prev_fund = jrh_ent.jrh_fund;
			}

			if(prev_fund != jrh_ent.jrh_fund) {
				break;
			}

			if(strcmp(jrh_ent.jrh_acct,prev_acct) != 0) {
				break;
			}

			jrh_ent.jrh_amount = jrh_ent.jrh_amount * -1;

			tot_amt += jrh_ent.jrh_amount;

			bank_amount += jrh_ent.jrh_amount;
			if(jrh_ent.jrh_amount < 0.00)
				tot_db += jrh_ent.jrh_amount;

			dbcr_amt += jrh_ent.jrh_amount;

			if( put_jrh_ent(&jrh_ent,P_DEL,e_mesg) < 0){
				DispError((char *)&s_sth,e_mesg) ;
				roll_back(e_mesg);
				return(-1);
			}
			if( commit(e_mesg)<0 ){
				DispError((char *)&s_sth,e_mesg) ;
				return(-1);
			}
		}

		sprintf(e_mesg,"acct # %s",prev_acct);
		fomen(e_mesg);
		fflush(stdout) ;

		if((retval = WriteGlmast(prev_fund,
				prev_acct,tot_amt))< 0 ) return(retval);

		if((retval = WriteTrItems(prev_fund,
				prev_acct,tot_amt,0))< 0 ) return(retval);

		if(err == EFL)  break;

		item_no ++;
		if(prev_fund == s_sth.s_fund)
			bank_item_no = item_no;

		if(jrh_ent.jrh_fund != prev_fund){
			item_no = 1;
			if(prev_fund != s_sth.s_fund){
			  if((retval = WriteTrHdr(prev_fund,
				dbcr_amt))< 0 ) return(retval);
			}
			dbcr_amt = 0;
		}

		strcpy(prev_acct, jrh_ent.jrh_acct);
		prev_fund = jrh_ent.jrh_fund;

		if(strcmp(jrh_ent.jrh_emp_numb,s_sth.s_empcd) != 0 ||
		   jrh_ent.jrh_date != chqhist.ch_date)
			break;
	}
	seq_over(JRH_ENT);
	if(prev_fund != s_sth.s_fund){
		if((retval = WriteTrHdr(prev_fund,
				dbcr_amt))< 0 ) return(retval);
	}

	tr_hdr.th_fund = s_sth.s_fund;
	tr_hdr.th_reccod = 99;
	tr_hdr.th_create[0] = 'G';
	tr_hdr.th_seq_no = tmp_seq_no;

	retval = get_trhdr( &tr_hdr, UPDATE, 0, e_mesg );
	if( retval==ERROR ){
		DispError((char *)&s_sth,e_mesg);
		return(-1);
	}

	tr_hdr.th_debits = tot_db;
	tr_hdr.th_credits = tot_db;

	/*  Roundoff double items that have calculated values  */
	tr_hdr.th_debits 	= D_Roundoff(tr_hdr.th_debits);
	tr_hdr.th_credits 	= D_Roundoff(tr_hdr.th_credits);

	retval = put_trhdr( &tr_hdr, UPDATE, e_mesg );
	if(retval<0) {
		DispError((char *)&s_sth,e_mesg);
		roll_back(e_mesg);
		return(retval);
	}

	bank_amount = (bank_amount * -1);

	if((retval = WriteTrItems(s_sth.s_fund,
			s_sth.s_bank,bank_amount,1))< 0 ) return(retval);

	gl_rec.funds = s_sth.s_fund;
	strcpy(gl_rec.accno, s_sth.s_bank);
	gl_rec.reccod = 99;
	retval = get_gl( &gl_rec, UPDATE, 0, e_mesg );
	if( retval!=NOERROR ){
		DispError((char *)&s_sth,e_mesg);
		roll_back(e_mesg);
		return(retval);
	}
	gl_rec.currel[pa_rec.pa_cur_period-1] += bank_amount; 
	gl_rec.ytd += bank_amount;
	if(bank_amount > 0.00)
		gl_rec.curdb += bank_amount;
	else
		gl_rec.curcr += bank_amount;

	gl_rec.currel[pa_rec.pa_cur_period-1] =
			 D_Roundoff(gl_rec.currel[pa_rec.pa_cur_period-1]);
	gl_rec.ytd = D_Roundoff(gl_rec.ytd);
	gl_rec.curdb = D_Roundoff(gl_rec.curdb);
	gl_rec.curcr = D_Roundoff(gl_rec.curcr);

	retval = put_gl( &gl_rec, UPDATE, e_mesg );
	if( retval!=NOERROR ){
		DispError((char *)&s_sth,e_mesg);
		roll_back(e_mesg);
		return(retval);
	}

	return(NOERROR);
}
/*-----------------------------------------------------------------------*/ 
WriteTrHdr(fund, amount)
short	fund;
double	amount;
{
	int	retval;

	long	sysdt ;
#ifdef ORACLE
	long	sno, get_maxsno();
#endif
	tr_hdr.th_fund = fund;
	tr_hdr.th_reccod = 99;
	tr_hdr.th_create[0] = 'G';

#ifndef ORACLE
	tr_hdr.th_seq_no = HV_SHORT;
	retval = get_n_trhdr( &tr_hdr, BROWSE, 0, BACKWARD, e_mesg );
	seq_over( GLTRHDR );
	if( retval==ERROR ){
		DispError((char *)&s_sth,e_mesg);
		roll_back(e_mesg);
		return(-1);
	}
	if( retval==EFL || 
	    tr_hdr.th_fund != fund ||	
	    tr_hdr.th_reccod != 99 || tr_hdr.th_create[0] != 'G' ){
		tr_hdr.th_fund = fund;
		tr_hdr.th_reccod = 99;
		tr_hdr.th_create[0] = 'G';
		tr_hdr.th_seq_no = 1;
	}
	else
		tr_hdr.th_seq_no++;
#else
	sno = get_maxsno(GLTRHDR,(char *)&tr_hdr,0,-1,e_mesg);
	if(sno < 0) {
		DispError((char *)&s_sth,e_mesg);
		roll_back(e_mesg);
		return(-1);
	}
	tr_hdr.th_seq_no = sno + 1;
#endif

	strcpy( tr_hdr.th_userid, User_Id );
	tr_hdr.th_sys_dt = sysdt = get_date() ;
	tr_hdr.th_period = pa_rec.pa_cur_period;
	tr_hdr.th_date = get_date();
	tr_hdr.th_debits = tr_hdr.th_credits = amount;

	/*  Roundoff double items that have calculated values  */
	tr_hdr.th_debits 	= D_Roundoff(tr_hdr.th_debits);
	tr_hdr.th_credits 	= D_Roundoff(tr_hdr.th_credits);

	strcpy(tr_hdr.th_descr, "PAYROLL CHEQUE RUN");
	tr_hdr.th_type[0] = 'P';
	tr_hdr.th_supp_cd[0] = '\0';
	strcpy(tr_hdr.th_reference, "PAYROLL");

	retval = put_trhdr( &tr_hdr, ADD, e_mesg );
	if(retval<0) {
		DispError((char *)&s_sth,e_mesg);
		roll_back(e_mesg);
		return(retval);
	}
	return(0);
}
/*-----------------------------------------------------------------------*/ 
WriteTrItems(fund, acct, amount,flag)
short	fund;
char	*acct;
double	amount;
int	flag;
{
	int	retval;

	tr_item.ti_fund = fund;
	tr_item.ti_reccod = 99;
	tr_item.ti_create[0] = 'G';
	tr_item.ti_seq_no = tr_hdr.th_seq_no;
	if(flag == 0)
		tr_item.ti_item_no = item_no;
	else
		tr_item.ti_item_no = bank_item_no + 1;
	tr_item.ti_sys_dt = tr_hdr.th_sys_dt;
	tr_item.ti_period = tr_hdr.th_period;
	strcpy(tr_item.ti_accno,acct);
	tr_item.ti_amount = amount;
	tr_item.ti_status = 0;

	tr_item.ti_section = gl_rec.sect;

	/* Roundoff ti_amount which is double	*/
	tr_item.ti_amount = D_Roundoff(tr_item.ti_amount);

	if( put_tritem(&tr_item, ADD, e_mesg)<0 ){
		DispError((char *)&s_sth,e_mesg);
		roll_back(e_mesg);
		return(-1);
	}

	if (fund == s_sth.s_fund) return(0);

	/**************************************************** 
	 if Cr Fund not equal to Db Fund then we must also 
	 perform the following reverse entries 
	 ****************************************************/

	/* read the ctl record for the duetofrom_acct number for the Db Fund */

	ctl_rec.fund = fund;
	retval = get_ctl( &ctl_rec, BROWSE, 0, e_mesg );
	if( retval < 0 ){
		DispError((char *)&s_sth,e_mesg);
		return(-1);
	}

	tr_item.ti_fund = fund;
	tr_item.ti_reccod = 99;
	tr_item.ti_create[0] = 'G';
	tr_item.ti_seq_no = tr_hdr.th_seq_no;
	item_no ++;
	tr_item.ti_item_no = item_no;
	tr_item.ti_sys_dt = tr_hdr.th_sys_dt;
	tr_item.ti_period = tr_hdr.th_period;
	strcpy(tr_item.ti_accno,ctl_rec.duetofrom_acct);

	tr_item.ti_amount = (-1 * amount);
	tr_item.ti_status = 0;

	tr_item.ti_section = gl_rec.sect;

	/* Roundoff ti_amount which is double	*/
	tr_item.ti_amount = D_Roundoff(tr_item.ti_amount);

	if( put_tritem(&tr_item, ADD, e_mesg)<0 ){
		DispError((char *)&s_sth,e_mesg);
		roll_back(e_mesg);
		return(-1);
	}

	/* read the ctl record for the duetofrom_acct number for the Cr Fund */

	ctl_rec.fund = s_sth.s_fund;
	retval = get_ctl( &ctl_rec, BROWSE, 0, e_mesg );
	if( retval < 0 ){
		DispError((char *)&s_sth,e_mesg);
		return(-1);
	}

	tr_item.ti_fund = s_sth.s_fund;
	tr_item.ti_reccod = 99;
	tr_item.ti_create[0] = 'G';
	tr_item.ti_seq_no = tmp_seq_no;
	bank_item_no ++;
	tr_item.ti_item_no = bank_item_no;
	tr_item.ti_sys_dt = tr_hdr.th_sys_dt;
	tr_item.ti_period = tr_hdr.th_period;
	strcpy(tr_item.ti_accno,ctl_rec.duetofrom_acct);
	tr_item.ti_amount = amount;
	tr_item.ti_status = 0;

	tr_item.ti_section = gl_rec.sect;

	/* Roundoff ti_amount which is double	*/
	tr_item.ti_amount = D_Roundoff(tr_item.ti_amount);

	if( put_tritem(&tr_item, ADD, e_mesg)<0 ){
		DispError((char *)&s_sth,e_mesg);
		roll_back(e_mesg);
		return(-1);
	}
	return(NOERROR);
}
/*-----------------------------------------------------------------------*/ 
WriteGlmast(fund, acct, amount)
short	fund;
char	*acct;
double	amount;
{
	double	tempamount;
	int	retval;

	gl_rec.funds = fund;
	strcpy(gl_rec.accno, acct);
	gl_rec.reccod = 99;
	retval = get_gl( &gl_rec, UPDATE, 0, e_mesg );
	if( retval!=NOERROR ){
		DispError((char *)&s_sth,e_mesg);
		roll_back(e_mesg);
		return(retval);
	}
	gl_rec.currel[pa_rec.pa_cur_period-1] += amount; 
	gl_rec.ytd += amount;
	if(amount > 0.00)
		gl_rec.curdb += amount;
	else
		gl_rec.curcr += amount;

	gl_rec.currel[pa_rec.pa_cur_period-1] =
			 D_Roundoff(gl_rec.currel[pa_rec.pa_cur_period-1]);
	gl_rec.ytd = D_Roundoff(gl_rec.ytd);
	gl_rec.curdb = D_Roundoff(gl_rec.curdb);
	gl_rec.curcr = D_Roundoff(gl_rec.curcr);

	retval = put_gl( &gl_rec, UPDATE, e_mesg );
	if( retval!=NOERROR ){
		DispError((char *)&s_sth,e_mesg);
		roll_back(e_mesg);
		return(retval);
	}

	if (fund == s_sth.s_fund) return(0);

	/**************************************************** 
	 if Cr Fund not equal to Db Fund then we must also 
	 perform the following reverse entries 
	 ****************************************************/

	/* read the ctl record for the duetofrom_acct number for the Db Fund */

	ctl_rec.fund = fund;
	retval = get_ctl( &ctl_rec, BROWSE, 0, e_mesg );
	if( retval < 0 ){
		DispError((char *)&s_sth,e_mesg);
		return(-1);
	}

	gl_rec.funds = fund;
	strcpy( gl_rec.accno, ctl_rec.duetofrom_acct );
	gl_rec.reccod = 99;
	retval = get_gl( &gl_rec, UPDATE, 0, e_mesg );
	if( retval!=NOERROR ){
		DispError((char *)&s_sth,e_mesg);
		roll_back(e_mesg);
		return(retval);
	}

	/* reverse the transaction for the duetofrom acct for the fund */

	amount = amount * -1;
	gl_rec.currel[pa_rec.pa_cur_period-1] += amount;
	gl_rec.ytd += amount;
	if(amount > 0.00)
		gl_rec.curdb += amount;
	else
		gl_rec.curcr += amount;

	/*  Round off double items that may have been calculated  */
	gl_rec.currel[pa_rec.pa_cur_period-1] =
		D_Roundoff(gl_rec.currel[pa_rec.pa_cur_period-1]);
	gl_rec.ytd	= D_Roundoff(gl_rec.ytd);
	gl_rec.curdb	= D_Roundoff(gl_rec.curdb);
	gl_rec.curcr	= D_Roundoff(gl_rec.curcr);

	retval = put_gl( &gl_rec, UPDATE, e_mesg );
	if( retval!=NOERROR ){
		DispError((char *)&s_sth,e_mesg);
		roll_back(e_mesg);
		return(retval);
	}

	/* read the ctl record for the duetofrom_acct number for the Cr Fund */

	ctl_rec.fund = s_sth.s_fund;
	retval = get_ctl( &ctl_rec, BROWSE, 0, e_mesg );
	if( retval < 0 ){
		DispError((char *)&s_sth,e_mesg);
		return(-1);
	}

	gl_rec.funds = s_sth.s_fund;
	STRCPY( gl_rec.accno, ctl_rec.duetofrom_acct );
	gl_rec.reccod = 99;
	retval = get_gl( &gl_rec, UPDATE, 0, e_mesg );
	if( retval!=NOERROR ){
		DispError((char *)&s_sth,e_mesg);
		roll_back(e_mesg);
		return(retval);
	}

	/* reverse the transaction for the duetofrom acct for the fund2 */
	amount = amount * -1;

	gl_rec.currel[pa_rec.pa_cur_period-1] += amount;
	gl_rec.ytd += amount;
	if(amount > 0.00)
		gl_rec.curdb += amount;
	else
		gl_rec.curcr += amount;

	/*  Round off double items that may have been calculated  */
	gl_rec.currel[pa_rec.pa_cur_period-1] =
		D_Roundoff(gl_rec.currel[pa_rec.pa_cur_period-1]);
	gl_rec.ytd	= D_Roundoff(gl_rec.ytd);
	gl_rec.curdb	= D_Roundoff(gl_rec.curdb);
	gl_rec.curcr	= D_Roundoff(gl_rec.curcr);

	retval = put_gl( &gl_rec, UPDATE, e_mesg );
	if( retval!=NOERROR ){
		DispError((char *)&s_sth,e_mesg);
		roll_back(e_mesg);
		return(retval);
	}
	return(NOERROR);

}
/*---------------------------------------------------------------------------*/
GetFilename(ptr)
char	*ptr;
{
	return(0);
}
GetOutputon(ptr)
char	*ptr;
{
	return(0);
}
GetNbrCopies(par)
short	par;
{
	return(0);
}
Confirm()
{
	return(0);
}
/*-----------------------   End of program   ---------------------------*/
