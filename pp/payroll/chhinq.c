/*-----------------------------------------------------------------------------
		Sourcename    : chhinq.c
		System        : Personel Payroll System.
		Subsystem     : PP 
		Module        : Cheque History File Inquiry 
		Created on    : 91-11-01
		Created  By   : Sheldon Floyd

HISTORY:
 Date           Programmer     Description of modification
____/__/__      __________     ___________________________
-----------------------------------------------------------------------------*/
#define MAIN
#define MAINFL		CHQHIST		/* main file used */

#include <bfs_pp.h>
#include <stdio.h>
#include <reports.h>
#include <cfomstrc.h>
#include <pp_msgs.h>
#include <repdef.h>

#define SYSTEM		"ACCOUNTS PAYABLE"
#define MOD_DATE	"23-JAN-90"
#define SCREEN_NAME	"chhinq"
#define RANDOM  	18
#define SEQUENTIAL	19
#define	COL_HDG_NO	0
#define	COL_HDG_YES	1
#define	HIGH		1
#define	LOW		-1
#define	CASHCHQFMT	3
#define HL_CHAR(VAL)	(VAL==HIGH) ? HV_CHAR : LV_CHAR

#define	NO_HLP_WIN	(sr.curfld!=PGM_FLD)
#define PURGEFMT	3
#define FUND_DEFAULT	1

#define CHQMAINT	'1'
#define CASHENTRY	'2'

#define BANKSTAT	'3'
#define CHQPURGE	'4'

#define T_CHQMAINT	'M'
#define T_CASHENTRY	'C'
#define T_CHQPURGE	'P'
#define T_EXITOPT	'E'

#ifdef ENGLISH

#define INQUIRE	'I'
#define NEXT	'N'
#define PREV	'P'
#define EXITOPT	'E'
#define	YES	'Y'
#define	NO	'N'
#define AP_SYS	'A'

#else

#define NEXT	'N'
#define PREV	'P'
#define INQUIRE	'I'
#define EXITOPT	'F'
#define	YES	'O'
#define	NO	'N'
#define AP_SYS	'S'

#endif

#define PGM_FLD		100		/* Program Name field	*/
#define FN_FLD		400		/* Function field	*/
#define CHG_FLD		500		/* Editing field	*/

#define FUND_FLD	600		/* Fund No. field	*/
#define KEY_START 	600		/* Key starting field	*/

#define ACCNO_FLD	650		/* Account No. field	*/

#define CHQNO_FLD	700		/* Cheque No. field	*/
#define KEY_END  	700		/* Key ending field	*/

#define OPT_FLD		900		/* Menu option field	*/

#define DATE_FLD	900		/* Date   field		*/
#define BEGN_FLD	900		/* Beginning data field	*/

#define PERI_FLD	950		/* Period field		*/
#define NAME_FLD	1000		/* Supplier Name Field	*/
#define AMT_FLD		1100		/* Amount field		*/
#define SYS_FLD		1200		/* System field		*/

#define STA_FLD		1300		/* Status field		*/
#define LAST_FLD	1300		/* Last data field	*/

#define MSG_FLD		1400		/* Message line   field */
#define RESP_FLD	1500		/* Option response field */



/* chqhisinq.sth - header for C structure generated by PROFOM EDITOR */
typedef struct {
	char	s_progname[11];	/* 100 STRING XXXXXXXXXX */
	char	s_scrhdg[27];	/* 200 STRING XXXXXXXXXX */
	long	s_rundt;	/* 300 DATE YYYYFMMFDD */
	char	s_fn[2];	/* 400 STRING X */
	short	s_fld_no;	/* 500 NUMERIC 9 */
	short	s_fund;		/* 600 NUMERIC 999 */
	char	s_accno[19];	/* 650 bank account# */
	long	s_chq_no;	/* 700 NUMERIC 99999999 */
	long	s_date;		/* 900 DATE YYYYFMMFDD */
	short	s_period;	/* 950 NUMERIC 99 */
	char	s_name[49];	/* 1000 STRING */
	double	s_amount;	/* 1100 NUMERIC 99999999.99 */
	char	s_system[2];	/* 1200 STRING X */
	char	s_status[2];	/* 1300 STRING X */
	char	s_mesg[77];	/* 1400 STRING */
	char	s_resp[2];	/* 1500 STRING X */
}	s_struct;

static	s_struct  s_sth,image;	/* PROFOM Screen Structure */
struct stat_rec 	sr;		/* profom status record */
static Gl_rec		gl_rec;
static Chq_hist	chqhist;
Chq_hist	cheque, pre_rec;
Pa_rec		pa_rec;
Ctl_rec		ctl_rec;

static char	e_mesg[80];

char	chardate[11];
char	projname[50];
char	*arayptr[5];

static int retval, pgcnt;	/* Global variable to store function values */
static char	 procflag;
static int	first_time = 0;

static int	Validate();
static int	WindowHelp();

/*---------------------------------------------------------------------------*/
/* Initialize profom fields, call entry procedures */
main( argc, argv )
int argc;
char *argv[];
{
	strncpy( SYS_NAME, SYSTEM, 50 ); /* Module name */
	strncpy( CHNG_DATE, MOD_DATE, 10 );/* Last date of change */
	
	proc_switch( argc,argv,MAINFL );/* process the switches */

	if( (retval=Initialize())<0 )	/* Initialize profom enviroment */
		exit(-1);
	retval = Process();	/* Interact with the user */
	CleanExit();
	exit(retval);

}    /*  Main()   */
/*---------------------------------------------------------------------------*/
static	int
CleanExit()
{
	/* clear and exit the screen , close files & exit program */
	free_audit();	/* free memory allocated for writing audit rec */
	fomcs();
	fomrt();
	close_dbh();

	return(NOERROR);
}  /* CleanExit  */
/*---------------------------------------------------------------------------*/
static	int
Initialize()
{
	/* initialize the profom status variables */
	strcpy( sr.scrnam, NFM_PATH );
	strcat( sr.scrnam, SCREEN_NAME );
	strcpy( sr.termnm, terminal );

	/* initialize the fields and the profom screen */
	if( FillScrHdg()<0 ) 			return(-1);
	if( FillKeyFields( LOW )<0 ) 		return(-1);
	if( FillField( HIGH )<0 ) 		return(-1);
	if( FillNonKeyFlds( HIGH )<0 ) 		return(-1);
	if( FillMesgRespFlds( HIGH )<0 ) 	return(-1);
	fomin( &sr );			/* initialize profom */
	fomcf(1,1);			/* Enable snap-screen option */

	return(NOERROR);
}   /*  Initialize()  */
/*---------------------------------------------------------------------------*/
/* Fill the screen heading fields: the program name and the date */
static	int
FillScrHdg()
{
	STRCPY( s_sth.s_progname, PROG_NAME );
	s_sth.s_rundt = get_date();
	return(NOERROR);
}   /*  FillScrHdg()   */
/*---------------------------------------------------------------------------*/
/* Fill the keyfields with high or low values */
static	int
FillKeyFields( value )
short value;
{
	s_sth.s_fund = value * HV_SHORT;
	s_sth.s_accno[0] = HL_CHAR( value );
	s_sth.s_chq_no = value * HV_LONG;

	return(NOERROR);
}   /* FillKeyfields()  */
/*---------------------------------------------------------------------------*/
/* Fill the field# field with high/low values */
static int
FillField( value )
short value;
{
	s_sth.s_fld_no = value * HV_SHORT;
	return(NOERROR);
}   /*  FillField()  */
/*---------------------------------------------------------------------------*/
/* Fill the non key fields with high/low values */
static int
FillNonKeyFlds( value )
short value;
{
	s_sth.s_date		= value * HV_LONG;
	s_sth.s_period		= HV_SHORT;  /* only used for bank statement */
	s_sth.s_name[0] 	= HL_CHAR( value );
	s_sth.s_amount		= value * HV_DOUBLE;
	s_sth.s_system[0] 	= HL_CHAR( value );
	s_sth.s_status[0] 	= HL_CHAR( value );
	return(NOERROR);
}  /*  FillNonKeyFlds()  */
/*---------------------------------------------------------------------------*/
/* Fill the message and response fields with high or low values */
static int
FillMesgRespFlds( value )
short value;
{
	s_sth.s_mesg[0] = HL_CHAR(value);
	s_sth.s_resp[0] = HL_CHAR(value);
	return(NOERROR);
}  /*  FillMesgRespFlds()  */
/*---------------------------------------------------------------------------*/
/*	Allow the user to choose one of the three options as below */
static int
SelectProc()
{
	int retval;

	strcpy( sr.scrnam, NFM_PATH );
	strcat( sr.scrnam, SCREEN_NAME );

	strcpy(s_sth.s_scrhdg,"CHEQUE HISTORY INQUIRY");
	retval = WriteFields((char *)&s_sth,PGM_FLD,FN_FLD-100);
	if(retval < 0) return(retval);
	
	procflag = T_CHQMAINT;	

	return(NOERROR);
}  /*  SelectProc()  */
/*---------------------------------------------------------------------------*/
/* Accept user's option and call the corresponding routine in a loop */
static int
Process()
{
	/* Get the parameter file record */
	if( get_param(&pa_rec,BROWSE,1,e_mesg)<1 ){
		fomen(e_mesg);
		get();
		return(-1);
	}

	mkdate(get_date(),chardate);

	for( ; ; ){
		/* Allow user to choose option */
		if( SelectProc()<0 )
			return(-1);

		CHKACC(retval,BROWSE,e_mesg);
		if( InitReport(procflag)<0 )
			return(-1);
#ifdef ENGLISH
		STRCPY( s_sth.s_scrhdg,"CHEQUE HISTORY INQUIRY");
#else
		STRCPY( s_sth.s_scrhdg,"CHEQUE HISTORY INQUIRY");
#endif
		s_sth.s_fund = HV_SHORT;
		s_sth.s_accno[0] = HV_CHAR;
		s_sth.s_chq_no = HV_LONG;
		retval = MaintProc();
		if(retval < 0) return(retval);

		ClearScreen();
		rpclose();

		if(s_sth.s_fn[0] == EXITOPT) return(NOERROR);
	}

	return(NOERROR);
}    /*  Process()   */
/*---------------------------------------------------------------------------*/

/*	Cheque History File Maintenance process */
static int
MaintProc()
{
	int retval;

	chqhist.ch_funds = 0;
	chqhist.ch_accno[0] = '\0';
	chqhist.ch_chq_no = 0;
	flg_reset(CHQHIST);

	for( ; ; ){
		retval = ReadFunction();
		if(retval < 0) return(-1);
		if(s_sth.s_fn[0] == EXITOPT) break;

		s_sth.s_fund = 1;
		retval = WriteFields((char *)&s_sth,FUND_FLD,FUND_FLD);
		if(retval < 0) return(retval);
		SetDupBuffers(FUND_FLD,FUND_FLD,1);

		s_sth.s_fund = LV_SHORT;
		s_sth.s_accno[0] = LV_CHAR;
		s_sth.s_chq_no = LV_LONG;

		CHKACC(retval,BROWSE,e_mesg);
		if( Inquiry()<0 ) return(-1);
	}

	return(NOERROR);
}   /*   MaintProc()  */
/*---------------------------------------------------------------------------*/
static int
ReadFunction()	/* Display options at the bottom, and read entry */
{
#ifdef ENGLISH
	fomen("I(nquire), N(ext), P(rev), E(xit)");
#else
	fomen("I(nquire), N(ext), P(rev), E(xit)");
#endif
	if((retval=ReadFields((char *)&s_sth,FN_FLD,FN_FLD,Validate, 
		WindowHelp,0))<0 ) return(retval);

	return(NOERROR);
}    /*   ReadFunction   */
/*---------------------------------------------------------------------------*/
static int
ClearScreen()	/* clear the screen except fn field, screen hdg & key */
{
	if(FillKeyFields(LOW)<0 ) return(-1);
	if(FillField(HIGH)<0 ) return(-1);
	if(FillNonKeyFlds(HIGH)<0 ) return(-1);
	if(FillMesgRespFlds(HIGH)<0 ) return(-1);

	if( WriteFields((char *)&s_sth,CHG_FLD,RESP_FLD)<0 ) return(-1);
	
	return(NOERROR);
}    /*   CleanScreen()   */
/*---------------------------------------------------------------------------*/
Validate()	/* Validate the values entered by the user */
{
	int index;
	int save_nextfld, save_endfld;

	switch( sr.curfld ){
		case FN_FLD:
			if(s_sth.s_fn[0] == '\0'){
				s_sth.s_fn[0] = LV_CHAR;
				return(-1);
			}
			
			if(s_sth.s_fn[0] == INQUIRE || s_sth.s_fn[0] == EXITOPT)
				break;
			if(s_sth.s_fn[0] == NEXT || s_sth.s_fn[0] == PREV) 
				break;
			
#ifdef ENGLISH
			fomen("Must Be I, N, P or E");
#else
			fomen("Must Be I, N, P or E");
#endif
			s_sth.s_fn[0] = LV_CHAR;
			return(-1);
			
		case CHG_FLD:	/* field # for editing */
			if( sr.fillcode==FIL_OMITTED )	/* Nothing entered */
				return(RET_USER_ESC);
			break;
		case FUND_FLD:	/* fund code: check by reading control rec */
			ctl_rec.fund = (short)s_sth.s_fund;
			index = get_ctl( &ctl_rec, BROWSE, 0, e_mesg );
			if( index==UNDEF ){
				fomen(NOKEY);
				s_sth.s_fund = LV_SHORT; 
				return(-1);
			}
			if( index < 0){
				fomen(e_mesg);
				s_sth.s_fund = LV_SHORT; 
				return(-1);
			}

			save_nextfld = sr.nextfld;
			save_endfld = sr.endfld;
			strcpy(s_sth.s_accno,ctl_rec.bank1_acnt);
			s_sth.s_accno[0] = LV_CHAR ;
			sr.nextfld = save_nextfld ;
			sr.endfld = save_endfld ;
			
			break;
		case ACCNO_FLD:	/* bank account # */
			if(acnt_chk(s_sth.s_accno)==ERROR){
#ifdef ENGLISH
				fomen("Invalid Account number");
#else
				fomen("Numero de compte invalide");
#endif
				s_sth.s_accno[0]=LV_CHAR;
				return(-1);
			}
			if( strcmp(s_sth.s_accno,ctl_rec.bank1_acnt) &&
				strcmp(s_sth.s_accno,ctl_rec.bank2_acnt) ){
#ifdef ENGLISH
				sprintf(e_mesg,"Bank1: %s, Bank2: %s",
						ctl_rec.bank1_acnt,
						ctl_rec.bank2_acnt );
#else
				sprintf(e_mesg,"Banque1: %s, Banque2: %s",
						ctl_rec.bank1_acnt,
						ctl_rec.bank2_acnt );
#endif
				fomen(e_mesg);
				s_sth.s_accno[0]=LV_CHAR;
				return(-1);
			}
			break;
		case CHQNO_FLD:	/* cheque number */
			if( s_sth.s_chq_no<1 ){
#ifdef ENGLISH
				fomen("Invalid cheque number");
#else
				fomen("Numero de cheque invalide");
#endif
				s_sth.s_chq_no = LV_LONG;
				return(-1);
			}
			chqhist.ch_funds = s_sth.s_fund;
			STRCPY( chqhist.ch_accno, s_sth.s_accno );
			chqhist.ch_chq_no = s_sth.s_chq_no;
			retval = get_chqhist(&chqhist,BROWSE,0,e_mesg);
			if( retval==ERROR ){
				fomen(e_mesg);
				get();
				return(retval);
			}
			else if( retval!=NOERROR ){
#ifdef ENGLISH
				fomen("Record with given key not found");
#else
				fomen("Fiche avec cle donnee pas retrouvee");
#endif
				s_sth.s_chq_no = LV_LONG;
				return(-1);
			}
			break;
		case PERI_FLD:	/* period */
			if(s_sth.s_period > pa_rec.pa_cur_period) {
#ifdef ENGLISH
				fomen("Period Invalid or Not Open");
#else
				fomen("Periode invalide ou pas ouverte");
#endif
				s_sth.s_period = LV_SHORT;
				return(-1);
			}
			break;
		case AMT_FLD:	/* Cheque amount */
			if(s_sth.s_amount<=0.0){
#ifdef ENGLISH
				fomen("Amount too small to be accepted");
#else
				fomen("Montant trop petit pour etre accepte");
#endif
				s_sth.s_amount = LV_DOUBLE ; 
				return(-1);
			}
			else{
				s_sth.s_system[0] = AP_SYS;
			}
			break;
		case SYS_FLD:	/* System */
			if( s_sth.s_system[0]!=AP_SYS ){
#ifdef ENGLISH
				fomen("Enter A(PS)");
#else
				fomen("Entrer S(C/P)");
#endif
				s_sth.s_system[0]=LV_CHAR;
				return(-1);
			}
			break;
		case STA_FLD:	/* Cheque status */
			if( s_sth.s_status[0]!=OUTSTANDING 
			 && s_sth.s_status[0]!=CASHED ){
#ifdef ENGLISH
				fomen("Status allowed: O(utstanding), C(ashed)");
#else
				fomen("Etats permis: N(on-regles), E(ncaisses)");
#endif
				s_sth.s_status[0]=LV_CHAR;
				return(-1);
			}
			break;
		default:
#ifdef ENGLISH
			fomen("No validation for this field");
#else
			fomen("Pas de validation pour ce champ");
#endif
			break;
	}
	sr.nextfld = sr.curfld;
	return(NOERROR);
}    /*  Validate()   */
/*---------------------------------------------------------------------------*/
static int
Inquiry()
{
	int retval;

	retval = GetRecord();	/* Read the key values */
	if( retval==UNDEF || retval==RET_USER_ESC || retval==LOCKED )
		return( RET_USER_ESC );

	if( retval<0 ){	/* errors in reading */
		fomen(e_mesg);
		get();
		return(-1);
	}

	retval = DisplayRecord();	/* Display the records */
	if( retval<0 ) return(retval);

	return(NOERROR);
}     /*    Inquiry   */
/*---------------------------------------------------------------------------*/
static int
DisplayRecord()	/* Display the obtained record through profom screen */
{

	s_sth.s_date = chqhist.ch_date;
	s_sth.s_amount = chqhist.ch_net_amt;
	strcpy(s_sth.s_name,chqhist.ch_name);
	s_sth.s_system[0] = chqhist.ch_sys[0];
	s_sth.s_status[0] = chqhist.ch_status[0];
	s_sth.s_fund = chqhist.ch_funds;
	strcpy(s_sth.s_accno,chqhist.ch_accno);
	s_sth.s_chq_no = chqhist.ch_chq_no;

	if(s_sth.s_system[0] != 'P' && s_sth.s_fn[0] == INQUIRE){
#ifdef ENGLISH
		fomen("System Must Be Payroll");
#else
		fomen("System Must Be Payroll");
#endif
		get();
		return(NOERROR);
	}
	if(s_sth.s_system[0] != 'P') return(NOERROR);

	if( WriteFields((char *)&s_sth,FUND_FLD,LAST_FLD) < 0 )
		return(-1);
	return(NOERROR);
}   /*  DisplayRecord()    */
/*---------------------------------------------------------------------------*/
static int
SetDupBuffers( firstfld, lastfld, value )
int	firstfld, lastfld;	/* field numbers range */
int	value;			/* ENABLE or DISABLE */
{
	int i;

	for( i=firstfld; i<=lastfld; i+=50 )
		fomca1( i, 19, value);
	sr.nextfld = firstfld;
	sr.endfld = lastfld;
	fomud( (char *)&s_sth );
	ret( err_chk(&sr) );

	return( 0 );
}     /*    SetDupBuffers()    */
/*---------------------------------------------------------------------------*/
static int
GetRecord()	/* Read the header key values, read rec */
{
	int retval;
	int mode;

	if(s_sth.s_fn[0] == NEXT){
		if(first_time != 0){
			chqhist.ch_chq_no++;
			flg_reset(CHQHIST);
		}
		retval = get_n_chqhist(&chqhist,BROWSE,0,FORWARD,e_mesg);
		if(retval == EFL){
			fomen(NOMORE);
			get();
			return(NOERROR);
		}
		if(retval < 0){
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}
	}

	if(s_sth.s_fn[0] == PREV){
		if(first_time != 0){
			chqhist.ch_chq_no--;
			flg_reset(CHQHIST);
		}
		retval = get_n_chqhist(&chqhist,BROWSE,0,BACKWARD,e_mesg);
		if(retval == EFL){
			fomen(NOMORE);
			get();
			return(NOERROR);
		}

		if(retval < 0){
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}
	}
	first_time = 1;

	if(s_sth.s_fn[0] == INQUIRE){
		s_sth.s_fund = LV_SHORT;
		s_sth.s_accno[0] = LV_CHAR;
		s_sth.s_chq_no = LV_LONG;

		retval=ReadFields((char *)&s_sth,FUND_FLD,CHQNO_FLD,
			Validate,WindowHelp,1);
		if(retval < 0 || retval == RET_USER_ESC) return(retval);

		/* Fetch the record having the given key */
		chqhist.ch_funds = s_sth.s_fund;
		strcpy(chqhist.ch_accno,s_sth.s_accno);
		chqhist.ch_chq_no = s_sth.s_chq_no;

		retval = get_chqhist(&chqhist,BROWSE,0,e_mesg);
		if( retval!=NOERROR ){
			fomen(e_mesg);
			get();
			return(retval);
		}
	}

	return(NOERROR);
}
/*---------------------------------------------------------------------------*/
/* help window for screen fields					     */
WindowHelp()
{
	fomen(NOHELP);

	return(NOERROR);
}
/*---------------------------------------------------------------------------*/
static int
InitReport(procflag)
char	procflag;
{
	int	Format;

	Format = CASHCHQFMT;

	arayptr[0] = (char *)&chqhist;

	arayptr[1] = (char *)&ctl_rec;
	arayptr[2] = (char *)NULL;

	return(NOERROR);
}
/*---------------------------------------------------------------------------*/
default_fund()
{
	s_sth.s_fund = FUND_DEFAULT;
	if( (retval=WriteFields((char *)&s_sth,FUND_FLD,CHQNO_FLD))<0 )
		return(retval);
	s_sth.s_fund = LV_SHORT;

	return(NOERROR);
}
	
/*-----------------------   End of program   ---------------------------*/
