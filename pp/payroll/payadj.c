/*----------------------------------------------------------------------
Source Name: payadj.c  
System     : PP
Module     : Payroll/Personel
Created On : Oct. 31, 1991
Created By : Sheldon Floyd

DESCRIPTION:

	This program is used to make adjustmenst to the employees pay   
	period earnings.

MODIFICATIONS:        

Programmer     	YY/MM/DD       	Description of modification
~~~~~~~~~~     	~~~~~~~~       	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Andre Cormier	92/08/16	Updating the payroll audit file with the
				upper part of the screen, and change for the
				lower part of the screen to write only those
				that have changed.
------------------------------------------------------------------------*/

#define	MAIN	
#define	MAINFL		PP_EARN

#include <stdio.h>
#include <ctype.h>
#include <cfomstrc.h>
#include <repdef.h>
#include <bfs_defs.h>
#include <bfs_pp.h>
#include <bfs_com.h>
#include <pp_msgs.h>

#define MOD_DATE	"31-OCT-91"
#define SYSTEM   	"PAYROLL/PERSONEL"

#define	SCRNM1		"payadj"
#define	PRGNM		"payadj"

#define	ALLOC_ERROR	-19
#define	MAX_KEYS	12

#ifdef ENGLISH

#define HDREDIT		'H'
#define ITEMEDIT	'I'
#define NEXT		'N'
#define EDITITEMS	'E'
#define INQREC		'I'
#define REACTIVATE	'R'
#define PREV		'P'
#define END 		'E'
#define ACTIVE		"ACT"
#define INACTIVE	"DEL"
#define	CHGREC		'C'
#define EXIT		'E'
#define NEXTREC		'N'
#define PREVREC		'P'
#define ITEMEDIT	'I'
#define YES		'Y'
#define NO		'N'
#define	LINEEDIT	'L'
#define	SCREDIT		'S'
#define	FIRST_SCR	'1'
#define	SECOND_SCR	'2'
#define	CANCEL		'C'
#define	ALL		'A' 
#define EARNED		'E'

#else		/* if FRENCH */

#define HDREDIT		'H'
#define ITEMEDIT	'I'
#define NEXT		'N'
#define EDITITEMS	'E'
#define INQREC		'I'
#define REACTIVATE	'R'
#define PREV		'P'
#define END 		'E'
#define ACTIVE		"ACT"
#define INACTIVE	"DEL"
#define	CHGREC		'C'
#define EXIT		'E'
#define NEXTREC		'N'
#define PREVREC		'P'
#define ITEMEDIT	'I'
#define YES		'O'
#define NO		'N'
#define	LINEEDIT	'M'
#define	SCREDIT		'C'
#define	FIRST_SCR	'1'
#define	SECOND_SCR	'2'
#define	CANCEL		'A'
#define	ALL		'T' 
#define EARNED		'E'

#endif

#define STEP		400
#define	NO_ITEMS	5
#define	NO_EARN		13

/*-------------------- screen 1 information -------------------------*/

/* repcd1.sth - header for C structure generated by PROFOM EDITOR */
typedef struct{
	char	s_dedcd[7];	/* benefit code */
	char	s_ddesc[31];	/* benefit description */
	double	s_amount;	/* benefit amount */
	char	s_status[6];	/* status */
	long	s_dummy_fld;	/* status */
	} S1_item;

typedef struct{
	long	s_sysdate;	/* 300 system date */
	char	s_ftn[2];	/* 400 fucntion */
	char	s_empcd[13];	/* 500 employee code */
	short	s_field;	/* 600 field: */
	char	s_name[31];	/* 800 employee name */
	short	s_paypd;	/* 900 pay period number */
	char	s_empstat[2];	/* 1000 employee status */
	double  s_amnts[NO_EARN];/* 1100 - 2300 pay period earnings */
	short	s_page;		/* 2500 line number 1 */
	char	s_dummy1[2];	/* 2600	dummy field */
	S1_item	s_deds[NO_ITEMS];/*2700 - 4600 benefit information */
	char	s_mesg[78];	/* 4700 message line */
	char	s_opt[2];	/* 4800 message option line */
	} s1_struct;

#define FTN_FLD1	400	/* function field */
#define EMPCD_FLD	500	/* employee code field */
#define	CHG_FLD 	600	/* field: prompt */
#define NAME_FLD	800	/* employee name field */

#define PAYPD_FLD	900	/* pay period field */
#define ST_AMOUNT	1100	/* start earning amount field */
#define END_AMOUNT	2300	/* start earning amount field */
#define	EMP_CCP		1500	/* employer CCP contribution */

#define STITEM		2700	/* start item field */
#define ENDITEM		4600 	/* end item field */
#define STAMOUNT	2900	/* start amount field */
#define PAGE_FLD	2500	/* page number field */

#define	MESG_FLD1	4700	/* message field */
#define	OPT_FLD1	4800	/* option field */

static  Pay_ded		payded;		/* pay period deduction file */
static  Csb_loan	loan;	/* pay period deduction file */
static  Pay_loan	payloan;	/* pay period deduction file */
static  Pay_garn	paygarn;	/* pay period deduction file */
static	Pay_earn	payearn;	/* pay period earnings file */
static	Pay_param	pay_param;	/* pay period earnings file */
static  Jr_ent		jrent;		/* journal entry file */
static	Gl_acct		gl_acct;
static	Aud_pay		audpay;		/* audit file */
static  Emp		emprec;		/* employee file */
static	Emp_garn	emp_garn;
static  Deduction	deduct;		/* deduction file */
static  Ded_group	dedgrp;		/* deduction file */
static  Reg_pen		reg_pen;	/* deduction file */
static	Barg_unit	barg_unit;

struct stat_rec	sr;
s1_struct	s_sth, tmp_sth;

char	e_mesg[80];

/* link list node for holding one page of entries */

typedef	struct 	 pgofitems{

	struct 	 pgofitems *prevptr;	/* pointer to previous entry */
	int	 lines_entered;		/* no of lines entered */
	S1_item  fields[NO_ITEMS];	/* array of lines per page */
	double	 pr_amount[NO_ITEMS];
	struct	 pgofitems *nextptr;	/* pointer to next entry */

}	Page;

typedef struct{		/* structure to record current page & line of entry */
	short	page;
	short	line;
}	Counter;

static int totalitemsadded;		/* total items added in add session */
static Page	*headptr,*tempptr, 
		*tailptr,*itemptr; 	/* to maintain list */

static Counter	current;		/* Forcurrent line & page of item */
int line_no;

char	txt_buff[80];	

char	txt_buff2[80];	
int	first_time = 0;
double	new_total, old_total;
int	esc_flg;
short	temp_pp;
long	temp_date;
double	tot_ded, tot_income;
double	tmp_share, tmp_income;
double	tot_amount;
char	last_type[2];
short	last_fund, last_jr;
double  D_Roundoff();

static	int	Validate();
static	int	WindowHelp();

/*-------------------------------------------------------------------*/

main(argc,argv)
int argc;
char *argv[];
{
	
	strncpy(SYS_NAME,SYSTEM,50);		/* Sub system name */
	strncpy(CHNG_DATE,MOD_DATE,10);		/* Modification Date */
	proc_switch(argc, argv, MAINFL) ; 	/* Process Switches */

	strcpy(sr.termnm,terminal);	/* Copy Terminal Name */
	
	if (Initialize()<0)
		exit(-1);		/* Initialization routine */

	if (Payadj() < 0){ 		/* maintenance processing */
		Close();
		exit(-1);
	}

	Close();			/* return to menu */
	exit(NOERROR);

} /* end of main */

/*-------------------------------------------------------------------*/
/* Reset information */

static
Close()
{
	/* Set terminal back to normal mode from PROFOM */
	FreeList();
	fomcs();
	fomrt();
	close_dbh();			/* Close files */
	close_rep();

	return(NOERROR);
}

/*-------------------------------------------------------------------*/
/* Initialize PROFOM  and Screens*/

static
Initialize()
{

	if(InitProfom()<0) { 			/* Initialize PROFOM */
		fomcs();
		fomrt();
		return(-1);
	}	
	if(InitScreens()<0) { 
		fomcs();
		fomrt();
		return(-1);
	}	

	return(NOERROR);
}
/*-------------------------------------------------------------------*/
/* Initialize PROFOM */
static
InitProfom()
{
	fomin(&sr);		/* Check for Error */
	ret( err_chk(&sr) );

	fomcf(1,1);		/* Enable Print screen option */
	return(NOERROR);

}	/* InitProfom() */
/*----------------------------------------------------------------*/
/* Initialize screens before going to process options */
static
InitScreens()
{
	int i; 

	strcpy(sr.scrnam,NFM_PATH);
	strcat(sr.scrnam,SCRNM1) ;

	s_sth.s_sysdate = get_date();	
	s_sth.s_field = HV_SHORT ;

	s_sth.s_empcd[0] = HV_CHAR;
	s_sth.s_name[0] = HV_CHAR;
	s_sth.s_ftn[0] = HV_CHAR;

	s_sth.s_empstat[0] = HV_CHAR;
	s_sth.s_paypd = HV_SHORT;
	s_sth.s_page = HV_SHORT;
	s_sth.s_dummy1[0] = HV_CHAR;

	for(i=0;i<NO_EARN;i++){
		s_sth.s_amnts[i] = HV_DOUBLE;
	}

	for(i=0;i<NO_ITEMS;i++){
		s_sth.s_deds[i].s_dedcd[0] = HV_CHAR;
		s_sth.s_deds[i].s_ddesc[0] = HV_CHAR;
		s_sth.s_deds[i].s_amount = HV_DOUBLE;
		s_sth.s_deds[i].s_status[0] = HV_CHAR;
		s_sth.s_deds[i].s_dummy_fld = HV_LONG;
	}
	
	s_sth.s_mesg[0] = HV_CHAR;
	s_sth.s_opt[0] = HV_CHAR;
	if(WriteFields((char*)&s_sth,FTN_FLD1,OPT_FLD1)<0) return(-1);

	return(NOERROR);

}	/* InitScreens() */
/*-------------------------------------------------------------------
process maintenance selections and make changes to file
-------------------------------------------------------------------*/
static
Payadj() 
{
	int retval;


	retval = get_pay_param(&pay_param,BROWSE, 1, e_mesg) ;
	if(retval < 0) {
		fomen(e_mesg) ;
		get();
		return(ERROR) ;
	}

	payearn.pe_numb[0] = '\0';

	payearn.pe_date = LV_LONG;
	payearn.pe_pp = LV_SHORT;
	flg_reset(PP_EARN);

	for(;;){
#ifdef ENGLISH
		fomen("C(hange), I(nquire), N(ext), P(rev), E(xit)");
#else
		fomen("C(hange), I(nquire), N(ext), P(rev), E(xit)");
#endif

		s_sth.s_ftn[0] = LV_CHAR;

		/* read the screen fields */
		retval = ReadFields((char*)&s_sth,FTN_FLD1,FTN_FLD1,Validate,
							WindowHelp,1);
		if(retval == RET_USER_ESC) continue;
		if(retval <0) return(-1);

		if(s_sth.s_ftn[0] == EXIT) break;

		current.page = 0;
		retval = ClearScreen();
		if(retval < 0) return(retval);
		current.line = NO_ITEMS;

		if(s_sth.s_ftn[0] == CHGREC || s_sth.s_ftn[0] == INQREC){
			retval = ReadFields((char*)&s_sth,EMPCD_FLD,EMPCD_FLD,
				Validate,WindowHelp,1);
			if(retval < 0) return(retval);
			if(retval == RET_USER_ESC) continue;
		}

		retval = DisplayRec();
		if(retval < 0) return(retval);

/*		if(s_sth.s_ftn[0] == CHGREC){
			esc_flg = 1;
			retval = ChangeHeader();
			if(retval < 0) return(retval);

			retval = ChangeScreen();
			if(retval < 0) return(retval);
			esc_flg = 1;
		}

		if(s_sth.s_ftn[0] == INQREC){
			retval = InquireRec();
			if(retval < 0) return(retval);
			if(retval==CANCEL) continue;
		} 

		if(s_sth.s_ftn[0] != CHGREC) continue;
	*/
		retval=ReadOption();		
		if(retval<0) return(retval);
		if(retval==CANCEL) continue;

		retval = UpdateFiles();
		if(retval < 0) return(retval);
	}

	return(NOERROR);
}
/*-----------------------------------------------------------------------*/
/* allows the user to inquire on both screens of information		 */
InquireRec()
{
	int retval;

	for( ; ; ) {
#ifdef	ENGLISH
		retval = GetOpt("Y(es), N(ext), P(rev)", "YNP");
#else	
		retval = GetOpt("Y(es), N(ext), P(rev)", "YNP");
#endif

	 	if(retval == YES) break;

		if(retval == NEXTREC){
			if(tempptr && tempptr->nextptr){
				tempptr = tempptr->nextptr;
				current.page ++;
				if(ShowPage()<0 ) return(-1);
			}
			else{
				fomer(LASTPG);
			}
		}

		if(retval == PREVREC){
			if(tempptr && tempptr->prevptr){
				tempptr = tempptr->prevptr;
				current.page --;
				if(ShowPage()<0 ) return(-1);
			}
			else{
				fomer(FIRSTPG);
			}
		}
	}

	return(CANCEL);
}
/*-------------------------------------------------------------------*/
static
Page *PageAllocated()	/* Allocate memory for 1 page of items on screen */
{
	return( (Page *)(malloc((unsigned)sizeof( Page ))) );
}
/*-----------------------------------------------------------------------*/
/* display record contents for all options but add			 */
DisplayRec()
{
	int	retval, i;
	char	prev_cd[sizeof(payded.pd_code)];

	old_total = 0;

	if(s_sth.s_ftn[0] == NEXTREC){
		if(first_time != 0){
			inc_str(payearn.pe_numb,sizeof(payearn.pe_numb)-1,
				FORWARD);
			flg_reset(PP_EARN);
		}
		first_time = 1;
		retval = get_n_pp_earn(&payearn,BROWSE,0,FORWARD,e_mesg);
		if(retval == EFL){
			fomen(NOMORE);
			get();
			return(NOERROR);
		}
		if(retval < 0){
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}
	}

	if(s_sth.s_ftn[0] == PREVREC){
		if(first_time != 0){
			inc_str(payearn.pe_numb,sizeof(payearn.pe_numb)-1,
				BACKWARD);
			flg_reset(PP_EARN);
		}
		first_time = 1;
		retval = get_n_pp_earn(&payearn,BROWSE,0,BACKWARD,e_mesg);
		if(retval == EFL){
			fomen(NOMORE);
			get();
			return(NOERROR);
		}

		if(retval < 0){
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}
	}

	if(s_sth.s_ftn[0] != NEXTREC && s_sth.s_ftn[0] != PREVREC){
		strcpy(payearn.pe_numb,s_sth.s_empcd);
		payearn.pe_pp = 0;
		flg_reset(PP_EARN);
		retval = get_n_pp_earn(&payearn,BROWSE,0,FORWARD,e_mesg);

		if(retval < 0){
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}
	}

	/*strcpy(payearn.pe_numb,s_sth.s_empcd);
	payearn.pe_pp = 0;
	payearn.pe_date = 0;
	flg_reset(PP_EARN);

	retval = get_n_pp_earn(&payearn,BROWSE,0,FORWARD,e_mesg);
	if(retval < 0 ||(strcmp(s_sth.s_empcd,payearn.pe_numb)!=0)){
		DispError((char *)&s_sth,e_mesg);
		return(retval);
	}
	*/

	strcpy(s_sth.s_empcd,payearn.pe_numb);
	strcpy(emprec.em_numb,payearn.pe_numb);

	retval = get_employee(&emprec,BROWSE,0,e_mesg);
	if(retval < 0){
		DispError((char *)&s_sth,e_mesg);
		return(retval);
	}

	strcpy(e_mesg,emprec.em_last_name);
	strcat(e_mesg,", ");
	strcat(e_mesg,emprec.em_first_name);
	strcat(e_mesg," ");
	strcat(e_mesg,emprec.em_mid_name);

	strncpy(s_sth.s_name,e_mesg,30);
	strcpy(s_sth.s_empstat,emprec.em_status);
	s_sth.s_amnts[0] = (payearn.pe_reg_inc1 + payearn.pe_reg_inc2 +
		 payearn.pe_ben + payearn.pe_high_inc);
	s_sth.s_paypd = payearn.pe_pp;

	s_sth.s_amnts[1] = payearn.pe_vac;
	s_sth.s_amnts[2] = payearn.pe_cpp;
	s_sth.s_amnts[3] = payearn.pe_def_inc;
	s_sth.s_amnts[4] = payearn.pe_cpp;
	s_sth.s_amnts[5] = payearn.pe_cpp_pen;
	s_sth.s_amnts[6] = payearn.pe_uic;
	s_sth.s_amnts[7] = payearn.pe_uic_ins;
	s_sth.s_amnts[8] = payearn.pe_uic_employer;
	s_sth.s_amnts[9] = payearn.pe_reg1;
	s_sth.s_amnts[10] = payearn.pe_reg2;
	s_sth.s_amnts[11] = payearn.pe_reg3;
	s_sth.s_amnts[12] = payearn.pe_tax;

	WriteFields((char *)&s_sth,EMPCD_FLD,END_AMOUNT);

	FreeList();
	totalitemsadded = 0;

	headptr = tailptr = tempptr = NULL;

	current.page = 1;
	s_sth.s_page = current.page;
	line_no = 1;
	strcpy(payded.pd_numb,emprec.em_numb);
	payded.pd_code[0] = '\0';
	payded.pd_acct[0] = '\0';
	flg_reset(PP_DED);

	for(;;){
		retval = get_n_pp_ded(&payded,BROWSE,1,FORWARD,e_mesg);
		if(retval == EFL) break;
		if(retval < 0){
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}
		if(strcmp(payded.pd_numb,s_sth.s_empcd)!=0) break;

		strcpy(prev_cd,payded.pd_code);

		current.line = line_no % NO_ITEMS;

		if( current.line==0 ) current.line = NO_ITEMS;
		if( current.line==1 ){	/* New page to be formed */
		
			/* Allocate memory for page */
			
			tempptr=PageAllocated();

			if( tempptr==NULL ){

				fomen(MEMERR);
				get();
				return(-1);
			}

			tempptr->lines_entered = 0;
			if( line_no==1 ){			/* First item */
				headptr = tailptr = tempptr;
				tempptr->nextptr = tempptr->prevptr = NULL;
			}
			else{
				tailptr->nextptr = tempptr;
				tempptr->prevptr = tailptr;
				tempptr->nextptr = NULL;
				tailptr = tempptr;
			}
		}

		strcpy(deduct.dd_code,payded.pd_code);
		strcpy(deduct.dd_pp_code,barg_unit.b_pp_code);

		retval = get_deduction(&deduct,BROWSE,0,e_mesg);
		if(retval < 0){
			DispError((char *)&s_sth,e_mesg);
			if(retval != UNDEF) return(retval);
		}
		if(retval == UNDEF){
			strcpy(deduct.dd_desc,"             ");
		}

  		strcpy(tempptr->fields[current.line-1].s_status, ACTIVE);
		strcpy(tempptr->fields[current.line-1].s_ddesc,deduct.dd_desc);
		strcpy(tempptr->fields[current.line-1].s_dedcd,payded.pd_code);
		tempptr->fields[current.line-1].s_amount = payded.pd_amount;
		tempptr->pr_amount[current.line-1] = payded.pd_amount;
		old_total += payded.pd_amount;

		tempptr->lines_entered++;
		totalitemsadded ++; 
		line_no++;
	}
	seq_over(PP_DED);

	strcpy(payloan.pc_numb,emprec.em_numb);
	payloan.pc_pp = payearn.pe_pp;
	payloan.pc_code[0] = '\0';
	payloan.pc_seq = LV_SHORT;
	payloan.pc_fund = LV_SHORT;
	payloan.pc_acct[0] = '\0';
	flg_reset(PP_LOAN);

	for(;;){
		retval = get_n_pp_loan(&payloan,BROWSE,0,FORWARD,e_mesg);
		if(retval == EFL) break;
		if(retval < 0){
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}
		if(strcmp(payloan.pc_numb,s_sth.s_empcd)!=0) break;

		strcpy(prev_cd,payloan.pc_code);

		current.line = line_no % NO_ITEMS;

		if( current.line==0 ) current.line = NO_ITEMS;
		if( current.line==1 ){	/* New page to be formed */
		
			/* Allocate memory for page */
			
			tempptr=PageAllocated();

			if( tempptr==NULL ){

				fomen(MEMERR);
				get();
				return(-1);
			}

			tempptr->lines_entered = 0;
			if( line_no==1 ){			/* First item */
				headptr = tailptr = tempptr;
				tempptr->nextptr = tempptr->prevptr = NULL;
			}
			else{
				tailptr->nextptr = tempptr;
				tempptr->prevptr = tailptr;
				tempptr->nextptr = NULL;
				tailptr = tempptr;
			}
		}

		strcpy(loan.cs_code,payloan.pc_code);

		retval = get_loan(&loan,BROWSE,0,e_mesg);
		if(retval < 0){
			DispError((char *)&s_sth,e_mesg);
			if(retval != UNDEF) return(retval);
		}
		if(retval == UNDEF){
			strcpy(loan.cs_desc,"             ");
		}

  		strcpy(tempptr->fields[current.line-1].s_status, ACTIVE);
		strcpy(tempptr->fields[current.line-1].s_ddesc,loan.cs_desc);
		strcpy(tempptr->fields[current.line-1].s_dedcd,payloan.pc_code);
		tempptr->fields[current.line-1].s_amount = payloan.pc_amount;
		tempptr->pr_amount[current.line-1] = payloan.pc_amount;
		old_total += payloan.pc_amount;

		tempptr->lines_entered++;
		totalitemsadded ++; 
		line_no++;
	}
	seq_over(PP_LOAN);

	strcpy(paygarn.pg_numb,emprec.em_numb);
	paygarn.pg_pp = payearn.pe_pp;
	paygarn.pg_date = payearn.pe_date;
	paygarn.pg_pr_cd = 0;
	paygarn.pg_seq = 0;
	paygarn.pg_fund = 0;
	paygarn.pg_acct[0] = '\0';
	flg_reset(PP_GARN);

	for(;;){
		retval = get_n_pp_garn(&paygarn,BROWSE,0,FORWARD,e_mesg);
		if(retval == EFL) break;
		if(retval < 0){
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}
		if(strcmp(paygarn.pg_numb,s_sth.s_empcd)!=0) break;

		current.line = line_no % NO_ITEMS;

		if( current.line==0 ) current.line = NO_ITEMS;
		if( current.line==1 ){	/* New page to be formed */
		
			/* Allocate memory for page */
			
			tempptr=PageAllocated();

			if( tempptr==NULL ){

				fomen(MEMERR);
				get();
				return(-1);
			}

			tempptr->lines_entered = 0;
			if( line_no==1 ){			/* First item */
				headptr = tailptr = tempptr;
				tempptr->nextptr = tempptr->prevptr = NULL;
			}
			else{
				tailptr->nextptr = tempptr;
				tempptr->prevptr = tailptr;
				tempptr->nextptr = NULL;
				tailptr = tempptr;
			}
		}

  		strcpy(tempptr->fields[current.line-1].s_status, ACTIVE);
		strcpy(tempptr->fields[current.line-1].s_ddesc,"Garnishment");
		sprintf(tempptr->fields[current.line-1].s_dedcd,"%d",paygarn.pg_pr_cd);
		tempptr->fields[current.line-1].s_amount = paygarn.pg_amount;
		tempptr->pr_amount[current.line-1] = paygarn.pg_amount;
		old_total += paygarn.pg_amount;

		tempptr->lines_entered++;
		totalitemsadded ++; 
		line_no++;
	}
	seq_over(PP_GARN);

	if(totalitemsadded == 0){
		s_sth.s_dummy1[0] = HV_CHAR;
		WriteFields((char *)&s_sth,PAGE_FLD,PAGE_FLD+200);
		return(NOERROR);
	}

	strcpy(s_sth.s_dummy1," ");

	itemptr = tempptr;
	tempptr = headptr;

	for(i=0;i<NO_ITEMS;i++){
		if(tempptr->fields[i].s_dedcd[0] == HV_CHAR) break;
		if(tempptr->fields[i].s_dedcd[0] == LV_CHAR) break;
		if(tempptr->fields[i].s_dedcd[0] == '\0') break;

  		strcpy(s_sth.s_deds[i].s_status,	
 			tempptr->fields[i].s_status);
		strcpy(s_sth.s_deds[i].s_ddesc,tempptr->fields[i].s_ddesc);
		strcpy(s_sth.s_deds[i].s_dedcd,tempptr->fields[i].s_dedcd);
		s_sth.s_deds[i].s_amount = tempptr->fields[i].s_amount;
	}

	WriteFields((char *)&s_sth,PAGE_FLD,ENDITEM);

	SetDupBuffers(STITEM,ENDITEM,1);

	return(NOERROR);
}
/*-----------------------------------------------------------------------*/
/* update changes to the deduction file					 */
UpdateFiles()
{
	int retval, i;
	double	week_income[5];
	double	total_income;

	tot_ded = 0;
	new_total = 0;
	tempptr = headptr;	/* initialize tempptr to beginning of list */

	strcpy(barg_unit.b_code,emprec.em_barg);
	barg_unit.b_date = get_date();
	flg_reset(BARG);

	retval = get_n_barg(&barg_unit,BROWSE,0,BACKWARD,e_mesg);
	if(retval == EFL ||
	   strcmp(barg_unit.b_code, emprec.em_barg) != 0){
	   sprintf(e_mesg,"Bargaining Unit Does Not Exist: %s",emprec.em_barg);
		DispError((char *)&s_sth,e_mesg);
		roll_back(e_mesg);
		seq_over(BARG);
		return(retval);	
	}
	if(retval < 0){
		DispError((char *)&s_sth,e_mesg);
		roll_back(e_mesg);
		seq_over(BARG);
		return(retval);	
	}
	seq_over(BARG);

	for(;;){	
	
		/* to write the items in file */

		if(tempptr==NULL) break;

		for( i=1; i <= NO_ITEMS; i++){ /* for each line on page */

			if(tempptr->fields[i-1].s_dedcd[0]==HV_CHAR)
				break;

			if(i > tempptr->lines_entered) break;

			retval = WriteItem(i-1);
			if(retval < 0) return(-1);

			new_total += tempptr->fields[i-1].s_amount;
		}   /* end inner for loop */

		tempptr = tempptr->nextptr;

	}  /* end outer for loop */

/*	strcpy(payearn.pe_numb,s_sth.s_empcd);
	payearn.pe_pp = temp_pp;
	payearn.pe_date = temp_date; */

	retval = get_pp_earn(&payearn,UPDATE,0,e_mesg);
	if(retval < 0){
		DispError((char *)&s_sth,e_mesg);
		if(retval == UNDEF) return(NOERROR);
		return(retval);
	}
	for(i=0;i<5;i++){
		week_income[i] = D_Roundoff(payearn.pe_week_inc[i] +
					    payearn.pe_week_hinc[i]);
	} 
	payearn.pe_net = s_sth.s_amnts[0] + 
			 s_sth.s_amnts[1]; /* re-calculate net pay */

	total_income = D_Roundoff(payearn.pe_net);
	payearn.pe_net -= new_total;
	
	payearn.pe_vac = s_sth.s_amnts[1];
	for(i=0;i<5;i++){
		payearn.pe_week_vac[i] = D_Roundoff((week_income[i]/
				    total_income) * payearn.pe_vac);
	} 
	if(payearn.pe_def_inc != s_sth.s_amnts[3]){
		retval = WriteAud(3,payearn.pe_def_inc,s_sth.s_amnts[3]);
	}
	payearn.pe_def_inc = s_sth.s_amnts[3];
	for(i=0;i<5;i++){
		payearn.pe_wk_def_inc[i] = D_Roundoff((week_income[i]/
				    total_income) * payearn.pe_def_inc);
	} 
	payearn.pe_net -= s_sth.s_amnts[3];/*	 re-calculate net pay */
	
	tot_income = payearn.pe_reg_inc1 + payearn.pe_reg_inc2 +
		     payearn.pe_high_inc + payearn.pe_ben + payearn.pe_vac; 
		
	if(payearn.pe_cpp != s_sth.s_amnts[2]){
		AdjCPP();
		retval = WriteAud(2,payearn.pe_cpp,s_sth.s_amnts[2]);
	}
	payearn.pe_cpp = s_sth.s_amnts[2];
	for(i=0;i<5;i++){
		payearn.pe_week_cpp[i] = D_Roundoff((week_income[i]/
				    total_income) * payearn.pe_cpp);
	} 
	payearn.pe_net -= s_sth.s_amnts[2];/*	 re-calculate net pay */

	if(payearn.pe_cpp_pen != s_sth.s_amnts[5]){
		retval = WriteAud(5,payearn.pe_cpp_pen,s_sth.s_amnts[5]);
	}
	payearn.pe_cpp_pen = s_sth.s_amnts[5];
	for(i=0;i<5;i++){
		payearn.pe_wk_cpp_pen[i] = D_Roundoff((week_income[i]/
				    total_income) * payearn.pe_cpp_pen);
	} 
	if(payearn.pe_uic != s_sth.s_amnts[6]){
		AdjUIC();
		retval = WriteAud(6,payearn.pe_uic,s_sth.s_amnts[6]);
	}
	payearn.pe_uic = s_sth.s_amnts[6];
	for(i=0;i<5;i++){
		payearn.pe_week_uic[i] = D_Roundoff((week_income[i]/
				    total_income) * payearn.pe_uic);
	} 
	payearn.pe_net -= s_sth.s_amnts[6];/*	 re-calculate net pay */
	if(payearn.pe_uic_ins != s_sth.s_amnts[7]) {
		retval = WriteAud(7,payearn.pe_uic_ins,s_sth.s_amnts[7]);
	}
	payearn.pe_uic_ins = s_sth.s_amnts[7];
	if(payearn.pe_uic_employer != s_sth.s_amnts[8]) {
		retval = WriteAud(8,payearn.pe_uic_employer,s_sth.s_amnts[8]);
	}
	payearn.pe_uic_employer = s_sth.s_amnts[8];

	if((payearn.pe_reg1 != s_sth.s_amnts[9]) ||
	   (payearn.pe_reg2 != s_sth.s_amnts[10]) ||
	   (payearn.pe_reg3 != s_sth.s_amnts[11]))
		AdjReg();
	if(payearn.pe_reg1 != s_sth.s_amnts[9]) {
		retval = WriteAud(9,payearn.pe_reg1,s_sth.s_amnts[9]);
	}
	payearn.pe_reg1 = s_sth.s_amnts[9];
	for(i=0;i<5;i++){
		payearn.pe_week_reg1[i] = D_Roundoff((week_income[i]/
				    total_income) * payearn.pe_reg1);
	} 
	payearn.pe_net -= s_sth.s_amnts[9];/*	 re-calculate net pay */
	if(payearn.pe_reg2 != s_sth.s_amnts[10]) {
		retval = WriteAud(10,payearn.pe_reg2,s_sth.s_amnts[10]);
	}
	payearn.pe_reg2 = s_sth.s_amnts[10];
	for(i=0;i<5;i++){
		payearn.pe_week_reg2[i] = D_Roundoff((week_income[i]/
				    total_income) * payearn.pe_reg2);
	} 
	payearn.pe_net -= s_sth.s_amnts[10];/*	 re-calculate net pay */
	if(payearn.pe_reg3 != s_sth.s_amnts[11]) {
		retval = WriteAud(11,payearn.pe_reg3,s_sth.s_amnts[11]);
	}
	payearn.pe_reg3 = s_sth.s_amnts[11];
	for(i=0;i<5;i++){
		payearn.pe_week_reg3[i] = D_Roundoff((week_income[i]/
				    total_income) * payearn.pe_reg3);
	} 
	payearn.pe_net -= s_sth.s_amnts[11];/*	 re-calculate net pay */

	if(payearn.pe_tax != s_sth.s_amnts[12]) {
		AdjTaxLia();
		retval = WriteAud(12,payearn.pe_tax,s_sth.s_amnts[12]);
	}
	payearn.pe_tax = s_sth.s_amnts[12];
	for(i=0;i<5;i++){
		payearn.pe_week_tax[i] = D_Roundoff((week_income[i]/
				    total_income) * payearn.pe_tax);
	} 
	payearn.pe_net -= s_sth.s_amnts[12];/*	 re-calculate net pay */
	for(i=0;i<5;i++){
		payearn.pe_week_net[i] = D_Roundoff((week_income[i]/
				    total_income) * payearn.pe_net);
	} 

	retval = put_pp_earn(&payearn,UPDATE,e_mesg);
	if(retval < 0){
		DispError((char *)&s_sth,e_mesg);
		return(retval);
	}

	retval = commit(e_mesg);
	if(retval < 0) return(retval);

	return(NOERROR);
}
/*-----------------------------------------------------------------------*/
/* write items to file							 */
WriteAud(item_no,old_amnt,new_amnt)
int item_no;
double old_amnt;
double new_amnt;
{
	int retval;

	strcpy(audpay.aud_emp,s_sth.s_empcd);

	switch(item_no){

	case	2:
		strcpy(audpay.aud_code,"CPP Contr           ");
		break;

	case	3:
		strcpy(audpay.aud_code,"Deffered Income     ");
		break;

	case	5:
		strcpy(audpay.aud_code,"CPP Pens Earn       ");
		break;

	case	6:
		strcpy(audpay.aud_code,"UIC Contr           ");
		break;

	case	7:
		strcpy(audpay.aud_code,"UIC Ins Earnings    ");
		break;

	case	8:
		strcpy(audpay.aud_code,"Employer UIC Contr  ");
		break;

	case	9:
		strcpy(audpay.aud_code,"Reg Pen Contr Rate1 ");
		break;

	case	10:
		strcpy(audpay.aud_code,"Reg Pen Contr Rate2 ");
		break;

	case	11:
		strcpy(audpay.aud_code,"Reg Pen Contr Rate3 ");
		break;

	case	12:
		strcpy(audpay.aud_code,"Income Tax          ");
		break;

	default:
		audpay.aud_code[0] = '\0';
		break;
	}/* end switch */	


	retval = get_aud_pay(&audpay,UPDATE,0,e_mesg);
	if(retval < 0 && retval != UNDEF){
		DispError((char *)&s_sth,e_mesg);
		return(retval);
	}

	strcpy(audpay.aud_flag,EARNED);
	audpay.aud_old_amnt = old_amnt;
	audpay.aud_new_amnt = new_amnt;

	if(audpay.aud_old_amnt != audpay.aud_new_amnt) {
		if(retval == UNDEF){
			retval = put_aud_pay(&audpay,ADD,e_mesg);
		}
		else{
			retval = put_aud_pay(&audpay,UPDATE,e_mesg);
		}
		if(retval < 0) return(retval);

		retval = commit(e_mesg);
		if(retval < 0) return(retval);
	}

	return(NOERROR);
}
/*-----------------------------------------------------------------------*/
/* write items to file							 */
WriteItem(item_no)
int item_no;
{
	int retval;

	strcpy(payded.pd_numb,s_sth.s_empcd);
	strcpy(payded.pd_code,tempptr->fields[item_no].s_dedcd);
	payded.pd_group[0] = '\0';
	payded.pd_pp = 0;
	payded.pd_fund = 0;
	payded.pd_acct[0] = '\0';
	flg_reset(PP_DED);

	retval = get_n_pp_ded(&payded,UPDATE,1,FORWARD,e_mesg);
	if(retval != EFL && retval < 0){
		DispError((char *)&s_sth,e_mesg);
		roll_back(e_mesg);
		return(retval);
	}

	if(retval != EFL && strcmp(s_sth.s_empcd,payded.pd_numb)==0 && 
	   strcmp(tempptr->fields[item_no].s_dedcd,payded.pd_code)==0) {

		if(tempptr->fields[item_no].s_amount != payded.pd_amount){
			AdjDed(tempptr->fields[item_no].s_amount);

			payded.pd_amount = tempptr->fields[item_no].s_amount;

			tot_ded += payded.pd_amount;/* re-calculate net pay */
			retval = put_pp_ded(&payded,UPDATE,e_mesg);
			if(retval < 0){
				roll_back(e_mesg);
				return(retval);
			}
			retval = commit(e_mesg);
			if(retval < 0) return(retval);
		}
		else
			roll_back(e_mesg);
	}
	else {
		strcpy(payloan.pc_numb,emprec.em_numb);
		payloan.pc_pp = payearn.pe_pp;
		payloan.pc_date = payearn.pe_date;
		strcpy(payloan.pc_code,tempptr->fields[item_no].s_dedcd);
		payloan.pc_seq = 0;
		payloan.pc_fund = 0;
		payloan.pc_acct[0] = '\0';
		flg_reset(PP_LOAN);

		retval = get_n_pp_loan(&payloan,BROWSE,0,FORWARD,e_mesg);
		if(retval != EFL && retval < 0){
			DispError((char *)&s_sth,e_mesg);
			roll_back(e_mesg);
			return(retval);
		}
		if(retval != EFL && strcmp(payloan.pc_numb,s_sth.s_empcd)==0 && 
		   strcmp(tempptr->fields[item_no].s_dedcd,payloan.pc_code)==0){

		  if(tempptr->fields[item_no].s_amount != payded.pd_amount){
			AdjLoan(tempptr->fields[item_no].s_amount);

			payloan.pc_amount = tempptr->fields[item_no].s_amount;

			tot_ded += payloan.pc_amount;/* re-calculate net pay */
			retval = put_pp_loan(&payloan,UPDATE,e_mesg);
			if(retval < 0){
				roll_back(e_mesg);
				return(retval);
			}


			retval = commit(e_mesg);
			if(retval < 0) return(retval);

			payded.pd_fund = payloan.pc_fund;
			strcpy(payded.pd_acct,payloan.pc_acct);
		  }
		  else
			roll_back(e_mesg);
		}
		else {
			strcpy(paygarn.pg_numb,emprec.em_numb);
			paygarn.pg_pp = payearn.pe_pp;
			paygarn.pg_date = payearn.pe_date;
			paygarn.pg_pr_cd=atoi(tempptr->fields[item_no].s_dedcd);
			paygarn.pg_seq = 0;
			paygarn.pg_fund = 0;
			paygarn.pg_acct[0] = '\0';
			flg_reset(PP_GARN);

			retval =get_n_pp_garn(&paygarn,BROWSE,0,FORWARD,e_mesg);
			if(retval != EFL && retval < 0){
				DispError((char *)&s_sth,e_mesg);
				roll_back(e_mesg);
				return(retval);
			}
			if(retval != EFL && 
			   strcmp(paygarn.pg_numb,s_sth.s_empcd)==0 && 
			   paygarn.pg_pr_cd == atoi(tempptr->fields[item_no].s_dedcd)){ 
			  if(tempptr->fields[item_no].s_amount !=
							 paygarn.pg_amount){
				AdjGarn(tempptr->fields[item_no].s_amount);

				paygarn.pg_amount = tempptr->fields[item_no].s_amount;

				tot_ded += paygarn.pg_amount;/* re-calculate net pay */
				retval = put_pp_garn(&paygarn,UPDATE,e_mesg);
				if(retval < 0){
					roll_back(e_mesg);
					return(retval);
				}
				retval = commit(e_mesg);
				if(retval < 0) return(retval);

				payded.pd_fund = paygarn.pg_fund;
				strcpy(payded.pd_acct,paygarn.pg_acct);
			  }
			  else
				roll_back(e_mesg);
			}
		}
	}

	temp_pp = payded.pd_pp;
	temp_date = payded.pd_date;

	strcpy(audpay.aud_emp,s_sth.s_empcd);
	strncpy(audpay.aud_code,tempptr->fields[item_no].s_dedcd,6);
	audpay.aud_code[6] = '\0';
	retval = get_aud_pay(&audpay,UPDATE,0,e_mesg);
	if(retval < 0 && retval != UNDEF){
		DispError((char *)&s_sth,e_mesg);
		roll_back(e_mesg);
		return(retval);
	}

	strcpy(audpay.aud_flag,EARNED);
	audpay.aud_old_amnt = tempptr->pr_amount[item_no];
	audpay.aud_new_amnt = tempptr->fields[item_no].s_amount;

	if(audpay.aud_old_amnt != audpay.aud_new_amnt) {
		if(retval == UNDEF){
			retval = put_aud_pay(&audpay,ADD,e_mesg);
		}
		else{
			retval = put_aud_pay(&audpay,UPDATE,e_mesg);
		}
		if(retval < 0){
			roll_back(e_mesg);
			return(retval);
		}
		retval = commit(e_mesg);
		if(retval < 0) return(retval);
	}

	return(NOERROR);
}
/*-----------------------------------------------------------------------*/
/* Validate flds when PROFOM returns RET_VAL_CHK    			 */
static
Validate()	
{
	int	retval;

	switch(sr.curfld){

	case	FTN_FLD1:
		if(s_sth.s_ftn[0] == '\0'){
			s_sth.s_ftn[0] = LV_CHAR;
			return(-1);
		}

		if(s_sth.s_ftn[0] == CHGREC) break;
		if(s_sth.s_ftn[0] == INQREC) break;
		if(s_sth.s_ftn[0] == NEXTREC) break;
		if(s_sth.s_ftn[0] == PREVREC) break;
		if(s_sth.s_ftn[0] == EXIT){
			break;
		}

#ifdef ENGLISH
		fomen("Must Be C, I, N, P, or E");
#else
		fomen("Must Be C, I, N, P, or E");
#endif
		s_sth.s_ftn[0] = LV_CHAR;
		return(-1);

	case	EMPCD_FLD:
		Right_Justify_Numeric(s_sth.s_empcd,
			sizeof(emprec.em_numb)-1);
		if(s_sth.s_empcd[0] == '\0'){
			s_sth.s_empcd[0] = LV_CHAR;
			return(-1);
		}

		strcpy(emprec.em_numb,s_sth.s_empcd);
		retval = get_employee(&emprec,BROWSE,0,e_mesg);
		if(retval == UNDEF){
			fomen(NOKEY);
			s_sth.s_empcd[0] = LV_CHAR;
			return(-1);
		}
		
		if(retval < 0){
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}

		strcpy(e_mesg,emprec.em_last_name);
		strcat(e_mesg,", ");
		strcat(e_mesg,emprec.em_first_name);
		strcat(e_mesg," ");
		strcat(e_mesg,emprec.em_mid_name);

		strncpy(s_sth.s_name,e_mesg,30);
	
		strcpy(barg_unit.b_code,emprec.em_barg);
		barg_unit.b_date = get_date();
		flg_reset(BARG);

		retval = get_n_barg(&barg_unit,BROWSE,0,BACKWARD,e_mesg);
		if(retval == EFL ||
			strcmp(barg_unit.b_code, emprec.em_barg) != 0){
			sprintf(e_mesg,"Bargaining Unit does no exist: %s",
				emprec.em_barg);
  			DispError((char *)&s_sth,e_mesg);
			s_sth.s_empcd[0] = LV_CHAR;
			return(ERROR);
		}
		if(retval < 0){
  			DispError((char *)&s_sth,e_mesg);
			s_sth.s_empcd[0] = LV_CHAR;
  			return(ERROR);
		}
		seq_over(BARG);

		retval = WriteFields((char *)&s_sth,NAME_FLD,NAME_FLD);
		if(retval < 0) return(retval);
		break;

	default:
		break;
	}/* end switch */	

	return(NOERROR);

}	/* Validate() */
/*-----------------------------------------------------------------------*/
/*                                                                       */
/*  Display help window for applicable fields                            */
static
WindowHelp()
{
	int	err, retval;

	switch(sr.curfld){
	case EMPCD_FLD:
		err = emp_hlp(s_sth.s_empcd,7,13);
		if(err < 0) return(err);
		redraw();

		if(s_sth.s_empcd[0] == '\0'){
			s_sth.s_empcd[0] = LV_CHAR;
			return(-1);
		}
		strcpy(emprec.em_numb,s_sth.s_empcd);
		retval = get_employee(&emprec,BROWSE,0,e_mesg);
		if(retval < 0){
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}

		strcpy(e_mesg,emprec.em_last_name);
		strcat(e_mesg,", ");
		strcat(e_mesg,emprec.em_first_name);
		strcat(e_mesg," ");
		strcat(e_mesg,emprec.em_mid_name);

		strncpy(s_sth.s_name,e_mesg,30);
		strcpy(s_sth.s_empstat,emprec.em_status);

		strcpy(barg_unit.b_code,emprec.em_barg);
		barg_unit.b_date = get_date();
		flg_reset(BARG);

		retval = get_n_barg(&barg_unit,BROWSE,0,BACKWARD,e_mesg);
		if(retval == EFL ||
			strcmp(barg_unit.b_code, emprec.em_barg) != 0){
			sprintf(e_mesg,"Bargaining Unit does no exist: %s",
				emprec.em_barg);
  			DispError((char *)&s_sth,e_mesg);
			s_sth.s_empcd[0] = LV_CHAR;
			return(ERROR);
		}
		if(retval < 0){
  			DispError((char *)&s_sth,e_mesg);
			s_sth.s_empcd[0] = LV_CHAR;
  			return(ERROR);
		}
		seq_over(BARG);

		retval = WriteFields((char *)&s_sth,NAME_FLD,ST_AMOUNT);
		if(retval < 0) return(retval);
		break;

	default:
		fomen(NOHELP);
		break;
	}
	sr.nextfld = sr.curfld ;
	return(NOERROR) ;

}	/* WindowHelp() */
/*-----------------------------------------------------------------------*/
/* Display the confirmation message at the bottom of the screen, take the
   option from user and call necessary functions */
/*-----------------------------------------------------------------------*/
static
ReadOption()
{
	int	retval;

	for( ; ; ) {

#ifdef	ENGLISH
		retval = GetOpt("Y(es), H(eader edit), E(dit Item), C(ancel)", "YHLEC");
#else	
		retval = GetOpt("Y(es), H(eader edit), E(dit Item), C(ancel)", "YHLEC");
#endif

		switch(retval) {	/* process the option */
		case  YES :
			s_sth.s_mesg[0] = HV_CHAR;
			sr.nextfld = MESG_FLD1; 
			fomwf((char *)&s_sth);

	
			return(YES);	

		case  HDREDIT :
			retval = ChangeHeader();
			if(retval < 0) return(retval);
			break;

		case  EDITITEMS:
			retval = GetNextOpt();
			if(retval < 0) return(retval);
			break;

		case  CANCEL:
#ifdef	ENGLISH
			retval = GetOpt("Confirm The Cancel (Y/N)?", "YN");
#else	
			retval = GetOpt("Confirmer l'annulation (O/N)?", "ON");
#endif
			if ( retval == YES ) 
				return( CANCEL );
			break ;

		}/* switch */

		if(retval < 0) return(retval);

	}	/* for(;;) */
}	
/*-------------------------------------------------------------------*/
/* get the next sub option line 				     */
GetNextOpt()
{
	int retval;

	for( ; ; ) {

#ifdef	ENGLISH
		retval = GetOpt("I(tem edit), S(creen edit), N(ext), P(rev), E(nd)", "ISNPE");
#else	
		retval = GetOpt("I(tem edit), S(creen edit), N(ext), P(rev), E(nd)", "ISNPE");
#endif

		switch(retval) {	/* process the option */
		case ITEMEDIT:
			for(;;){
				s_sth.s_field = LV_SHORT;
				retval = ReadFields((char *)&s_sth,CHG_FLD,
					CHG_FLD,Validate,WindowHelp,1);

				if(retval < 0) return(retval);
				if(s_sth.s_field <0 || s_sth.s_field > 5)
					 continue;

				if(s_sth.s_field == 0 || retval == RET_USER_ESC)
 					break;

				retval = LineChange(s_sth.s_field);
				if(retval < 0) return(retval);
			}
			s_sth.s_field = HV_SHORT;
			retval = WriteFields((char *)&s_sth,CHG_FLD,CHG_FLD);
			if(retval < 0) return(retval);
			break;
			
		case  SCREDIT:
			retval = ChangeScreen();
			if(retval < 0 && retval != UNDEF) return(retval);
			if(retval == UNDEF)
				retval = 0;
			break;

		case PREV:	/* Display the prev page of items */

			if(tempptr && tempptr->prevptr){
				tempptr = tempptr->prevptr;
				current.page --;
				if(ShowPage()<0 ) return(-1);
			}
			else{
				fomer(FIRSTPG);
			}
			break;

		case NEXT:	/* Display the next page of items */

			if(tempptr && tempptr->nextptr){
				tempptr = tempptr->nextptr;
				current.page ++;
				if(ShowPage()<0 ) return(-1);
			}
			else{
				fomer(LASTPG);
			}

			break;

		case END:
			return(NOERROR);
		
		default:
			break;	
		}/* switch */

		if(retval < 0) return(retval);

	}	/* for(;;) */
}	
/*-------------------------------------------------------------------*/
/* Edit the header fields					     */
ChangeHeader()
{
	int retval, stfld, i;
	double tmp_amount;

	SetDupBuffers(ST_AMOUNT, END_AMOUNT, 1);

	for(i=2;i<NO_EARN;i++){
		tmp_amount = s_sth.s_amnts[i];
		stfld = ST_AMOUNT +(i * 100);
		if(stfld == EMP_CCP) continue;
		s_sth.s_amnts[i] = LV_DOUBLE;

		retval=ReadFields((char*)&s_sth,stfld,stfld,Validate,
			WindowHelp,1);
		if(retval < 0) return(retval);
		if(retval == RET_USER_ESC){
			s_sth.s_amnts[i] = tmp_amount;
			break;
		}
		
		s_sth.s_amnts[4] = s_sth.s_amnts[2];
		stfld = ST_AMOUNT + 400;
		WriteFields((char *)&s_sth,stfld,stfld);
	}

	return(NOERROR);
}
/*-------------------------------------------------------------------*/
/* change specific header field					     */
ChangeFields()
{
	int retval, stfld;
	double tmp_amount;

	for(;;){
		SetDupBuffers(ST_AMOUNT, END_AMOUNT, 1);
		s_sth.s_field = LV_SHORT;
		retval =ReadFields((char*)&s_sth,PAGE_FLD,PAGE_FLD,Validate,
			WindowHelp,1);
		if(retval < 0) return(retval);

		if(s_sth.s_field == 0) break;
		if(s_sth.s_field < 2 || s_sth.s_field > 13) continue;

		stfld = ST_AMOUNT + ((s_sth.s_field - 1) * 100);
		if(stfld == EMP_CCP) continue;
		tmp_amount = s_sth.s_amnts[s_sth.s_field-1];
		s_sth.s_amnts[s_sth.s_field-1] = LV_DOUBLE;

		retval =ReadFields((char*)&s_sth,stfld,stfld,Validate,
			WindowHelp,1);
		if(retval < 0) return(retval);

		if(retval == RET_USER_ESC){
			s_sth.s_amnts[s_sth.s_field-1] = tmp_amount;
		}

		s_sth.s_amnts[4] = s_sth.s_amnts[2];
		stfld = ST_AMOUNT + 400;
		WriteFields((char *)&s_sth,stfld,stfld);
	}

	return(NOERROR);
}
/*-------------------------------------------------------------------*/
ClearScreen()
{
	int retval, i;
	
	s_sth.s_empcd[0] = HV_CHAR;
	s_sth.s_name[0] = HV_CHAR;
	s_sth.s_empstat[0] = HV_CHAR;
	s_sth.s_page = HV_SHORT;
	s_sth.s_dummy1[0] = HV_CHAR;

	for(i=0;i<NO_EARN;i++){
		s_sth.s_amnts[i] = HV_DOUBLE;
	}

	retval = WriteFields((char *)&s_sth,EMPCD_FLD,PAGE_FLD);
	if(retval < 0) return(retval);

	retval = ClearItemLines();
	if(retval < 0) return(retval);

	return(NOERROR);
}
/*-------------------------------------------------------------------
Fill the item array with high values
-------------------------------------------------------------------*/
ClearItemLines()
{
	int 	j;
	int	retval;

	s_sth.s_page = HV_SHORT;

	for( j=0; j < NO_ITEMS; j++ ){
		s_sth.s_deds[j].s_dedcd[0] = HV_CHAR;
		s_sth.s_deds[j].s_amount = HV_DOUBLE;
		s_sth.s_deds[j].s_ddesc[0] = HV_CHAR;
		s_sth.s_deds[j].s_status[0] = HV_CHAR;
	}

	retval = WriteFields((char*)&s_sth,STITEM, ENDITEM);
	if(retval < 0) return(-1);

	return(NOERROR);
}
/*-----------------------------------------------------------------------*/
/*                                                                       */
/* Display message and get the option */
static
GetOpt( msg, option )
       char *msg;
       char *option;
{
        int	j,  i;
	
        strcpy( s_sth.s_mesg, msg );
	sr.nextfld = MESG_FLD1; 
	fomwf((char *)&s_sth);

	for ( ; ; ) {
		s_sth.s_opt[0] = LV_CHAR ;
		if ( ReadFields((char*)&s_sth, OPT_FLD1, OPT_FLD1, Validate,
						WindowHelp, 0) < 0 ) 
			return(-1);

                j = strlen(option);
		for ( i = 0; i < j; i++ ) 
			if ( s_sth.s_opt[0] == option[i] )
                           break;
                if(i != j) break ;
                fomer(INVOPT);
	}
        s_sth.s_mesg[0] = HV_CHAR ;
        s_sth.s_opt[0] = HV_CHAR ;
	if ( WriteFields((char*)&s_sth,MESG_FLD1,OPT_FLD1) < 0 ) 
		return(-1);
 
        return( (int)(option[i])) ;
}
/*-------------------------------------------------------------------
Change item fields 
-------------------------------------------------------------------*/
ChangeScreen()
{
	int	retval;
	int	i;

	tempptr = headptr;
	current.page = 1;
	current.line = 1;

	if(tempptr == NULL) return(UNDEF);

	if(ShowPage()<0) return(-1);

	fomen(ITMMSG);

	for(;;){

		for(i=0; i<NO_ITEMS; i++){

			/* no changes if item inactive or non-existant */

			if(i >= tempptr->lines_entered)
				return(NOERROR);

			if(strcmp(tempptr->fields[i].s_status,INACTIVE)==0 )
				continue;

			retval = LineChange(i+1);
			if(retval < 0) return(-1);

			if(retval == EXIT) return(NOERROR);
		}

		/* next page */

		if(tempptr && tempptr->nextptr){
			tempptr = tempptr->nextptr;
			current.page ++;
			if(ShowPage()<0 ) return(-1);
		}
		else{
			return(NOERROR);
		}

	} /* end for loop */
}
/*-------------------------------------------------------------------*/
/* change items in line						     */
ChangeItems()
{
	int retval;

	for(;;){
		scpy((char*)&tmp_sth, (char*)&s_sth, sizeof(s_sth));
		SetDupBuffers(EMPCD_FLD, ENDITEM, 1);

		strcpy(s_sth.s_mesg, FLDPROMPT);
		DispMesgFld((char*)&s_sth);

		s_sth.s_field = LV_SHORT;
		retval = ReadFields((char*)&s_sth, CHG_FLD, CHG_FLD,
			Validate, WindowHelp, 1);
		if (retval < 0) return(-1);

		if (retval == RET_USER_ESC) break;  /* User enters ESC-F */
       		if (s_sth.s_field == 0 ) break;   /* Finished changing */

		s_sth.s_mesg[0] = HV_CHAR ;
		DispMesgFld((char*)&s_sth);

		retval = LineChange(s_sth.s_field);
		if(retval < 0) return(retval);
	}

	s_sth.s_field = HV_SHORT;
	WriteFields((char *)&s_sth,CHG_FLD,CHG_FLD);

	return(retval);
}
/*-------------------------------------------------------------------
Read new values at given line 
-------------------------------------------------------------------*/
LineChange( line )	
int line;
{
	int 	retval, st_fld, end_fld;

	if(!tempptr) return(NOERROR);	/* if no pages, return */

	if(strcmp(tempptr->fields[line].s_status, INACTIVE) == 0){
		fomer(NOTACT);
		get();
		return(NOERROR);
	}

	if( line > tempptr->lines_entered )
		return(NOERROR);

	scpy((char*)&tmp_sth,(char*)&s_sth,sizeof(s_sth));

	/* course code field */

	st_fld = STAMOUNT + ((line-1)*STEP);
	end_fld = st_fld;

	SetDupBuffers(st_fld, end_fld, 1);

	s_sth.s_deds[line-1].s_amount = LV_DOUBLE;

	retval = ReadFields((char*)&s_sth, st_fld, 
			end_fld, Validate, WindowHelp,1);

	if(retval == RET_USER_ESC) retval = EXIT;
	if(retval<0)	return(retval);

	if(retval == EXIT){ 
		CopyBack((char*)&s_sth, (char*)&tmp_sth,sr.curfld,
			end_fld);
		return(retval);
	}
	
	strcpy(s_sth.s_deds[line-1].s_status, ACTIVE);

	tempptr->fields[line-1].s_amount = 
		    s_sth.s_deds[line-1].s_amount;
	strncpy(tempptr->fields[line-1].s_status,
		    s_sth.s_deds[line-1].s_status, 4);

	/* Display Changes After Edit is complete */
	if( WriteFields((char*)&s_sth, st_fld, end_fld + 100) < 0)
		return(-1);

	return(NOERROR);
}
/*-------------------------------------------------------------------
Free the linked list
-------------------------------------------------------------------*/
static
FreeList()	
{
	int 	i;

	/* clear the screen items from linked list */

	for(tempptr = headptr;tempptr;tempptr = tempptr->nextptr){

		for( i=0; i <= NO_ITEMS; i++) {
			if(i >= tempptr->lines_entered) break;
			tempptr->fields[i].s_dedcd[0] = HV_CHAR;
		}
	}

	for( tempptr=tailptr; tempptr; tempptr=tailptr ){
		tailptr=tailptr->prevptr;
		free((char *)tempptr );
	}

	headptr = NULL;

	return(NOERROR);
}
/*-------------------------------------------------------------------*/
/* Dump contents of node pointed to by tempptr onto screen */
ShowPage()	
{
	/* transfer data to screen structure */
	if( ListToScreen()<0 ) return(-1);
	
	/* display on screen */
	if( WriteFields((char*)&s_sth,STITEM,ENDITEM)<0) 
		return(-1);
	
	/* Paginate properly */
	s_sth.s_page = current.page;
	WriteFields((char *)&s_sth,PAGE_FLD,PAGE_FLD);

	return(0);
}
/*-------------------------------------------------------------------
copy contents of *tempptr to screen (items part) 
-------------------------------------------------------------------*/
ListToScreen()	
{
	short i;

	if(tempptr==NULL) return(-1);

	/* for group already made */
	for( i=0; i < tempptr->lines_entered; i++){ 

		strcpy(s_sth.s_deds[i].s_dedcd, 
			tempptr->fields[i].s_dedcd);
		s_sth.s_deds[i].s_amount = 
			tempptr->fields[i].s_amount; 
		strcpy(s_sth.s_deds[i].s_ddesc,
		    	tempptr->fields[i].s_ddesc);
		strcpy(s_sth.s_deds[i].s_status,
			tempptr->fields[i].s_status);
	}
	
	/* clear other lines */

	for(i=tempptr->lines_entered; i < NO_ITEMS; i++){
		s_sth.s_deds[i].s_dedcd[0] = HV_CHAR;
		s_sth.s_deds[i].s_amount= HV_DOUBLE;
		s_sth.s_deds[i].s_ddesc[0] = HV_CHAR;
		s_sth.s_deds[i].s_status[0]  = HV_CHAR;
	}

	return(NOERROR);
}
/*-------------------------------------------------------------------
Add a new node to the linked list
-------------------------------------------------------------------*/
MakeFreshPage()	
{
	tempptr=PageAllocated();

	if( tempptr==NULL ){

		fomen(MEMERR);
		get();
		return(ALLOC_ERROR);
	}

	if( tailptr == NULL ){	/* If not a single node in the list yet */
		headptr=tailptr=tempptr;
		tempptr->prevptr = NULL;
		tempptr->nextptr = NULL;
	}
	else{			/* if at least one node exists */
		tailptr->lines_entered = current.line;
		tailptr->nextptr = tempptr;
		tempptr->prevptr = tailptr;
		tempptr->nextptr = NULL;
		tailptr = tempptr;
	}
	tempptr->lines_entered = 0;

	if(ClearItemLines()<0 ) return(-1);

	if(WriteFields((char*)&s_sth,STITEM,ENDITEM)<0 )
		return(-1);

	return(NOERROR);
}
/*-----------------------------------------------------------------------*/
MoveLows()
{
	int i;

	for(i=0;i<NO_ITEMS;i++){
		s_sth.s_deds[i].s_amount = LV_DOUBLE;
	}

	return(NOERROR);
}
/*-----------------------------------------------------------------------*/
SetDupBuffers(stfld, endfld, value)
int	stfld, endfld, value;
{
	int	i;

	for(i = stfld; i <= endfld; i += 100){

		fomca1(i, 19, value);
		fomca1(i, 10, value);
	}

	sr.nextfld = stfld;
	sr.endfld = endfld;
	fomud((char*)&s_sth );

	return(NOERROR);
}
/*-----------------------------------------------------------------------*/
AdjCPP()
{
	int retval;
	double	tmp_cpp, tmp_old_cpp;

	tmp_cpp = D_Roundoff(s_sth.s_amnts[4]);
	tmp_old_cpp = D_Roundoff(payearn.pe_cpp);

	tmp_share = tmp_cpp;
	tmp_income = tot_income;

	if(tmp_old_cpp != 0){
		strcpy(jrent.jr_emp_numb,s_sth.s_empcd);
		strcpy(jrent.jr_code,"CPP");
		jrent.jr_fund = 0;
		jrent.jr_no = 0;
		flg_reset(JR_ENT);

		for( ; ; ){
			retval = get_n_jr_ent(&jrent,UPDATE,1,FORWARD,e_mesg);
			if(retval < 0){
				if(retval == EFL) break;
				DispError((char *)&s_sth,e_mesg);
				seq_over(JR_ENT);
			  	return(ERROR);
			}
			if(strcmp(jrent.jr_emp_numb, s_sth.s_empcd) != 0 ||
			   strcmp(jrent.jr_code,"CPP") != 0)
				break;

			if(jrent.jr_type[0] != 'S') continue;

			tot_amount = jrent.jr_amount;
			if(tmp_old_cpp != 0)
				jrent.jr_amount = D_Roundoff(tmp_cpp *
					 tot_amount / tmp_old_cpp);

			tmp_cpp -= jrent.jr_amount;
			tmp_old_cpp -= tot_amount;

			retval = put_jr_ent(&jrent,UPDATE,e_mesg);
			if(retval < 0) return(retval);
	
			retval = commit(e_mesg);
			if(retval < 0) return(retval);

			jrent.jr_no++;
			flg_reset(JR_ENT);
		}
		seq_over(JR_ENT);

		strcpy(jrent.jr_emp_numb,s_sth.s_empcd);
		strcpy(jrent.jr_code,"CPP");
		jrent.jr_fund = 0;
		jrent.jr_no = 0;
		flg_reset(JR_ENT);

		for( ; ; ){

			retval = get_n_jr_ent(&jrent,UPDATE,1,FORWARD,e_mesg);
			if(retval < 0){
				DispError((char *)&s_sth,e_mesg);
				return(retval);
			}
			if(strcmp(jrent.jr_emp_numb, s_sth.s_empcd) != 0 ||
			   strcmp(jrent.jr_code,"CPP") != 0)
				return(NOERROR);

			if(jrent.jr_type[0] == 'D') break;
		}
		seq_over(JR_ENT);

		jrent.jr_amount = s_sth.s_amnts[4]*2;
		jrent.jr_amount = jrent.jr_amount * -1;

		retval = put_jr_ent(&jrent,UPDATE,e_mesg);
		if(retval < 0) return(retval);

		retval = commit(e_mesg);
		if(retval < 0) return(retval);
	}
	else{
		/* Create journal entries for the employer share */

		strcpy(jrent.jr_emp_numb,emprec.em_numb);
		strcpy(jrent.jr_type,"B");
		jrent.jr_fund = 0;
		jrent.jr_no = 0;
		
		flg_reset(JR_ENT);
		for( ; ; ){
			retval = get_n_jr_ent(&jrent,BROWSE,2,FORWARD,e_mesg);
		        if(retval < 0){
				if(retval == EFL) break;
				DispError((char *)&s_sth,e_mesg);
				roll_back(e_mesg);
				seq_over(JR_ENT);
				return(ERROR);
			}
			if(strcmp(jrent.jr_emp_numb,emprec.em_numb) != 0) 
				break;
		
			if(strcmp(jrent.jr_type,"E") != 0 &&
			   strcmp(jrent.jr_type,"X") != 0 &&
			   strcmp(jrent.jr_type,"B") != 0) 
				continue;

			strcpy(last_type,jrent.jr_type);
			last_fund = jrent.jr_fund;
			last_jr = jrent.jr_no;

			tot_amount = D_Roundoff(jrent.jr_amount);

			/* this first glacct read finds the needed fields
			   in order to do the second read - these fields are
			   the fund, the cost center and the class */

			gl_acct.gl_fund = jrent.jr_fund;
			strcpy(gl_acct.gl_acct,jrent.jr_acct);
			strcpy(gl_acct.gl_class,jrent.jr_class);
	
			retval = get_glacct(&gl_acct,BROWSE,2,e_mesg);
			if(retval < 0){
				DispError((char *)&s_sth,e_mesg);
				roll_back(e_mesg);
				return(ERROR);
			}
			strcpy(gl_acct.gl_type,"C");
			strcpy(gl_acct.gl_earn,"CPP");

			retval=get_glacct(&gl_acct,BROWSE,0,e_mesg);
			if(retval < 0){
				DispError((char *)&s_sth,e_mesg);
				roll_back(e_mesg);
				return(ERROR);
		}
		seq_over(GLACCT);
		retval = GetJr(gl_acct.gl_fund);
		if(retval < 0) {
			return(ERROR);
		}

		strcpy(jrent.jr_emp_numb,emprec.em_numb);
		jrent.jr_fund = gl_acct.gl_fund;
		strcpy(jrent.jr_acct,gl_acct.gl_acct);
		strcpy(jrent.jr_code,"CPP");
		strcpy(jrent.jr_type,"S");
		jrent.jr_amount = ((tmp_share * tot_amount) /
						 tmp_income);

		jrent.jr_amount = D_Roundoff(jrent.jr_amount);
		tmp_share -= jrent.jr_amount;
		tmp_income -= tot_amount;

		if(jrent.jr_amount != 0.00) {
			retval = put_jr_ent(&jrent,ADD,e_mesg);	
			if(retval < 0) {
				DispError((char *)&s_sth,e_mesg);
				roll_back(e_mesg);
				return(ERROR);
			}
			retval = commit(e_mesg) ;
		  	if(retval < 0) {
				DispError((char *)&s_sth,e_mesg);
				roll_back(e_mesg);
				return(ERROR);
				}
			}
			strcpy(jrent.jr_emp_numb,emprec.em_numb);
			strcpy(jrent.jr_type, last_type);
			jrent.jr_fund = last_fund;
			jrent.jr_no = last_jr + 1;
	
			flg_reset(JR_ENT);
		}
		seq_over(JR_ENT);

		/* Create journal entry for the liability */

		jrent.jr_fund = barg_unit.b_fund;
		retval = GetJr(barg_unit.b_fund);
		if(retval < 0) {
			return(ERROR);
		}
		strcpy(jrent.jr_acct,barg_unit.b_cpp_acct);

		/* Journal entry includes matching shares of the
		  employee and employer share.	*/

		jrent.jr_amount = s_sth.s_amnts[4]*2;
	
		strcpy(jrent.jr_emp_numb,payearn.pe_numb);
		strcpy(jrent.jr_code,"CPP");
		strcpy(jrent.jr_type,"D");
	
		if(jrent.jr_amount != 0.00) {
			jrent.jr_amount = jrent.jr_amount * -1;
			retval = put_jr_ent(&jrent,ADD,e_mesg);	
			if(retval < 0) {
				DispError((char *)&s_sth,e_mesg);
				roll_back(e_mesg);
				return(ERROR);
			}
		       	retval = commit(e_mesg) ;
		      	if(retval < 0) {
				DispError((char *)&s_sth,e_mesg);
				roll_back(e_mesg);
				return(ERROR);
		       	}
		}
	}

	return(NOERROR);
}
/*-----------------------------------------------------------------------*/
AdjUIC()
{
	int retval;
	double	tmp_amount;
	double	tmp_uic, tmp_old_uic;

	tmp_uic = D_Roundoff(s_sth.s_amnts[6]);
	tmp_old_uic = D_Roundoff(payearn.pe_uic_employer);

	tmp_share = s_sth.s_amnts[8];
	tmp_income = tot_income;

	if(tmp_old_uic != 0){
		strcpy(jrent.jr_emp_numb,s_sth.s_empcd);
		strcpy(jrent.jr_code,"UIC");
		jrent.jr_fund = 0;
		jrent.jr_no = 0;
		flg_reset(JR_ENT);

		for( ; ; ){
			retval = get_n_jr_ent(&jrent,UPDATE,1,FORWARD,e_mesg);
			if(retval < 0){
				if(retval == EFL) break;
				DispError((char *)&s_sth,e_mesg);
				seq_over(JR_ENT);
			  	return(ERROR);
			}
			if(strcmp(jrent.jr_emp_numb, s_sth.s_empcd) != 0 ||
			   strcmp(jrent.jr_code,"UIC") != 0)
				break;

			if(jrent.jr_type[0] != 'S') continue;

			tmp_amount = jrent.jr_amount;
			if(tmp_old_uic != 0)
				jrent.jr_amount = D_Roundoff(tmp_share *
				 tmp_amount / tmp_old_uic);

			tmp_uic -= jrent.jr_amount;
		/*	tmp_old_uic -= tmp_amount; */

			retval = put_jr_ent(&jrent,UPDATE,e_mesg);
			if(retval < 0) return(retval);

			retval = commit(e_mesg);
			if(retval < 0) return(retval);

			jrent.jr_no++;
			flg_reset(JR_ENT);
		}
		seq_over(JR_ENT);

		strcpy(jrent.jr_emp_numb,s_sth.s_empcd);
		strcpy(jrent.jr_code,"UIC");
		jrent.jr_fund = 0;
		jrent.jr_no = 0;
		flg_reset(JR_ENT);

		for( ; ; ){
			retval = get_n_jr_ent(&jrent,UPDATE,1,FORWARD,e_mesg);
			if(retval == EFL)
				break;
			if(retval < 0){
				DispError((char *)&s_sth,e_mesg);
				return(retval);
			}
			if(strcmp(jrent.jr_emp_numb, s_sth.s_empcd) != 0 || 
			   strcmp(jrent.jr_code,"UIC") != 0)
				return(NOERROR);

			if(strcmp(jrent.jr_type,"D")!=0) 
				continue;
			if(jrent.jr_type[0] == 'D'){ 

			    jrent.jr_amount = D_Roundoff(s_sth.s_amnts[6] 
			          	 + s_sth.s_amnts[8]);
			    jrent.jr_amount = jrent.jr_amount * -1;

			    retval = put_jr_ent(&jrent,UPDATE,e_mesg);
			    if(retval < 0) return(retval);
			}
			jrent.jr_no++;
			flg_reset(JR_ENT);

		}
		seq_over(JR_ENT);
		retval = commit(e_mesg);
		if(retval < 0) return(retval);
	}
	else{
		/* Create journal entries for the employer shares */

		strcpy(jrent.jr_emp_numb,emprec.em_numb);
		strcpy(jrent.jr_type,"B");
		jrent.jr_fund = 0;
		jrent.jr_no = 0;
		flg_reset(JR_ENT);

		for( ; ; ){
			retval = get_n_jr_ent(&jrent,BROWSE,2,FORWARD,e_mesg);
			if(retval < 0){
				if(retval == EFL) break;
				DispError((char *)&s_sth,e_mesg);
				roll_back(e_mesg);
				seq_over(JR_ENT);
				return(ERROR);
	      		}
	     		if(strcmp(jrent.jr_emp_numb,emprec.em_numb) != 0) 
				break;
	      		if((strcmp(jrent.jr_type,"E") != 0) &&
				(strcmp(jrent.jr_type,"X") != 0) &&
				(strcmp(jrent.jr_type,"B") != 0)) 
				continue;

			strcpy(last_type, jrent.jr_type);
			last_fund = jrent.jr_fund;
			last_jr = jrent.jr_no;

			tot_amount = D_Roundoff(jrent.jr_amount);

			/* this first read gets the rest of the keys needed
			   for the second glacct read */

			gl_acct.gl_fund = jrent.jr_fund;
			strcpy(gl_acct.gl_acct,jrent.jr_acct);
			strcpy(gl_acct.gl_class,jrent.jr_class);

			retval = get_glacct(&gl_acct,BROWSE,2,e_mesg);
			if(retval < 0 && retval != UNDEF){
				DispError((char *)&s_sth,e_mesg);
				roll_back(e_mesg);
				return(ERROR);
			}
			if(retval == UNDEF)
				continue;
			strcpy(gl_acct.gl_type,"U");
			strcpy(gl_acct.gl_earn,"UIC");
	
			retval = get_glacct(&gl_acct,BROWSE,0,e_mesg);
			if(retval < 0 && retval != UNDEF){
				DispError((char *)&s_sth,e_mesg);
				roll_back(e_mesg);
				return(ERROR);
		 	}
		 	if(retval == UNDEF)
				continue;
			seq_over(GLACCT);
			retval = GetJr(gl_acct.gl_fund);
			if(retval < 0) {
				return(ERROR);
			}
 
		 	strcpy(jrent.jr_emp_numb,payearn.pe_numb);
			jrent.jr_fund = gl_acct.gl_fund;
			strcpy(jrent.jr_acct,gl_acct.gl_acct);
			strcpy(jrent.jr_code,"UIC");
			strcpy(jrent.jr_type,"S");
			jrent.jr_amount = D_Roundoff((tmp_share * tot_amount)/
						 tmp_income);

			tmp_share -= jrent.jr_amount;
			tmp_income -= tot_amount;

		 	if(jrent.jr_amount != 0.00) {
		      	  retval = put_jr_ent(&jrent,ADD,e_mesg);	
		       	  if(retval < 0) {
				DispError((char *)&s_sth,e_mesg);
				roll_back(e_mesg);
				return(ERROR);
		       	  }
		          retval = commit(e_mesg) ;
  		          if(retval < 0) {
				DispError((char *)&s_sth,e_mesg);
				roll_back(e_mesg);
				seq_over(JR_ENT);
				return(ERROR);
		          }
		 	}
			strcpy(jrent.jr_emp_numb,emprec.em_numb);
		 	strcpy(jrent.jr_type,last_type);
		 	jrent.jr_fund = last_fund;
		 	jrent.jr_no = last_jr + 1;

		 	flg_reset(JR_ENT);
  		    }
		    seq_over(JR_ENT);

		    /* Create journal entry for liability	*/

		    jrent.jr_fund = barg_unit.b_fund;
		    retval = GetJr(barg_unit.b_fund);
		    if(retval < 0) {
			return(ERROR);
		    }
		    jrent.jr_fund = barg_unit.b_fund;
		    strcpy(jrent.jr_acct,barg_unit.b_uic_acct);

		    jrent.jr_amount =
			 D_Roundoff(s_sth.s_amnts[8]+ s_sth.s_amnts[6]); 
		    strcpy(jrent.jr_emp_numb,payearn.pe_numb);
		    strcpy(jrent.jr_code,"UIC");
		    strcpy(jrent.jr_type,"D");

		    if(jrent.jr_amount != 0.00) {
			jrent.jr_amount = jrent.jr_amount * -1;
			retval = put_jr_ent(&jrent,ADD,e_mesg);	
			if(retval < 0) {
				DispError((char *)&s_sth,e_mesg);
				roll_back(e_mesg);
				return(ERROR);
			}
		    	retval = commit(e_mesg) ;
  		    	if(retval < 0) {
				DispError((char *)&s_sth,e_mesg);
				roll_back(e_mesg);
				return(ERROR);
		    	}
		    }
	}

	return(NOERROR);
}
/*-----------------------------------------------------------------------*/
AdjTaxLia()
{
	int retval;

	if(payearn.pe_tax != 0){
		strcpy(jrent.jr_emp_numb,s_sth.s_empcd);
		strcpy(jrent.jr_code,"TAX");
		jrent.jr_fund = 0;
		jrent.jr_no = 0;
		flg_reset(JR_ENT);

		for( ; ; ){
			retval = get_n_jr_ent(&jrent,UPDATE,1,FORWARD,e_mesg);
			if(retval < 0){
				DispError((char *)&s_sth,e_mesg);
				return(retval);
			}
			if(strcmp(jrent.jr_emp_numb, s_sth.s_empcd) != 0 ||
			   strcmp(jrent.jr_code,"TAX") != 0)
				return(NOERROR);

			if(jrent.jr_type[0] == 'D') break;
		}
		seq_over(JR_ENT);

		jrent.jr_amount = s_sth.s_amnts[12];
		jrent.jr_amount = jrent.jr_amount * -1;

		retval = put_jr_ent(&jrent,UPDATE,e_mesg);
		if(retval < 0) return(retval);

		retval = commit(e_mesg);
		if(retval < 0) return(retval);
	}
	else{
		/* Create journal entry for the liability	*/

		jrent.jr_fund = barg_unit.b_fund;
		retval = GetJr(barg_unit.b_fund);
		if(retval < 0) {
			return(ERROR);
		}
		jrent.jr_fund = barg_unit.b_fund;
		strcpy(jrent.jr_acct,barg_unit.b_tax_acct);

	  	jrent.jr_amount = s_sth.s_amnts[12];
		strcpy(jrent.jr_emp_numb,payearn.pe_numb);
		strcpy(jrent.jr_code,"TAX");
		strcpy(jrent.jr_type,"D");

		if(jrent.jr_amount != 0.00) {
		  jrent.jr_amount = jrent.jr_amount * -1;
		  retval = put_jr_ent(&jrent,ADD,e_mesg);	
		  if(retval < 0) {
			DispError((char *)&s_sth,e_mesg);
			roll_back(e_mesg);
			return(ERROR);
		  }
		  retval = commit(e_mesg) ;
	  	  if(retval < 0) {
			DispError((char *)&s_sth,e_mesg);
			roll_back(e_mesg);
			return(ERROR);
		  }
		}
	}

	return(NOERROR);
}
/*-----------------------------------------------------------------------*/
AdjReg()
{
	int retval;
	double	tot_reg_pen;
	double	empr_share, empr_share2;
	double	tmp_amount;
	double	tmp_reg, tmp_old_reg;

	strcpy(reg_pen.rg_code,emprec.em_reg_pen);
	strcpy(reg_pen.rg_pp_code,barg_unit.b_pp_code);

	retval = get_reg_pen(&reg_pen,BROWSE,0,e_mesg);
	if(retval != NOERROR && retval != UNDEF){
		DispError((char *)&s_sth,e_mesg) ;
	  	return(ERROR);
	}

	tot_reg_pen = (payearn.pe_reg1 + payearn.pe_reg2 +
			payearn.pe_reg3 + payearn.pe_reg_prior +
			payearn.pe_reg_opt + payearn.pe_reg_nonm);

	empr_share = ((tot_reg_pen / ((100 - 
		reg_pen.rg_employer_sh) / 100)) - tot_reg_pen);

	tot_reg_pen = (s_sth.s_amnts[9] + s_sth.s_amnts[10] +
			s_sth.s_amnts[11] + payearn.pe_reg_prior +
			payearn.pe_reg_opt + payearn.pe_reg_nonm);

	empr_share2 = ((tot_reg_pen / ((100 - 
		reg_pen.rg_employer_sh) / 100)) - tot_reg_pen);
		
	tmp_reg = D_Roundoff(empr_share2);
	tmp_old_reg = D_Roundoff(empr_share);

	if(tmp_old_reg != 0){
		strcpy(jrent.jr_emp_numb,s_sth.s_empcd);
		strcpy(jrent.jr_code,emprec.em_reg_pen);
		jrent.jr_fund = 0;
		jrent.jr_no = 0;
		flg_reset(JR_ENT);

		for( ; ; ){
			retval = get_n_jr_ent(&jrent,UPDATE,1,FORWARD,e_mesg);
			if(retval < 0){
				if(retval == EFL) break;
				DispError((char *)&s_sth,e_mesg);
				seq_over(JR_ENT);
			  	return(ERROR);
			}
			if(strcmp(jrent.jr_emp_numb, s_sth.s_empcd) != 0 ||
			   strcmp(jrent.jr_code,emprec.em_reg_pen) != 0)
				break;
	
			if(jrent.jr_type[0] != 'S') continue;
	
			tmp_amount = jrent.jr_amount;
			if(tmp_old_reg != 0)
				jrent.jr_amount = D_Roundoff(tmp_reg *
					 tmp_amount / tmp_old_reg);
	
			tmp_reg -= jrent.jr_amount;
			tmp_old_reg -= tmp_amount;
		
			retval = put_jr_ent(&jrent,UPDATE,e_mesg);
			if(retval < 0) return(retval);
	
			retval = commit(e_mesg);
			if(retval < 0) return(retval);

			jrent.jr_no++;
			flg_reset(JR_ENT);
		}
		seq_over(JR_ENT);

		strcpy(jrent.jr_emp_numb,s_sth.s_empcd);
		strcpy(jrent.jr_code,emprec.em_reg_pen);
		jrent.jr_fund = 0;
		jrent.jr_no = 0;
		flg_reset(JR_ENT);

		for( ; ; ){
			retval = get_n_jr_ent(&jrent,UPDATE,1,FORWARD,e_mesg);
			if(retval < 0){
				DispError((char *)&s_sth,e_mesg);
				return(retval);
			}
			if(strcmp(jrent.jr_emp_numb, s_sth.s_empcd) != 0 ||
			   strcmp(jrent.jr_code,emprec.em_reg_pen) != 0)
				return(NOERROR);

			if(jrent.jr_type[0] == 'D') break;
		}
		seq_over(JR_ENT);

		tot_reg_pen = (s_sth.s_amnts[9] + s_sth.s_amnts[10] +
			s_sth.s_amnts[11] + payearn.pe_reg_prior +
			payearn.pe_reg_opt + payearn.pe_reg_nonm);

		empr_share2 = ((tot_reg_pen / ((100 - 
		reg_pen.rg_employer_sh) / 100)) - tot_reg_pen);
		
		jrent.jr_amount = D_Roundoff((tot_reg_pen + empr_share2)* -1);

		retval = put_jr_ent(&jrent,UPDATE,e_mesg);
		if(retval < 0) return(retval);

		retval = commit(e_mesg);
		if(retval < 0) return(retval);
	}
	else{
	    tmp_share = empr_share2;
	    tmp_income = tot_income;
	
	    /* Create journal entries for employer share	*/

	    strcpy(jrent.jr_emp_numb,emprec.em_numb);
	    strcpy(jrent.jr_type,"B");
	    jrent.jr_fund = 0;
	    jrent.jr_no = 0;
		
	    flg_reset(JR_ENT);
	    for( ; ; ){
	      retval = get_n_jr_ent(&jrent,BROWSE,2,FORWARD,e_mesg);
	      if(retval < 0){
		if(retval == EFL) break;
		DispError((char *)&s_sth,e_mesg);
		roll_back(e_mesg);
		seq_over(JR_ENT);
		return(retval);
	      }
	      if(strcmp(jrent.jr_emp_numb,emprec.em_numb) != 0)
			break;
	      if((strcmp(jrent.jr_type,"E") != 0) &&
	         (strcmp(jrent.jr_type,"X") != 0) &&
	         (strcmp(jrent.jr_type,"B") != 0))
			continue;

	      strcpy(last_type,jrent.jr_type);
	      last_fund = jrent.jr_fund;
	      last_jr = jrent.jr_no;

	      tot_amount = D_Roundoff(jrent.jr_amount);

	      gl_acct.gl_fund = jrent.jr_fund;
	      strcpy(gl_acct.gl_acct,jrent.jr_acct);
	      strcpy(gl_acct.gl_class,jrent.jr_class);
	
	      retval = get_glacct(&gl_acct,BROWSE,2,e_mesg);
	      if(retval < 0 ){
		DispError((char *)&s_sth,e_mesg);
		roll_back(e_mesg);
		return(ERROR);
	      }
	      strcpy(gl_acct.gl_type,"R");
	      strcpy(gl_acct.gl_earn,reg_pen.rg_code);
	
	      retval = get_glacct(&gl_acct,BROWSE,0,e_mesg);
	      if(retval < 0){
			DispError((char *)&s_sth,e_mesg);
			roll_back(e_mesg);
			return(ERROR);
	      }
	      retval = GetJr(gl_acct.gl_fund);
	      if(retval < 0) {
		return(ERROR);
	      }
	      strcpy(jrent.jr_emp_numb,payearn.pe_numb);
	      jrent.jr_fund = gl_acct.gl_fund;
	      strcpy(jrent.jr_acct,gl_acct.gl_acct);
	      strcpy(jrent.jr_code,emprec.em_reg_pen);
	      strcpy(jrent.jr_type,"S");
	      jrent.jr_amount = D_Roundoff((tmp_share * tot_amount) /
							 tmp_income);

	      tmp_share -= jrent.jr_amount;
	      tmp_income -= tot_amount;

	      if(jrent.jr_amount != 0.00) {
		retval = put_jr_ent(&jrent,ADD,e_mesg);	
		if(retval < 0) {
			DispError((char *)&s_sth,e_mesg);
			roll_back(e_mesg);
			return(ERROR);
		}
	        retval = commit(e_mesg) ;
	        if(retval < 0) {
			DispError((char *)&s_sth,e_mesg);
			roll_back(e_mesg);
			return(ERROR);
	        }
	      }
	      strcpy(jrent.jr_emp_numb,emprec.em_numb);
	      strcpy(jrent.jr_type,last_type);
	      jrent.jr_fund = last_fund;
	      jrent.jr_no = last_jr + 1;

	      flg_reset(JR_ENT);
	    }
	    seq_over(JR_ENT);

	    /* Create journal entry for the liability	*/

	    jrent.jr_fund = reg_pen.rg_fund;
	    retval = GetJr(reg_pen.rg_fund);
	    if(retval < 0) {
		return(ERROR);
	    }
	    jrent.jr_fund = reg_pen.rg_fund;
	    strcpy(jrent.jr_acct,reg_pen.rg_lia_acct);

	    jrent.jr_amount = D_Roundoff(tot_reg_pen + tmp_share);
	    strcpy(jrent.jr_emp_numb,payearn.pe_numb);
	    strcpy(jrent.jr_code,emprec.em_reg_pen);
	    strcpy(jrent.jr_type,"D");

	    if(jrent.jr_amount != 0.00) {
		jrent.jr_amount = jrent.jr_amount * -1;
		retval = put_jr_ent(&jrent,ADD,e_mesg);	
		if(retval < 0) {
			DispError((char *)&s_sth,e_mesg);
			roll_back(e_mesg);
			return(ERROR);
		}
	    	retval = commit(e_mesg) ;
	    	if(retval < 0){
			DispError((char *)&s_sth,e_mesg);
			roll_back(e_mesg);
			return(ERROR);
	    	}
	    }
	}

	return(NOERROR);
}
/*-----------------------------------------------------------------------*/
AdjDed(amount)
double	amount;
{
	int retval;
	double	empr_share, empr_share2;
	double	tmp_amount;
	double	tmp_ded, tmp_old_ded;

	strcpy(dedgrp.dg_code,payded.pd_code);
	strcpy(dedgrp.dg_pp_code,barg_unit.b_pp_code);
	strcpy(dedgrp.dg_group,payded.pd_group);

	retval = get_ded_grp(&dedgrp,BROWSE,0,e_mesg);
	if(retval != NOERROR && retval != UNDEF){
		DispError((char *)&s_sth,e_mesg);
		roll_back(e_mesg);
		return(ERROR);
	}

	empr_share = ((payded.pd_amount / ((100 - 
		dedgrp.dg_employer_sh) / 100)) - payded.pd_amount);

	empr_share2 = ((amount / ((100 - 
		dedgrp.dg_employer_sh) / 100)) - amount);

	tmp_ded = D_Roundoff(empr_share2);
	tmp_old_ded = D_Roundoff(empr_share);
		
	if(payded.pd_amount != 0){
		strcpy(jrent.jr_emp_numb,s_sth.s_empcd);
		strcpy(jrent.jr_code,payded.pd_code);
		jrent.jr_fund = 0;
		jrent.jr_no = 0;
		flg_reset(JR_ENT);

		for( ; ; ){
			retval = get_n_jr_ent(&jrent,UPDATE,1,FORWARD,e_mesg);
			if(retval < 0){
				if(retval == EFL) break;
				DispError((char *)&s_sth,e_mesg);
				roll_back(e_mesg);
				seq_over(JR_ENT);
				return(ERROR);
			}
			if(strcmp(jrent.jr_emp_numb, s_sth.s_empcd) != 0 ||
			   strcmp(jrent.jr_code,payded.pd_code) != 0)
				break;

			if(jrent.jr_type[0] != 'S') continue;

			tmp_amount = D_Roundoff(jrent.jr_amount);
			if(tmp_old_ded != 0)
				jrent.jr_amount = D_Roundoff(tmp_ded *
					 tmp_amount / tmp_old_ded);

			tmp_ded -= jrent.jr_amount;
			tmp_old_ded -= tmp_amount;

			retval = put_jr_ent(&jrent,UPDATE,e_mesg);
			if(retval < 0) return(retval);

			retval = commit(e_mesg);
			if(retval < 0) return(retval);

			jrent.jr_no++;
			flg_reset(JR_ENT);
		}
		seq_over(JR_ENT);

		strcpy(jrent.jr_emp_numb,s_sth.s_empcd);
		strcpy(jrent.jr_code,payded.pd_code);
		jrent.jr_fund = 0;
		jrent.jr_no = 0;
		flg_reset(JR_ENT);

		for( ; ; ){
			retval = get_n_jr_ent(&jrent,UPDATE,1,FORWARD,e_mesg);
			if(retval < 0){
				DispError((char *)&s_sth,e_mesg);
				return(retval);
			}
			if(strcmp(jrent.jr_emp_numb, s_sth.s_empcd) != 0 ||
			   strcmp(jrent.jr_code,payded.pd_code) != 0)
				return(NOERROR);

			if(jrent.jr_type[0] == 'D') break;
		}
		seq_over(JR_ENT);

		empr_share2 = ((amount / ((100 - 
		dedgrp.dg_employer_sh) / 100)) - amount);
		
		jrent.jr_amount = D_Roundoff((amount + empr_share2)* -1);

		retval = put_jr_ent(&jrent,UPDATE,e_mesg);
		if(retval < 0) return(retval);

		retval = commit(e_mesg);
		if(retval < 0) return(retval);
	}
	else{
		tmp_income = tot_income;
		tmp_share = empr_share2;

		/* Create journal entries for the employer share */

		if(empr_share2 != 0) {
		  strcpy(jrent.jr_emp_numb,emprec.em_numb);
		  strcpy(jrent.jr_type,"B");
		  jrent.jr_fund = 0;
		  jrent.jr_no = 0;
		
		  flg_reset(JR_ENT);
		  for( ; ; ){
		    retval = get_n_jr_ent(&jrent,BROWSE,2,FORWARD,e_mesg);
		    if(retval < 0){
			if(retval == EFL) break;
			DispError((char *)&s_sth,e_mesg);
			roll_back(e_mesg);
			seq_over(JR_ENT);
			return(ERROR);
		    }
		    if(strcmp(jrent.jr_emp_numb,emprec.em_numb) != 0)
			break;

		    if((strcmp(jrent.jr_type,"E") != 0) &&
		       (strcmp(jrent.jr_type,"X") != 0) &&
		       (strcmp(jrent.jr_type,"B") != 0))
			continue;	

		    strcpy(last_type,jrent.jr_type);
		    last_fund = jrent.jr_fund;
		    last_jr = jrent.jr_no;

		    tot_amount = D_Roundoff(jrent.jr_amount);

		    gl_acct.gl_fund = jrent.jr_fund;
		    strcpy(gl_acct.gl_acct,jrent.jr_acct);
		    strcpy(gl_acct.gl_class,jrent.jr_class);
	
		    retval = get_glacct(&gl_acct,BROWSE,2,e_mesg);
		    if(retval < 0){
			DispError((char *)&s_sth,e_mesg);
			roll_back(e_mesg);
			return(ERROR);
		    }
		    strcpy(gl_acct.gl_type,"D");
		    strcpy(gl_acct.gl_earn,payded.pd_code);
	
		    retval = get_glacct(&gl_acct,BROWSE,0,e_mesg);
		    if(retval < 0){
			DispError((char *)&s_sth,e_mesg);
			roll_back(e_mesg);
			return(ERROR);
		    }
		    seq_over(GLACCT);
		    retval = GetJr(gl_acct.gl_fund);
		    if(retval < 0) {
			return(ERROR);
		    }

		    strcpy(jrent.jr_emp_numb,emprec.em_numb);
		    jrent.jr_fund = gl_acct.gl_fund;
		    strcpy(jrent.jr_acct,gl_acct.gl_acct);
		    strcpy(jrent.jr_code,payded.pd_code);
		    strcpy(jrent.jr_type,"S");

		    jrent.jr_amount = D_Roundoff((tmp_share * tot_amount) /
							 tmp_income);
		    tmp_share -= jrent.jr_amount;
		    tmp_income -= tot_amount;

		    if(jrent.jr_amount != 0.00) {
			retval = put_jr_ent(&jrent,ADD,e_mesg);	
			if(retval < 0) {
				DispError((char *)&s_sth,e_mesg);
				roll_back(e_mesg);
				return(ERROR);
			}
		    	retval = commit(e_mesg) ;
	  	    	if(retval < 0) {
				DispError((char *)&s_sth,e_mesg);
				roll_back(e_mesg);
				return(ERROR);
		    	}
		    }	
		    strcpy(jrent.jr_emp_numb,emprec.em_numb);
		    strcpy(jrent.jr_type,last_type);
		    jrent.jr_fund = last_fund;
		    jrent.jr_no = last_jr + 1;

		    flg_reset(JR_ENT);
		  }
		  seq_over(JR_ENT);

		}

		/* Create journal entry for liability	*/

		jrent.jr_fund = deduct.dd_fund;
		retval = GetJr(deduct.dd_fund);
		if(retval < 0) {
			return(ERROR);
	  	}
		jrent.jr_fund = deduct.dd_fund;
		strcpy(jrent.jr_acct,deduct.dd_lia_acct);

		jrent.jr_amount = D_Roundoff(amount + empr_share2);
		strcpy(jrent.jr_emp_numb,payearn.pe_numb);
		strcpy(jrent.jr_code,payded.pd_code);
		strcpy(jrent.jr_type,"D");

		if(jrent.jr_amount != 0.00) {
			jrent.jr_amount = jrent.jr_amount * -1;
			retval = put_jr_ent(&jrent,ADD,e_mesg);	
			if(retval < 0) {
				DispError((char *)&s_sth,e_mesg);
				roll_back(e_mesg);
				return(ERROR);
		  	}
			retval = commit(e_mesg) ;
	  		if(retval < 0) {
				DispError((char *)&s_sth,e_mesg);
				roll_back(e_mesg);
				return(ERROR);
			}
		}
	}

	return(NOERROR);
}
/*-----------------------------------------------------------------------*/
AdjLoan(amount)
double	amount;
{
	int retval;

	if(payloan.pc_amount != 0){
		strcpy(jrent.jr_emp_numb,s_sth.s_empcd);
		strcpy(jrent.jr_code,payloan.pc_code);
		jrent.jr_fund = 0;
		jrent.jr_no = 0;
		flg_reset(JR_ENT);

		for( ; ; ){
			retval = get_n_jr_ent(&jrent,UPDATE,1,FORWARD,e_mesg);
			if(retval < 0){
				DispError((char *)&s_sth,e_mesg);
				return(retval);
			}
			if(strcmp(jrent.jr_emp_numb, s_sth.s_empcd) != 0 ||
			   strcmp(jrent.jr_code,payloan.pc_code) != 0)
					return(NOERROR);
	
			if(jrent.jr_type[0] == 'D') break;
		}
		seq_over(JR_ENT);

		jrent.jr_amount = amount;
		jrent.jr_amount = jrent.jr_amount * -1;

		retval = put_jr_ent(&jrent,UPDATE,e_mesg);
		if(retval < 0) return(retval);

		retval = commit(e_mesg);
		if(retval < 0) return(retval);
	}
	else{
		/* Create jounral entry for liability */

		jrent.jr_fund = loan.cs_fund;
		retval = GetJr(loan.cs_fund);
		if(retval < 0) {
			return(ERROR);
		}
		jrent.jr_fund = loan.cs_fund;
		strcpy(jrent.jr_acct,loan.cs_amt_acct);

	  	jrent.jr_amount = amount;
		strcpy(jrent.jr_emp_numb,payearn.pe_numb);
		strcpy(jrent.jr_code,payloan.pc_code);
		strcpy(jrent.jr_type,"D");

		if(jrent.jr_amount != 0.00) {
			jrent.jr_amount = jrent.jr_amount * -1;
			retval = put_jr_ent(&jrent,ADD,e_mesg);	
			if(retval < 0) {
				DispError((char *)&s_sth,e_mesg);
				roll_back(e_mesg);
				return(ERROR);
			}
		      	retval = commit(e_mesg) ;
	  	     	if(retval < 0) {
				DispError((char *)&s_sth,e_mesg);
				roll_back(e_mesg);
				return(ERROR);
		      	}
		}

		/* Create jounral entry for the liability for the
			 interest 	*/

		jrent.jr_fund = loan.cs_fund;
		retval = GetJr(loan.cs_fund);
		if(retval < 0) {
			return(ERROR);
		}
		jrent.jr_fund = loan.cs_fund;
		strcpy(jrent.jr_acct,loan.cs_int_acct);

		jrent.jr_amount = D_Roundoff(payloan.pc_int_amt);
		strcpy(jrent.jr_emp_numb,payearn.pe_numb);
		strcpy(jrent.jr_code,payloan.pc_code);
		strcpy(jrent.jr_type,"D");

 		if(jrent.jr_amount != 0.00) {
			jrent.jr_amount = jrent.jr_amount * -1;
			retval = put_jr_ent(&jrent,ADD,e_mesg);	
			if(retval < 0) {
				DispError((char *)&s_sth,e_mesg);
				roll_back(e_mesg);
				return(ERROR);
			}
		      	retval = commit(e_mesg) ;
	  	      	if(retval < 0) {
				DispError((char *)&s_sth,e_mesg);
				roll_back(e_mesg);
				return(ERROR);
		      	}
		}
		
	}

	return(NOERROR);
}
/*-----------------------------------------------------------------------*/
AdjGarn(amount)
double	amount;
{
	int retval;

	if(paygarn.pg_amount != 0){
		strcpy(jrent.jr_emp_numb,s_sth.s_empcd);
		strcpy(jrent.jr_code,"GARN");
		jrent.jr_fund = 0;
		jrent.jr_no = 0;
		flg_reset(JR_ENT);

		for( ; ; ){
			retval = get_n_jr_ent(&jrent,UPDATE,1,FORWARD,e_mesg);
			if(retval < 0){
				DispError((char *)&s_sth,e_mesg);
				return(retval);
			}
			if(strcmp(jrent.jr_emp_numb, s_sth.s_empcd) != 0 ||
			   strcmp(jrent.jr_code,"GARN") != 0)
				return(NOERROR);

			if(jrent.jr_type[0] == 'D') break;
		}
		seq_over(JR_ENT);

		jrent.jr_amount = amount;
		jrent.jr_amount = jrent.jr_amount * -1;

		retval = put_jr_ent(&jrent,UPDATE,e_mesg);
		if(retval < 0) return(retval);

		retval = commit(e_mesg);
		if(retval < 0) return(retval);
	}
	else{
		strcpy(emp_garn.eg_numb,paygarn.pg_numb);
		emp_garn.eg_pr_cd = paygarn.pg_pr_cd;
		emp_garn.eg_seq = paygarn.pg_seq;

		retval = get_emp_garn(&emp_garn,BROWSE,0,e_mesg);
		if(retval < 0){
			DispError((char *)&s_sth,e_mesg);
			roll_back(e_mesg);
			return(ERROR);
		}

		/* Create journal entry for the liability	*/

		jrent.jr_fund = emp_garn.eg_fund;
		retval = GetJr(emp_garn.eg_fund);
		if(retval < 0) {
			return(ERROR);
		}
		jrent.jr_fund = emp_garn.eg_fund;
		strcpy(jrent.jr_acct,emp_garn.eg_lia_acct);
		strcpy(jrent.jr_type,"D");

	  	jrent.jr_amount = amount;
		strcpy(jrent.jr_emp_numb,payearn.pe_numb);
		strcpy(jrent.jr_code,"GARN");

		if(jrent.jr_amount != 0.00) {
			jrent.jr_amount = jrent.jr_amount * -1;
			retval = put_jr_ent(&jrent,ADD,e_mesg);	
			if(retval < 0) {
				DispError((char *)&s_sth,e_mesg);
				roll_back(e_mesg);
				return(ERROR);
			}
		  	retval = commit(e_mesg) ;
	  	 	if(retval < 0) {
				DispError((char *)&s_sth,e_mesg);
				roll_back(e_mesg);
				return(ERROR);
			}
		}
	}

	return(NOERROR);
}
/*-----------------------------------------------------------------------*/
GetJr(fund)
short	fund;
{
	int	retval;

	jrent.jr_no = HV_SHORT;
	flg_reset(JR_ENT);

	retval = get_n_jr_ent(&jrent,UPDATE,0,BACKWARD,e_mesg);
	if(retval < 0 && retval != EFL){
	  	DispError((char *)&s_sth,e_mesg) ;
		seq_over(JR_ENT);
		roll_back(e_mesg);
	  	return(ERROR);
	}
	if(retval == EFL || jrent.jr_no < 1 || jrent.jr_fund != fund){
	  jrent.jr_fund = fund;
	  jrent.jr_no = 1;
	}
	else 
	  jrent.jr_no ++;

	return(NOERROR);
}
/*------------------    END OF FILE   ------------------------*/
