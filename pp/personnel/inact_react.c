/*------------------------------------------------------------------------
Source Name: inact_react.c
System     : Personnel/Payroll System.
Created  On: Jaunary 10, 91.
Created  By: Eugene Roy.

DESCRIPTION:
	Program to inactivate or reactivate employee's.

MODIFICATIONS:        

Programmer     YY/MM/DD       Description of modification
~~~~~~~~~~     ~~~~~~~~       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
------------------------------------------------------------------------*/

#define	MAIN		/* Main program. This is to declare Switches */

#define	SYSTEM		"PERSONNEL"	/* Sub System Name */
#define	MOD_DATE	"10-JAN-92"		/* Program Last Modified */

#include <stdio.h>
#include <cfomstrc.h>
#include <bfs_defs.h>
#include <bfs_com.h>
#include <bfs_pp.h>
#include <pp_msgs.h>

#define EXIT	   	12

/* User Interface define constants */
#ifdef ENGLISH
#define INACT_PROC	'I'
#define REACT_PROC	'R'
#define	TERM_PROC	'T'
#define EXITOPT		'E'

#define	YES		'Y'
#define NO		'N'
#define	EDIT		'E'
#define	CANCEL		'C'
#else
#define INACT_PROC	'I'
#define REACT_PROC	'R'
#define	TERM_PROC	'T'
#define EXITOPT		'F'

#define	YES		'O'
#define NO		'N'
#define	EDIT		'M'

#define	CANCEL		'A'
#endif

/* PROFOM Releted declarations */

#define	SCR_NAME	"inactreact"	/* PROFOM screen Name */

/* Field PROFOM numbers */
#define START_FLD 	400	/* Start Field in range */
#define	END_FLD		1800	/* Last Field of the screen */

#define STEP		100

#define INACT		400	/* Starting Bargaining Unit		*/
#define TERMIN		500
#define BARG1		700	/* Starting Bargaining Unit		*/
#define BARG2		800	/* Ending Bargaining Unit		*/
#define POS1		900	/* Starting Classification		*/
#define POS2		1000	/* Ending Classification		*/
#define EMP1		1100	/* Starting Employee Number		*/
#define EMP2		1200	/* Ending Employee Number		*/
#define OPTION		1300	/* */
#define NO_INACT	1400	/* */
#define NO_REACT	1500	/* */
#define NO_TERM		1600
#define MESSAGE		1700	/* */
#define RESPONSE	1800	/* */

/* pselect.sth - header for C structure generated by PROFOM EDITOR */

typedef struct	{

	char	s_pgm[11];	/* 100 program name */
	long	s_rundate;	/* 300 run date */
	char	s_inact[4];
	char	s_desc[31];
	char	s_term[3];
	char	s_term_desc[31];
	long	s_term_date;
	char	s_barg1[7];	/* 400 due date */
	char	s_barg2[7];	/* 500 transaction date */
	char	s_pos1[7];	/* 600 release holdbacks option */
	char 	s_pos2[7];	/* 700 starting supplier code */
	char	s_emp1[13];	/* 800 ending supllier code */
	char	s_emp2[13];	/* 900 starting trans ref. no. */
	char	s_option[2];	/* 1300 option choice */
	short	s_no_inact;
	short	s_no_react;
	short	s_no_term;
	char	s_mesg[78];	/* 1500 message field */
	char	s_resp[2];	/* 1600 response field */
	} S_STRUCT;


S_STRUCT	s_sth;	/* PROFOM Screen Structure */
static	struct  stat_rec  sr;		/* PROFOM status rec */

/* File structures */
static	Emp	emp_rec,	pre_emp;
static	Inact	inact;
static	Barg_unit	barg_rec;
static	Position	position;
static	Term	termination;
static	Emp_extra	emp_extra;

static  char    cur_emp[13]; 	/* Active employee number	*/
static  long    cur_barg;
static  long    cur_pp;

static	char 	e_mesg[100];  		/* dbh will return err msg in this */

static	Validation();
static	WindowHelp();

static  double disc_taken;
static  double disc_lost;
static  double gross_pay;

double 	D_Roundoff();
main(argc,argv)
int argc;
char *argv[];
{
	int 	retval;

	retval = Initialize(argc,argv);	/* Initialization routine */

	if (retval == NOERROR) retval = Process();

	CloseRtn();			/* return to menu */
	if (retval != NOERROR) exit(1);
	exit(0);
}

/*-------------------------------------------------------------------*/
/* Initialize PROFOM */

Initialize(argc, argv)
int	argc ;
char	*argv[] ;
{
	int	err ;

	/*
	*	Initialize DBH Environment
	*/
	strncpy(SYS_NAME,SYSTEM,50);	/* Sub system name */
	strncpy(CHNG_DATE,MOD_DATE,10);	/* Modification Date */

	proc_switch(argc, argv, CHEQUE) ; 	/* Process Switches */

	/*
	*	Initialize PROFOM & Screen
	*/
	STRCPY(sr.termnm,terminal);	/* Copy Terminal Name */
	fomin(&sr);
	ret(err_chk(&sr)) ;		/* Check for PROFOM Error */
	fomcf(1,1);			/* Enable Snap screen option */

	err = InitScreen() ;		/* Initialize Screen */
	if(NOERROR != err) return(err) ;

	return(NOERROR) ;
}	/* Initialize() */

/*--------------------------------------------------------------------------*/
/* Close nessary files and environment before exiting program               */

CloseRtn() 
{
	/* Set terminal back to normal mode from PROFOM */
	fomcs();
	fomrt();

	close_dbh();	/* Close files */

	return(NOERROR);
}	/* CloseRtn() */
/*----------------------------------------------------------------*/
/* Initialize screen before going to process options */

InitScreen()
{
	/* move screen name to Profom status structure */
	STRCPY(sr.scrnam,NFM_PATH);
	strcat(sr.scrnam,SCR_NAME) ;

	STRCPY(s_sth.s_pgm,PROG_NAME);
	s_sth.s_rundate = get_date();	/* get Today's Date in YYYYMMDD format*/
	s_sth.s_option[0] = HV_CHAR;
	s_sth.s_no_inact = HV_SHORT;
	s_sth.s_no_react = HV_SHORT;
	s_sth.s_no_term = HV_SHORT;
	s_sth.s_mesg[0] = HV_CHAR ;
	s_sth.s_resp[0] = HV_CHAR ;

	/* Move Low Values to data fields */
	InitFields() ;

	return(NOERROR) ;
}	/* InitScreen() */

/*-------------------------------------------------------------------*/
/* Get Option from user and call corresponding function */

Process()
{
	int	err;

	for( ; ; ){

		if((err = ReadOption())<0) 
			return(err);

		switch(s_sth.s_option[0]) {
		case  EXITOPT :
			return(NOERROR);
		case  INACT_PROC :
			CHKACC(err,ADD,e_mesg);
			err = ProcOption() ;
			break ;
		case  REACT_PROC :
			CHKACC(err,ADD,e_mesg);
			err = ProcOption() ;
			break ;
		case  TERM_PROC :
			CHKACC(err,ADD,e_mesg);
			err = ProcOption() ;
			break ;
		default :
			continue;
		}

		if(NOACCESS == err)	fomen(e_mesg);
		if(PROFOM_ERR == err)	return(PROFOM_ERR);  /* PROFOM ERROR */
		if(DBH_ERR == err) {
			DispError((char *)&s_sth,e_mesg);
#ifdef ENGLISH
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"System Error... Iserror:",
				iserror, dberror, errno);
#else
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"Erreur du systeme... Iserror:",
				iserror, dberror, errno);
#endif
			DispError((char *)&s_sth,e_mesg);
			return(DBH_ERR); /* DBH ERROR */
		
		}
	}      /*   end of the for( ; ; )       */
}	/* Process() */
/*------------------------------------------------------------*/
ReadOption()
{

	s_sth.s_mesg[0] = HV_CHAR;
	DispMesgFld((char *)&s_sth);	
#ifdef ENGLISH
	fomer("I(nactivate), R(eactivate), T(erminate), E(xit)");
#else
	fomer("I(nactiver), R(eacticer),?????? F(in)");
#endif
	sr.nextfld = OPTION;
	fomrf((char *)&s_sth);
	ret(err_chk(&sr));

}	/* ReadOption */
/*------------------------------------------------------------*/
ProcOption()
{
	int	i, err ;

	for(i = START_FLD ; i <= END_FLD - 300 ; i += 100)
		fomca1(i, 19, 0) ;    /* disable dup control */

	err = ReadRange(ADD) ;
	if(err != NOERROR) return(err) ;

	err = Confirm() ;
	if(err != YES) return(NOERROR) ;

	err = ProcRanges() ;

	return(NOERROR);
}	/* ProcSelection() */
/*------------------------------------------------------------*/
/* Get the Header details from user */

ReadRange(mode)
int	mode ;
{
	int	 i, err ;

	if(mode == ADD) {
#ifdef ENGLISH
		STRCPY(s_sth.s_mesg,"Press ESC-F to Go to Option:");
#else
		STRCPY(s_sth.s_mesg,"Appuyer sur ESC-F pour retourner a Option:");
#endif
		DispMesgFld((char *)&s_sth);

		fomca1(BARG1, 19, 2) ;
		fomca1(BARG2, 19, 2) ;
		fomca1(POS1, 19, 2);
		fomca1(POS2, 19, 2) ;
		fomca1(EMP1, 19, 2) ;
		fomca1(EMP2, 19, 2) ;
		s_sth.s_barg1[0] = '\0';
		strcpy(s_sth.s_barg2, "ZZZZZZ");
		s_sth.s_pos1[0] = '\0';
		strcpy(s_sth.s_pos2, "ZZZZZZ");
		strcpy(s_sth.s_emp1, "           0");
		strcpy(s_sth.s_emp2, "ZZZZZZZZZZZZ");
		sr.nextfld = BARG1 ;
		sr.endfld = END_FLD - 300 ;
		fomud((char*)&s_sth);
		ret(err_chk(&sr));
	}
	InitFields() ;

	i = ReadFields((char *)&s_sth,START_FLD, END_FLD - 300,
			Validation, WindowHelp, 1) ;
	if(PROFOM_ERR == i || DBH_ERR == i) return(i) ;
	if(RET_USER_ESC == i) {	/* ESC-F */
		return(RET_USER_ESC) ;
	}

	return(NOERROR) ;
}	/* ReadRange() */
/*----------------------------------------------------------------*/
/* Validation function() for Key and Header fields when PROFOM returns
  RET_VAL_CHK */

static
Validation()
{
	int	err;

	switch(sr.curfld){
	case INACT:
		Right_Justify_Numeric(s_sth.s_inact
					,(sizeof(s_sth.s_inact)-1));
		strcpy(inact.i_code,s_sth.s_inact);

		err = get_inact(&inact,BROWSE,0,e_mesg);
		if(err == UNDEF) {
			fomen(NOKEY) ;
			s_sth.s_inact[0] = LV_CHAR;
			return(err);
		}
		if(err < 0) {
			fomen(e_mesg);
			get();
			return(err);
		}

		strcpy(s_sth.s_desc, inact.i_desc);
		break;

	case TERMIN:
		Right_Justify_Numeric(s_sth.s_term
					,(sizeof(s_sth.s_term)-1));
		strcpy(termination.t_code,s_sth.s_term);

		err = get_pterm(&termination,BROWSE,0,e_mesg);
		if(err == UNDEF) {
			fomen(NOKEY) ;
			s_sth.s_term[0] = LV_CHAR;
			return(err);
		}
		if(err < 0) {
			fomen(e_mesg);
			get();
			return(err);
		}

		strcpy(s_sth.s_term_desc, termination.t_desc);
		break;

	case BARG1:  /* ending bargaining unit code */
		if(s_sth.s_barg1[0] == '\0'){
			sr.curfld += 100;
			break;
		}
		Right_Justify_Numeric(s_sth.s_barg1
					,(sizeof(s_sth.s_barg1)-1));
		break;
	case BARG2:  /* ending bargaining unit code */
		Right_Justify_Numeric(s_sth.s_barg2
					,(sizeof(s_sth.s_barg2)-1));
		if(strcmp(s_sth.s_barg2,s_sth.s_barg1) <0) {
#ifdef ENGLISH
			fomer("Ending code cannot precede starting code");
#else
			fomer("Code finissant ne peut pas preceder le code debutant");
#endif
			s_sth.s_barg2[0] = LV_CHAR;
		}
		break;
	case POS1:  
		if(s_sth.s_pos1[0] == '\0'){
			sr.curfld += 100;
			break;
		}
		Right_Justify_Numeric(s_sth.s_pos1
					,(sizeof(s_sth.s_pos1)-1));
		break;
	case POS2: 
		Right_Justify_Numeric(s_sth.s_pos2
					,(sizeof(s_sth.s_pos2)-1));
		if(strcmp(s_sth.s_pos2,s_sth.s_pos1) <0) {
#ifdef ENGLISH
			fomer("Ending code cannot precede starting code");
#else
			fomer("Code finissant ne peut pas preceder le code debutant");
#endif
			s_sth.s_pos2[0] = LV_CHAR;
		}
		break;
	case EMP1:
		Right_Justify_Numeric(s_sth.s_emp1
					,(sizeof(emp_rec.em_numb)-1));
		strcpy(s_sth.s_emp2,s_sth.s_emp1);
		ret( WriteFields((char *)&s_sth,EMP1,EMP2) ) ;
		s_sth.s_emp2[0] = LV_CHAR;
		break;
	case EMP2:  /* ending employee code */
		Right_Justify_Numeric(s_sth.s_emp2
					,(sizeof(emp_rec.em_numb)-1));
		if(strcmp(s_sth.s_emp2,s_sth.s_emp1) <0) {
#ifdef ENGLISH
			fomer("Ending number cannot precede starting number");
#else
			fomer("Numero finissant ne peut pas preceder le numero debutant");
#endif
			s_sth.s_emp2[0] = LV_CHAR;
		}
		break;
	default :
#ifdef ENGLISH
		sprintf(e_mesg,"No Validity Check For Field#  %d",sr.curfld);
#else
		sprintf(e_mesg,"Pas de controle de validite pour le Champ#  %d",sr.curfld);
#endif
		fomen(e_mesg);
		get();
		return(ERROR) ;
	}	/* Switch sr.curfld */

	return(NOERROR) ;
}	/* Validation() */
/*----------------------------------------------------------------*/
/* Show Help Windows, if applicable, when user gives ESC-H in key
   and header fields */

static
WindowHelp()
{
	int	retval ;
	int	fld_no;
	int	item_no;
	long	temp_date;

	switch(sr.curfld){
	case INACT:
		retval = inact_hlp(s_sth.s_inact,7,13);
		if(retval == DBH_ERR) return(retval);
		redraw();
		strcpy(inact.i_code,s_sth.s_inact);

		retval = get_inact(&inact,BROWSE,0,e_mesg);
		if(retval < 0) {
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}
		strcpy(s_sth.s_desc, inact.i_desc);
		break;

	case TERMIN:
		retval = term_hlp(s_sth.s_term,7,13);
		if(retval == DBH_ERR) return(retval);
		redraw();
		strcpy(termination.t_code,s_sth.s_term);

		retval = get_pterm(&termination,BROWSE,0,e_mesg);
		if(retval < 0) {
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}
		strcpy(s_sth.s_term_desc, termination.t_desc);
		break;

	case BARG1:
		retval = barg_hlp(s_sth.s_barg1,&temp_date,7,13);
		if(retval == DBH_ERR) return(retval);
		if(retval >= 0) redraw();
		if(retval == 0) return(ERROR);
		if(retval < 0) return(ERROR);

		break;
	case BARG2:
		retval = barg_hlp(s_sth.s_barg2,&temp_date,7,13);
		if(retval == DBH_ERR) return(retval);
		if(retval >= 0) redraw();
		if(retval == 0) return(ERROR);
		if(retval < 0) return(ERROR);
		strcpy(barg_rec.b_code,s_sth.s_barg2);

		if(strcmp(s_sth.s_barg2,s_sth.s_barg1) <0) {
#ifdef ENGLISH
			fomer("Ending code cannot precede starting code");
#else
			fomer("Code finissant ne peut pas preceder le code debutant");
#endif
			s_sth.s_barg2[0] = LV_CHAR;
		}
		break;
	case POS1:
		retval = position_hlp(s_sth.s_pos1,7,13);
		if(retval == DBH_ERR) return(retval);
		if(retval >= 0) redraw();
		if(retval == 0) return(ERROR);
		if(retval < 0) return(ERROR);

		break;
	case POS2:
		retval = position_hlp(s_sth.s_pos2,7,13);
		if(retval == DBH_ERR) return(retval);
		if(retval >= 0) redraw();
		if(retval == 0) return(ERROR);
		if(retval < 0) return(ERROR);

		if(strcmp(s_sth.s_pos2,s_sth.s_pos1) <0) {
#ifdef ENGLISH
			fomer("Ending code cannot precede starting code");
#else
			fomer("Code finissant ne peut pas preceder le code debutant");
#endif
			s_sth.s_pos2[0] = LV_CHAR;
		}
		break;

	case EMP1:
		retval = emp_hlp(s_sth.s_emp1,7,13);
		if(retval == DBH_ERR) return(retval);
		if(retval >= 0) redraw();
		if(retval == 0) return(ERROR);
		if(retval < 0) return(ERROR);
		Right_Justify_Numeric(s_sth.s_emp1, sizeof(s_sth.s_emp1)-1);

		break;
	case EMP2:
		retval = emp_hlp(s_sth.s_emp2,7,13);
		if(retval == DBH_ERR) return(retval);
		if(retval >= 0) redraw();
		if(retval == 0) return(ERROR);
		if(retval < 0) return(ERROR);
		Right_Justify_Numeric(s_sth.s_emp2, sizeof(s_sth.s_emp2)-1);

		if(strcmp(s_sth.s_emp2,s_sth.s_emp1) <0) {
#ifdef ENGLISH
			fomer("Ending code cannot precede starting code");
#else
			fomer("Code finissant ne peut pas preceder le code debutant");
#endif
			s_sth.s_emp2[0] = LV_CHAR;
		}

		break;
	default :
		fomer("No Help Window for This Field");
	}	/* Switch sr.curfld */

	return(NOERROR) ;
}	/* HdrAndKeyWindowHelp() */
/*-----------------------------------------------------------------------*/
/* Take the confirmation from user for the header part */

Confirm()
{
	int	err ;

	for( ; ; ) {
#ifdef ENGLISH
		err = GetOption((char *)&s_sth,"Y(es), E(dit), C(ancel)", "YEC");
#else
		err = GetOption((char *)&s_sth,"O(ui), M(odifier), A(nnuler)", "OMA");
#endif
		if(err == PROFOM_ERR) return(err) ;

		switch(err) {
		case  YES :
			return(YES) ;
		case  EDIT  :
			err = FieldEdit();
			break ;
		case  CANCEL :
#ifdef ENGLISH
			err = GetOption((char *)&s_sth,"Confirm the Cancel (Y/N)?", "YN") ;
#else
			err = GetOption((char *)&s_sth,"Confirmer l'annulation (O/N)?", "ON") ;
#endif
			if(err == YES) { 
				roll_back(e_mesg) ;	/* Unlock  Records */
				return(CANCEL) ;
			}
			break ;
		}	/* switch err */

		if(err == PROFOM_ERR) return(err) ;
		if(err == DBH_ERR) return(err) ;
	}	/* for(; ; ) */
}	/* Confirm() */
/*-----------------------------------------------------------------------*/
/*                                                                       */
/* Changing fields. Accept fld to be changed and read that fld 		 */

FieldEdit()
{
     	int	i,retval;

     	for ( i = START_FLD; i <= END_FLD - 300 ; i += 100 )
       		fomca1( i,19,2 );      		/*  enable Dup Control */

     	sr.nextfld = START_FLD;
     	sr.endfld = END_FLD - 300;
     	fomud( (char *) &s_sth );
     	ret(err_chk(&sr));

	retval = ReadRange(UPDATE);
	if(retval != NOERROR) return(retval) ;

     	return(NOERROR);
}	/* FieldEdit() */
/*-------------------------------------------------------------------------*/
/* Initialize Screen Header with either Low Values */

InitFields()
{
	if(s_sth.s_option[0] == 'T'){
		s_sth.s_inact[0] = HV_CHAR;
		s_sth.s_desc[0] = HV_CHAR;
		s_sth.s_term[0] = LV_CHAR;
		s_sth.s_term_date = LV_LONG;
	}

	if(s_sth.s_option[0] == 'I'){
		s_sth.s_inact[0] = LV_CHAR;
		s_sth.s_term[0] = HV_CHAR;
		s_sth.s_term_desc[0] = HV_CHAR;
		s_sth.s_term_date = HV_LONG;
	}

	if(s_sth.s_option[0] == 'R'){
		s_sth.s_inact[0] = HV_CHAR;
		s_sth.s_desc[0] = HV_CHAR;
		s_sth.s_term[0] = HV_CHAR;
		s_sth.s_term_desc[0] = HV_CHAR;
		s_sth.s_term_date = HV_LONG;
	}

	s_sth.s_barg1[0] = LV_CHAR;
	s_sth.s_barg2[0] = LV_CHAR;
	s_sth.s_pos1[0] = LV_CHAR;
	s_sth.s_pos2[0] = LV_CHAR;
	s_sth.s_emp1[0] = LV_CHAR;
	s_sth.s_emp2[0] = LV_CHAR;
	
	return(NOERROR) ;
}	/* InitFields() */
/*-----------------------------------------------------------------------*/
ProcRanges()
{
	int	i, j, retval, err;
	int	gl_true;

	s_sth.s_no_inact = 0;
	s_sth.s_no_react = 0;
	s_sth.s_no_term = 0;

	strcpy(emp_rec.em_numb, s_sth.s_emp1);
	flg_reset(EMPLOYEE);

	for( ; ; ){
	  retval = get_n_employee(&emp_rec,UPDATE,0,FORWARD,e_mesg);
	  if(retval < 0) {
		if(retval == EFL) break;
		DispError((char *)&s_sth,e_mesg);
		roll_back(e_mesg);
		return(retval);
	  }
	  retval=UsrBargVal(UPDATE,emp_rec.em_numb,emp_rec.em_barg,0,e_mesg);
	  if(retval < 0){
		roll_back(e_mesg);
		continue;
	  }

	  if(strcmp(emp_rec.em_numb,s_sth.s_emp2) > 0){
		roll_back(e_mesg);
		break;
	  }

	  if((strcmp(emp_rec.em_barg,s_sth.s_barg1) < 0) ||
	     (strcmp(emp_rec.em_barg,s_sth.s_barg2) > 0)){
		roll_back(e_mesg);
	  	continue ;
	  }

  	  if((strcmp(emp_rec.em_pos,s_sth.s_pos1) < 0) ||
   	    (strcmp(emp_rec.em_pos,s_sth.s_pos2) > 0)){
		roll_back(e_mesg);
	  	continue ;
	  }

	  retval = WriteRecords();
	  if(retval != NOERROR) return(retval) ;

	  inc_str(emp_rec.em_numb, sizeof(emp_rec.em_numb)-1, 
			FORWARD);
	  flg_reset(EMPLOYEE);
	}
	seq_over(EMPLOYEE);

	ret( WriteFields((char *)&s_sth,NO_INACT,NO_TERM) ) ;
	
	return(NOERROR) ;
}

/*-----------------------------------------------------------------------*/ 
/* Check to see if record is to be added, changed or deleted .		 */
/*-----------------------------------------------------------------------*/ 
WriteRecords()
{
	int	i,retval;

	if(s_sth.s_option[0] == 'I'){
		strcpy(emp_rec.em_status, s_sth.s_inact);
		s_sth.s_no_inact++;
	}
	if(s_sth.s_option[0] == 'R'){
		emp_rec.em_term[0] = '\0';
		emp_rec.em_term_dt = 0;
		strcpy(emp_rec.em_status, "ACT");
		s_sth.s_no_react++;
	}
	if(s_sth.s_option[0] == 'T'){
		strcpy(emp_rec.em_term,s_sth.s_term);
		emp_rec.em_term_dt = s_sth.s_term_date;
		s_sth.s_no_term++;
	}

	retval = put_employee(&emp_rec,UPDATE,e_mesg);
	if(retval < 0) {
		DispError((char *)&s_sth,e_mesg);
		roll_back(e_mesg);
		return(retval);
	}

	retval = rite_audit((char*)&s_sth,EMPLOYEE,UPDATE,(char*)&emp_rec,
			(char*)&pre_emp,e_mesg);
	if(retval==LOCKED) {
		DispError((char *)&s_sth,e_mesg);
		roll_back(e_mesg) ;
		return(LOCKED) ;
	}
	if(retval < 0 ){
#ifdef	ENGLISH
		DispError((char *)&s_sth,"ERROR in Saving Records"); 
#else
		DispError((char *)&s_sth,
					"ERREUR en conservant les fiches");
#endif
		DispError((char *)&s_sth,e_mesg);
		roll_back(e_mesg);
		return(retval);
	}

	retval = commit(e_mesg) ;
	if(retval < 0) {
#ifdef ENGLISH
		DispError((char *)&s_sth,"ERROR in Saving Records"); 
#else
		DispError((char *)&s_sth,"ERREUR en conservant les fiches");
#endif
		DispError((char *)&s_sth,e_mesg);
		roll_back(e_mesg);
		return(retval);
	}

	return(NOERROR);
}
/*--------------------------------------------------------------*/
