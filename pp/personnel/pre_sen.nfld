/*------------------------------------------------------------------------
Source Name: pre_sen.c
System     : Personnel/Payroll System.
Created  On: Nov 10, 1991.
Created  By: Eugene Roy.

DESCRIPTION:

MODIFICATIONS:        

Programmer     YY/MM/DD       Description of modification
~~~~~~~~~~     ~~~~~~~~       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
------------------------------------------------------------------------*/

#define	MAIN		/* Main program. This is to declare Switches */

#define	SYSTEM		"PAYROLL PROCESSING"	/* Sub System Name */
#define	MOD_DATE	"04-01-93"		/* Program Last Modified */

#include <stdio.h>
#include <cfomstrc.h>
#include <bfs_defs.h>
#include <bfs_com.h>
#include <bfs_pp.h>
#include <repdef.h>
#include <filein.h>
#include <isnames.h>

#define EXIT	   	12

/* User Interface define constants */
#ifdef ENGLISH
#define SELECT		'S'
#define EXITOPT		'E'

#define	YES		'Y'
#define NO		'N'
#define	EDIT		'E'

#define	ADDITEMS	'A'
#define	DELITEM		'D'
#define	REACTITEM	'R'
#define	NEXT		'N'
#define	PREV		'P'
#define	CANCEL		'C'
#else
#define SELECT		'C'
#define EXITOPT		'F'

#define	YES		'O'
#define NO		'N'
#define	EDIT		'M'

#define	ADDITEMS	'A'
#define	DELITEM		'D'
#define	REACTITEM	'R'
#define	NEXT		'N'
#define	PREV		'P'
#define	CANCEL		'A'
#endif
#define U_NO		'N'

#define	INACTIVE	"DEL"
#define	ACTIVE		"ACT"
/* PROFOM Releted declarations */

#define	SCR_NAME	"pre_sen"	/* PROFOM screen Name */

#define	PAGESIZE	3		/* No of Items */
/* Field PROFOM numbers */
#define START_FLD 	400	/* Start Field in range */
#define	END_FLD		2900	/* Last Field of the screen */

#define	ITEM_ST_FLD	1900
#define	STEP		300

#define BARG1		400	/* Starting Bargaining Unit		*/
#define BARG2		500	/* Ending Bargaining Unit		*/
#define POS1		600	/* Starting Classification		*/
#define POS2		700	/* Ending Classification		*/
#define	CENTER1		800
#define	CENTER2		900
#define PAYDATE		1000	/* Payment for Pay Date			*/
#define PAYPER1		1100	/* Include from Pay Period		*/
#define	RGIND		1200
#define EMP1		1300	/* Starting Employee Number		*/
#define EMP2		1400	/* Ending Employee Number		*/
#define OPTION		1500	/* */
#define	CHG_FLD		1600
#define	PAGE_FLD	1800
#define	EMP_ITEM	100
#define	STATUS_FLD	200

#define MESSAGE		2800
#define RESPONSE	2900

/* pre_earn.sth - header for C structure generated by PROFOM EDITOR */

typedef	struct	{	/* Start Fld 1500, Endfld 4200 */

	char	s_emp[13];	/* 800 STRING X(6) */
	char	s_name[30];	/* 900 STRING X(30) */
	char	s_status[5];	/* 1300 STRING XXX */

}	S_item ;

typedef struct	{

	char	s_pgm[11];	/* 100 program name */
	long	s_rundate;	/* 300 run date */
	char	s_barg1[7];	/* 400 due date */
	char	s_barg2[7];	/* 500 transaction date */
	char	s_pos1[7];	/* 600 release holdbacks option */
	char 	s_pos2[7];	/* 700 starting supplier code */
	short	s_center1;
	short	s_center2;
	long	s_paydate;	/* 1000 ending trans ref. no. */
	short	s_payper1;	/* 1100 past due date */
	char	s_rgind[2];	/* 900 starting trans ref. no. */
	char	s_emp1[13];	/* 800 ending supllier code */
	char	s_emp2[13];	/* 900 starting trans ref. no. */
	char	s_option[2];	/* 1300 option choice */
	short	s_field;
	char	s_dummy[2];
	short	s_page;

	S_item	s_items[PAGESIZE] ;	/* Start Fld 800, End Fld 3100  */

	char	s_mesg[78];	/* 1500 message field */
	char	s_resp[2];	/* 1600 response field */
	} s_struct;

static	s_struct  s_sth,image;	/* PROFOM Screen Structure */
static	struct  stat_rec  sr;		/* PROFOM status rec */

typedef struct Page {
	S_item	Items[PAGESIZE] ;	/* Items Information */
	struct	Page	*PrevPage ;	/* ptr to previous page */
	struct	Page	*NextPage ;	/* ptr to next page */
	char	I_Status[PAGESIZE][2];	/* item status ie A(DD) C(hange) */
	short	NoItems;		/* number of Items on the page */
	short	Pageno;			/* Page number */
}	Page;

static	Page	*FirstPage,		/* Address of First Page */
		*CurPage,		/* Address of Current Page */
		*CurLast,		/* Address of Curr. record last page */
		*LastPage;		/* Address of Last Page of Memory
					   Allocated */

/* File structures */
static	Pay_per	pay_per;
static	Pa_rec	pa_rec;
static	Barg_unit	barg_unit;
static	Position	position;
static	Class	class;
static	Gl_acct	gl_acct;
static	Emp	emp_rec;
static	Emp_at_his	att_his;
static	Emp_sen	emp_sen;
static	Pay_per	payper;
static	Pay_per_it	pay_per_it;
static	Pay_param	pay_param;
static	Gov_param	gov_param;
static	Sen_par	sen_par;
static	Att	att;
static	Tmp_sen	tmp_sen;
static	Vc_acc	vac;
static	Jr_ent	jr_ent;

/* number of days in months */

short	d_month[12] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };

static	int	day, day2, month;
static	short	month2;
static	int	start_mth;
static	long	curr_year;

static	double	num_sen_days0, num_sen_days1;
static	double	num_sic_days0, num_sic_days1;
static	double	num_vac_days0, num_vac_days1;
static	int	sched_flag;
static	int	no_sick_acc;

static	short	perm_years = 0;
static	double	perm_days=0;
static	short	cas_years=0;
static	double	cas_days=0;
static	short	tot_years=0;
static	double	tot_days=0;

static	double	hours;
static	double	salary;
static	double	amount;

static	char 	e_mesg[180];  		/* dbh will return err msg in this */

static int	PG_SIZE;
static short	pgcnt; 		/* for page count */

static	Validation();
static	WindowHelp();

void	free() ;
char	*malloc() ;

double 	D_Roundoff();
main(argc,argv)
int argc;
char *argv[];
{
	int 	retval;

	LNSZ = 133;
	retval = Initialize(argc,argv);	/* Initialization routine */

	if (retval == NOERROR) retval = Process();

	CloseRtn();			/* return to menu */
	if (retval != NOERROR) exit(1);
	exit(0);
}

/*-------------------------------------------------------------------*/
/* Initialize PROFOM */

Initialize(argc, argv)
int	argc ;
char	*argv[] ;
{
	int	err ;

	/*
	*	Initialize DBH Environment
	*/
	strncpy(SYS_NAME,SYSTEM,50);	/* Sub system name */
	strncpy(CHNG_DATE,MOD_DATE,10);	/* Modification Date */

	proc_switch(argc, argv, CHEQUE) ; 	/* Process Switches */

	/*
	*	Initialize PROFOM & Screen
	*/
	STRCPY(sr.termnm,terminal);	/* Copy Terminal Name */
	fomin(&sr);
	ret(err_chk(&sr)) ;		/* Check for PROFOM Error */
	fomcf(1,1);			/* Enable Snap screen option */

	err = InitScreen() ;		/* Initialize Screen */
	if(NOERROR != err) return(err) ;

	FirstPage = NULL;
	LastPage = NULL;

	return(NOERROR) ;
}	/* Initialize() */

/*--------------------------------------------------------------------------*/
/* Close nessary files and environment before exiting program               */

CloseRtn() 
{
	FreeList();

	/* Set terminal back to normal mode from PROFOM */
	fomcs();
	fomrt();
	close_dbh();			/* Close files */
	close_rep();

	return(NOERROR);
}	/* CloseRtn() */
/* Free the linked list */

static
FreeList()	
{
	int 	i;

	/* clear the screen items from linked list */

	for(CurPage = FirstPage;CurPage;CurPage = CurPage->NextPage){
		for( i=0; i <= PAGESIZE; i++) {
			if(i >= CurPage->NoItems) break;
		}
	}

	for( CurPage=LastPage; CurPage; CurPage=LastPage){
		LastPage=LastPage->PrevPage;
		free((char *)CurPage );
	}

	FirstPage = NULL;

	return(NOERROR);
}
/*----------------------------------------------------------------*/
/* Initialize screen before going to process options */

InitScreen()
{
	/* move screen name to Profom status structure */
	STRCPY(sr.scrnam,NFM_PATH);
	strcat(sr.scrnam,SCR_NAME) ;

	STRCPY(s_sth.s_pgm,PROG_NAME);
	s_sth.s_rundate = get_date();	/* get Today's Date in YYYYMMDD format*/
	s_sth.s_option[0] = HV_CHAR;
	s_sth.s_mesg[0] = HV_CHAR ;
	s_sth.s_resp[0] = HV_CHAR ;

	/* Move Low Values to data fields */
	InitFields() ;

	s_sth.s_emp1[0] = HV_CHAR;
	s_sth.s_emp2[0] = HV_CHAR;

	ClearScreen();

	return(NOERROR) ;
}	/* InitScreen() */

/*-------------------------------------------------------------------*/
/* Get Option from user and call corresponding function */

Process()
{
	int	err;

	for( ; ; ){

		if((err = ReadOption())<0) 
			return(err);

		switch(s_sth.s_option[0]) {
		case  EXITOPT :
			return(NOERROR);
		case  SELECT :
			CHKACC(err,ADD,e_mesg);
			err = ProcOption() ;
			break ;
		default :
			continue;
		}

		if(NOACCESS == err)	fomen(e_mesg);
		if(PROFOM_ERR == err)	return(PROFOM_ERR);  /* PROFOM ERROR */
		if(DBH_ERR == err) {
			DispError((char *)&s_sth,e_mesg);
#ifdef ENGLISH
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"System Error... Iserror:",
				iserror, dberror, errno);
#else
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"Erreur du systeme... Iserror:",
				iserror, dberror, errno);
#endif
			DispError((char *)&s_sth,e_mesg);
			return(DBH_ERR); /* DBH ERROR */
		
		}
		fomce();
	}      /*   end of the for( ; ; )       */
}	/* Process() */
/*------------------------------------------------------------*/
ReadOption()
{

	fomer("                                                    ");
	s_sth.s_mesg[0] = HV_CHAR;
	DispMesgFld((char *)&s_sth);	
#ifdef ENGLISH
	fomer("S(elect), E(xit)");
#else
	fomer("C(hoisir), F(in)");
#endif
	sr.nextfld = OPTION;
	fomrf((char *)&s_sth);
	ret(err_chk(&sr));

}	/* ReadOption */
/*------------------------------------------------------------*/
ProcOption()
{
	int	i, err ;

	for(i = START_FLD ; i <= END_FLD - 300 ; i += 100)
		fomca1(i, 19, 0) ;    /* disable dup control */

	err = ReadRange(ADD) ;
	if(err != NOERROR) return(err) ;

	err = Confirm() ;
	if(err != YES) return(NOERROR) ;

	/* Check to see if payroll in process */
	jr_ent.jr_fund = 0;
	jr_ent.jr_no = 0;
	flg_reset(JR_ENT);

	err = get_n_jr_ent(&jr_ent,UPDATE,0,FORWARD,e_mesg);
	if(err < 0 && err != EFL){
	  	DispError((char *)&s_sth,e_mesg) ;
		seq_over(JR_ENT);
		roll_back(e_mesg);
	  	return(ERROR);
	}
	if(err != EFL && jr_ent.jr_pay_sen[0] == 'P'){
	  	DispError((char *)&s_sth,"Payroll in process, can't continue") ;
		return(NOERROR);
	}

	unlink_file(TMP_SEN);
	unlink_file(JR_ENT);

	if(strcmp(s_sth.s_rgind, "R") == 0)
		err = ProcRanges() ;
	else
		err = ProcItemUpdates();

	if(pgcnt){
		if(term < 99)
			last_page();
#ifndef	SPOOLER
	else
		rite_top();
#endif
	}

	close_rep();

	err = jourlist(1);
	if(err < 0)	return(err);

	return(NOERROR);

}	/* ProcSelection() */
/*------------------------------------------------------------*/
/* Get the Header details from user */

ReadRange(mode)
int	mode ;
{
	int	 i;

	if(mode == ADD) {
#ifdef ENGLISH
		STRCPY(s_sth.s_mesg,"Press ESC-F to Go to Option:");
#else
		STRCPY(s_sth.s_mesg,"Appuyer sur ESC-F pour retourner a Option:");
#endif
		DispMesgFld((char *)&s_sth);

		fomca1(BARG1, 19, 2) ;
		fomca1(BARG2, 19, 2) ;
		fomca1(POS1, 19, 2);
		fomca1(POS2, 19, 2) ;
		fomca1(CENTER1, 19, 2) ;
		fomca1(CENTER2, 19, 2) ;
		fomca1(PAYDATE, 19, 2) ;
		fomca1(PAYPER1, 19, 2) ;
		fomca1(RGIND, 19, 2) ;
		strcpy(s_sth.s_barg1, "     0");
		strcpy(s_sth.s_barg2, "ZZZZZZ");
		strcpy(s_sth.s_pos1, "     0");
		strcpy(s_sth.s_pos2, "ZZZZZZ");
		s_sth.s_center1 = 0;
		s_sth.s_center2 = 9999;
		s_sth.s_paydate = 99991231 ;
		s_sth.s_payper1 = 1 ;
		sr.nextfld = BARG1 ;
		sr.endfld = RGIND ;
		fomud((char*)&s_sth);
		ret(err_chk(&sr));
	}
	InitFields() ;

	i = ReadFields((char *)&s_sth,START_FLD, END_FLD - 200,
			Validation, WindowHelp, 1) ;
	if(PROFOM_ERR == i || DBH_ERR == i) return(i) ;
	if(RET_USER_ESC == i) {	/* ESC-F */
		return(RET_USER_ESC) ;
	}

	ReadEmp();

	return(NOERROR) ;
}	/* ReadRange() */
/*------------------------------------------------------------*/
/* Get the Header details from user */

ReadEmp()
{
	int	 i ;

	if(strcmp(s_sth.s_rgind, "R") == 0){
		fomca1(EMP1, 19, 2) ;
		fomca1(EMP2, 19, 2) ;
		strcpy(s_sth.s_emp1, "           0");
		strcpy(s_sth.s_emp2, "ZZZZZZZZZZZZ");
		sr.nextfld = EMP1 ;
		sr.endfld = EMP2;
		fomud((char*)&s_sth);
		ret(err_chk(&sr));
		s_sth.s_emp1[0] = LV_CHAR;
		s_sth.s_emp2[0] = LV_CHAR;

		ClearScreen();	/* Clear the Screen */

		i = ReadFields((char *)&s_sth, EMP1, EMP2,
			Validation, WindowHelp, 1) ;
		if(PROFOM_ERR == i || DBH_ERR == i) return(i) ;
		if(RET_USER_ESC == i) {	/* ESC-F */
			return(RET_USER_ESC) ;
		}
	}
	else{
		s_sth.s_emp1[0] = HV_CHAR;
		s_sth.s_emp2[0] = HV_CHAR;

		ret( WriteFields((char *)&s_sth, EMP1, EMP2) );

		i = Add();
		if(NOERROR != i) return(i) ;
	}

	return(NOERROR) ;
}	/* ReadEmp() */
/*----------------------------------------------------------------*/
/* Validation function() for Key and Header fields when PROFOM returns
  RET_VAL_CHK */

static
Validation()
{
	int	retval;
	int	fld_no, item_no;
	
	fld_no = sr.curfld;
	if(sr.curfld >= ITEM_ST_FLD) {	
		item_no = (sr.curfld - ITEM_ST_FLD) / STEP;
 		fld_no = (sr.curfld - ITEM_ST_FLD) % STEP + 100;
	}

	switch(fld_no){
	case BARG1:  /* ending bargaining unit code */
		Right_Justify_Numeric(s_sth.s_barg1
					,(sizeof(s_sth.s_barg1)-1));
		break;
	case BARG2:  /* ending bargaining unit code */
		Right_Justify_Numeric(s_sth.s_barg2
					,(sizeof(s_sth.s_barg2)-1));
		if(strcmp(s_sth.s_barg2,s_sth.s_barg1) <0) {
#ifdef ENGLISH
			fomer("Ending code cannot precede starting code");
#else
			fomer("Code finissant ne peut pas preceder le code debutant");
#endif
			s_sth.s_barg2[0] = LV_CHAR;
		}
		break;
	case POS1:  
		Right_Justify_Numeric(s_sth.s_pos1
					,(sizeof(s_sth.s_pos1)-1));
		break;
	case POS2: 
		Right_Justify_Numeric(s_sth.s_pos2
					,(sizeof(s_sth.s_pos2)-1));
		if(strcmp(s_sth.s_pos2,s_sth.s_pos1) <0) {
#ifdef ENGLISH
			fomer("Ending code cannot precede starting code");
#else
			fomer("Code finissant ne peut pas preceder le code debutant");
#endif
			s_sth.s_pos2[0] = LV_CHAR;
		}
		break;
	case CENTER2:  
		if(s_sth.s_center2 < s_sth.s_center1) {
#ifdef ENGLISH
			fomer("Ending number cannot precede starting number");
#else
			fomer("Numero finissant ne peut pas preceder le numero debutant");
#endif
			s_sth.s_center2 = LV_SHORT;
		}
		break;
	case RGIND:  /* ending employee code */
		if(s_sth.s_rgind[0] != 'R' &&
			 s_sth.s_rgind[0] != 'I'){
#ifdef ENGLISH
			fomer("Invalid option - PLEASE re-enter");
#else
			fomer("Invalid option - PLEASE re-enter");
#endif
			s_sth.s_rgind[0] = LV_CHAR;
		}
		break;
	case EMP1:
		Right_Justify_Numeric(s_sth.s_emp1
					,(sizeof(emp_rec.em_numb)-1));
		break;
	case EMP2:  /* ending employee code */
		Right_Justify_Numeric(s_sth.s_emp2
					,(sizeof(emp_rec.em_numb)-1));
		if(strcmp(s_sth.s_emp2,s_sth.s_emp1) <0) {
#ifdef ENGLISH
			fomer("Ending number cannot precede starting number");
#else
			fomer("Numero finissant ne peut pas preceder le numero debutant");
#endif
			s_sth.s_emp2[0] = LV_CHAR;
		}
		break;
	case EMP_ITEM:
		Right_Justify_Numeric(s_sth.s_items[item_no].s_emp,
			sizeof(s_sth.s_items[item_no].s_emp)-1);
		strcpy(emp_rec.em_numb,s_sth.s_items[item_no].s_emp);
		retval = get_employee(&emp_rec,BROWSE,0,e_mesg);
		if(retval < 0) {
			fomer("Employee Does not Exist");
			s_sth.s_items[item_no].s_emp[0] = LV_CHAR;
			return(ERROR);
		}
		retval=UsrBargVal(BROWSE,emp_rec.em_numb,emp_rec.em_barg,
								1,e_mesg);
		if(retval < 0){
			DispError((char *)&s_sth,e_mesg);
			s_sth.s_items[item_no].s_emp[0] = LV_CHAR;
			return(ERROR);
		}
	
		retval = CheckEmp(emp_rec.em_numb);
		if(retval < 0){
			s_sth.s_items[item_no].s_emp[0] = LV_CHAR;
			return(ERROR);
		}

		strcpy(s_sth.s_items[item_no].s_name, emp_rec.em_last_name);
		strcat(s_sth.s_items[item_no].s_name, ", ");
		strcat(s_sth.s_items[item_no].s_name, emp_rec.em_first_name);
		strcat(s_sth.s_items[item_no].s_name, " ");
		strcat(s_sth.s_items[item_no].s_name, emp_rec.em_mid_name);
		break;
	default :
#ifdef ENGLISH
		sprintf(e_mesg,"No Validity Check For Field#  %d",sr.curfld);
#else
		sprintf(e_mesg,"Pas de controle de validite pour le Champ#  %d",sr.curfld);
#endif
		fomen(e_mesg);
		get();
		return(ERROR) ;
	}	/* Switch sr.curfld */

	return(NOERROR) ;
}	/* Validation() */
/*----------------------------------------------------------------*/
/* Show Help Windows, if applicable, when user gives ESC-H in key
   and header fields */

static
WindowHelp()
{
	int	retval ;
	int	fld_no;
	int	item_no;
	int	st_fld;

	fld_no = sr.curfld;
	if(sr.curfld >= ITEM_ST_FLD) {	
		item_no = (sr.curfld - ITEM_ST_FLD) / STEP;
 		fld_no = (sr.curfld - ITEM_ST_FLD) % STEP + 100;

		st_fld = ITEM_ST_FLD + (STEP * item_no);
	}

	switch(fld_no){
	case EMP_ITEM:
		retval = emp_hlp(s_sth.s_items[item_no].s_emp,7,13);
		if(retval == DBH_ERR) return(retval);
		redraw();
		strcpy(emp_rec.em_numb,s_sth.s_items[item_no].s_emp);
		retval = get_employee(&emp_rec,BROWSE,0,e_mesg);
		if(retval < 0) {
			fomer("Employee Number Does not Exist");
			s_sth.s_items[item_no].s_emp[0] = LV_CHAR;
			return(ERROR);
		}
		retval=UsrBargVal(BROWSE,emp_rec.em_numb,emp_rec.em_barg,
								1,e_mesg);
		if(retval < 0){
			DispError((char *)&s_sth,e_mesg);
			s_sth.s_items[item_no].s_emp[0] = LV_CHAR;
			return(ERROR);
		}
	
		retval = CheckEmp(emp_rec.em_numb);
		if(retval < 0){
			s_sth.s_items[item_no].s_emp[0] = LV_CHAR;
			return(ERROR);
		}

		strcpy(e_mesg,emp_rec.em_last_name);
		strcat(e_mesg,", ");
		strcat(e_mesg,emp_rec.em_first_name);
		strncpy(s_sth.s_items[item_no].s_name,e_mesg,28);

		if ( WriteFields((char *)&s_sth,
					st_fld+100, st_fld+100) < 0 ) 
			return(-1);
		break;
	default :
		fomer("No Help Window for This Field");
	}	/* Switch sr.curfld */

	return(NOERROR) ;
}	/* HdrAndKeyWindowHelp() */
/*----------------------------------------------------------------*/
CheckEmp(emp)
char	*emp;
{
	int	i;
	Page	*temppage;

	if(emp[0] == '\0') {
		fomer("This is a Required Field");
		return(ERROR);
	}

	/* check to see if item is already in list */
	if(CurLast != NULL) {
	   for(temppage=FirstPage; temppage!=NULL;temppage=temppage->NextPage) {
	      for(i =0; i< temppage->NoItems; i++) {
			if(temppage->Items[i].s_emp[0] == NULL) {
				return(NOERROR);
			}
			if(strcmp(temppage->Items[i].s_emp,emp) == 0) {
				fomer("Employee Number Already Entered on Screen");
				return(ERROR);
			}
	      }
	      if(temppage == CurLast) break;
	   }
	}

	return(NOERROR);
}
/*-----------------------------------------------------------------------*/
/* Take the confirmation from user for the items part of the screen      */
/*-----------------------------------------------------------------------*/
Confirm()
{
	int	err ;

	/* Options:
	     YLNPC
	*/

	for( ; ; ) {
	    if(strcmp(s_sth.s_rgind, "R") == 0){
#ifdef ENGLISH
		err = GetOption((char *)&s_sth,"Y(es), E(dit), C(ancel)", "YEC");
#else
		err = GetOption((char *)&s_sth,"O(ui), M(odifier), A(nnuler)", "OMA");
#endif
	    }
	    else{
#ifdef ENGLISH
		err = GetOption((char *)&s_sth,
		"Y(es), A(dd), E(dit), D(el), R(eactivate), N(ext), P(rev), C(ancel)"
		,"YAEDRNPC");
#else
		err = GetOption((char *)&s_sth,
		"Y(es), A(dd), E(dit), D(el), R(eactivate), N(ext), P(rev), C(ancel)"
		,"ORCLEVSPA");
#endif
	    }
	    switch(err) {
	    case  YES  :
		return(YES);
	    case  EDIT  :
		err = FieldEdit();
		break ;
	    case  ADDITEMS:
		err = AddItems();
		break;
	    case  DELITEM:
	    case  REACTITEM:
		err = ChangeStatus(err);
		break;
	    case  NEXT:
		if(CurPage == CurLast || CurLast == NULL) {
#ifdef ENGLISH
			fomer("No More Pages....");
#else
			fomer("Plus de pages....");
#endif
			continue;
		}
		CurPage = CurPage->NextPage ;
		err = ShowItems(CurPage);
		break;
	    case  PREV:
		if(CurLast == NULL || CurPage == FirstPage) {
#ifdef ENGLISH
			fomer("No More Pages....");
#else
			fomer("Plus de pages....");
#endif
			continue;
		}
		CurPage = CurPage->PrevPage ;
		err = ShowItems(CurPage);
		break;
	    case  CANCEL :
#ifdef ENGLISH
		err = GetOption((char *)&s_sth,
				"Confirm the Cancel (Y/N)?", "YN") ;
#else
		err = GetOption((char *)&s_sth,
				"Confirmer l'annulation (O/N)?", "ON") ;
#endif
		if(err == YES) return(CANCEL) ;
		break ;
	    }	/* switch err */

	    if(err == PROFOM_ERR) return(err) ;
	    if(err == DBH_ERR) return(err) ;
	}	/* for(; ; ) */
}	/* ConfirmItems() */
/*-----------------------------------------------------------------------*/
/*                                                                       */
/* Changing fields. Accept fld to be changed and read that fld 		 */

FieldEdit()
{
     	int	i,retval;

     	for ( i = START_FLD; i <= END_FLD - 300 ; i += 100 )
       		fomca1( i,19,2 );      		/*  enable Dup Control */

     	sr.nextfld = START_FLD;
     	sr.endfld = END_FLD - 300;
     	fomud( (char *) &s_sth );
     	ret(err_chk(&sr));

	retval = ReadRange(UPDATE);
	if(retval != NOERROR) return(retval) ;

     	return(NOERROR);
}	/* FieldEdit() */
/*-------------------------------------------------------------------------*/
/* Initialize Screen Header with either Low Values */

InitFields()
{
	s_sth.s_barg1[0] = LV_CHAR;
	s_sth.s_barg2[0] = LV_CHAR;
	s_sth.s_pos1[0] = LV_CHAR;
	s_sth.s_pos2[0] = LV_CHAR;
	s_sth.s_center1 = LV_SHORT;
	s_sth.s_center2 = LV_SHORT;
	s_sth.s_paydate = LV_LONG;
	s_sth.s_payper1 = LV_SHORT;
	s_sth.s_rgind[0] = LV_CHAR;
	
	return(NOERROR) ;
}	/* InitFields() */
/*----------------------------------------------------------------------*/
/* Adding.  Get the unique Key, accept details and update the files */
Add()
{
	int	err ;

	FirstPage = NULL;
	LastPage = NULL;
	CurLast = NULL;

	err = GetDetails() ;
	if(PROFOM_ERR == err || DBH_ERR == err) return(err) ;
	if(err < 0 || CANCEL == err) {
		roll_back(e_mesg) ;	/* Unlock the locked Records */
		return(ClearScreen()) ;	/* Clear the Screen */
	}

	return(NOERROR);
}	/* Add() */
/*------------------------------------------------------------*/
/* Read the Area Details from the User */

GetDetails()
{
	int	i ;

	i = AddItems();
	if(NOERROR != i) return(i) ;

	return(NOERROR) ;
}	/* GetDetails() */
/*------------------------------------------------------------*/
/* Read Item Details from the User */

AddItems()
{
	int	i, err ;

	/* If the last node of po is Partial filled then Show Page */
	if(CurLast != NULL && CurLast->NoItems < PAGESIZE ) {
		ret( ShowItems(CurLast) ) ;
		i = CurLast->NoItems ;
		CurPage = CurLast ;
	}
	else {
		/* Calculate the page# */
		if(CurLast != NULL) {
			i = PAGESIZE ;
			CurPage = CurLast ;
		}
		else {
			s_sth.s_page = 1 ;
			WriteFields((char*)&s_sth,PAGE_FLD,PAGE_FLD);
			i = 0 ;
		}
	}

	for( ; ; ) {
		if( PAGESIZE == i) {	/* Page Full */

			/* move High Values to All items exept First one */
			for(i--;i > 0; i--)
				InitItem(HV_CHAR,i);

			/* Calculate the page# */
			s_sth.s_page = CurLast->Pageno + 1 ;

			ret( WriteFields((char *)&s_sth,PAGE_FLD, 
				(END_FLD - 200)) ) ;

			i = 0 ;
		}

		err = ReadItem(i,ADD) ;		/* Read Each Item Line */
		if(PROFOM_ERR == err || DBH_ERR == err) return(err) ;
		if(NOERROR != err) break ;	/* ESC-F */

		if(0 == i)	/* First Item in the Page */
			if((err = MakeFreshPage()) < 0) return(err) ;
		
		/* Copy the Item to List */
		scpy((char*)&(CurPage->Items[i]), (char*)&(s_sth.s_items[i]),
			sizeof(S_item)) ;

		CurPage->I_Status[i][0] = ADDITEMS;

		i++ ;

		CurPage->NoItems = i;
	}
	if(i == 0) 
		if((err=ShowItems(CurPage))<0) return(err) ;

	return(NOERROR) ;
}	/* AddItems() */
/*-----------------------------------------------------------------------*/
/*	Get the next node in linked list to add invoice items. If the
*	(Cur. invc last page) = (Last Page in linked List) or no
*	nodes in list, allocate node and add to linked list
*/

MakeFreshPage()
{
	Page	*tempptr ;

	/* If, no node is allocated yet or Current invoice used all the nodes,
	   then allocate new node */

	if( LastPage == NULL || CurLast == LastPage ){
		tempptr= (Page *)malloc((unsigned)sizeof(Page)) ;

		if( tempptr == NULL ){
			DispError((char*)&s_sth,"Memory Allocation Error");
			return(ERROR);
		}
		tempptr->NextPage = NULL ;

		if( LastPage == NULL ){	/* No node is allocated Yet */
			tempptr->PrevPage = NULL ;
			tempptr->Pageno = 1 ;
			FirstPage = tempptr ;
		}
		else {				/* Not a first node in list */
			tempptr->Pageno = LastPage->Pageno + 1 ;
			LastPage->NextPage = tempptr ;
			tempptr->PrevPage = LastPage ;
		}
		LastPage = tempptr ;
	}

	if(CurLast == NULL)
		CurLast = FirstPage ;
	else
		CurLast = CurLast->NextPage ;

	CurLast->NoItems = 0 ;
	CurPage = CurLast ;

	return(NOERROR);
}	/* MakeFreshPage() */
/*------------------------------------------------------------*/
/* Show all the items on the current page 		      */
ShowItems(pageptr)
Page	*pageptr ;
{
	int	i ;


	if(pageptr != NULL) {
		/* Copy the items to screen */
		scpy((char*)s_sth.s_items, (char*)pageptr->Items,
			(pageptr->NoItems * sizeof(S_item)) );

		s_sth.s_page   = pageptr->Pageno ;
		i = pageptr->NoItems ;
	}
	else {
		s_sth.s_page = HV_SHORT ;
		i = 0 ;
	}

	/* Move High Values to remaining Items */
	for( ; i < PAGESIZE ; i++ )
		InitItem(HV_CHAR,i);

	ret( WriteFields((char *)&s_sth, PAGE_FLD, (END_FLD - 200)) );

	return(NOERROR) ;
}	/* ShowItems() */
/*-----------------------------------------------------------------------*/ 
/* Process all the items in the link list and write any changes to the   */
/* file.								 */
/*-----------------------------------------------------------------------*/ 
ProcItemUpdates()
{
	Page	*temppage;
	int	i;
	int	retval;

	if(CurLast != NULL) {
	   for(temppage=FirstPage; temppage!=NULL;temppage=temppage->NextPage) {
	      for(i =0; i< temppage->NoItems; i++) {
		if(strcmp(temppage->Items[i].s_status, ACTIVE) == 0){
			strcpy(s_sth.s_emp1,temppage->Items[i].s_emp);
			strcpy(s_sth.s_emp2,temppage->Items[i].s_emp);

			retval = ProcRanges();
  			if(retval < 0) break; 
		}
	      }
	      if(temppage == CurLast) break;
	   }
	}
	return(NOERROR);
}
/*------------------------------------------------------------*/
/* Read details of given item# */
/*------------------------------------------------------------*/
ReadItem(item_no,mode)
int	item_no ;
int	mode ;
{
	int	i;
	int	st_fld ;
	int	end_fld ;

#ifdef ENGLISH
	strcpy(s_sth.s_mesg,"Press ESC-F to Terminate");
#else
	strcpy(s_sth.s_mesg,"Appuyer sur ESC-F pour terminer");
#endif
	DispMesgFld((char *)&s_sth);

	if(mode == ADD) {
		SetDupBuffers(ITEM_ST_FLD, END_FLD - 200,0);
		strcpy(s_sth.s_items[item_no].s_status,"ACT");
	}
	else {
		SetDupBuffers(ITEM_ST_FLD, END_FLD - 200,1);
	}

	st_fld = ITEM_ST_FLD + (STEP * item_no);
	end_fld = ITEM_ST_FLD + (STEP * item_no) + STATUS_FLD;
	
	s_sth.s_items[item_no].s_emp[0] = LV_CHAR;
	s_sth.s_items[item_no].s_name[0] = LV_CHAR;

	i = ReadFields((char *)&s_sth,st_fld,end_fld,Validation,WindowHelp,1) ;
	if(PROFOM_ERR == i || DBH_ERR == i) return(i) ;
	if(RET_USER_ESC == i) {
		if(mode == ADD) {
			InitItem(HV_CHAR,item_no);
			WriteFields((char *)&s_sth,st_fld,end_fld);
			return(RET_USER_ESC);
		}
		/* When user gives ESC-F while changing fields, assumption is
		* he completed his changes, and remaining fields are same as
		* old. But, at this point STH will be having low values in the 
		* remaining fields. So move the old values form the linked list.
		*/

		i = CopyBack((char *)&s_sth,(char *)&image,sr.curfld, END_FLD);
		if(i == PROFOM_ERR) return(i);

		return(RET_USER_ESC) ;
	}

	return(NOERROR) ;
}	/* ReadItem() */
/*----------------------------------------------------------------*/
/* Set Duplication buffers for fields 				  */
SetDupBuffers( firstfld, lastfld, value )
int	firstfld, lastfld;	/* field numbers range */
int	value;			/* ENABLE or DISABLE */
{
	int i ;

	for( i=firstfld; i<=lastfld; i+=100 )
		fomca1( i, 19, value);
	if( value==0 )
		return(0);
	sr.nextfld = firstfld;
	sr.endfld = lastfld;
	fomud( (char *)&s_sth );
	ret( err_chk(&sr) );

	return( 0 );
}

/*------------------------------------------------------------------------*/
ChangeStatus(status)
int	status;
{
	int	retval;
	int	st_fld, end_fld;

	/* Get The Field to Be Modified */
#ifdef	ENGLISH
	strcpy(s_sth.s_mesg,"Enter RETURN to Terminate Edit");
#else
	strcpy(s_sth.s_mesg,"Appuyer sur RETURN pour terminer l'ajustement");
#endif
	DispMesgFld((char *)&s_sth); ;
        
     	for (; ;) {
		s_sth.s_field = LV_SHORT;
		retval = ReadFields((char *)&s_sth,CHG_FLD,CHG_FLD,
			(int (*)())NULL,(int (*)())NULL, 1);

		if (retval < 0) return(-1);
		if (retval == RET_USER_ESC) break;	/* User enter ESC-F */
		if (s_sth.s_field > CurPage->NoItems)
			continue;

       		if (s_sth.s_field == 0 ) break;  /* Finished changing fields */

		st_fld  = ITEM_ST_FLD + (STEP * (s_sth.s_field-1)) + STATUS_FLD;
		end_fld  = ITEM_ST_FLD + (STEP * (s_sth.s_field-1))+STATUS_FLD;

		if(status == DELITEM) {
			if(strcmp(s_sth.s_items[s_sth.s_field-1].s_status,
			   INACTIVE)==0) {
				fomer("Item is Already Deleted");
			}
			else {
				strcpy(s_sth.s_items[s_sth.s_field-1].s_status,
			   		INACTIVE);
			}
		}
		else {
			if(strcmp(s_sth.s_items[s_sth.s_field-1].s_status,
			   ACTIVE)==0) {
				fomer("Item is Already Active");
			}
			else {
				strcpy(s_sth.s_items[s_sth.s_field-1].s_status,
			   		ACTIVE);
			}
		}
		/* Update Linked List */
		scpy((char*)&(CurPage->Items[s_sth.s_field -1]), 
		     (char*)&(s_sth.s_items[s_sth.s_field -1]),sizeof(S_item)) ;
		
		ret(WriteFields((char *)&s_sth,st_fld,end_fld));
	}
     	s_sth.s_field = HV_SHORT ;
	if ( WriteFields((char *)&s_sth,CHG_FLD, CHG_FLD) < 0 ) return(-1);

	return(NOERROR);
}
/*------------------------------------------------------------------------*/
/* Move High values to all data fields and clear the screen */

ClearScreen()
{
	int	i;

	FreeList();

	/* Move High Values to Hedaer part */
	s_sth.s_field = HV_SHORT;
	s_sth.s_dummy[0] = HV_CHAR;
	s_sth.s_page = HV_SHORT;
	
	/* Move High Values to The one item */
	for( i=0; i < PAGESIZE ; i++) {
		InitItem(HV_CHAR,i);
	}

	ret( WriteFields((char *)&s_sth,PAGE_FLD, (END_FLD - 200)) );

	return(NOERROR);
}	/* ClearScreen() */
/*-------------------------------------------------------------------------*/
/* Initialize Given screen item with either Low values or High values */

InitItem(t_char, item_no)
char	t_char ;
short	item_no ;
{

	s_sth.s_items[item_no].s_emp[0] = t_char ;
	s_sth.s_items[item_no].s_name[0] = t_char ;
	if(t_char != LV_CHAR){
		s_sth.s_items[item_no].s_status[0] = t_char ;
	}

	return(NOERROR) ;
}	/* Inititem() */
/*-----------------------------------------------------------------------*/
ProcRanges()
{
	int	retval, err;

	gov_param.gp_eff_date = get_date();

	flg_reset(GOV_PARAM);

	err = get_n_gov_param(&gov_param,BROWSE, 0, BACKWARD, e_mesg) ;
	if(err == EFL) {
		DispError((char *)&s_sth,"Government Parameter Record Not Setup");
		return(err);
	}
	if(err < 0) {
  		DispError((char *)&s_sth,e_mesg);
		return(ERROR) ;
	}
	seq_over(GOV_PARAM);

 	retval = get_pay_param(&pay_param,BROWSE,1,e_mesg);
	if(retval < 0) {
  		DispError((char *)&s_sth,e_mesg);
		return(retval);
	}

	if(InitPrinter1()<0) {
		return(-1);
	}	

	retval = PrntHdg();
	if(retval < 0)	return(retval);

	strcpy(emp_rec.em_numb, s_sth.s_emp1);
	flg_reset(EMPLOYEE);

	for( ; ; ){
			
	  retval = get_n_employee(&emp_rec,BROWSE,0,FORWARD,e_mesg);
	  if(retval < 0) {
		if(retval == EFL) break;
		DispError((char *)&s_sth,e_mesg);
	  	retval = PrntRec(e_mesg);
	  	if(retval < 0){
	  		DispError((char *)&s_sth,e_mesg) ;
	  	}
		return(retval);
	  }
	  retval=UsrBargVal(BROWSE,emp_rec.em_numb,emp_rec.em_barg,1,e_mesg);
	  if(retval < 0)
		continue;
	
	  if(strcmp(emp_rec.em_numb,s_sth.s_emp2) > 0)
		break;

	  if((strcmp(emp_rec.em_barg,s_sth.s_barg1) < 0) ||
	     (strcmp(emp_rec.em_barg,s_sth.s_barg2) > 0))
	  	continue ;


  	  if((strcmp(emp_rec.em_pos,s_sth.s_pos1) < 0) ||
   	    (strcmp(emp_rec.em_pos,s_sth.s_pos2) > 0))
	  	continue ;

  	  if((emp_rec.em_cc < s_sth.s_center1) ||
   	     (emp_rec.em_cc > s_sth.s_center2))
	  	continue ;

	  if(strcmp(emp_rec.em_status, "ACT") != 0){
		sprintf(e_mesg,"Employee Status: %s", emp_rec.em_status);
	  	retval = PrntRec(e_mesg) ;
	  	if(retval < 0){
	  		DispError((char *)&s_sth,e_mesg) ;
	  	}
		continue;
	  }

	  retval = GetPPit();
	  if(retval != NOERROR){
		continue;
	  }

	  retval = Pre_Sched();
	  if(retval != NOERROR){
		DispError((char *)&s_sth,e_mesg) ;
		return(ERROR);
	  }
	}
	seq_over(EMPLOYEE);

	return(NOERROR) ;
}

/*--------------------------------------------------------------*/
/* Read all time entry info for the key's given 		*/

Pre_Sched()
{
	int retval;

	tmp_sen.tsn_cas_totd0 = 0;
	tmp_sen.tsn_cas_totd1 = 0;
	tmp_sen.tsn_cas_hrs0 = 0;
	tmp_sen.tsn_cas_hrs1 = 0;
	tmp_sen.tsn_cas_days0 = 0;
	tmp_sen.tsn_cas_days1 = 0;
	tmp_sen.tsn_perm_days0 = 0;
	tmp_sen.tsn_perm_days1 = 0;
	tmp_sen.tsn_vac_acc0 = 0;
	tmp_sen.tsn_vac_acc1 = 0;
	tmp_sen.tsn_sick_acc0 = 0;
	tmp_sen.tsn_sick_acc1 = 0;

	sched_flag = 1; /* this flag is set to one if the employee's
			   schedule is to be used for seniority calc */

	sprintf(e_mesg,"Employee Number: %s",emp_rec.em_numb);
	fomen(e_mesg);
	fflush(stdout);

	retval = GetClass(emp_rec.em_class);
	if(retval == UNDEF) return(NOERROR);

	retval = GetPos(class.c_pos);
	if(retval == UNDEF) return(NOERROR);

	/**********					*********/
	/*  Calculate Seniority for employee			*/

	SenAcc(class.c_pos);

	return(NOERROR);
}
/*-----------------------------------------------------------------------*/
GetPos(pos)
char	*pos;
{
	int	retval;

	strcpy(position.p_code,pos);

	retval = get_position(&position,BROWSE,0,e_mesg);
	if(retval < 0) {
		DispError((char *)&s_sth,e_mesg);
	  	retval = PrntRec(e_mesg);
	  	if(retval < 0){
	  		DispError((char *)&s_sth,e_mesg) ;
	  	}
		return(UNDEF);
	}

	return(NOERROR);
}
/*--------------------------------------------------------------*/
GetClass(class_rec)
char	*class_rec;
{
	int	retval;

	strcpy(class.c_code,class_rec);
	class.c_date = s_sth.s_rundate;
	flg_reset(CLASSIFICATION);

	retval = get_n_class(&class,BROWSE,0,BACKWARD,e_mesg);
	if(retval < 0 && retval != EFL){
		DispError((char *)&s_sth, e_mesg);
	  	retval = PrntRec(e_mesg);
	  	if(retval < 0){
	  		DispError((char *)&s_sth,e_mesg) ;
	  	}
		return(UNDEF);
	}
	if((strcmp(class.c_code,class_rec) != 0) || retval == EFL){
		sprintf(e_mesg,"Classification Code Does Not Exist %s",
								class_rec);
		DispError((char *)&s_sth, e_mesg);
	  	retval = PrntRec(e_mesg);
	  	if(retval < 0){
	  		DispError((char *)&s_sth,e_mesg) ;
	  	}
	    	return(UNDEF);
	}
	seq_over(CLASSIFICATION);
	return(NOERROR);
}
/*------------------------------------------------------------------------*/
static
VacAcc()
{
	int	retval, i, j;
	int	nbr_of_mths = 12;

	retval = CalcSen();
	if(retval < 0)
		return(NOERROR);
	
	if(month >= start_mth){
		i = month-start_mth;
	}
	else{
		i = month+start_mth-2;
	}
	if(month2 >= start_mth){
		j = month2-start_mth;
	}
	else{
		j = month2+start_mth-2;
	}

	strcpy(vac.vc_barg,emp_rec.em_barg);
	vac.vc_low_sen = 0;
	vac.vc_high_sen = 0;
	flg_reset(VC_ACC);

	for( ; ; ){
		retval = get_n_vc_acc(&vac, BROWSE, 0, FORWARD, e_mesg);

		if( retval == EFL ||		
		  ( strcmp(vac.vc_barg, emp_rec.em_barg) != 0))
			return(NOERROR);

		if(retval < 0) {
	  		DispError((char *)&s_sth,e_mesg) ;
	 		retval = PrntRec(e_mesg);
	  		if(retval < 0){
	  			DispError((char *)&s_sth,e_mesg) ;
	  		}
	  		return(ERROR);
		}
		if(tot_years >= vac.vc_low_sen && 
		   tot_years <= vac.vc_high_sen)
			break;

	}
	seq_over(VC_ACC);
	if(vac.vc_days == 0)
		return(NOERROR);

	tmp_sen.tsn_vac_acc0 = (vac.vc_days / nbr_of_mths) *
			       num_vac_days0 / (double)sen_par.sn_poss_days[i] *
			       (emp_rec.em_sen_perc/100.0);
	tmp_sen.tsn_vac_acc1 = (vac.vc_days / nbr_of_mths) *
			       num_vac_days1 / (double)sen_par.sn_poss_days[j] *
			       (emp_rec.em_sen_perc/100.0);

	return(NOERROR);
}
/*------------------------------------------------------------------------*/
static
CalcSen()
{
	int	retval;
	char	old_position[7];

	tot_days = 0;
	tot_years = 0;
	/*
	************** Calculate the Seniority for the Employees ************
	*/
	perm_years = emp_rec.em_per_tot_yrs;
	perm_days = emp_rec.em_per_tot_days + tmp_sen.tsn_perm_days0 +
		    tmp_sen.tsn_perm_days1;

	if(perm_days > sen_par.sn_max_days_yr) {
		perm_years ++;
		perm_days -= sen_par.sn_max_days_yr;
	}

	cas_years = emp_rec.em_cas_tot_yrs;
	cas_days = emp_rec.em_cas_tot_days + tmp_sen.tsn_cas_totd0 + 
		   tmp_sen.tsn_cas_totd1;

	if(cas_days >= sen_par.sn_max_days_yr) {
		cas_years ++;
		cas_days -= sen_par.sn_max_days_yr;
	}

	strcpy(emp_sen.esn_numb, emp_rec.em_numb);
	emp_sen.esn_month = 0;
	emp_sen.esn_pos[0] = '\0';
	emp_sen.esn_class[0] = '\0';
	flg_reset(EMP_SEN);

	old_position[0] = '\0';

	for(;;){

		retval = get_n_emp_sen(&emp_sen,BROWSE,0,FORWARD,e_mesg);
		if( retval == EFL ||		
		  (strcmp(emp_sen.esn_numb, emp_rec.em_numb) != 0))
			break;

		if(retval < 0) {
	  		DispError((char *)&s_sth,e_mesg) ;
	 		retval = PrntRec(e_mesg);
	  		if(retval < 0){
	  			DispError((char *)&s_sth,e_mesg) ;
	  		}
	  		return(ERROR);
		}

		if(strcmp(old_position,emp_sen.esn_pos) != 0) {

			strcpy(sen_par.sn_position,emp_sen.esn_pos);
			sen_par.sn_eff_date = get_date();

			flg_reset(SEN_PAR);

			retval = get_n_sen_par(&sen_par,BROWSE,0,BACKWARD,
				e_mesg);
			if(retval == EFL ||
			   strcmp(sen_par.sn_position,emp_sen.esn_pos)!=0){
				sprintf(e_mesg,
				  "Error Reading Seniority Parameter File: %s",
				  emp_sen.esn_pos);
	  			DispError((char *)&s_sth,e_mesg) ;
	 			retval = PrntRec(e_mesg);
	  			if(retval < 0){
	  				DispError((char *)&s_sth,e_mesg) ;
	  			}
	  			return(ERROR);
			}
			if(retval < 0) {
	  			DispError((char *)&s_sth,e_mesg) ;
	 			retval = PrntRec(e_mesg);
	  			if(retval < 0){
	  				DispError((char *)&s_sth,e_mesg) ;
	  			}
	  			return(ERROR);
			}

			strcpy(old_position,emp_sen.esn_pos);
		}

		perm_days += emp_sen.esn_perm_days;
		if(perm_days > sen_par.sn_max_days_yr) {
			perm_years ++;
			perm_days -= sen_par.sn_max_days_yr;
		}

		cas_days +=  emp_sen.esn_cas_totd;
		if(cas_days >= sen_par.sn_max_days_yr) {
			cas_years ++;
			cas_days -= sen_par.sn_max_days_yr;
		}

	}/*end endless loop*/
	seq_over(EMP_SEN);

	if(sen_par.sn_position[0] == '\0'){
		strcpy(sen_par.sn_position,emp_rec.em_pos);
		sen_par.sn_eff_date = get_date();

		flg_reset(SEN_PAR);

		retval = get_n_sen_par(&sen_par,BROWSE,0,BACKWARD,
				e_mesg);
		if(retval == EFL ||
		   strcmp(sen_par.sn_position,emp_sen.esn_pos)!=0){
			sprintf(e_mesg,
			  "Error Reading Seniority Parameter File: %s",
			  emp_sen.esn_pos);
	  		DispError((char *)&s_sth,e_mesg) ;
	 		retval = PrntRec(e_mesg);
	  		if(retval < 0){
	  			DispError((char *)&s_sth,e_mesg) ;
	  		}
	  		return(ERROR);
		}
		if(retval < 0) {
	  		DispError((char *)&s_sth,e_mesg) ;
	 		retval = PrntRec(e_mesg);
	  		if(retval < 0){
	  			DispError((char *)&s_sth,e_mesg) ;
	  		}
	  		return(ERROR);
		}
	}

	/* calc tot*/
	tot_years +=(cas_years + perm_years);
	tot_days  +=(cas_days + perm_days);
	if(tot_days >= sen_par.sn_max_days_yr) {
		tot_years ++;
		tot_days -= sen_par.sn_max_days_yr;
	}

	if(sen_par.sn_max_days_yr != 0)
		tot_years += ((short)tot_days/(short)sen_par.sn_max_days_yr);
	else
		return(ERROR);

	return(NOERROR);
}
/*--------------------------------------------------------------*/
AttAcc()
{
	int	i, j;

	tmp_sen.tsn_sick_acc0 = 0;
	tmp_sen.tsn_sick_acc1 = 0;

	if(emp_rec.em_term_dt != 0)
		return(NOERROR);

	if(no_sick_acc == 1)
		return(NOERROR);

	if(month >= start_mth){
		i = month-start_mth;
	}
	else{
		i = month+start_mth-2;
	}
	if(month2 >= start_mth){
		j = month2-start_mth;
	}
	else{
		j = month2+start_mth-2;
	}

	if(sen_par.sn_poss_days[i] != 0)
	    tmp_sen.tsn_sick_acc0 = barg_unit.b_sick_rate * 
		(double)num_sic_days0 / (double)sen_par.sn_poss_days[i] *
				     (emp_rec.em_sen_perc / 100.0);
	else
	    tmp_sen.tsn_sick_acc0 = 0;

	if(sen_par.sn_poss_days[j] != 0)
	    tmp_sen.tsn_sick_acc1 = barg_unit.b_sick_rate * 
		(double)num_sic_days1 / (double)sen_par.sn_poss_days[j] *
				     (emp_rec.em_sen_perc / 100.0);
	else
	    tmp_sen.tsn_sick_acc1 = 0;

	return(NOERROR);
}
/***********************************************************************/
SenAcc(pos)
char *pos;
{
	int	err, retval;
	int	mode;
	double	tmp_total;

	num_sen_days0 = 0;
	num_sen_days1 = 0;

	strcpy(tmp_sen.tsn_numb, emp_rec.em_numb); 
	tmp_sen.tsn_month = month2;
	strcpy(tmp_sen.tsn_pos, pos);
	strcpy(tmp_sen.tsn_class, class.c_code);

	err = get_tmp_sen(&tmp_sen,UPDATE,0,e_mesg);
	if(err < 0 && err != UNDEF){
	  	DispError((char *)&s_sth,e_mesg) ;
	 	err = PrntRec(e_mesg);
	  	if(err < 0){
	  		DispError((char *)&s_sth,e_mesg) ;
	  	}
	  	return(ERROR);
	}
	if(err == UNDEF)
		mode = ADD;
	else
		mode = UPDATE;

	strcpy(sen_par.sn_position,pos);
	sen_par.sn_eff_date = get_date();
	flg_reset(SEN_PAR);

	err = get_n_sen_par(&sen_par, BROWSE, 0, BACKWARD, e_mesg);
	if(err < 0) {
  		DispError((char *)&s_sth,e_mesg);
	 	err = PrntRec(e_mesg);
	  	if(err < 0){
	  		DispError((char *)&s_sth,e_mesg) ;
	  	}
		return(ERROR);
	}
	seq_over(SEN_PAR);
	if(strcmp(sen_par.sn_position,pos)!=0){
		sprintf(e_mesg,"Error Reading Seniority Parameter File: %s",
			pos);
		DispError((char *)&s_sth,e_mesg);
	 	err = PrntRec(e_mesg);
	  	if(err < 0){
	  		DispError((char *)&s_sth,e_mesg) ;
	  	}
		return(ERROR);
	}

	if(mode != ADD) return(NOERROR);

	/* Get Number of Seniority Days	*/
	GetSen();

	/* Get Number of Non-Seniority Days	*/
	GetNonSen();

	tmp_sen.tsn_cas_hrs0 = 0;
	tmp_sen.tsn_cas_days0 = 0;
	tmp_sen.tsn_cas_hrs1 = 0;
	tmp_sen.tsn_cas_days1 = 0;
	if(strcmp(position.p_type,"FT")==0 ||
	   strcmp(position.p_type,"PT")==0){
		tmp_sen.tsn_perm_days0 = (double)num_sen_days0 *
					(emp_rec.em_sen_perc / 100.0);
		tmp_sen.tsn_perm_days1 = (double)num_sen_days1*
					(emp_rec.em_sen_perc / 100.0);
	}
	else{
		tmp_sen.tsn_cas_totd0 = (double)num_sen_days0 *
					(emp_rec.em_sen_perc / 100.0);
		tmp_sen.tsn_cas_totd1 = (double)num_sen_days1*
					(emp_rec.em_sen_perc / 100.0);
	}

	/*   Accrual Attendance for the Pay Period	*/

	if(num_sic_days0 != 0 || num_sic_days1 != 0)
	  	AttAcc();
	if(num_vac_days0 != 0 || num_vac_days1 != 0)
	  	VacAcc();


	tmp_total = tmp_sen.tsn_cas_hrs0 + tmp_sen.tsn_cas_days0 +
			tmp_sen.tsn_perm_days0 + tmp_sen.tsn_cas_totd0 +
			tmp_sen.tsn_cas_hrs1 + tmp_sen.tsn_cas_days1 +
			tmp_sen.tsn_perm_days1 + tmp_sen.tsn_cas_totd1 +
			tmp_sen.tsn_vac_acc0 + tmp_sen.tsn_sick_acc0 +
			tmp_sen.tsn_vac_acc1 + tmp_sen.tsn_sick_acc1;

	if(tmp_total != 0){
  		err = put_tmp_sen(&tmp_sen,mode,e_mesg);	
		if(err < 0) {
		 	DispError((char *)&s_sth,e_mesg);
	  		retval = PrntRec(e_mesg);
	  		if(retval < 0){
	  			DispError((char *)&s_sth,e_mesg) ;
	  		}
		  	return(ERROR);
		}
		err = commit(e_mesg);
		if(err < 0) {
			DispError((char *)&s_sth,e_mesg);
			roll_back(e_mesg);
			return(ERROR);
		}

		retval = WriteJr();
		if(retval < 0)	return(retval);

	}
	else{
		roll_back(e_mesg);
		if(sched_flag != 0){
		  sprintf(e_mesg,"Seniority Calculated is Zero");
	  	  retval = PrntRec(e_mesg);
	  	  if(retval < 0)
	  		DispError((char *)&s_sth,e_mesg) ;
	  	}
	}
	return(NOERROR);
}
/*-----------------------------------------------------------------------*/
WriteJr()
{
	int	retval;


	gl_acct.gl_fund = pay_param.pr_fund;
	gl_acct.gl_cc = emp_rec.em_cc;

	strcpy(gl_acct.gl_type, "S");
	strcpy(gl_acct.gl_class, emp_rec.em_class);
	strcpy(gl_acct.gl_earn, pay_param.pr_vac_earn);
	gl_acct.gl_acct[0] = '\0';
	flg_reset(GLACCT);

	retval = get_n_glacct(&gl_acct,BROWSE,0,FORWARD,e_mesg);
	if(retval < 0 && retval != EFL){
	  	DispError((char *)&s_sth,e_mesg) ;
		retval = PrntRec(e_mesg);
		if(retval < 0)
  			DispError((char *)&s_sth,e_mesg) ;
		seq_over(GLACCT);
		roll_back(e_mesg);
	  	return(ERROR);
	}
	if(retval == EFL || gl_acct.gl_fund != pay_param.pr_fund ||
	   gl_acct.gl_cc != emp_rec.em_cc ||
	   strcmp(gl_acct.gl_type,"S")!=0 ||
	   strcmp(gl_acct.gl_class,emp_rec.em_class)!=0 ||
	   strcmp(gl_acct.gl_earn,pay_param.pr_vac_earn)!=0){
		sprintf(e_mesg,"G/L Account Not Setup For Fund: %d, CC: %d, Type: S, Class: %s, Earn Code: %s", pay_param.pr_fund, 
		  emp_rec.em_cc,emp_rec.em_class,
		  pay_param.pr_vac_earn);
		retval = PrntRec(e_mesg);
		if(retval < 0)
  			DispError((char *)&s_sth,e_mesg) ;
		roll_back(e_mesg);
	  	return(NOERROR);
	}
	seq_over(GLACCT);
	jr_ent.jr_fund = gl_acct.gl_fund;
	retval = GetJr(gl_acct.gl_fund);
	if(retval < 0){
	  	return(ERROR);
	}
	jr_ent.jr_fund = gl_acct.gl_fund;
	jr_ent.jr_date = s_sth.s_paydate;
	strcpy(jr_ent.jr_acct,gl_acct.gl_acct);
	strcpy(jr_ent.jr_emp_numb,emp_rec.em_numb);
	strcpy(jr_ent.jr_type,"E");
	strcpy(jr_ent.jr_code,pay_param.pr_vac_earn);
	strcpy(jr_ent.jr_class,emp_rec.em_class);
	strcpy(jr_ent.jr_pay_sen,"S");

	retval = CalcHours();
	if(retval < 0)	return(retval);

	retval = CalcSalary();
	if(retval < 0)	return(retval);

	amount = tmp_sen.tsn_vac_acc0 + tmp_sen.tsn_vac_acc1;
	amount = amount * hours * salary;
	jr_ent.jr_amount = D_Roundoff(amount);

	/*  if no income return	*/
	if(jr_ent.jr_amount != 0) {
		retval = put_jr_ent(&jr_ent,ADD,e_mesg);	
		if(retval < 0) {
		 	DispError((char *)&s_sth,e_mesg);
			retval = PrntRec(e_mesg);
			if(retval < 0)
	  			DispError((char *)&s_sth,e_mesg) ;
			roll_back(e_mesg);
		  	return(ERROR);
		}

	  	jr_ent.jr_no++;
		strcpy(jr_ent.jr_acct,pay_param.pr_teach_gl);
		jr_ent.jr_amount = jr_ent.jr_amount*-1;

		retval = put_jr_ent(&jr_ent,ADD,e_mesg);	
		if(retval < 0) {
		 	DispError((char *)&s_sth,e_mesg);
			retval = PrntRec(e_mesg);
			if(retval < 0)
	  			DispError((char *)&s_sth,e_mesg) ;
			roll_back(e_mesg);
		  	return(ERROR);
		}

		retval = commit(e_mesg);
		if(retval < 0) {
	  		DispError((char *)&s_sth,e_mesg);
			retval = PrntRec(e_mesg);
			if(retval < 0)
  				DispError((char *)&s_sth,e_mesg) ;
				roll_back(e_mesg);
		  		return(ERROR);
		}
	}
	
	return(NOERROR);
}
/*--------------------------------------------------------------*/
GetPPit()
{
	int	err, retval, nbr_weeks_pay;

	no_sick_acc = 0;

	strcpy(barg_unit.b_code,emp_rec.em_barg);
	barg_unit.b_date = get_date();
	flg_reset(BARG);

	err = get_n_barg(&barg_unit,BROWSE,0,BACKWARD,e_mesg);
	if(err == EFL ||
		strcmp(barg_unit.b_code, emp_rec.em_barg) != 0){
		sprintf(e_mesg,"Bargaining Unit Does Not Exist: %s",
			emp_rec.em_barg);
  		DispError((char *)&s_sth,e_mesg);
	  	retval = PrntRec(e_mesg) ;
	  	if(retval < 0){
	  		DispError((char *)&s_sth,e_mesg) ;
	  	}
		return(NOERROR);
	}
	if(err < 0){
  		DispError((char *)&s_sth,e_mesg);
	  	retval = PrntRec(e_mesg) ;
	  	if(retval < 0){
	  		DispError((char *)&s_sth,e_mesg) ;
	  	}
  		return(ERROR);
	}
	seq_over(BARG);

	strcpy(payper.pp_code,barg_unit.b_pp_code);
	payper.pp_year = 0;
	flg_reset(PAY_PERIOD);

	retval = get_n_pay_per(&payper,BROWSE,0,FORWARD,e_mesg);
	if(retval == EFL || strcmp(payper.pp_code,barg_unit.b_pp_code)!=0){
		sprintf(e_mesg,"Pay Period Code Does Not Exist: %s",
			barg_unit.b_pp_code);
  		DispError((char *)&s_sth,e_mesg);
	  	retval = PrntRec(e_mesg) ;
	  	if(retval < 0){
	  		DispError((char *)&s_sth,e_mesg) ;
	  	}
  		return(ERROR);
	}
	if(retval < 0){	
		DispError((char *)&s_sth,e_mesg);
	  	retval = PrntRec(e_mesg) ;
	  	if(retval < 0){
	  		DispError((char *)&s_sth,e_mesg) ;
	  	}
  		return(ERROR);
	}
	seq_over(PAY_PERIOD);

	strcpy(pay_per_it.ppi_code,barg_unit.b_pp_code);
	pay_per_it.ppi_numb = s_sth.s_payper1;
	pay_per_it.ppi_year = 9999;
	flg_reset(PAY_PER_ITEM);

	retval = get_n_pp_it(&pay_per_it,BROWSE,3,BACKWARD,e_mesg);
	if(retval < 0 ){
		DispError((char *)&s_sth,e_mesg);
	  	retval = PrntRec(e_mesg) ;
	  	if(retval < 0){
	  		DispError((char *)&s_sth,e_mesg) ;
	  	}
  		return(ERROR);
	}
	if(strcmp(pay_per_it.ppi_code,barg_unit.b_pp_code)!=0){
		sprintf(e_mesg,"Pay Period Item Does Not Exist: %s",
			barg_unit.b_pp_code);
		DispError((char *)&s_sth,e_mesg);
	  	retval = PrntRec(e_mesg) ;
	  	if(retval < 0){
	  		DispError((char *)&s_sth,e_mesg) ;
	  	}
  		return(ERROR);
	}
	if(pay_per_it.ppi_numb != s_sth.s_payper1){
		no_sick_acc = 1; /* employees do not receive sick accrual
					for pay periods that they are not set up
					for */
	}
	seq_over(PAY_PER_ITEM);

	nbr_weeks_pay = 52/payper.pp_numb ;
	if(nbr_weeks_pay >= 2)
		strcpy(pay_per_it.ppi_code,"BIWEEK");
	else
		strcpy(pay_per_it.ppi_code,pay_param.pr_payper);
	pay_per_it.ppi_numb = s_sth.s_payper1;
	pay_per_it.ppi_year = 9999;
	flg_reset(PAY_PER_ITEM);

	retval = get_n_pp_it(&pay_per_it,BROWSE,3,BACKWARD,e_mesg);
	if(retval < 0 ){
		DispError((char *)&s_sth,e_mesg);
	  	retval = PrntRec(e_mesg) ;
	  	if(retval < 0){
	  		DispError((char *)&s_sth,e_mesg) ;
	  	}
  		return(ERROR);
	}
	if(nbr_weeks_pay >= 2){
	  if(strcmp(pay_per_it.ppi_code,"BIWEEK")!=0){
		sprintf(e_mesg,"Employee Not Setup for Pay Period: %s",
			barg_unit.b_pp_code);
		DispError((char *)&s_sth,e_mesg);
	  	retval = PrntRec(e_mesg) ;
	  	if(retval < 0){
	  		DispError((char *)&s_sth,e_mesg) ;
	  	}
  		return(ERROR);
	  }
	}
	else{
	  if(strcmp(pay_per_it.ppi_code,pay_param.pr_payper)!=0){
		sprintf(e_mesg,"Pay Period Item Does Not Exist: %s",
			barg_unit.b_pp_code);
		DispError((char *)&s_sth,e_mesg);
	  	retval = PrntRec(e_mesg) ;
	  	if(retval < 0){
	  		DispError((char *)&s_sth,e_mesg) ;
	  	}
  		return(ERROR);
	  }
	}
	if(pay_per_it.ppi_numb != s_sth.s_payper1){
		sprintf(e_mesg,"Employee Not Setup for Pay Period: %d",
			s_sth.s_payper1);
	  	retval = PrntRec(e_mesg) ;
	  	if(retval < 0){
	  		DispError((char *)&s_sth,e_mesg) ;
	  	}
  		return(ERROR);
	}
	seq_over(PAY_PER_ITEM);

	if(pay_param.pr_st_mth == 1){
		start_mth = ((pay_param.pr_cal_st_dt / 100) % 100);
	}
	if(pay_param.pr_st_mth == 2){
		start_mth = ((pay_param.pr_fisc_st_dt / 100) % 100);
	}
	if(pay_param.pr_st_mth == 3){
		start_mth = ((pay_param.pr_schl_st_dt / 100) % 100);
	}
	day = (pay_per_it.ppi_st_date) % 100; 
	day2 = (pay_per_it.ppi_end_date) % 100; 
	month = (pay_per_it.ppi_st_date / 100) % 100; 
	month2 = (pay_per_it.ppi_end_date / 100) % 100; 

	return(NOERROR);
}
/*--------------------------------------------------------------*/
GetNonSen()
{
	int 	retval, curr_month;

	num_vac_days0 = num_sen_days0;
	num_vac_days1 = num_sen_days1;

	num_sic_days0 = num_sen_days0;
	num_sic_days1 = num_sen_days1;

	strcpy(att_his.eah_numb, emp_rec.em_numb);
	att_his.eah_date = pay_per_it.ppi_st_date;
	flg_reset(EMP_ATT);

	for(;;){
		retval = get_n_emp_at(&att_his, BROWSE, 0, FORWARD, e_mesg);
		if(retval == EFL ||		
		    (strcmp(att_his.eah_numb, emp_rec.em_numb) != 0)){
			break;
		}
		if(retval < 0) {
	  		DispError((char *)&s_sth,e_mesg) ;
	 		retval = PrntRec(e_mesg);
	  		if(retval < 0){
	  			DispError((char *)&s_sth,e_mesg) ;
	  		}
	  		return(ERROR);
		}

		if(att_his.eah_date > pay_per_it.ppi_end_date)
			break;
		strcpy(att.at_code, att_his.eah_code);

		retval = get_att(&att,BROWSE,1,e_mesg);
		if(retval < 0)  {
	  		DispError((char *)&s_sth,e_mesg) ;
	 		retval = PrntRec(e_mesg);
	  		if(retval < 0){
	  			DispError((char *)&s_sth,e_mesg) ;
	  		}
	  		return(ERROR);
		}
		curr_month = ((att_his.eah_date /100) % 100);

		if(att.at_sen[0] == 'Y'){
		  if(month != month2){
			if(curr_month == month)
				num_sen_days0 --;
	    		else
				num_sen_days1 --;
		  }
		  else
			num_sen_days1 --;
		}

		if(att.at_sic_acc[0] == 'Y'){
		  if(month != month2){
			if(curr_month == month)
				num_sic_days0 --;
	    		else
				num_sic_days1 --;
		  }
		  else
			num_sic_days1 --;
		}

		if(att.at_vac_acc[0] == 'Y'){
		  if(month != month2){
			if(curr_month == month)
				num_vac_days0 --;
	    		else
				num_vac_days1 --;
		  }
		  else
			num_vac_days1 --;
		}

		att_his.eah_date ++;
		flg_reset(EMP_ATT);
	}
	seq_over(EMP_ATT);

	if(num_vac_days0 < 0)
		num_vac_days0 = 0;
	if(num_vac_days1 < 0)
		num_vac_days1 = 0;

	if(num_sen_days0 < 0)
		num_sen_days0 = 0;
	if(num_sen_days1 < 0)
		num_sen_days1 = 0;

	if(num_sic_days0 < 0)
		num_sic_days0 = 0;
	if(num_sic_days1 < 0)
		num_sic_days1 = 0;

	return(NOERROR);
}
/*--------------------------------------------------------------*/
GetSen()
{
	int	i;
	long	this_year;

	Disp_Mth();
	if(curr_year > pay_per_it.ppi_st_date){
		month = start_mth;
		day = 1;
	}

	if(month != month2){
	  this_year = get_date() / 10000;  /* Get current year */
printf("\nthis year is %ld",this_year);
	  if(this_year / 4 == 0){
printf("\n\n\tChangeing %d to 29\n",d_month[1]);get();
		d_month[1] = 29; /* Leap Year */
	  }
	  for(i=day; i<= d_month[month-1]; i++){
	    if(month >= start_mth){
	      if(sen_par.sn_month[month-(start_mth)][i-1] == '.')
		num_sen_days0 ++;
	    }
	    else{
	      if(sen_par.sn_month[month+start_mth-2][i-1] == '.')
		num_sen_days0 ++;
	    }
	  }
	  for(i=1; i<= day2; i++){
	      if(month2 >= start_mth){
	  	if(sen_par.sn_month[month2-start_mth][i-1] == '.')
			num_sen_days1 ++;
	      }
	      else{
	  	if(sen_par.sn_month[month2+start_mth-2][i-1] == '.')
			num_sen_days1 ++;
	      }
	  }
	}
	else{
	    for(i=day; i<= day2; i++){
	      if(month2 >= start_mth){
		if(sen_par.sn_month[month2-start_mth][i-1] == '.')
			num_sen_days1 ++;
	      }
	      else{
		if(sen_par.sn_month[month2+start_mth-2][i-1] == '.')
			num_sen_days1 ++;
	      }
	    }
	}
	return(NOERROR);
}
/*-----------------------------------------------------------*/
Disp_Mth()
{
	
	if(pay_param.pr_st_mth == 1){
		start_mth = ((pay_param.pr_cal_st_dt / 100) % 100);
		curr_year = pay_param.pr_cal_st_dt;
	}
	if(pay_param.pr_st_mth == 2){
		start_mth = ((pay_param.pr_fisc_st_dt / 100) % 100);
		curr_year = pay_param.pr_fisc_st_dt;
	}
	if(pay_param.pr_st_mth == 3){
		start_mth = ((pay_param.pr_schl_st_dt / 100) % 100);
		curr_year = pay_param.pr_schl_st_dt;
	}
	return(NOERROR);
}
/*-----------------------------------------------------------------*/
InitPrinter1()

{
	char	resp[2] ;
	char	discfile[15] ;

	/* Always to Printer */
	STRCPY(resp,"P");
	discfile[0]= '\0';
	PG_SIZE = 60;

	if( opn_prnt( resp, discfile, 1, e_mesg, 1 /* spool */)<0 ){
		return(REPORT_ERR);
	}
	pgcnt = 0;		/* Page count is zero */
	LNSZ = 132;		/* line size in no. of chars */
	linecnt = PG_SIZE;	/* Page size in no. of lines */

	return(NOERROR) ;
}
/******************************************************************************
Prints the headings
******************************************************************************/
static
PrntHdg()	/* Print heading  */
{
	long	sysdt ;
	int	offset;

	if( pgcnt && term < 99)   /* new page and display */
		if(next_page()<0) return(EXIT);	
		
	if( pgcnt || term < 99) { /* if not the first page or display */
		if( rite_top()<0 ) return( -1 );	/* form_feed */
	}
	else
		linecnt = 0;
	pgcnt++; 			/* increment page no */

	mkln( 1, PROG_NAME, 10 );
#ifdef ENGLISH
	mkln( 103, "Date:", 5 );
#else
	mkln( 103, "Date:", 5 );
#endif
	sysdt = get_date() ;
	tedit( (char *)&sysdt,"____/__/__",line+cur_pos, R_LONG ); 
	cur_pos += 10;

#ifdef ENGLISH
	mkln( 122, "PAGE:", 5 );
#else
	mkln( 122, "PAGE:", 5 );
#endif
	tedit( (char *)&pgcnt,"__0_",  line+cur_pos, R_SHORT ); 
	cur_pos += 4;
	if(prnt_line() < 0 )	return(REPORT_ERR);
 
	offset = ( LNSZ-strlen(pa_rec.pa_co_name) )/2;
	mkln( offset, pa_rec.pa_co_name, strlen(pa_rec.pa_co_name) );
	if( prnt_line()<0 )	return(REPORT_ERR);

#ifdef ENGLISH
	mkln((LNSZ-35)/2,"END OF PAY PERIOD ERROR AUDIT TRAIL", 35 );
#else
	mkln((LNSZ-26)/2,"TRANSLATE        ", 26 );
#endif
	if(prnt_line() < 0 )	return(REPORT_ERR);
	if(prnt_line() < 0 )	return(REPORT_ERR);

	mkln(3,"EMPLOYEE",8);
	mkln(14,"EMPLOYEE NAME",13);
	mkln(14,"COMMENT",7);

	if(prnt_line() < 0 )	return(REPORT_ERR);
	if(prnt_line() < 0 )	return(REPORT_ERR);

	return(NOERROR);
}
/****************************************************************************/
static
PrntRec(err_mesg)
char	*err_mesg;
{
	char	txt_line[132];
	int	retval;

	mkln(1,emp_rec.em_numb,12);
	sprintf(txt_line,"%s, %s",
		emp_rec.em_last_name,
		emp_rec.em_first_name);
	mkln(15,txt_line,22);
	mkln(40,err_mesg,90);
	if(prnt_line() < 0 )	return(REPORT_ERR);
	mkln(40,err_mesg+91,90);
	if(prnt_line() < 0 )	return(REPORT_ERR);
	if(prnt_line() < 0 )	return(REPORT_ERR);
			
	else if(linecnt > PG_SIZE) {
		if((retval=PrntHdg()) == EXIT)	
			return(retval);
	}

	return(NOERROR);
}
/*-----------------------------------------------------------------------*/
GetJr(fund)
short	fund;
{
	int	retval;

	jr_ent.jr_no = HV_SHORT;
	flg_reset(JR_ENT);

	retval = get_n_jr_ent(&jr_ent,UPDATE,0,BACKWARD,e_mesg);
	if(retval < 0 && retval != EFL){
	  	DispError((char *)&s_sth,e_mesg) ;
		retval = PrntRec(e_mesg);
		if(retval < 0)
	  		DispError((char *)&s_sth,e_mesg) ;
		seq_over(JR_ENT);
		roll_back(e_mesg);
	  	return(ERROR);
	}
	if(retval == EFL || jr_ent.jr_no < 1 || jr_ent.jr_fund != fund){
	  jr_ent.jr_fund = fund;
	  jr_ent.jr_no = 1;
	}
	else 
	  jr_ent.jr_no ++;

	return(NOERROR);
}
/*---------------------------------------------------------------------------*/
static
CalcHours()
{
	int retval;

	strcpy(sen_par.sn_position,emp_rec.em_pos);
	sen_par.sn_eff_date = get_date();

	flg_reset(SEN_PAR);

	retval = get_n_sen_par(&sen_par,BROWSE,0,BACKWARD,e_mesg);
	if(retval == EFL || strcmp(emp_rec.em_pos,sen_par.sn_position) != 0) {
		sprintf(e_mesg,"Seniority Parameter Not Setup, Employee: %s",
			emp_rec.em_numb); 
		fomen(e_mesg);
		return(retval);
	}
	if(retval < 0) {
		fomen(e_mesg) ;
		get();
		return(ERROR) ;
	}
	hours = D_Roundoff(sen_par.sn_num_hrs_day);

	return(NOERROR);
}
/*---------------------------------------------------------------------------*/
static
CalcSalary()
{
	int retval;
	double 	temp_calc = 0;
	double temp_calc2 = 0;
	double	one_hundred;

	one_hundred = 100;

	strcpy(barg_unit.b_code,emp_rec.em_barg);
	barg_unit.b_date = get_date();
	flg_reset(BARG);

	retval = get_n_barg(&barg_unit,BROWSE,0,BACKWARD,e_mesg);
	if(retval == EFL ||
		strcmp(barg_unit.b_code, emp_rec.em_barg) != 0){
  		fomer("Bargaining Unit does not Exist");
		return(NOERROR);
	}
	if(retval < 0){
  		fomer(e_mesg);
  		return(ERROR);
	}
	seq_over(BARG);

	if(emp_rec.em_class[0] == '\0') {
		salary = 0;
	}
	else {
		strcpy(class.c_code,emp_rec.em_class);
		class.c_date = get_date();
		flg_reset(CLASSIFICATION);
		retval = get_n_class(&class,BROWSE,0,BACKWARD,e_mesg);
		if((retval < 0 ||
		    strcmp(class.c_code,emp_rec.em_class) != 0)){
			fomer("Classification Code Does Not Exist - Please Re-enter");
			get();
			salary = 0;
			return(-1);
		}
	 	if(class.c_units != 0) {	
 		        salary = D_Roundoff(class.c_yrly_inc / class.c_units); 
		}
		else{
			strcpy(pay_per.pp_code,barg_unit.b_pp_code);
			pay_per.pp_year = 0;
			flg_reset(PAY_PERIOD);

			retval = get_n_pay_per(&pay_per,BROWSE,0,FORWARD,
								e_mesg);
			if(retval < 0 || strcmp(pay_per.pp_code,
					        barg_unit.b_pp_code)!=0) {
				fomer("Pay Period Code Does not Exist");
				get();
			}
			seq_over(PAY_PERIOD);
			if(class.c_yrly_inc == 0){
				salary = 0;
			}
			else{
				 	temp_calc2 = class.c_yrly_inc / 
						(double)pay_per.pp_numb;
					temp_calc = temp_calc2 * emp_rec.em_perc/ one_hundred; 
					temp_calc = D_Roundoff(temp_calc);
		    	}
			salary = (double)temp_calc;
		}
	}
	return(NOERROR);
}
/******************   END OF PROGRAM *******************************/
