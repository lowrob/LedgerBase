/******************************************************************************
		Sourcename   : pre_senrpt.c
		Created on   : 10-APR-92
		Created  By  : Andre Cormier 
		Cobol Source : 

******************************************************************************
About the file:	
	This file has routines to print Fixed Asset Report. 
	It is called by the file pprep.c .

History:
Programmer      Last change on    Details

******************************************************************************/

#define 	MAIN 
#define		MAINFL	TMP_SEN		/* main file used */

#include <stdio.h>
#include <bfs_defs.h>
#include <bfs_pp.h>
#include <bfs_com.h>
#include <repdef.h>
#include <cfomstrc.h>
#include <filein.h>
#include <isnames.h>

#define	SYSTEM		"ACCOUNTS PAYABLE"	/* Sub System Name */
#define	MOD_DATE	"19-JUL-92"		/* Program Last Modified */
#define	SCR_NAME	"sen_aud"		/* First screen */

#define	ST_FLD		600 
#define	END_FLD		1700 

#define OPTION_FLD	400
#define SORTOP1		600
#define SORTOP2		700
#define MESG_FLD	1600

#define EXIT	12
#define CONTINUE	10

#ifdef ENGLISH
#define PROCCHQ		'P'
#define EXITOPT		'E'
	
#define	YES		'Y'
#define NO		'N'
#define EDIT		'E'
#define CANCEL		'C'
#define PRINTER		'P'
#define ALPHSORT	'A'
#define NUMSORT		'N'
#define BARGSORT	'B'
#define CENTERSORT	'C'
#define POSISORT	'P'
#else
#define PAY_SYS		'P'
#define PROCCHQ		'T'
#define EXITOPT		'F'

#define	YES		'O'
#define NO		'N'
#define EDIT		'M'
#define CANCEL		'A'
#define ALPHSORT	'A'   /*translate for the FRENCH */
#define NUMSORT		'N'
#define BARGSORT	'B'
#define CENTERSORT	'C'
#define POSISORT	'P'
#endif

/*  Data items for storing the key range end values */
	
/* cheque.sth - header for C structure generated by PROFOM EDITOR */

typedef struct	{

	char	s_pgm[11];	/* STRING XXXXXXXXXX 	Field 100 */
	long	s_rundate;
	char	s_option[2]; 	/* STRING X 		Field 900 */
	char	s_sortop1[2];
	char	s_sortop2[2];
	char	s_mesg[78];	/* STRING X(78) 	Field 1500 */
	char	s_opt[2];	/* STRING X 		Field 1600 */
	} S_STRUCT;

static	S_STRUCT	s_sth ;

/* PROFOM Related variables */

struct  	stat_rec  sr;	/* PROFOM status rec */

static	Pay_param	pay_param;
static	Pa_rec	pa_rec;
static	Emp_sen	emp_sen;
static	Tmp_sen	tmp_sen;
static	Sen_par	sen_par;
static	Emp	emp_rec;
static	Tmp_Emp	tmp_emp;
static	Sch_rec	sch_rec;
static	Barg_unit barg_unit;
static	Position	position;
static  Class	class;
static	Pay_earn	pp_earn;

char 	e_mesg[180];	/* for storing error messages */

/*  Data items for storing the key range end values */

static	short	totp_years;
static	double	totp_days;
static	short	totc_years;
static	double	totc_days;

char 	e_mesg[180];	/* for storing error messages */
static int	PG_SIZE;
static int	retval;
static char 	discfile[15];	/* for storing outputfile name */
static short	pgcnt; 		/* for page count */

char	month[12][4] = { "JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG",
			"SEP", "OCT", "NOV", "DEC" };

int	Validation();
int	Window();

double 	D_Roundoff();

main(argc,argv)
int argc;
char *argv[];
{
	int err;

	err = get_param(&pa_rec, BROWSE, 1, e_mesg) ;
	if(err == ERROR) {
		DispError((char *)&s_sth,e_mesg);
		return(ERROR) ;
	}
	else if(err == UNDEF) {
#ifdef ENGLISH
		DispError((char *)&s_sth,"Parameters Are Not Set Up ...");
#else
		DispError((char *)&s_sth,"Parametres ne sont pas etablis... ");
#endif
		return(ERROR) ;
	}

	LNSZ = 133;
	strncpy(SYS_NAME,SYSTEM,50);	/* Sub system name */
	strncpy(CHNG_DATE,MOD_DATE,10);	/* Modification Date */
	proc_switch(argc, argv, TMP_SEN) ; 	/* Process Switches */

	STRCPY(sr.termnm,terminal);	/* Copy Terminal Name */

	if (Initialize()<0)
		exit(-1);		/* Initialization routine */

	if ( Process() < 0) { 		/* Initiate Process */
		exit(-1);
	}

	CloseRtn();			/* return to menu */

	exit(NOERROR);

} /* END OF MAIN */
/*----------------------------------------------------------------*/
/* Close nessary files and environment before exiting program               */

CloseRtn() 
{
	/* Set terminal back to normal mode from PROFOM */

	fomcs();
	fomrt();
	close_dbh();			/* Close files */
	close_rep();

	return(NOERROR);
}	/* CloseRtn1() */
/*-------------------------------------------------------------------*/
/* Initialize PROFOM  and Screens*/
Initialize()
{
	if(InitProfom()<0) { 			/* Initialize PROFOM */
		fomcs();
		fomrt();
		return(-1);
	}	
	if(InitScreens()<0) { 
		fomcs();
		fomrt();
		return(-1);
	}	
	return(NOERROR);
}

/*-------------------------------------------------------------------*/
/* Initialize PROFOM */

InitProfom()
{
	fomin(&sr);
	/* Check for Error */
	ret( err_chk(&sr) );

	fomcf(1,1);			/* Enable Print screen option */
	return(NOERROR);
}	/* InitProfom() */
/*----------------------------------------------------------------*/
/* Initialize screens before going to process options */
InitScreens()
{
	STRCPY(sr.scrnam,NFM_PATH);
	strcat(sr.scrnam,SCR_NAME) ;

	STRCPY(s_sth.s_pgm,PROG_NAME);
	s_sth.s_rundate = get_date();	/* get Today's Date in YYMMDD format */
	s_sth.s_mesg[0] = HV_CHAR ;
	s_sth.s_opt[0] = HV_CHAR ;

	return(NOERROR);

}	/* InitScreens() */
/*-----------------------------------------------------------------*/
InitPrinter1()
{
	char	resp[2] ;
	char	discfile[15] ;

	/* Always to Printer */
	STRCPY(resp,"P");
	discfile[0]= '\0';
	PG_SIZE = 63;

	if( opn_prnt( resp, discfile, 1, e_mesg, 1 /* spool */)<0 ){
		return(REPORT_ERR);
	}
	pgcnt = 0;		/* Page count is zero */
	LNSZ = 132;		/* line size in no. of chars */
	linecnt = PG_SIZE;	/* Page size in no. of lines */

	return(NOERROR) ;
}
/*-----------------------------------------------------------------*/
Process()
{
	int	err;

	s_sth.s_mesg[0] = HV_CHAR;
	DispMesgFld((char *)&s_sth);	
	for( ; ; ){

#ifdef ENGLISH
		fomer("P(rint), E(xit)");
#else
		fomer("I(mprimer), F(in)");
#endif
		sr.nextfld = OPTION_FLD;
		fomrf((char *)&s_sth);
		ret(err_chk(&sr));

		switch(s_sth.s_option[0]) {
		case  EXITOPT :
			return(EXIT);
		case  PROCCHQ :
			CHKACC(err,ADD,e_mesg);	
			CHKACC(err,UPDATE,e_mesg);	
			err = ChqProcess() ;
			break ;
		default :
			continue;
		}

		if(NOACCESS == err) {
			fomen(e_mesg);
			get();
		}
		if(PROFOM_ERR == err)	return(PROFOM_ERR);  /* PROFOM ERROR */
		if(DBH_ERR == err) {
			DispError((char *)&s_sth,e_mesg);
#ifdef ENGLISH
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"System Error... Iserror:",
				iserror, dberror, errno);
#else
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"Erreur du systeme... Iserror:",
				iserror, dberror, errno);
#endif
			DispError((char *)&s_sth,e_mesg);
			return(DBH_ERR); /* DBH ERROR */
		
		}
	}      /*   end of the for( ; ; )       */
}
/*-----------------------------------------------------------------*/
ChqProcess()
{
	int 	retval ;

	retval = ReadInfo() ;
	if( retval < 0 ) return(retval) ;
	if( retval == EXIT ) return(NOERROR) ;

	retval = ConfirmScreen() ;
	if( retval != YES ) 
		return(NOERROR) ;
	
	if(retval != YES) 
	return(NOERROR) ;

	if(InitPrinter1()<0) {
		return(-1);
	}	

	retval = CreateTmp();
	if( retval < 0 ) 
		return(retval) ;

	retval = PrintRep();
	if( retval < 0 ) 
		return(retval) ;

	return(NOERROR) ;
}
/*-----------------------------------------------------------------------*/
/*                                                                       */
/* Reads Cheque processing information.                                  */
ReadInfo()
{
	int 	i,retval ;

	/* In Add mode turn off dup control for key fields.
	   Other modes reverse it */
	sr.nextfld = SORTOP1;
	sr.endfld = END_FLD - 200 ;

#ifdef ENGLISH
	STRCPY(s_sth.s_mesg,"Press ESC-F to Go Back to Option:");
#else
	STRCPY(s_sth.s_mesg,"Appuyer sur ESC-F pour retourner a Option:");
#endif
	DispMesgFld((char *)&s_sth);

	SetDupBuffers(SORTOP1,END_FLD-200,1);
	s_sth.s_sortop1[0] = LV_CHAR;
	s_sth.s_sortop2[0] = LV_CHAR;

	i = ReadFields((char *)&s_sth,SORTOP1, END_FLD-200,Validation,Window,1); 
	if(PROFOM_ERR == i || DBH_ERR == i) return(i) ;
	if(EXIT == i){
		s_sth.s_mesg[0] = HV_CHAR;
		DispMesgFld((char *)&s_sth);
		return(i) ;
	}
	return(NOERROR) ;
}
/*-----------------------------------------------------------------------*/
/*                                                                       */
/* Reads the cheque and prints the cheque after accumulating invoices.   */
CreateTmp()
{
	int	retval ;

	unlink_file(TMP_EMP);

	emp_rec.em_numb[0] = '\0';

	tmp_sen.tsn_numb[0] = '\0';
	tmp_sen.tsn_month = 0;
	tmp_sen.tsn_pos[0] = '\0';
	tmp_sen.tsn_class[0] = '\0';
	flg_reset(TMP_SEN);

	for(;;) {
	  retval=get_n_tmp_sen(&tmp_sen,BROWSE,0,FORWARD,e_mesg);
	  if( retval < 0 ) {
	  	if(retval == EFL) 
			break;
		DispError((char *)&s_sth,e_mesg) ;
		return(retval) ;
	  }

	  if(strcmp(emp_rec.em_numb, tmp_sen.tsn_numb) != 0){
		strcpy(emp_rec.em_numb,tmp_sen.tsn_numb);
		retval = get_employee(&emp_rec,BROWSE,0,e_mesg);
		if(retval < 0){
			if(retval == UNDEF)	continue;	
			DispError((char *)&s_sth,e_mesg) ;
			return(-1);
		}

	  	retval=UsrBargVal(BROWSE,emp_rec.em_numb,emp_rec.em_barg,0,
									e_mesg);
	  	if(retval < 0){
			emp_rec.em_numb[0] = '\0';
			continue;
		}

		if(strcmp(emp_rec.em_status, "ACT") != 0)
			continue;

		strcpy(tmp_emp.tem_numb, emp_rec.em_numb);
		strcpy(tmp_emp.tem_last_name, emp_rec.em_last_name);
		strcpy(tmp_emp.tem_first_name, emp_rec.em_first_name);
		strcpy(tmp_emp.tem_mid_name, emp_rec.em_mid_name);
		strcpy(tmp_emp.tem_barg, emp_rec.em_barg);
		strcpy(tmp_emp.tem_pos, emp_rec.em_pos);
		tmp_emp.tem_cc = emp_rec.em_cc;

	  	retval = put_tmp_emp(&tmp_emp,ADD,e_mesg);	
	 	if(retval < 0) {
	  		DispError((char *)&s_sth,e_mesg);
	  		return(ERROR);
	  	}
		retval = commit(e_mesg);
		if(retval < 0) {
		  	DispError((char *)&s_sth,e_mesg);
		  	roll_back(e_mesg);
		  	return(ERROR);
		}
	  }
	}
	seq_over(TMP_SEN);

	return(NOERROR) ;

}
/*----------------------------------------------------------------*/
/* Validation function() for Key and Header fields when PROFOM returns
  RET_VAL_CHK */

Validation()
{
	switch(sr.curfld){
	case SORTOP1:
		if(s_sth.s_sortop1[0] != 'A' && s_sth.s_sortop1[0] != 'N') {
#ifdef ENGLISH
			fomen("Must be A(lpha), N(umeric)");
#else
			fomen("Doit etre A, N");
#endif
			s_sth.s_sortop1[0] = LV_CHAR;
		}
		break;
	case SORTOP2:
		if(s_sth.s_sortop2[0] != 'B' && s_sth.s_sortop2[0] != 'P' &&
		   s_sth.s_sortop2[0] != 'C' && s_sth.s_sortop2[0] != 'X' &&
		   s_sth.s_sortop2[0] != 'N'){
#ifdef ENGLISH
			fomen("Must be B(arg), P(osition), C(ost), X(Barg & Cost) or N(o Sortop2)");
#else
			fomen("Doit etre B, P, C, X");
#endif
			s_sth.s_sortop2[0] = LV_CHAR;
		}
		break;
	default :
#ifdef ENGLISH
		sprintf(e_mesg,"No Validity Check For Field#  %d",sr.curfld);
#else
		sprintf(e_mesg,"Pas de controle de validite pour le Champ#  %d",sr.curfld);
#endif
		fomen(e_mesg);
		get();
		return(ERROR) ;
	}	/* Switch sr.curfld */

	return(NOERROR) ;
}	/* Validation() */
/*----------------------------------------------------------------*/
Window()
{
	return(NOERROR);
}
/*-----------------------------------------------------------------------*/
/*                                                                       */
ConfirmScreen() 
{
	int	err ;

	for( ; ; ) {
#ifdef ENGLISH
		err = GetOption((char *)&s_sth,"Y(es), E(dit), C(ancel)", "YEC");
#else
		err = GetOption((char *)&s_sth,"O(ui), M(odifier), A(nnuler)",
									 "OMA");
#endif
		if(err == PROFOM_ERR) return(err) ;

		switch(err) {
		case  YES :
			return(YES) ;
		case  EDIT  :
			err = ReadInfo();
			break ;
		case  CANCEL :
#ifdef ENGLISH
			err = GetOption((char *)&s_sth,"Confirm the Cancel (Y/N)?", "YN") ;
#else
			err = GetOption((char *)&s_sth,"Confirmer l'annulation (O/N)?", "ON") ;
#endif
			if(err == YES) { 
				roll_back(e_mesg) ;	/* Unlock  Records */
				return(CANCEL) ;
			}
			break ;
		}	/* switch err */

		if(err == PROFOM_ERR) return(err) ;
		if(err == DBH_ERR) return(err) ;
	}	/* for(; ; ) */
}	/* ConfirmScreen() */

Confirm()
{
	return(0);
}
/*----------------------------------------------------------------*/
/* Set Duplication buffers for fields 				  */
SetDupBuffers( firstfld, lastfld, value )
int	firstfld, lastfld;	/* field numbers range */
int	value;			/* ENABLE or DISABLE */
{
	int i ;

	for( i=firstfld; i<=lastfld; i+=100 )
		fomca1( i, 19, value);
	if( value==0 )
		return(0);
	sr.nextfld = firstfld;
	sr.endfld = lastfld;
	fomud( (char *)&s_sth );
	ret( err_chk(&sr) );

	return( 0 );
}
/******************************************************************************
Main logic of the program
******************************************************************************/
static
PrintRep()
{
	char	old_position[7];
	int	err;
	int	first_time;
	int 	retval;
	int	key_no;

 	retval = get_pay_param(&pay_param,BROWSE,1,e_mesg);
	if(retval < 0) {
  		fomen(e_mesg);
		return(retval);
	}

	if(s_sth.s_sortop1[0] == 'N'){
		if(s_sth.s_sortop2[0] == 'B') key_no = 1;
		else if(s_sth.s_sortop2[0] == 'P') key_no = 3;
		else if(s_sth.s_sortop2[0] == 'C') key_no = 5;
		else if(s_sth.s_sortop2[0] == 'X') key_no = 8;
		else if(s_sth.s_sortop2[0] == 'N') key_no = 0;
	}
	else if(s_sth.s_sortop1[0] == 'A'){
		if(s_sth.s_sortop2[0] == 'B') key_no = 2;
		else if(s_sth.s_sortop2[0] == 'P') key_no = 4;
		else if(s_sth.s_sortop2[0] == 'C') key_no = 6;
		else if(s_sth.s_sortop2[0] == 'X') key_no = 9;
		else if(s_sth.s_sortop2[0] == 'N') key_no = 7;
	}

	tmp_emp.tem_numb[0] = '\0';
	tmp_emp.tem_barg[0] = '\0';
	tmp_emp.tem_pos[0] = '\0';
	tmp_emp.tem_last_name[0] = '\0';
	tmp_emp.tem_first_name[0] = '\0';
	tmp_emp.tem_mid_name[0] = '\0';
	tmp_emp.tem_cc = 0;
	flg_reset(TMP_EMP);

	for( ; ; ){
		retval = get_n_tmp_emp(&tmp_emp,BROWSE,key_no,FORWARD,e_mesg) ;
		if( retval < 0 ) {
	  		if(retval == EFL) 
				break;
			DispError((char *)&s_sth,e_mesg) ;
			return(retval) ;
	  	}
		totp_years = 0;
		totp_days = 0;
		totc_years = 0;
		totc_days = 0;

		strcpy(emp_rec.em_numb,tmp_emp.tem_numb);
		retval = get_employee(&emp_rec,BROWSE,0,e_mesg);
		if(retval < 0){
			if(retval == UNDEF)	continue;
			DispError((char *)&s_sth,e_mesg) ;
			return(-1);
		}
	  	retval=UsrBargVal(BROWSE,emp_rec.em_numb,emp_rec.em_barg,0,
									e_mesg);
	  	if(retval < 0)
			continue;

		sprintf(e_mesg,"Employee # : %s",emp_rec.em_numb);
		fomen(e_mesg);
		fflush(stdout);

		totp_years = emp_rec.em_per_tot_yrs;
		totp_days = emp_rec.em_per_tot_days;

		totc_years = emp_rec.em_cas_tot_yrs;
		totc_days = emp_rec.em_cas_tot_days;

		strcpy(emp_sen.esn_numb, emp_rec.em_numb);
		emp_sen.esn_month = 0;
		emp_sen.esn_pos[0] = '\0';
		emp_sen.esn_class[0] = '\0';
		flg_reset(EMP_SEN);

		old_position[0] = '\0';

		first_time = 0;
		for(;;){

			retval = get_n_emp_sen(&emp_sen, BROWSE, 0, FORWARD, 
				e_mesg);

			if( retval == EFL ||		
			  ( strcmp(emp_sen.esn_numb, emp_rec.em_numb) != 0))
				break;

			if(retval < 0) {
				fomen(e_mesg);
				get();
				return(-1);
			}

			if(strcmp(old_position,emp_sen.esn_pos) != 0) {

				strcpy(sen_par.sn_position,emp_sen.esn_pos);
				sen_par.sn_eff_date = get_date();

				flg_reset(SEN_PAR);

				err = get_n_sen_par(&sen_par,BROWSE,0,BACKWARD,
					e_mesg);
				if(err == EFL) {
					fomen("Seniority Parameter Record Not Setup");
					return(err);
				}
				if(err < 0) {
					fomen(e_mesg) ;
					get();
					return(ERROR) ;
				}

				strcpy(old_position,emp_sen.esn_pos);
			}

			totp_days += emp_sen.esn_perm_days;

			if(totp_days > sen_par.sn_max_days_yr) {
				totp_years ++;
				totp_days -= sen_par.sn_max_days_yr;
			}

			totc_days += emp_sen.esn_cas_totd;

			if(totc_days > sen_par.sn_max_days_yr) {
				totc_years ++;
				totc_days -= sen_par.sn_max_days_yr;
			}
		}
		seq_over(EMP_SEN);

		old_position[0] = '\0';

		strcpy(tmp_sen.tsn_numb,emp_rec.em_numb);
		tmp_sen.tsn_month = 0;
		tmp_sen.tsn_pos[0] = '\0';
		tmp_sen.tsn_class[0] = '\0';
		flg_reset(TMP_SEN);

		for(;;) {
			retval=get_n_tmp_sen(&tmp_sen,BROWSE,0,FORWARD,e_mesg);

			if(retval == EFL || strcmp(tmp_sen.tsn_numb,
			   emp_rec.em_numb) != 0){
				break;
			}
			if(first_time == 0) {
				if((retval = PrntInit())<0 )
					return(retval);
				first_time = 1;
			}

			if(strcmp(old_position,tmp_sen.tsn_pos) != 0) {

				strcpy(sen_par.sn_position,tmp_sen.tsn_pos);
				sen_par.sn_eff_date = get_date();

				flg_reset(SEN_PAR);

				err = get_n_sen_par(&sen_par,BROWSE,0,BACKWARD,
					e_mesg);
				if(err == EFL) {
					fomen("Seniority Parameter Record Not Setup");
					return(err);
				}
				if(err < 0) {
					fomen(e_mesg) ;
					get();
					return(ERROR) ;
				}

				strcpy(old_position,tmp_sen.tsn_pos);
			}

			if((retval = PrntTmpSen())<0 )
				return(retval);
		}
		seq_over(TMP_SEN);
	}

	seq_over(EMPLOYEE);

	if(pgcnt) {
		if(term < 99) 
			last_page();	
#ifndef	SPOOLER
		else
			rite_top();
#endif
	}

	return(NOERROR);
}
/******************************************************************************
Prints the headings of the report GROSS EARNINGS FOR PAY PERIOD
******************************************************************************/
static
PrntHdg()	/* Print heading  */
{
	short	offset;
	long	sysdt ;
	char	txt_buff[132];

	if( pgcnt && term < 99)   /* new page and display */
		if(next_page()<0) return(EXIT);	
		
	if( pgcnt || term < 99) { /* if not the first page or display */
		if( rite_top()<0 ) return( -1 );	/* form_feed */
	}
	else
		linecnt = 0;
	pgcnt++; 			/* increment page no */

	mkln( 1, PROG_NAME, 10 );
#ifdef ENGLISH
	mkln( 103, "Date:", 5 );
#else
	mkln( 103, "Date:", 5 );
#endif
	sysdt = get_date() ;
	tedit( (char *)&sysdt,"____/__/__",line+cur_pos, R_LONG ); 
	cur_pos += 10;

#ifdef ENGLISH
	mkln( 122, "PAGE:", 5 );
#else
	mkln( 122, "PAGE:", 5 );
#endif
	tedit( (char *)&pgcnt,"__0_",  line+cur_pos, R_SHORT ); 
	cur_pos += 4;
	if( prnt_line()<0 )	return(REPORT_ERR);

	offset = ( LNSZ-strlen(pa_rec.pa_co_name) )/2;
	mkln( offset, pa_rec.pa_co_name, strlen(pa_rec.pa_co_name) );
	if( prnt_line()<0 )	return(REPORT_ERR);

#ifdef ENGLISH
	mkln((LNSZ-29)/2,"END OF PAY PERIOD AUDIT TRAIL", 29 );
#else
	mkln((LNSZ-32)/2,"PAY PERIOD SENIORITY AUDIT TRAIL", 32 );
#endif
	if( prnt_line()<0 )	return(REPORT_ERR);
	if( prnt_line()<0 )	return(REPORT_ERR);

	mkln(60,"CASUAL",6);
	mkln(79,"PERM",4);
	mkln(90,"CASUAL",6);
	mkln(102,"PERM TOTAL",10);
	mkln(118,"CASUAL TOTAL",12);
	
	if( prnt_line()<0 )	return(REPORT_ERR);

	mkln(55,"HOURS",5);
	mkln(67,"DAYS",4);
	mkln(79,"DAYS",4);
	mkln(89,"TOT DAYS",8);
	mkln(101,"YEARS",5);
	mkln(109,"DAYS",4);
	mkln(117,"YEARS",5);
	mkln(126,"DAYS",4);

	if( prnt_line()<0 )	return(REPORT_ERR);

	return(NOERROR);
}
/******************************************************************************
Prints the detail line for employee schedule file
******************************************************************************/
static
PrntTmpSen()
{
	int	retval;
	char	txt_buff[132], tmp_month[4];
	double	vac_acc, sick_acc, cas_hrs, cas_days, perm_days, cas_totd;

	if(linecnt >= PG_SIZE) {
		if((retval = PrntHdg())<0 )
			return(retval);
		if( retval == EXIT )	return(EXIT);
		if((retval = PrntInit())<0 )
			return(retval);
	}

	if(tmp_sen.tsn_month == 1)
		strcpy(tmp_month,month[tmp_sen.tsn_month-1+11]);
	else
		strcpy(tmp_month,month[tmp_sen.tsn_month-2]);

	mkln(1,tmp_month,3);		
	mkln(9,"Vac. Acc:",9);
	vac_acc = tmp_sen.tsn_vac_acc0;
	tedit((char *)&vac_acc,"_0_.__",txt_buff,R_DOUBLE);
	mkln(20,txt_buff,6);

	mkln(29,"Sick Acc:",9);
	sick_acc = tmp_sen.tsn_sick_acc0;
	tedit((char *)&sick_acc,"_0_.__",txt_buff,R_DOUBLE);
	mkln(44,txt_buff,6);

	cas_hrs = tmp_sen.tsn_cas_hrs0;
	tedit((char *)&cas_hrs,"__0_.__",txt_buff,R_DOUBLE);
	mkln(54,txt_buff,7);
	cas_days = tmp_sen.tsn_cas_days0;
	tedit((char *)&cas_days,"__0_.__",txt_buff,R_DOUBLE);
	mkln(66,txt_buff,7);
	perm_days = tmp_sen.tsn_perm_days0;
	tedit((char *)&perm_days,"__0_.__",txt_buff,R_DOUBLE);
	mkln(78,txt_buff,7);
	cas_totd = tmp_sen.tsn_cas_totd0;
	tedit((char *)&cas_totd,"__0_.__",txt_buff,R_DOUBLE);
	mkln(90,txt_buff,7);

	totp_days += perm_days;
	totc_days += cas_totd;

	if(totp_days > sen_par.sn_max_days_yr) {
		totp_years ++;
		totp_days -= sen_par.sn_max_days_yr;
	}
	if(totc_days > sen_par.sn_max_days_yr) {
		totc_years ++;
		totc_days -= sen_par.sn_max_days_yr;
	}

	tedit((char *)&totp_years,"0_",txt_buff,R_SHORT);
	mkln(102,txt_buff,2);
	tedit((char *)&totp_days,"__0_.__",txt_buff,R_DOUBLE);
	mkln(108,txt_buff,7);
	tedit((char *)&totc_years,"0_",txt_buff,R_SHORT);
	mkln(119,txt_buff,2);
	tedit((char *)&totc_days,"__0_.__",txt_buff,R_DOUBLE);
	mkln(125,txt_buff,7);

	retval = prnt_line();
	if( retval < 0 )	return(REPORT_ERR);

	strcpy(tmp_month,month[tmp_sen.tsn_month-1]);

	mkln(1,tmp_month,3);		
	mkln(9,"Vac. Acc:",9);
	vac_acc = tmp_sen.tsn_vac_acc1;
	tedit((char *)&vac_acc,"_0_.__",txt_buff,R_DOUBLE);
	mkln(20,txt_buff,6);

	mkln(29,"Sick Acc:",9);
	sick_acc = tmp_sen.tsn_sick_acc1;
	tedit((char *)&sick_acc,"_0_.__",txt_buff,R_DOUBLE);
	mkln(44,txt_buff,6);

	cas_hrs = tmp_sen.tsn_cas_hrs1;
	tedit((char *)&cas_hrs,"__0_.__",txt_buff,R_DOUBLE);
	mkln(54,txt_buff,7);
	cas_days = tmp_sen.tsn_cas_days1;
	tedit((char *)&cas_days,"__0_.__",txt_buff,R_DOUBLE);
	mkln(66,txt_buff,7);
	perm_days = tmp_sen.tsn_perm_days1;
	tedit((char *)&perm_days,"__0_.__",txt_buff,R_DOUBLE);
	mkln(78,txt_buff,7);
	cas_totd = tmp_sen.tsn_cas_totd1;
	tedit((char *)&cas_totd,"__0_.__",txt_buff,R_DOUBLE);
	mkln(90,txt_buff,7);

	totp_days += perm_days;
	totc_days += cas_totd;

	if(totp_days > sen_par.sn_max_days_yr) {
		totp_years ++;
		totp_days -= sen_par.sn_max_days_yr;
	}
	if(totc_days > sen_par.sn_max_days_yr) {
		totc_years ++;
		totc_days -= sen_par.sn_max_days_yr;
	}

	tedit((char *)&totp_years,"0_",txt_buff,R_SHORT);
	mkln(102,txt_buff,2);
	tedit((char *)&totp_days,"__0_.__",txt_buff,R_DOUBLE);
	mkln(108,txt_buff,7);
	tedit((char *)&totc_years,"0_",txt_buff,R_SHORT);
	mkln(119,txt_buff,2);
	tedit((char *)&totc_days,"__0_.__",txt_buff,R_DOUBLE);
	mkln(125,txt_buff,7);

	retval = prnt_line();
	if( retval < 0 )	return(REPORT_ERR);

	return(NOERROR);
}
/******************************************************************************
Prints the detail line for employee schedule file
******************************************************************************/
static
PrntInit()
{
	char	txt_buff[132];
	int	retval;
	char	emp_name[31];

	if(linecnt >= (PG_SIZE-1)) {
		if((retval = PrntHdg())<0 )
			return(retval);
		if( retval == EXIT )	return(EXIT);
	}

	retval = prnt_line();
	if( retval < 0 )	return(REPORT_ERR);

	if((retval = PrntDetl())<0 )
		return(retval);

	tedit((char *)&totp_years,"0_",txt_buff,R_SHORT);
	mkln(102,txt_buff,2);
	tedit((char *)&totp_days,"__0_.__",txt_buff,R_DOUBLE);
	mkln(108,txt_buff,7);
	tedit((char *)&totc_years,"0_",txt_buff,R_SHORT);
	mkln(119,txt_buff,2);
	tedit((char *)&totc_days,"__0_.__",txt_buff,R_DOUBLE);
	mkln(125,txt_buff,7);

	retval = prnt_line();
	if( retval < 0 )	return(REPORT_ERR);

	return(NOERROR);
}
/******************************************************************************
Function that prints the employee details headings.  These headings include the
employee's number, name, bargaining unit, bargaining unit name, cost center
and cost center name.  This detail heading will be printed at the top of
every page.                                                      
******************************************************************************/
static
PrntDetl()
{
	char txt_buff[132];
	long sysdate = 0;
	double tot_earn = 0;
	int	retval;
	
	strcpy(barg_unit.b_code,tmp_emp.tem_barg);
	barg_unit.b_date = get_date();
	
	flg_reset(BARG);

	for(;;) {

		retval = get_n_barg(&barg_unit,BROWSE,0,BACKWARD,e_mesg);
		if(strcmp(barg_unit.b_code,emp_rec.em_barg) == 0) {
			break;
		}
		else { 
			if (retval < 0 || retval == EFL){
	 			fomen(e_mesg);
				get();
				roll_back(e_mesg);
				return(-1);	
			}
		}
	}
	seq_over(BARG);	

	mkln(1,"Employee Number:",16);
	mkln(18,tmp_emp.tem_numb,12);
	mkln(32,"Name:",5);
	sprintf(txt_buff,"%s %s",tmp_emp.tem_first_name,tmp_emp.tem_last_name);
	mkln(38,txt_buff,42);

	retval = prnt_line();
	if( retval < 0 )	return(REPORT_ERR);

	mkln(1,"Bargaining Unit:",16);
	mkln(18,tmp_emp.tem_barg,6);
	mkln(32,"Desc:",5);
	mkln(38,barg_unit.b_name,30);
	
	retval = prnt_line();
	if( retval < 0 )	return(REPORT_ERR);

	retval = GetClass(emp_rec.em_class);

	mkln(1,"Classification :",16);
	mkln(18,emp_rec.em_class,6);
	mkln(32,"Desc:",5);
	mkln(38,class.c_desc,30);
	retval = prnt_line();
	if( retval < 0 )	return(REPORT_ERR);

	retval = GetPos(emp_rec.em_pos);

	mkln(1,"Position       :",16);
	mkln(18,emp_rec.em_pos,6);
	mkln(32,"Desc:",5);
	mkln(38,position.p_desc,30);
	retval = prnt_line();
	if( retval < 0 )	return(REPORT_ERR);

	mkln(1,"Percentage     :",16);
	tedit( (char *)&emp_rec.em_perc,"_0_.____",txt_buff,R_DOUBLE);
  	mkln(18,txt_buff,8);

	return(NOERROR);
}
/*-----------------------------------------------------------------------*/
GetPos(pos)
char	*pos;
{
	int	retval;

	strcpy(position.p_code,pos);

	retval = get_position(&position,BROWSE,0,e_mesg);
	if(retval < 0) {
		DispError((char *)&s_sth,e_mesg);
	}

	return(NOERROR);
}
/*--------------------------------------------------------------*/
GetClass(class_rec)
char	*class_rec;
{
	int	retval;

	strcpy(class.c_code,class_rec);
	class.c_date = s_sth.s_rundate;
	flg_reset(CLASSIFICATION);

	retval = get_n_class(&class,BROWSE,0,BACKWARD,e_mesg);
	if(retval < 0 && retval != EFL){
		DispError((char *)&s_sth, e_mesg);
		return(NOERROR);
	}
	if((strcmp(class.c_code,class_rec) != 0) || retval == EFL){
		sprintf(e_mesg,"Classification Code Does Not Exist %s",class_rec);
		DispError((char *)&s_sth, e_mesg);
	    	return(NOERROR);
	}
	seq_over(CLASSIFICATION);
	return(NOERROR);
}
/******************   END OF PROGRAM *******************************/

