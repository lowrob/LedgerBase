/*------------------------------------------------------------------------
Source Name: roe_sel.c
System     : Personnel/Payroll System.
Created  On: February 4th, 1993.
Created  By: m. galvin.

DESCRIPTION:
	Program to individually select employee's to receive ROE's.

MODIFICATIONS:        

Programmer     YY/MM/DD       Description of modification
~~~~~~~~~~     ~~~~~~~~       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
------------------------------------------------------------------------*/

#define	MAIN		/* Main program. This is to declare Switches */

#define	SYSTEM		"ROE SELECTION"	/* Sub System Name */
#define	MOD_DATE	"04-FEB-93"		/* Program Last Modified */

#include <stdio.h>
#include <cfomstrc.h>
#include <bfs_defs.h>
#include <bfs_com.h>
#include <bfs_pp.h>

#define EXIT	   	12

/* User Interface define constants */
#ifdef ENGLISH
#define SELECT		'S'
#define EXITOPT		'E'

#define	YES		'Y'
#define NO		'N'
#define	EDIT		'E'
#define	CANCEL		'C'
#else
#define SELECT		'C'
#define EXITOPT		'F'

#define	YES		'O'
#define NO		'N'
#define	EDIT		'M'

#define	CANCEL		'A'
#endif

/* PROFOM Releted declarations */

#define	SCR_NAME	"roe_sel"	/* PROFOM screen Name */

/* Field PROFOM numbers */
#define START_FLD 	400	/* Start Field in range */
#define	END_FLD		2300	/* Last Field of the screen */

#define	STEP		100

#define EMP_FLD		400	/* Employee Number */
#define NAME_FLD	500	/* Employee Name */
#define FIRST_DT	600	/* Employee's First Day */
#define TERM_FLD	1000	/* Termination Code */	
#define TERM_DESC	1100	/* Termination Description */	
#define OPTION		2000	/* Option response field */
#define MESSAGE		2100	/* Message Field */
#define RESPONSE	2200	/* Response Field */

/* roe_sel.sth - header for C structure generated by PROFOM EDITOR */

typedef struct	{

	char	s_pgm[11];	/* 100 program name */
	long	s_rundate;	/* 300 run date */
	char	s_emp[13];	/* 400 employee # */
	char	s_emp_name[31]; /* 500 employee name */
	long	s_first_date;	/* 600 first day of work */
	long	s_last_date;	/* 700 last day of work */
	long	s_uic_predt;	/* 800 uic premium payable up to */
	long	s_recall_dt;	/* 900 expected date of recall date */
	char	s_roe_cd[3];	/* 1000 term. code */
	char	s_roe_desc[31];	/* 1100 term. desc */ 
	char	s_contact[31];	/* 1200 contact name */
	char	s_ctct_tel[11];	/* 1300 contact tel */
	char	s_issuer[31];	/* 1400 issuer name */
	char	s_iss_tel[11];	/* 1500 issuer tel */
	char	s_comm1[31];	/* 1600 roe comments */
	char	s_comm2[31];	/* 1700 roe comments */
	char	s_comm3[31];	/* 1800 roe comments */
	char	s_comm4[31];	/* 1900 roe comments */
	char	s_option[2];	/* 2000 option choice */
	char	s_mesg[78];	/* 2100 message field */
	char	s_resp[2];	/* 2200 response field */

	} S_STRUCT;


S_STRUCT	s_sth;	/* PROFOM Screen Structure */
static	struct  stat_rec  sr;		/* PROFOM status rec */

/* File structures */
static	Roe		roe;
static	Sen_par		sen_par;
static	Time		time;
static	Time_his	time_his;
static	Position	position;
static	Barg_unit	barg_unit;
static	Uic		uic_table;
static	Pay_per_it	pay_per_it;
static	Emp		emp_rec;
static	Emp_earn	emp_earn;
static	Term		term;
static	Pay_per		pay_period;

static	char 	e_mesg[100];  		/* dbh will return err msg in this */

static	double	tot_units[5];
static	double	tot_income[5];
static	double	wk_flg[5];
static	double	accum_wks_min_earn, accum_wks_min_hrs, accum_wks_max_earn,
		accum_wks_yrly_earn;
static	double	one_wks_min_earn, one_wks_min_hrs, one_wks_max_earn,
		total_uic;
static	int	k,first_time;
static	int	done,all_wks_max;

static int	day, mth, year;
static long	first_day;
static long	last_day;
static long	start_mth;
static long	start_date;

static short d_month[12] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };

short	nbr_ins_wks;
double	hrs_unit; 

extern	double	D_Roundoff();

static	Validation();
static	WindowHelp();

main(argc,argv)
int argc;
char *argv[];
{
	int 	retval;

	retval = Initialize(argc,argv);	/* Initialization routine */

	if (retval == NOERROR) retval = Process();

	CloseRtn();			/* return to menu */
	if (retval != NOERROR) exit(1);
	exit(0);
}

/*-------------------------------------------------------------------*/
/* Initialize PROFOM */

Initialize(argc, argv)
int	argc ;
char	*argv[] ;
{
	int	err ;

	/*
	*	Initialize DBH Environment
	*/
	strncpy(SYS_NAME,SYSTEM,50);	/* Sub system name */
	strncpy(CHNG_DATE,MOD_DATE,10);	/* Modification Date */

	proc_switch(argc, argv) ; 	/* Process Switches */

	/*
	*	Initialize PROFOM & Screen
	*/
	STRCPY(sr.termnm,terminal);	/* Copy Terminal Name */
	fomin(&sr);
	ret(err_chk(&sr)) ;		/* Check for PROFOM Error */
	fomcf(1,1);			/* Enable Snap screen option */

	err = InitScreen() ;		/* Initialize Screen */
	if(NOERROR != err) return(err) ;

	return(NOERROR) ;
}	/* Initialize() */

/*--------------------------------------------------------------------------*/
/* Close necessary files and environment before exiting program               */

CloseRtn() 
{
	/* Set terminal back to normal mode from PROFOM */
	fomcs();
	fomrt();

	close_dbh();	/* Close files */

	return(NOERROR);
}	/* CloseRtn() */
/*----------------------------------------------------------------*/
/* Initialize screen before going to process options */

InitScreen()
{
	/* move screen name to Profom status structure */
	STRCPY(sr.scrnam,NFM_PATH);
	strcat(sr.scrnam,SCR_NAME) ;

	STRCPY(s_sth.s_pgm,PROG_NAME);
	s_sth.s_rundate = get_date();	/* get Today's Date in YYYYMMDD format*/
	s_sth.s_option[0] = HV_CHAR;
	s_sth.s_mesg[0] = HV_CHAR ;
	s_sth.s_resp[0] = HV_CHAR ;

	/* Move Low Values to data fields */
	InitFields() ;

	return(NOERROR) ;
}	/* InitScreen() */

/*-------------------------------------------------------------------*/
/* Get Option from user and call corresponding function */

Process()
{
	int	err;

	for( ; ; ){

		if((err = ReadOption())<0) 
			return(err);

		switch(s_sth.s_option[0]) {
		case  EXITOPT :
			return(NOERROR);
		case  SELECT :
			CHKACC(err,ADD,e_mesg);
			err = ProcOption() ;
			break ;
		default :
			continue;
		}

		if(NOACCESS == err)	fomen(e_mesg);
		if(PROFOM_ERR == err)	return(PROFOM_ERR);  /* PROFOM ERROR */
		if(DBH_ERR == err) {
			DispError((char *)&s_sth,e_mesg);
#ifdef ENGLISH
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"System Error... Iserror:",
				iserror, dberror, errno);
#else
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"Erreur du systeme... Iserror:",
				iserror, dberror, errno);
#endif
			DispError((char *)&s_sth,e_mesg);
			return(DBH_ERR); /* DBH ERROR */
		
		}
	}      /*   end of the for( ; ; )       */
}	/* Process() */
/*------------------------------------------------------------*/
ReadOption()
{

	s_sth.s_mesg[0] = HV_CHAR;
	DispMesgFld((char *)&s_sth);	
#ifdef ENGLISH
	fomer("S(elect), E(xit)");
#else
	fomer("C(hoisir), F(in)");
#endif
	sr.nextfld = OPTION;
	fomrf((char *)&s_sth);
	ret(err_chk(&sr));

}	/* ReadOption */
/*------------------------------------------------------------*/
ProcOption()
{
	int	i, err ;

	for(i = START_FLD ; i <= END_FLD - 200 ; i += 100)
		fomca1(i, 19, 0) ;    /* disable dup control */

	err = ReadRange(ADD) ;
	if(err != NOERROR) return(err) ;

	err = Confirm() ;
	if(err != YES) return(NOERROR) ;

	err = ProcRoeSel() ;

	return(NOERROR);
}	/* ProcSelection() */
/*------------------------------------------------------------*/
/* Get the Header details from user */

ReadRange(mode)
int	mode ;
{
	int	 i;

	if(mode == ADD) {
#ifdef ENGLISH
		STRCPY(s_sth.s_mesg,"Press ESC-F to Go to Option:");
#else
		STRCPY(s_sth.s_mesg,"Appuyer sur ESC-F pour retourner a Option:");
#endif
		DispMesgFld((char *)&s_sth);

/* 		sr.nextfld = BARG1 ;
		sr.endfld = END_FLD - 300 ;
		fomud((char*)&s_sth);
		ret(err_chk(&sr)); */
	}
	InitFields() ;

	i = ReadFields((char *)&s_sth,START_FLD, END_FLD - 200,
			Validation, WindowHelp, 1) ;
	if(PROFOM_ERR == i || DBH_ERR == i) return(i) ;
	if(RET_USER_ESC == i) {	/* ESC-F */
		return(RET_USER_ESC) ;
	}

	return(NOERROR) ;
}	/* ReadRange() */
/*----------------------------------------------------------------*/
/* Validation function() for Key and Header fields when PROFOM returns
  RET_VAL_CHK */

static
Validation()
{
	int	retval;

	switch(sr.curfld){
	case EMP_FLD:
		Right_Justify_Numeric(s_sth.s_emp,
			sizeof(s_sth.s_emp)-1);
		ret( WriteFields((char *)&s_sth,EMP_FLD, EMP_FLD) ) ;

		if(s_sth.s_emp[0] == '\0'){
			s_sth.s_emp[0] = LV_CHAR;
			return(-1);
		}
		strcpy(emp_rec.em_numb,s_sth.s_emp);
		retval = get_employee(&emp_rec,BROWSE,0,e_mesg);

		if(retval < 0){
			DispError((char *)&s_sth,e_mesg);
		  	s_sth.s_emp[0] = LV_CHAR;
			return(-1);
		}
		strcpy(roe.ro_emp_numb, emp_rec.em_numb);

		retval = get_roe(&roe,BROWSE,0,e_mesg);
		if(retval < 0 && retval != UNDEF) {
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}
		if(retval == NOERROR){
			s_sth.s_emp[0] = LV_CHAR;
			fomer("Employee Already Selected");
			return(retval);
		}

		retval = UsrBargVal(UPDATE,emp_rec.em_numb,emp_rec.em_barg,1,
								e_mesg);
		if(retval < 0){
			DispError((char *)&s_sth,e_mesg);
		  	s_sth.s_emp[0] = LV_CHAR;
			return(-1);
		}
		strcpy(e_mesg,emp_rec.em_last_name);
		strcat(e_mesg,", ");
		strcat(e_mesg,emp_rec.em_first_name);
		strncpy(s_sth.s_emp_name,e_mesg,30);

		retval = WriteFields((char *)&s_sth,EMP_FLD,NAME_FLD);
		if(retval < 0) return(retval);

		break;

	case TERM_FLD:
		strcpy(term.t_code,s_sth.s_roe_cd);

		retval = get_pterm(&term,BROWSE,0,e_mesg);
		if(retval < 0) {
			DispError((char *)&s_sth,"Error Reading Termination File");
			s_sth.s_roe_cd[0] = LV_CHAR;
			return(ERROR);
		}
		strcpy(e_mesg,term.t_desc);
		strncpy(s_sth.s_roe_desc,e_mesg,30);

		retval = WriteFields((char *)&s_sth,TERM_FLD,TERM_DESC);
		if(retval < 0) return(retval);
		break;
	default :
#ifdef ENGLISH
		sprintf(e_mesg,"No Validity Check For Field#  %d",sr.curfld);
#else
		sprintf(e_mesg,"Pas de controle de validite pour le Champ#  %d",sr.curfld);
#endif
		fomen(e_mesg);
		get();
		return(ERROR) ;
	}	/* Switch sr.curfld */

	return(NOERROR) ;
}	/* Validation() */
/*----------------------------------------------------------------*/
/* Show Help Windows, if applicable, when user gives ESC-H in key
   and header fields */

static
WindowHelp()
{
	int	retval ;
	int	fld_no;

	fld_no = sr.curfld;

	switch(fld_no){
	case EMP_FLD:
		retval = emp_hlp(s_sth.s_emp,7,13);
		if(retval == DBH_ERR) return(retval);
		if(retval >= 0) redraw();
		if(retval == 0) return(ERROR);
		if(retval < 0) return(ERROR);
		strcpy(emp_rec.em_numb,s_sth.s_emp);
		retval = get_employee(&emp_rec,BROWSE,0,e_mesg);
		if(retval < 0)  {
			DispError((char *)&s_sth,e_mesg);
		  	s_sth.s_emp[0] = LV_CHAR;
			return(-1);
		}

		strcpy(roe.ro_emp_numb, emp_rec.em_numb);

		retval = get_roe(&roe,BROWSE,0,e_mesg);
		if(retval < 0 && retval != UNDEF) {
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}
		if(retval == NOERROR){
		  	s_sth.s_emp[0] = LV_CHAR;
			fomer("Employee Already Selected");
			return(retval);
		}

		retval = UsrBargVal(UPDATE,emp_rec.em_numb,emp_rec.em_barg,1,
								e_mesg);
		if(retval < 0){
			DispError((char *)&s_sth,e_mesg);
		  	s_sth.s_emp[0] = LV_CHAR;
			return(-1);
		}
		strcpy(e_mesg,emp_rec.em_last_name);
		strcat(e_mesg,", ");
		strcat(e_mesg,emp_rec.em_first_name);
		strncpy(s_sth.s_emp_name,e_mesg,30);

		retval = WriteFields((char *)&s_sth,EMP_FLD,NAME_FLD);
		if(retval < 0) return(retval);

		break;

	case TERM_FLD :
		retval = term_hlp( s_sth.s_roe_cd, 7,13);
		if (retval == DBH_ERR) return(retval);
		if (retval >= 0) redraw();
		if (retval < 1) return(ERROR);

		strcpy(term.t_code,s_sth.s_roe_cd);

		retval = get_pterm(&term,BROWSE,0,e_mesg);
		if(retval < 0) {
			DispError((char *)&s_sth,"Error Reading Termination File");
			s_sth.s_roe_cd[0] = LV_CHAR;
			return(ERROR);
		}
		strcpy(e_mesg,term.t_desc);
		strncpy(s_sth.s_roe_desc,e_mesg,30);

		retval = WriteFields((char *)&s_sth,TERM_FLD,TERM_DESC);
		if(retval < 0) return(retval);

		break;
	default :
		fomer("No Help Window for This Field");
	}	/* Switch sr.curfld */

	return(NOERROR) ;
}	/* HdrAndKeyWindowHelp() */
/*-----------------------------------------------------------------------*/
/* Take the confirmation from user for the header part */

Confirm()
{
	int	err ;

	for( ; ; ) {
#ifdef ENGLISH
		err = GetOption((char *)&s_sth,"Y(es), E(dit), C(ancel)", "YEC");
#else
		err = GetOption((char *)&s_sth,"O(ui), M(odifier), A(nnuler)", "OMA");
#endif
		if(err == PROFOM_ERR) return(err) ;

		switch(err) {
		case  YES :
			return(YES) ;
		case  EDIT  :
			err = FieldEdit();
			break ;
		case  CANCEL :
#ifdef ENGLISH
			err = GetOption((char *)&s_sth,"Confirm the Cancel (Y/N)?", "YN") ;
#else
			err = GetOption((char *)&s_sth,"Confirmer l'annulation (O/N)?", "ON") ;
#endif
			if(err == YES) { 
				roll_back(e_mesg) ;	/* Unlock  Records */
				return(CANCEL) ;
			}
			break ;
		}	/* switch err */

		if(err == PROFOM_ERR) return(err) ;
		if(err == DBH_ERR) return(err) ;
	}	/* for(; ; ) */
}	/* Confirm() */
/*-----------------------------------------------------------------------*/
/*                                                                       */
/* Changing fields. Accept fld to be changed and read that fld 		 */

FieldEdit()
{
     	int	i,retval;

     	for ( i = START_FLD; i <= END_FLD - 200 ; i += 100 )
       		fomca1( i,19,1 );      		/*  enable Dup Control */

     	sr.nextfld = START_FLD;
     	sr.endfld = END_FLD - 200;
     	fomud( (char *) &s_sth );
     	ret(err_chk(&sr));

	retval = ReadRange(UPDATE);
	if(retval != NOERROR) return(retval) ;

     	return(NOERROR);
}	/* FieldEdit() */
/*-------------------------------------------------------------------------*/
/* Initialize Screen Header with either Low Values */

InitFields()
{
	s_sth.s_emp[0] = LV_CHAR; 
	s_sth.s_first_date = LV_LONG;
	s_sth.s_last_date = LV_LONG;
	s_sth.s_uic_predt = LV_LONG;
	s_sth.s_recall_dt = LV_LONG;
	s_sth.s_roe_cd[0] = LV_CHAR;
	s_sth.s_contact[0] = LV_CHAR;
	s_sth.s_ctct_tel[0] = LV_CHAR;
	s_sth.s_issuer[0] = LV_CHAR;
	s_sth.s_iss_tel[0] = LV_CHAR;
	s_sth.s_comm1[0] = LV_CHAR;
	s_sth.s_comm2[0] = LV_CHAR;
	s_sth.s_comm3[0] = LV_CHAR;
	s_sth.s_comm4[0] = LV_CHAR;
	
	return(NOERROR) ;
}	/* InitFields() */
/*-----------------------------------------------------------------------*/
ProcRoeSel()
{
	int	retval;

	strcpy(emp_rec.em_numb, s_sth.s_emp);
	flg_reset(EMPLOYEE);

	retval = get_employee(&emp_rec,BROWSE,0,e_mesg);
	if(retval < 0) {
		DispError((char *)&s_sth,e_mesg);
		return(retval);
	}

	retval = ProcRoe();
	if(retval < 0) {
		DispError((char *)&s_sth,e_mesg);
		return(retval);
	}

	return(NOERROR) ;
}
/*----------------------------------------------------------------*/
/* Set Duplication buffers for fields 				  */
static int
SetDupBuffers( firstfld, lastfld, value )
int	firstfld, lastfld;	/* field numbers range */
int	value;			/* ENABLE or DISABLE */
{
	int i ;

	for( i=firstfld; i<=lastfld; i+=100 )
		fomca1( i, 19, value);
	if( value==0 )
		return(0);
	sr.nextfld = firstfld;
	sr.endfld = lastfld;
	fomud( (char *)&s_sth );
	ret( err_chk(&sr) );

	return( 0 );
}
/*--------------------------------------------------------------*/
ProcRoe()
{
	int	retval;

	strcpy(barg_unit.b_code,emp_rec.em_barg);
	barg_unit.b_date = get_date();
	flg_reset(BARG);

	retval = get_n_barg(&barg_unit,BROWSE,0,BACKWARD,e_mesg);
	if(retval == EFL ||
		strcmp(barg_unit.b_code, emp_rec.em_barg) != 0){
  	  DispError((char *)&s_sth,"Bargaining Unit does not Exist");
		return(ERROR);
	}
	if(retval < 0){
  		DispError((char *)&s_sth,e_mesg);
  		return(ERROR);
	}
	seq_over(BARG);

	strcpy(position.p_code,emp_rec.em_pos);

	retval = get_position(&position,BROWSE,0,e_mesg);
	if(retval < 0) {
		fomer(e_mesg);
		get();
	}

	if(strcmp(position.p_type,"FT") != 0 && 
	   strcmp(position.p_type,"PT") != 0) {
		hrs_unit = barg_unit.b_stat_hpd;

		retval = GetStatus();
		if(retval < 0)	return(retval);

		roe.ro_first_dt = first_day;
		roe.ro_last_dt = last_day;
		roe.ro_uic_prdt = s_sth.s_uic_predt;

	}
	else {
		roe.ro_first_dt = s_sth.s_first_date;
		roe.ro_last_dt = s_sth.s_last_date;
		roe.ro_uic_prdt = s_sth.s_uic_predt;

		hrs_unit = 1;
	}

	if(emp_rec.em_last_pp != 0){
	  strcpy(pay_per_it.ppi_code, barg_unit.b_pp_code);
	  pay_per_it.ppi_numb = emp_rec.em_last_pp;
	  pay_per_it.ppi_year = 9999;
	  flg_reset(PAY_PER_ITEM);

	  retval = get_n_pp_it(&pay_per_it,BROWSE,3,BACKWARD,e_mesg);
	  if(retval < 0 || strcmp(pay_per_it.ppi_code,barg_unit.b_pp_code)!=0 ||
	   pay_per_it.ppi_numb != emp_rec.em_last_pp) {
		DispError((char *)&s_sth,"Error Reading Pay Period Item File");
		return(retval);
	  }
	}
	else{
	  strcpy(pay_per_it.ppi_code, barg_unit.b_pp_code);
	  pay_per_it.ppi_st_date = roe.ro_last_dt;
	  flg_reset(PAY_PER_ITEM);

	  retval = get_n_pp_it(&pay_per_it,BROWSE,1,BACKWARD,e_mesg);
	  if(retval < 0 || strcmp(pay_per_it.ppi_code,barg_unit.b_pp_code)!=0){
		DispError((char *)&s_sth,"Error Reading Pay Period Item File");
		return(retval);
	  }
	}
	seq_over(PAY_PER_ITEM);

	roe.ro_final_dt = pay_per_it.ppi_end_date;	
	
	retval = GetEarn();
	if(retval < 0) return(retval);
	
	if(all_wks_max == 1)
		roe.ro_all_wks_max[0] = 'N';
	else
		roe.ro_all_wks_max[0] = 'Y';

	roe.ro_ret_dt = s_sth.s_recall_dt;
	if(roe.ro_ret_dt == 0)
		strcpy(roe.ro_e_n_u, "U");

	strcpy(roe.ro_reason,s_sth.s_roe_cd);
	
	strcpy(roe.ro_contact,s_sth.s_contact);
	strcpy(roe.ro_cntct_tel,s_sth.s_ctct_tel);
	strcpy(roe.ro_issuer,s_sth.s_issuer);
	strcpy(roe.ro_issuer_tel,s_sth.s_iss_tel);
	roe.ro_issue_dt = get_date();
	strcpy(roe.ro_com1,s_sth.s_comm1);
	strcpy(roe.ro_com2,s_sth.s_comm2);
	strcpy(roe.ro_com3,s_sth.s_comm3);
	strcpy(roe.ro_com4,s_sth.s_comm4);

	if(roe.ro_ins_week > 0) {
		retval = put_roe(&roe,ADD,0,e_mesg);
		if(retval < 0) {
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}
	}
	return(NOERROR);
}
/*-------------------------------------------------------------------*/
GetEarn()
{
	int 	retval, i = 0;
	short	last_pp_numb, last_pp_year, prev_pp, prev_year;
	
	done = 0;
	roe.ro_ins_week = 0;
	first_time = 0;
	all_wks_max = 0;
	total_uic = 0;
	k=0;

	/* Total hours for an employee */
	roe.ro_hours = 0;

	for(i=0;i<20;i++){
		roe.ro_ins_earn[i] = 0;
		roe.ro_ins_wks[i] = 0;
	}
	if(emp_rec.em_uic_exp[0] != 'N'){
		all_wks_max = 1;
		return(NOERROR);
	}
	for(i=0;i<5;i++){
		wk_flg[i] = 0;
		tot_units[i] = 0;
		tot_income[i] = 0;
	}
	/* get the employee's bargaining unit */		

	strcpy(barg_unit.b_code,emp_rec.em_barg);
	barg_unit.b_date = get_date();
	flg_reset(BARG);

	retval = get_n_barg(&barg_unit,BROWSE,0,BACKWARD,e_mesg);
	if(retval == EFL ||
		strcmp(barg_unit.b_code, emp_rec.em_barg) != 0){
  		DispError((char *)&s_sth,"Bargaining Unit does not Exist");
		return(NOERROR);
	}
	if(retval < 0){
  		DispError((char *)&s_sth,e_mesg);
  		return(ERROR);
	}
	seq_over(BARG);

	retval = LoadTable(get_date());
	if(retval < 0)	return(retval);

	retval = GetVac();
	if(retval < 0)	return(retval);

	strcpy(emp_earn.en_numb, emp_rec.em_numb);
	emp_earn.en_year = HV_SHORT;
	emp_earn.en_pp = HV_SHORT;
	emp_earn.en_week = HV_SHORT;
	flg_reset(EMP_EARN);

	for(;;){
		retval = get_n_emp_earn(&emp_earn, BROWSE,1,BACKWARD,e_mesg);
		if( retval < 0 && retval != EFL){
			DispError((char *)&s_sth, e_mesg);
			return(retval);
		}
		if(retval == EFL || 
		   strcmp(emp_earn.en_numb, emp_rec.em_numb) != 0){ 
			if(first_time == 0){
				all_wks_max = 1;
				return(NOERROR);
			}
			retval = Calc_Uic();
			if(retval < 0)	return(ERROR);
			break;
		}
		if(s_sth.s_first_date > emp_earn.en_date || 
		   emp_rec.em_last_roe > emp_earn.en_date){ 
			if(first_time == 0){
				all_wks_max = 1;
				return(NOERROR);
			}
			retval = Calc_Uic();
			if(retval < 0)	return(ERROR);
			break;
		}

		retval = LoadTable(emp_earn.en_date);
		if(retval < 0)	return(retval);

		/* after getting the first earnings record, find the last pay
		   period that will be included on the ROE */

		if(first_time == 0){
			last_pp_numb = emp_earn.en_pp;
			last_pp_year = emp_earn.en_year - 1;

			strcpy(pay_per_it.ppi_code,barg_unit.b_pp_code);
			pay_per_it.ppi_year = last_pp_year;
			pay_per_it.ppi_numb = last_pp_numb;

			retval=get_n_pp_it(&pay_per_it,BROWSE,0,FORWARD,e_mesg);
			if(retval < 0){ 
				DispError((char *)&s_sth,e_mesg);
				return(retval);
			}
			if(strcmp(pay_per_it.ppi_code,barg_unit.b_pp_code)!=0){
				sprintf(e_mesg,
		"Employees Pay Period %s not found in Pay Period Item file",
				barg_unit.b_pp_code);
				DispError((char *)&s_sth,e_mesg);
				return(-1);
			}

			if(roe.ro_first_dt > pay_per_it.ppi_end_date){
				strcpy(pay_per_it.ppi_code,barg_unit.b_pp_code);
				pay_per_it.ppi_st_date = roe.ro_first_dt;
				flg_reset(PAY_PER_ITEM);

				retval=get_n_pp_it(&pay_per_it,BROWSE,1, 
							BACKWARD,e_mesg);
				if(retval < 0 ||
				   strcmp(pay_per_it.ppi_code,
				          barg_unit.b_pp_code)!=0){ 
					DispError((char *)&s_sth,
					  "Error Reading Pay Period Item File");
					return(-1);
				}
				seq_over(PAY_PER_ITEM);

				last_pp_year = pay_per_it.ppi_year;
				last_pp_numb = pay_per_it.ppi_numb;
			}	
		}

		if(emp_earn.en_year < last_pp_year || 
		  (emp_earn.en_year <= last_pp_year &&
		   emp_earn.en_pp < last_pp_numb)){ 
			retval = Calc_Uic();
			if(retval < 0)	return(ERROR);
			if(first_time == 0)
				all_wks_max = 1;
		  	break; 
		}

		if((prev_pp != emp_earn.en_pp || 
		   prev_year != emp_earn.en_year) && first_time != 0) {
			retval = Calc_Uic();
			if(retval < 0)	return(ERROR);
		}	


		/* the week number will be from 1 to 5 
		   and accumulate the units and income */

		wk_flg[emp_earn.en_week - 1] = 1;
		tot_units[emp_earn.en_week-1]+=((emp_earn.en_reg_units+
	      		  	    emp_earn.en_high_units) * hrs_unit);
		tot_income[emp_earn.en_week-1]+=(emp_earn.en_reg_inc +
			       			     emp_earn.en_high_inc);
		prev_pp = emp_earn.en_pp; 
		prev_year = emp_earn.en_year;
		if(first_time == 0)
			first_time = 1;
	}
	seq_over(EMP_EARN);

	return(NOERROR);
}
/*-------------------------------------------------------------------*/
LoadTable(date)
long	date;
{
	int	retval;

	/* get the uic table for 52 weeks which will be used if the 
	   total for the pay period is not over the minimum earnings */

	uic_table.ui_numb = 52;
	uic_table.ui_date = date;
	flg_reset(UIC);

	retval = get_n_uic(&uic_table,BROWSE,0,BACKWARD,e_mesg);
	if(retval != NOERROR){
  		DispError((char *)&s_sth,e_mesg);
  		return(ERROR);
	}
	seq_over(UIC);

	if(retval == EFL || uic_table.ui_numb != 52)
		return(NOERROR);

	one_wks_min_earn = uic_table.ui_min_earn;
	one_wks_min_hrs = uic_table.ui_min_hrs;
	one_wks_max_earn = uic_table.ui_max_earn;

	/* get the employee's pay period in order to get the employee's
	   corresponding uic table */

	strcpy(pay_period.pp_code,barg_unit.b_pp_code);
	pay_period.pp_year = 0;
	flg_reset(PAY_PERIOD);

	retval = get_n_pay_per(&pay_period,BROWSE,0,FORWARD, e_mesg);
	if(retval < 0 || strcmp(pay_period.pp_code, barg_unit.b_pp_code)!=0) {
		fomer("Pay Period Code Does not Exist");
		get();
	}
	seq_over(PAY_PERIOD);

	uic_table.ui_numb = pay_period.pp_numb;
	uic_table.ui_date = date;
	flg_reset(UIC);

	retval = get_n_uic(&uic_table,BROWSE,0,BACKWARD,e_mesg);
	if(retval != NOERROR){
  		DispError((char *)&s_sth,e_mesg);
  		return(ERROR);
	}
	seq_over(UIC);

	if(retval == EFL || uic_table.ui_numb != pay_period.pp_numb)
		return(NOERROR);

	accum_wks_min_earn = uic_table.ui_min_earn;
	accum_wks_min_hrs = uic_table.ui_min_hrs;
	accum_wks_max_earn = uic_table.ui_max_earn;
	accum_wks_yrly_earn = uic_table.ui_yrly_earn;

	return(NOERROR);
}
/*-------------------------------------------------------------------------
This function will calculate the amount of uic earnings and the number of
weeks that the earnings were earned.  
--------------------------------------------------------------------------*/
static
Calc_Uic()
{
	int	retval, i;
	double	total_income, total_units, nbr_of_weeks = 0;

	for(i=0;i<5;i++){
		total_income += tot_income[i];
		total_units += tot_units[i];
		nbr_of_weeks += wk_flg[i]; 
	}
	/* Total hours for an employee */
	roe.ro_hours += total_units;

	if(k==0)
		total_income += roe.ro_vac;

	if((total_income >= accum_wks_min_earn ||
	    total_units >=accum_wks_min_hrs) && nbr_of_weeks > 1){
		if(roe.ro_ins_week == 19 && done == 0){
			retval = OneWeek();
			if(retval < 0)	return(retval);	

			done = 1;
		}
		if(total_income >= accum_wks_max_earn){
		   if(roe.ro_ins_week < 20 && done == 0)
			roe.ro_ins_earn[k] = D_Roundoff(accum_wks_max_earn);
		}
		else{
		   if(roe.ro_ins_week < 20 && done == 0){
			roe.ro_ins_earn[k] = D_Roundoff(total_income);
			all_wks_max = 1;
		   }	
		}
		if(roe.ro_ins_week < 20 && done == 0)
			roe.ro_ins_wks[k] = nbr_of_weeks;
		roe.ro_ins_week += nbr_of_weeks; 
		if(total_uic + roe.ro_ins_earn[k] > uic_table.ui_yrly_earn){
		   if(roe.ro_ins_week < 20 && done == 0){
			roe.ro_ins_earn[k] = D_Roundoff(uic_table.ui_yrly_earn -
					     total_uic);
			all_wks_max = 1;
		   }
		}
		total_uic += roe.ro_ins_earn[k];
		nbr_ins_wks += roe.ro_ins_wks[k];
		k++;
	} 
	else {
		for(i=0;i<5;i++){
			if(wk_flg[i] == 0)
				continue;
			if(tot_income[i] >= one_wks_min_earn ||
			   tot_units[i] >= one_wks_min_hrs){
				if(tot_income[i] >= one_wks_max_earn){
				   if(roe.ro_ins_week < 20)
					roe.ro_ins_earn[k] = 
						D_Roundoff(one_wks_max_earn);
				}
				else{
				   if(roe.ro_ins_week < 20){
					roe.ro_ins_earn[k] = 
						D_Roundoff(tot_income[i]);
					all_wks_max = 1;
				   }
				}
				if(total_uic + roe.ro_ins_earn[k] > 
				   uic_table.ui_yrly_earn){
				   if(roe.ro_ins_week < 20){
					roe.ro_ins_earn[k]=D_Roundoff(
						uic_table.ui_yrly_earn - 
						total_uic);
					all_wks_max = 1;
				   }
				}
				total_uic += roe.ro_ins_earn[k];
				if(roe.ro_ins_week < 20)
					roe.ro_ins_wks[k] = 1; 
				roe.ro_ins_week += 1; 
				nbr_ins_wks += roe.ro_ins_wks[k];
				k++;
			}	 
		}
	}

	for(i=0;i<5;i++){
		wk_flg[i] = 0;
		tot_units[i] = 0;
		tot_income[i] = 0;
	}

	total_income = 0;
	total_units = 0;

	return(NOERROR);
}
/*-------------------------------------------------------------------------*/
OneWeek()
{
	int i;

	for(i=4;i>=0;i--){
		if(wk_flg[i] == 0)
			continue;
		if(tot_income[i] >= one_wks_min_earn ||
		   tot_units[i] >= one_wks_min_hrs){
			if(tot_income[i] >= one_wks_max_earn) {
		 	   if(roe.ro_ins_week < 20) 
				roe.ro_ins_earn[k] = 
					D_Roundoff(one_wks_max_earn);
			}
			else{
		 	   if(roe.ro_ins_week < 20) 
				roe.ro_ins_earn[k] = 
					D_Roundoff(tot_income[i]);
				all_wks_max = 1;
			}
			if(total_uic + roe.ro_ins_earn[k] > 
			   uic_table.ui_yrly_earn){
		 	   if(roe.ro_ins_week < 20) {
				roe.ro_ins_earn[k]=D_Roundoff(
					uic_table.ui_yrly_earn - 
					total_uic);
				all_wks_max = 1;
			   }
			}
			total_uic += roe.ro_ins_earn[k];
		 	if(roe.ro_ins_week < 20)
				roe.ro_ins_wks[k] = 1; 
			nbr_ins_wks += roe.ro_ins_wks[k];
			k++;
			return(NOERROR);
		}	 
	}
	return(NOERROR);
}
/*--------------------------------------------------------------------
 GetStatus()  - this routine reads the employee seniority file and   
   		 shows what days the employee has hours for 
--------------------------------------------------------------------*/
static
GetStatus()
{
	int 	retval,i, curr_month, leap_year ;
	int	nbr_of_mths = 12, curr_day;
	int	start_year, curr_year;
	short	start_pp_numb, start_pp_year,end_pp_numb,
		end_pp_year,temp_mth;
	long	end_date, time_unit_date;
	long	temp_day,one = 1, value;

	first_day = 29999999;
	last_day = 0;
	temp_day = 0;
	curr_month = 1;

	/* initialize screen */

	end_date = get_date();

	start_mth = ((end_date/100)%100);

	start_date = end_date - 10000;
	start_date += 1;
	mth = ((start_date/100)%100);
	day = (start_date % 100);
	year = (start_date / 10000);
	leap_year = year % 4; 
	if(mth == 2 && day == 29 && leap_year == 0)
		start_date = (year * 10000) + (mth * 100) + day;
	else {
		if(day > d_month[mth-1]) {
			day = 1;
			if(mth == 12){
				mth = 1;
				year++;
			}
			else
				mth++;
			start_date = (year * 10000) + (mth * 100) + day;
		}
	}
	
	start_year = start_date / 10000;

	Get_day();

	strcpy(barg_unit.b_code,emp_rec.em_barg);
	barg_unit.b_date = get_date();
	flg_reset(BARG);

	retval = get_n_barg(&barg_unit,BROWSE,0,BACKWARD,e_mesg);
	if(retval < 0 || strcmp(barg_unit.b_code,emp_rec.em_barg)!=0){
		fomen("Error Reading Bargaining Unit File");
		return(-1);
	}
	seq_over(BARG);

	strcpy(pay_per_it.ppi_code,barg_unit.b_pp_code);
	pay_per_it.ppi_st_date = start_date;
	flg_reset(PAY_PER_ITEM);

	retval = get_n_pp_it(&pay_per_it,BROWSE,1,BACKWARD,e_mesg);
	if(retval < 0 || strcmp(pay_per_it.ppi_code,barg_unit.b_pp_code)!=0){
		fomen("Error Reading Pay Period Item File");
		return(-1);
	}
	seq_over(PAY_PER_ITEM);
	start_pp_numb = pay_per_it.ppi_numb;
	start_pp_year = pay_per_it.ppi_year;

	strcpy(pay_per_it.ppi_code,barg_unit.b_pp_code);
	pay_per_it.ppi_st_date = end_date;
	flg_reset(PAY_PER_ITEM);

	retval = get_n_pp_it(&pay_per_it,BROWSE,1,BACKWARD,e_mesg);
	if(retval < 0 || strcmp(pay_per_it.ppi_code,barg_unit.b_pp_code)!=0){
		fomen("Error Reading Pay Period Item File");
		return(-1);
	}
	seq_over(PAY_PER_ITEM);
	end_pp_numb = pay_per_it.ppi_numb;
	end_pp_year = pay_per_it.ppi_year;

	strcpy(time_his.tmh_numb, emp_rec.em_numb);
	time_his.tmh_year = start_pp_year;
	time_his.tmh_pp = start_pp_numb;
	time_his.tmh_week = 0;

	flg_reset(TIME_HIS);

	for(;;){
		retval = get_n_time_his(&time_his,BROWSE,1,FORWARD,e_mesg);
		if(retval == EFL ||	
		   (strcmp(time_his.tmh_numb, emp_rec.em_numb)) != 0){
			break;
		}
		if(retval < 0) {
			fomen(e_mesg);
			get();
			return(-1);
		}
		if(time_his.tmh_pp > end_pp_numb && 
		   time_his.tmh_year >= end_pp_year)
			break;
		
		strcpy(sen_par.sn_position,emp_rec.em_pos);
		sen_par.sn_eff_date = get_date();
		flg_reset(SEN_PAR);

		retval = get_n_sen_par(&sen_par, BROWSE, 0, BACKWARD, e_mesg);
		if(retval<0 || strcmp(sen_par.sn_position,emp_rec.em_pos)!=0) {
			fomen("Error Reading Seniority Parameter File");
			return(-1);
		}
		seq_over(SEN_PAR);

		strcpy(pay_per_it.ppi_code,barg_unit.b_pp_code);
		pay_per_it.ppi_year = time_his.tmh_year;
		pay_per_it.ppi_numb = time_his.tmh_pp;

		retval = get_pp_it(&pay_per_it,BROWSE,0,e_mesg);
		if(retval < 0){ 
			fomen("Error Reading Pay Period Item File");
			continue;
		}

		if(time_his.tmh_week == 1)
			time_unit_date = pay_per_it.ppi_st_date;
		else{
			time_unit_date = pay_per_it.ppi_st_date;
			for(i=0;i<7;i++){
				curr_day = (time_unit_date % 100);
				curr_month = ((time_unit_date/100)%100);
				curr_year = time_unit_date / 10000;
				curr_day++;
				leap_year = curr_year % 4;
				if(leap_year == 0 && curr_month == 2){
					if(curr_day > 29){
						if(curr_month == 12){
							curr_year++;
							curr_month = 1;
						}
						else
							curr_month++;
						curr_day = 1;
					}
				}
				else {
					if(curr_day > d_month[curr_month - 1]){
						if(curr_month == 12){
							curr_year++;
							curr_month = 1;
						}
						else
							curr_month++;
						curr_day = 1;
					}
				}
				time_unit_date=(curr_year*10000)+
					(curr_month*100)+ curr_day;
			}
		}
		for(i=0;i<7;i++){
			if(time_unit_date > end_date)
				break;
			
			if(time_his.tmh_units[i]!=0&&
			   time_unit_date>=start_date){
				curr_day = (time_unit_date % 100);
				curr_month = ((time_unit_date / 100) % 100);
				curr_year = time_unit_date / 10000;
				if((curr_month == start_mth && 
				   curr_year > start_year) ||
				   (curr_month < start_mth)){
					curr_month += nbr_of_mths;
				}
				if(sen_par.sn_num_hrs_day == 0){
					value = (long)time_his.tmh_units[i];
					if(value != one){
						if(curr_month > 12)
							temp_mth=curr_month-12;
						else
							temp_mth = curr_month;
						temp_day = (curr_year*10000)+
						      (temp_mth*100)+(curr_day);
						if(temp_day < first_day && 
						   temp_day>emp_rec.em_last_roe)
							first_day = temp_day;
						if(temp_day > last_day)
							last_day = temp_day;
					}
					else{
						if(curr_month > 12)
							temp_mth=curr_month-12;
						else
							temp_mth = curr_month;
						temp_day = (curr_year*10000)+
							(temp_mth*100)+
							(curr_day);
						if(temp_day < first_day && 
						   temp_day>emp_rec.em_last_roe)
							first_day = temp_day;
						if(temp_day > last_day)
							last_day = temp_day;
					}
				}
				else{	
					if(curr_month > 12)
						temp_mth = curr_month - 12;
					else
						temp_mth = curr_month;
					temp_day = (curr_year*10000)+
						(temp_mth*100)+
						(curr_day);
					if(temp_day < first_day && 
					   temp_day > emp_rec.em_last_roe) {
						first_day = temp_day;
					}
					if(temp_day > last_day)
						last_day = temp_day;
				}
			}
			if(i != 6){	
			        curr_day = (time_unit_date % 100);
			        curr_month = ((time_unit_date / 100) % 100);
			        curr_year = time_unit_date / 10000;
				curr_day++;
				leap_year = curr_year % 4;
				if(leap_year == 0 && curr_month == 2) {
					if(curr_day > 29){
						if(curr_month == 12){
							curr_year++;
							curr_month = 1;
						}
						else
							curr_month++;
						curr_day = 1;
					}
				}
				else {
					if(curr_day > d_month[curr_month - 1]){
						if(curr_month == 12){
							curr_year++;
							curr_month = 1;
						}
						else
							curr_month++;
						curr_day = 1;
					}
				}
				time_unit_date=(curr_year*10000)+
					(curr_month*100)+ curr_day;
			}
		}
	}
	seq_over(TIME_HIS);

	strcpy(time.tm_numb, emp_rec.em_numb);
	time.tm_year = start_pp_year;
	time.tm_pp = start_pp_numb;
	time.tm_week = 0;

	flg_reset(TIME);

	for(;;){
		retval = get_n_ptime(&time,BROWSE,3,FORWARD,e_mesg);
		if(retval == EFL ||	
		   (strcmp(time.tm_numb, emp_rec.em_numb)) != 0){
			break;
		}
		if(retval < 0) {
			fomen(e_mesg);
			get();
			return(-1);
		}
		if(time.tm_pp > end_pp_numb && 
		   time.tm_year >= end_pp_year){
			break;
		}

		strcpy(sen_par.sn_position,emp_rec.em_pos);
		sen_par.sn_eff_date = get_date();
		flg_reset(SEN_PAR);

		retval = get_n_sen_par(&sen_par, BROWSE, 0, BACKWARD, e_mesg);
		if(retval<0 || strcmp(sen_par.sn_position,emp_rec.em_pos)!=0) {
			fomen("Error Reading Seniority Parameter File");
			return(-1);
		}
		seq_over(SEN_PAR);

		strcpy(pay_per_it.ppi_code,barg_unit.b_pp_code);
		pay_per_it.ppi_year = time.tm_year;
		pay_per_it.ppi_numb = time.tm_pp;

		retval = get_pp_it(&pay_per_it,BROWSE,0,e_mesg);
		if(retval < 0){ 
			fomen( "Error Reading Pay Period Item File");
			continue;
		}

		if(time.tm_week == 1)
			time_unit_date = pay_per_it.ppi_st_date;
		else{
			time_unit_date = pay_per_it.ppi_st_date;
			for(i=0;i<7;i++){
				curr_day = (time_unit_date % 100);
				curr_month = ((time_unit_date/100)%100);
				curr_year = time_unit_date / 10000;
				curr_day++;
				leap_year = curr_year % 4;
			    	if(leap_year == 0 && curr_month == 2){	
					if(curr_day > 29){
						if(curr_month == 12){
							curr_year++;
							curr_month = 1;
						}
						else
							curr_month++;
						curr_day = 1;
					}
			      	}
				else {
					if(curr_day > d_month[curr_month-1]){
						if(curr_month == 12){
							curr_year++;
							curr_month = 1;
						}
						else
							curr_month++;
						curr_day = 1;
					}
				}
				time_unit_date=(curr_year*10000)+
					(curr_month*100)+curr_day;
			}
		}
		for(i=0;i<7;i++){
			if(time_unit_date > end_date)
				break;
			
			if(time.tm_units[i]!=0&&time_unit_date>=start_date){
				curr_day = (time_unit_date % 100);
				curr_month = ((time_unit_date / 100) % 100);
				curr_year = time_unit_date / 10000;
				if((curr_month == start_mth && 
				   curr_year > start_year) 
				   || (curr_month < start_mth)){
					curr_month += nbr_of_mths;
				}
				if(sen_par.sn_num_hrs_day == 0){
					value = (long)time.tm_units[i];
					if(value != one){
						if(curr_month > 12)
							temp_mth=curr_month-12;
						else
							temp_mth = curr_month;
						temp_day = (curr_year*10000)+
							(temp_mth*100)+
							(curr_day);
						if(temp_day < first_day && 
						   temp_day>emp_rec.em_last_roe)
							first_day = temp_day;
						if(temp_day > last_day)
							last_day = temp_day;
			  		}
					else{
						if(curr_month > 12)
							temp_mth=curr_month-12;
			 	 	 	else
							temp_mth = curr_month;
						temp_day = (curr_year*10000)+
							(temp_mth*100)+
							(curr_day);
						if(temp_day < first_day && 
						   temp_day>emp_rec.em_last_roe)
							first_day = temp_day;
						if(temp_day > last_day)
							last_day = temp_day;
					}
				}
				else{
					if(curr_month > 12)
						temp_mth = curr_month - 12;
					else
						temp_mth = curr_month;
					temp_day = (curr_year*10000)+
						(temp_mth*100)+
						(curr_day);
					if(temp_day < first_day && 
					   temp_day > emp_rec.em_last_roe) {
						first_day = temp_day;
					}
					if(temp_day > last_day)
						last_day = temp_day;
				}
			}
			if(i != 6){	
				curr_day = (time_unit_date % 100);
				curr_month = ((time_unit_date / 100) % 100);
				curr_year = time_unit_date / 10000;
				curr_day++;
				leap_year = curr_year % 4;
				if(leap_year == 0 && curr_month == 2){
					if(curr_day > 29){
						if(curr_month == 12){
							curr_year++;
							curr_month = 1;
						}
						else
							curr_month++;
						curr_day = 1;
					}
				}
				else{
					if(curr_day > d_month[curr_month - 1]){
						if(curr_month == 12){
							curr_year++;
							curr_month = 1;
						}
						else
							curr_month++;
						curr_day = 1;
					}
				}
				time_unit_date=(curr_year*10000)+
					(curr_month*100)+curr_day;
			}
		}
	}
	seq_over(TIME);

	return(NOERROR);
}
/*----------------------------------------------------------------*/
/* takes the date entered on the screen and get the corresponding */
/* day's name. i.e. MON, TUE, etc.                                */
/*----------------------------------------------------------------*/
static
Get_day()
{
	long	long_date, end_date;
	int	curr_month, leap_year,
		end_year, start_year;

	day = start_date % 100;	
	curr_month = (start_date / 100)%100;
	year = start_date / 10000;
	start_year = year;

	end_date = get_date();
	end_year = end_date / 10000;
	leap_year = end_year % 4;

	long_date = start_date;

	for( ; ; ){

		day = long_date % 100;	
		curr_month = (long_date / 100)%100;
		year = long_date / 10000;
		leap_year = year % 4;
		
		if(curr_month == start_mth && year > start_year)
			curr_month += 12;

		curr_month = (long_date / 100)%100;
		if(leap_year == 0 && curr_month == 2){
			if((++day) <= 29)
				long_date++;
			else{
				if(curr_month <= 11)
					long_date=(year*10000)+
						((curr_month+1)*100)+1; 
				else
					long_date=((year+1)*10000)+(1*100)+1;
			}
		}
		else{	
			if((++day) <= d_month[curr_month-1])
				long_date++;
			else{
				if(curr_month <= 11)
					long_date=(year*10000)+
						((curr_month+1)*100)+1;
				else
					long_date=((year+1)*10000)+(1*100)+1;
			}
		}
		if(long_date >= get_date())
			break;
	}

	return(NOERROR);
}	/* get_day() */
/*-------------------------------------------------------------------------*/
static
GetVac()
{
	int	retval;

	roe.ro_vac = 0;

	strcpy(emp_earn.en_numb, emp_rec.em_numb);
	emp_earn.en_year = HV_SHORT;
	emp_earn.en_pp = HV_SHORT;
	emp_earn.en_week = HV_SHORT;
	flg_reset(EMP_EARN);

	for(;;){
		retval = get_n_emp_earn(&emp_earn, BROWSE,1,BACKWARD,e_mesg);
		if( retval < 0 && retval != EFL){
			DispError((char *)&s_sth, e_mesg);
			return(retval);
		}
		if(retval == EFL || 
		   strcmp(emp_earn.en_numb, emp_rec.em_numb) != 0){ 
			break;
		}
		if(s_sth.s_first_date > emp_earn.en_date || 
		   emp_rec.em_last_roe > emp_earn.en_date){ 
			break;
		}

		roe.ro_vac += emp_earn.en_def_inc;
	}
	seq_over(EMP_EARN);

	return(NOERROR);
}
