/*-----------------------------------------------------------------------
Source Name: t4_adj.c
System     : Personnel/Payroll.
Created  On: 12th APR 92.
Created  By: Andre Cormier 

DESCRIPTION:

MODIFICATIONS:        

Programmer     YY/MM/DD       Description of modification
------------------------------------------------------------------------*/
#define	MAIN		/* Main program. This is to declare Switches */
#define MAINFL		T4_ADJ		/* main file used */

#define	SYSTEM		"Setup"			/* Sub System Name */
#define	MOD_DATE	"12-APR-92"		/* Progran Last Modified */

#include <stdio.h>
#include <cfomstrc.h>
#include <bfs_defs.h>
#include <bfs_pp.h>
#include <bfs_com.h>

/* User Interface define constants */

#ifdef ENGLISH
#define CHANGE		'C'
#define INQUIRE		'I'
#define EXITOPT		'E'
#define	NEXT		'N'
#define	PREV		'P'

#define	YES		'Y'
#define NO		'N'
#define	LINEEDIT	'L'
#define SCREENEDIT	'S'
#define	CANCEL		'C'

#else
#define CHANGE		'C'
#define INQUIRE		'I'
#define EXITOPT		'F'
#define	NEXT		'S'
#define	PREV		'P'

#define	YES		'O'
#define NO		'N'
#define	LINEEDIT	'L'
#define SCREENEDIT	'S'
#define	CANCEL		'A'

#endif

/* PROFOM Releted declarations */

#define	SCR_NAME	"t4_adj"	/* PROFOM screen Name */

#define MAX_FIELD	16	 	/* Maximum field # to edit */

/* PROFOM Screen STH file */

/* Field PROFOM numbers */
#define	FN_FLD			400	/* Fn: */
#define KEY_START		500	/* Employee Number */
#define KEY_END			500	/* Employee Number */
#define	CHG_FLD			600	/* Field: */

#define EMP_NAME		800	/* Employee Name  */
#define STATUS			900	/* Employee Status  */
#define TA_EMP_INC		1000	/* Employee Income  */
#define CPP_EXEMPT		1050	/* CPP Exemption  */
#define TA_CPP_CONT 		1100	/* CPP Contribution  */
#define UIC_EXEMPT		1150	/* UIC Exemption  */
#define TA_UIC_PREM 		1200	/* UIC Premium  */
#define	TA_TAX_DED		1300	/* Income Tax Deduction  */
#define REG_PEN_PLAN		1350	/* Reg Pension Plan  */
#define TA_UIC_INS_EARN		1400	/* UIC Insurance Earnings  */
#define REG_PEN_NUM		1450	/* Reg Pension Plan Number  */
#define TA_CPP_PEN_EARN		1500	/* CPP Pension Earnings  */
#define TA_HOUSING		1600	/* Housing Board and Lodging  */
#define TA_TRAVEL		1700	/* Travel in a Prescribed Area  */
#define TA_AUTO			1800	/* Personel USe of Employer's Auto  */
#define TA_INTREST		1900	/* Intrest Free & Low Intrest Loans  */
#define TA_OTHER_TAX		2000	/* Other Tax Allowance & Benefits  */
#define TA_EMP_COM		2100	/* Employment Commissions  */
#define TA_UNION_DU		2200	/* Union Dues  */
#define TA_DONNAT		2300	/* Charitable Donations  */
#define TA_PEN_ADJ		2400	/* Pension adjustment */

#define START_FLD		800	/* First Field on screen */
#define	END_FLD			2600	/* Last Field of the screen */
/* bargain.sth - header for C structure generated by PROFOM EDITOR */

typedef struct	{

	char	s_pgname[11];		/* 100 STRING X(10) */
	long	s_rundate;		/* 300 DATE YYYYFMMFDD */
	char	s_fn[2];		/* 400 STRING X */
	char	s_numb[13];		/* 500 STRING X(12) */
	short	s_field;		/* 600 NUMERIC 99 */

	char	s_name[31];		/* 800 STRING X(30)  */
	char	s_status[4];		/* 900 STRING X(4)  */
	double	s_emp_inc;		/* 1000 NUMERIC 9,999,999.99  */
	char	s_cpp_exempt[2];	/* 1100 STRING X  */
	double	s_cpp_cont;		/* 1200 NUMERIC 9,999,999.99 */
	char	s_uic_exempt[2]; 	/* 1300 STRING X */
	double	s_uic_prem;		/* 1400 NUMERIC 9,999,999.99 */
	double	s_tax_ded;		/* 1500 NUMERIC 9,999,999.99 */
	char	s_reg_pen_plan[19];	/* 1600 STRING X(18) */
	double	s_uic_ins_earn;		/* 1700 NUMERIC 9,999,999.99 */
	char	s_reg_pen_num[13];	/* 1650 STRING x(18) */
	double	s_cpp_pen_earn;		/* 1800 NUMERIC 9,999,999.99 */
	double	s_housing;		/* 1900 NUMERIC 9,999,999.99 */
	double	s_travel;		/* 2000 NUMERIC 9,999,999.99 */
	double	s_auto;			/* 2100 NUMERIC 9,999,999.99 */
	double	s_intrest;		/* 2200 NUMERIC 9,999,999.99 */
	double	s_other_tax;		/* Box 40, Other taxables */
	double	s_emp_com;		/* NUMERIC 9,999,999.99 */
	double	s_union_du;		/* 2500 NUMERIC 9,999,999.99 */
	double	s_donnat;		/* 2600 NUMERIC 9,999,999.99 */
	double	s_pen_adj;		/* Box 52, Pension Adjustment */

	char	s_mesg[78];		/* 2800 STRING X(76) */
	char	s_resp[2];		/* 2900 STRING X */
} s_struct;

static	s_struct  s_sth,image;	/* PROFOM Screen Structure */
static	struct  stat_rec  sr;		/* PROFOM status rec */

static	char 	e_mesg[100];  		/* dbh will return err msg in this */

static	T4_adj	t4_adj,	pre_t4_adj;
static	Emp	emp_rec;
static	Reg_pen	reg_pen;

int	Validation() ;
int	WindowHelp();
int	Argc;
char	**Argv;

void	free() ;
char	*malloc() ;

main(argc,argv)
int argc;
char *argv[];
{
	int 	retval;

	/* These two are passed to execute() when it is called */
	Argc = argc;
	Argv = argv;

	retval = Initialize(argc,argv);	/* Initialization routine */

	if (retval == NOERROR) retval = Process();

	CloseRtn();			/* return to menu */
	if (retval != NOERROR) exit(-1);
	exit(0);
}

/*-------------------------------------------------------------------*/
/* Initialize PROFOM */

Initialize(argc, argv)
int	argc ;
char	*argv[] ;
{
	int	err ;

	/*
	*	Initialize DBH Environment
	*/
	strncpy(SYS_NAME,SYSTEM,50);	/* Sub system name */
	strncpy(CHNG_DATE,MOD_DATE,10);	/* Modification Date */

	proc_switch(argc, argv, MAINFL) ; 	/* Process Switches */

	/*
	*	Initialize PROFOM & Screen
	*/
	strcpy(sr.termnm,terminal);	/* Copy Terminal Name */
	fomin(&sr);
	ret(err_chk(&sr)) ;		/* Check for PROFOM Error */
	fomcf(1,1);			/* Enable Snap screen option */

	err = InitScreen() ;		/* Initialize Screen */
	if(NOERROR != err) return(err) ;

	return(NOERROR) ;
}	/* Initialize() */

/*--------------------------------------------------------------------------*/
/* Close nessary files and environment before exiting program               */

CloseRtn() 
{
	/* Set terminal back to normal mode from PROFOM */
	fomcs();
	fomrt();

	close_dbh();	/* Close files */

	return(NOERROR);
}	/* CloseRtn() */
/*----------------------------------------------------------------*/
/* Initialize screen before going to process options */

InitScreen()
{
	int	err ;

	/* move screen name to Profom status structure */
	strcpy(sr.scrnam,NFM_PATH);
	strcat(sr.scrnam,SCR_NAME) ;

	strcpy(s_sth.s_pgname,PROG_NAME);

	s_sth.s_rundate = get_date();	/* get Today's Date in YYYYMMDD format*/
	s_sth.s_field = HV_SHORT ;
	s_sth.s_mesg[0] = HV_CHAR ;
	s_sth.s_resp[0] = HV_CHAR ;

	s_sth.s_numb[0] = '\0';

	/* Move High Values to data fields and Display the screen */
	err = ClearScreen() ;
	if(NOERROR != err) return(err) ;

	return(NOERROR) ;
}	/* InitScreen() */
/*-------------------------------------------------------------------*/
/* Get Option from user and call corresponding function */

Process()
{
	int err;

	for( ; ; ){

		/* Get the Fn: option from the user */
		if((err = ReadFunction()) != NOERROR) return(err) ;

		err = ProcFunction() ;	/* Process Function */

		if(QUIT == err)		return(NOERROR) ;    /* Exit */
		if(NOACCESS == err)	fomen(e_mesg);	     /* security */
		if(PROFOM_ERR == err)	return(PROFOM_ERR);  /* PROFOM ERROR */
		if(DBH_ERR == err) {
			DispError((char *)&s_sth,e_mesg);
#ifdef ENGLISH
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"System Error... Iserror:",
				iserror, dberror, errno);
#else
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"Erreur du systeme... Iserror:",
				iserror, dberror, errno);
#endif
			DispError((char *)&s_sth,e_mesg);
			return(DBH_ERR); /* DBH ERROR */
		}
	}      /*   end of the for( ; ; )       */
}	/* Process() */
/*----------------------------------------------------------------*/
/* Display the Function (Fn:) options and get the option from the user */

ReadFunction()
{
	/* Display Fn: options */

#ifdef ENGLISH
	fomer("C(hange), I(nquire), N(ext), P(rev), E(xit)");
#else
	fomer("C(hanger), I(nterroger), S(uivant), P(recedant), F(in)");
#endif
	/* Read Fn: field to get the option */
	sr.nextfld = FN_FLD ;
	fomrf( (char *)&s_sth );
	ret(err_chk(&sr));	/* Check for PROFOM error */

	return(NOERROR) ;
}	/* ReadFunction() */
/*----------------------------------------------------------------*/
/* Process the user selected Fn: option */

ProcFunction()
{
	int retval;

	switch (s_sth.s_fn[0]) {
	case CHANGE  :			/* CHANGE */
		CHKACC(retval,UPDATE,e_mesg);
		return( Change() ) ;
	case INQUIRE  :			/* Inquire */
		CHKACC(retval,BROWSE,e_mesg);
		return( Inquire() ) ;
	case NEXT  :			/* Inquire */
		CHKACC(retval,BROWSE,e_mesg);
		return( Next(FORWARD) ) ;
	case PREV  :			/* Inquire */
		CHKACC(retval,BROWSE,e_mesg);
		return( Next(BACKWARD) ) ;
	case EXITOPT  :
		return(QUIT);

	default   : 
		return(NOERROR);
	}  /*   end of the switch statement */
	return(retval);
}	/* ProcFunction() */

/*-----------------------------------------------------------------------*/
/* Change.*/ 
/*-----------------------------------------------------------------------*/
Change()
{
	int	err ;

	err = SelectRecord() ;
	if(NOERROR != err) return(err) ;

	for( ; ; ) {
		err = Confirm() ;
		if(err != YES) {
			roll_back(e_mesg);
			break;
		}

		err = WriteRecords() ;
		if(err==NOERROR) break;
		if(err==LOCKED) {
			roll_back(e_mesg) ;
			continue;
		}
		if (err < 0) {
			roll_back(e_mesg);
			return(err) ;
		}
	}

	return(NOERROR) ;
}	/* Change() */
/*-----------------------------------------------------------------------*/
/* Show Student Employee Demographic Date                                */
Inquire()
{
	int	err ;

	err = SelectRecord() ;
	if(NOERROR != err) return(err) ;

	return(NOERROR) ;
}	/* Inquire() */
/*----------------------------------------------------------*/
/* Show the next or previous Effective Date                 */

Next(direction)
int	direction ;
{
	int retval;

	strcpy(t4_adj.ta_numb,s_sth.s_numb);
	if (flg_start(T4_ADJ) != direction) {
		inc_str(t4_adj.ta_numb,sizeof(t4_adj.ta_numb)-1,
			direction);
		flg_reset(T4_ADJ);
	}

	retval = get_n_t4_adj(&t4_adj, BROWSE, 0, direction, e_mesg);
#ifndef ORACLE
	seq_over(T4_ADJ);
#endif
	if(ERROR == retval)return(DBH_ERR) ;
	if(EFL == retval) {
		fomen("No More Records....");
		get();
		return(NOERROR) ;
	}

	strcpy(s_sth.s_numb,t4_adj.ta_numb);
	retval = ShowScreen();

	return( retval ) ;
}	/* Next() */
/*------------------------------------------------------------*/
ReadScreen()
{
	int err;

	scpy((char *)&image,(char *)&s_sth,sizeof(image));

	SetDupBuffers(START_FLD,END_FLD,1); /* Off Dup Control */

	InitFields(LV_CHAR,LV_DOUBLE);

	err = ReadFields((char *)&s_sth,START_FLD, END_FLD-200,
		Validation, WindowHelp,1) ;
	if(PROFOM_ERR == err || DBH_ERR == err) return(err) ;
	if(RET_USER_ESC == err){

		/* When user gives ESC-F while changing fields, assumption is
		* he completed his changes, and remaining fields are same as
		* old. But, at this point STH will be having low values in the 
		* remaining fields. So move the old values form the linked list.
		*/

		err = CopyBack((char *)&s_sth,(char *)&image,sr.curfld,END_FLD);
		if(err == PROFOM_ERR) return(err);

		s_sth.s_mesg[0] = HV_CHAR;
		DispMesgFld((char *)&s_sth);

		return(RET_USER_ESC) ;
	}

	return(NOERROR);
}

/*----------------------------------------------------------*/
/* Get the key and show the record */
SelectRecord()
{
	int	err ;

	for( ;; ) {
		err = ReadKey();
		if(err != NOERROR) return(err) ;
	
		strcpy(t4_adj.ta_numb,s_sth.s_numb);
		err = get_t4_adj(&t4_adj,BROWSE,0,e_mesg);
		if(err < 0)  {
			fomen("T4 Adjustment Does Not Exist for That Employee");
			get();
			if( err == EFL ) continue;
			return(err);
		}
		break;
	}

	err = ShowScreen(BROWSE);

	return(NOERROR);
}	/* SelectRecord() */
/*----------------------------------------------------------------------*/
/* Get the Government Parameter key from user. In ADD mode disable dup */
/* buffers, other modes enable dup buffers and show the current key as a */
/* default key */
ReadKey()
{
	int	i;
	char	hold_numb[13];
	
	SetDupBuffers(KEY_START,KEY_END,1);

#ifdef ENGLISH
	strcpy(s_sth.s_mesg,"Press ESC-F to Go Back to Fn:");
#else
	strcpy(s_sth.s_mesg,"Appuyer sur ESC-F pour retourner a Fn:");
#endif
	DispMesgFld((char *)&s_sth);

	strcpy(hold_numb,s_sth.s_numb);

	s_sth.s_numb[0] = LV_CHAR;

	i = ReadFields((char *)&s_sth,KEY_START, KEY_END,
		Validation, WindowHelp,1) ;
	if(PROFOM_ERR == i || DBH_ERR == i) return(i) ;
	if(RET_USER_ESC == i){
		strcpy(s_sth.s_numb,hold_numb);
		
		ret( WriteFields((char *)&s_sth,KEY_START, KEY_END) ) ;

		s_sth.s_mesg[0] = HV_CHAR;
		DispMesgFld((char *)&s_sth);

		return(RET_USER_ESC) ;
	}

	s_sth.s_mesg[0] = HV_CHAR;
	DispMesgFld((char *)&s_sth);

	return(NOERROR);
}	/*  ReadKey() */
/*-----------------------------------------------------------------------*/ 
/* Check to see if record is to be added, changed or deleted .		 */
/*-----------------------------------------------------------------------*/ 
WriteRecords()
{
	int	retval;

	strcpy(t4_adj.ta_numb,s_sth.s_numb) ;
	t4_adj.ta_emp_inc = s_sth.s_emp_inc ;
	t4_adj.ta_cpp_cont = s_sth.s_cpp_cont ;
	t4_adj.ta_uic_prem = s_sth.s_uic_prem ;
	t4_adj.ta_tax_ded = s_sth.s_tax_ded ;
	t4_adj.ta_uic_ins_earn = s_sth.s_uic_ins_earn ;
	t4_adj.ta_cpp_pen_earn = s_sth.s_cpp_pen_earn ;
	t4_adj.ta_housing = s_sth.s_housing ;
	t4_adj.ta_travel = s_sth.s_travel ;
	t4_adj.ta_auto = s_sth.s_auto ;
	t4_adj.ta_intrest = s_sth.s_intrest ;
	t4_adj.ta_other_tax = s_sth.s_other_tax ;
	t4_adj.ta_emp_com = s_sth.s_emp_com ;
	t4_adj.ta_union_du = s_sth.s_union_du ;
	t4_adj.ta_donnat = s_sth.s_donnat ;
	strcpy(t4_adj.ta_reg_pen_num, s_sth.s_reg_pen_num);

	t4_adj.ta_pen_adj = s_sth.s_pen_adj ;

	retval = put_t4_adj(&t4_adj,UPDATE,1,e_mesg);
	if(retval < 0) {
		DispError((char *)&s_sth,e_mesg);
		roll_back(e_mesg);
		return(retval);
	}

	retval = rite_audit(T4_ADJ,UPDATE,(char*)&t4_adj,
		(char*)&pre_t4_adj,e_mesg);
	if(retval==LOCKED) {
		DispError((char *)&s_sth,e_mesg);
		roll_back(e_mesg) ;
		return(LOCKED) ;
	}
	if(retval < 0 ){
#ifdef ENGLISH
		DispError((char *)&s_sth,"ERROR in Saving Records"); 
#else
		DispError((char *)&s_sth, "ERREUR en conservant les fiches");
#endif
		DispError((char *)&s_sth,e_mesg);
		roll_back(e_mesg);
		return(retval);
	}

	retval = commit(e_mesg) ;
	if(retval < 0) {
#ifdef ENGLISH
		DispError((char *)&s_sth,"ERROR in Saving Records"); 
#else
		DispError((char *)&s_sth,"ERREUR en conservant les fiches");
#endif
		DispError((char *)&s_sth,e_mesg);
		roll_back(e_mesg);
		return(retval);
	}

	return(NOERROR);
}
/*----------------------------------------------------------------*/
/* Set Duplication buffers for fields 				  */
SetDupBuffers( firstfld, lastfld, value )
int	firstfld, lastfld;	/* field numbers range */
int	value;			/* ENABLE or DISABLE */
{
	int i ;
	
	for( i=firstfld; i<=lastfld; i+=100 )
		fomca1( i, 19, value);
	if( value==0 )
		return(0);
	sr.nextfld = firstfld;
	sr.endfld = lastfld;
	fomud( (char *)&s_sth );
	ret( err_chk(&sr) );

	return( 0 );
}
/*----------------------------------------------------------------*/
/* Validation function() for Key and Header fields when PROFOM returns
  RET_VAL_CHK */

Validation()
{
	int	retval;

	switch(sr.curfld){

	case KEY_START:

		Right_Justify_Numeric(s_sth.s_numb,
			sizeof(s_sth.s_numb)-1);
		strcpy(emp_rec.em_numb,s_sth.s_numb);
		retval = get_employee(&emp_rec,BROWSE,0,e_mesg);
		if(retval < 0) {
			fomer("Employee Does not Exist");
			s_sth.s_numb[0] = LV_CHAR;
			return(ERROR);
		}

		break;

	default :
#ifdef ENGLISH
		sprintf(e_mesg,"No Validity Check For Field#  %d",sr.curfld);
#else
		sprintf(e_mesg,"Pas de controle de validite pour le Champ#  %d",sr.curfld);
#endif
		fomen(e_mesg);
		get();
		return(ERROR) ;
	}	/* Switch sr.curfld */

	return(NOERROR) ;
}	/* Validation() */
/*----------------------------------------------------------------*/
/* Show Help Windows, if applicable, when user gives ESC-H in key
   and header fields */

WindowHelp()
{
	int	retval;

	switch(sr.curfld){

	case KEY_START:

		retval = emp_hlp(s_sth.s_numb,7,13);
		if(retval == DBH_ERR) return(retval);
		if(retval >= 0) redraw();
		if(retval == 0) return(ERROR);
		if(retval < 0) return(ERROR);
		strcpy(emp_rec.em_numb,s_sth.s_numb);
		retval = get_employee(&emp_rec,BROWSE,0,e_mesg);
		if(retval < 0) {
			fomer("Employee Does not Exist");
			s_sth.s_numb[0] = LV_CHAR;
			return(ERROR);
		}
		break;

	default :
		fomer("No Help Window for This Field");
	}	/* Switch sr.curfld */

	return(NOERROR) ;
}	/* HdrAndKeyWindowHelp() */
/*-----------------------------------------------------------------------*/
/* Take the confirmation from user for the header part */

Confirm()
{
	int	err ;

	/* Options:
	   Change   - YALSNPC
	*/

	for( ; ; ) {
	    switch(s_sth.s_fn[0]) {
	    case  CHANGE :		/* Change */
#ifdef ENGLISH
		err = GetOption((char *)&s_sth,
		"Y(es), S(creen edit), L(ine edit), C(ancel)","YSLC");
#else
		err = GetOption((char *)&s_sth,
		"O(ui), S(creen edit), L(ine edit), A(nnul)","OSLA");
#endif
		break ;
	    }
	    if(err == PROFOM_ERR) return(err) ;

	    switch(err) {
	    case  YES  :
		return(YES);
	    case  SCREENEDIT:
		err = ReadScreen();
		break;
	    case  LINEEDIT  :
		err = ChangeFields();
		break ;
	    case  CANCEL :
#ifdef ENGLISH
		err = GetOption((char *)&s_sth,
				"Confirm the Cancel (Y/N)?", "YN") ;
#else
		err = GetOption((char *)&s_sth,
				"Confirmer l'annulation (O/N)?", "ON") ;
#endif
		if(err == YES) return(CANCEL) ;
		break ;
	    }	/* switch err */

	    if(err == PROFOM_ERR) return(err) ;
	    if(err == DBH_ERR) return(err) ;
	}	/* for(; ; ) */
}	/* Confirm() */
/*-----------------------------------------------------------*/
ChangeFields()
{
	int	retval ;
	int	fld_no, end_fld;

	SetDupBuffers(START_FLD,END_FLD-200,1); /* Off Dup Control */

	/* Get The Field to Be Modified */
#ifdef	ENGLISH
	strcpy(s_sth.s_mesg,"Enter RETURN to Terminate Edit");
#else
	strcpy(s_sth.s_mesg,"Appuyer sur RETURN pour terminer l'ajustement");
#endif
	DispMesgFld((char *)&s_sth); ;
        
     	for (; ;) {
		s_sth.s_field = LV_SHORT;
		retval = ReadFields((char *)&s_sth,CHG_FLD,CHG_FLD,
			(int (*)())NULL,(int (*)())NULL, 1);

		if (retval < 0) return(-1);
		if (retval == RET_USER_ESC) break;	/* User enter ESC-F */

       		if (s_sth.s_field == 0 ) break;  /* Finished changing fields */

		if (s_sth.s_field > MAX_FIELD) {
			fomen("Invalid Field Number");
			get();
			continue;
		}

		fld_no = START_FLD + (100 * (s_sth.s_field-1));
		end_fld = fld_no;

		retval = ReadFields((char *)&s_sth,fld_no, end_fld,
			Validation, WindowHelp,1) ;
	}
     	s_sth.s_field = HV_SHORT ;
	if ( WriteFields((char *)&s_sth,CHG_FLD, CHG_FLD) < 0 ) return(-1);

     	s_sth.s_mesg[0] = HV_CHAR ;
     	DispMesgFld((char *)&s_sth);

	if(SetDupBuffers(START_FLD, END_FLD-200, 0)<0) return(PROFOM_ERR);

	return(NOERROR);
}
/*-----------------------------------------------------------*/
/* Move Header to Screen Hdr Fields */
ShowScreen()
{
	int	retval;

	strcpy(emp_rec.em_numb,s_sth.s_numb);
	retval = get_employee(&emp_rec,BROWSE,0,e_mesg);
	if(retval < 0) {
		fomer("Employee Does not Exist");
		s_sth.s_numb[0] = LV_CHAR;
		return(ERROR);
	}

	strcpy(s_sth.s_name, emp_rec.em_last_name);
	strcat(s_sth.s_name, ", ");
	strcat(s_sth.s_name, emp_rec.em_first_name);
	strcat(s_sth.s_name, " ");
	strcat(s_sth.s_name, emp_rec.em_mid_name);

	strcpy(s_sth.s_status,emp_rec.em_status);
	s_sth.s_emp_inc = t4_adj.ta_emp_inc;
	strcpy(s_sth.s_cpp_exempt,emp_rec.em_cpp_exp);
	s_sth.s_cpp_cont = t4_adj.ta_cpp_cont;
	strcpy(s_sth.s_uic_exempt,emp_rec.em_uic_exp);
	s_sth.s_uic_prem = t4_adj.ta_uic_prem;
	s_sth.s_tax_ded = t4_adj.ta_tax_ded;
	if(emp_rec.em_reg_pen[0] == '\0')
		s_sth.s_reg_pen_plan[0] = HV_CHAR;
	else
		strcpy(s_sth.s_reg_pen_plan,emp_rec.em_reg_pen);
	s_sth.s_uic_ins_earn = t4_adj.ta_uic_ins_earn;

/* Nicola */
	if(emp_rec.em_reg_pen[0] == '\0')
		s_sth.s_reg_pen_num[0] = HV_CHAR;
	else {
		strcpy(reg_pen.rg_code, emp_rec.em_reg_pen);
		strcpy(reg_pen.rg_pp_code, emp_rec.em_pp_code);
		retval = get_reg_pen(&reg_pen,BROWSE,0,e_mesg);
		if(retval < 0) {
			fomer("Registered pension plan Does not Exist");
			s_sth.s_numb[0] = LV_CHAR;
			return(ERROR);
		}

		strcpy(t4_adj.ta_reg_pen_num, reg_pen.rg_reg_num);
		strcpy(s_sth.s_reg_pen_num, t4_adj.ta_reg_pen_num);
	}
	s_sth.s_cpp_pen_earn = t4_adj.ta_cpp_pen_earn;
	s_sth.s_housing = t4_adj.ta_housing;
	s_sth.s_travel = t4_adj.ta_travel;
	s_sth.s_auto = t4_adj.ta_auto;
	s_sth.s_intrest = t4_adj.ta_intrest;
	s_sth.s_other_tax = t4_adj.ta_other_tax;
	s_sth.s_emp_com = t4_adj.ta_emp_com;
	s_sth.s_union_du = t4_adj.ta_union_du;
	s_sth.s_donnat = t4_adj.ta_donnat;
	s_sth.s_pen_adj = t4_adj.ta_pen_adj;

	ret( WriteFields((char *)&s_sth, KEY_START, END_FLD - 200) ) ;

	return(NOERROR) ;
}	/* ShowScreen() */
/*------------------------------------------------------------------------*/
/* Move High values to all data fields and clear the screen */

ClearScreen()
{
	/* Move High Values to Hedaer part */
	InitFields(HV_CHAR, HV_DOUBLE) ;

	ret( WriteFields((char *)&s_sth,START_FLD, (END_FLD - 200)) );

	return(NOERROR);
}	/* ClearScreen() */
/*-------------------------------------------------------------------------*/
/* Initialize Screen Header with either Low or High Values */

InitFields( t_char, t_double )
char	t_char ;
double	t_double;
{

	if(t_double == HV_DOUBLE) {
		s_sth.s_name[0] = t_char;
		s_sth.s_status[0] = t_char;
		s_sth.s_cpp_exempt[0] = t_char;
		s_sth.s_uic_exempt[0] = t_char;
		s_sth.s_reg_pen_plan[0] = t_char;
		s_sth.s_reg_pen_num[0] = t_char;
	}
	s_sth.s_emp_inc = t_double;
	s_sth.s_cpp_cont = t_double;
	s_sth.s_uic_prem = t_double;
	s_sth.s_tax_ded = t_double;
	s_sth.s_uic_ins_earn = t_double;
	s_sth.s_cpp_pen_earn = t_double;
	s_sth.s_housing = t_double;
	s_sth.s_travel = t_double;
	s_sth.s_auto = t_double;
	s_sth.s_intrest = t_double;
	s_sth.s_other_tax = t_double;
	s_sth.s_emp_com = t_double;
	s_sth.s_union_du = t_double;
	s_sth.s_donnat = t_double;
	s_sth.s_pen_adj = t_double;

	return(NOERROR) ;
}	/* InitFields() */
/*-------------------- E n d   O f   P r o g r a m ---------------------*/
