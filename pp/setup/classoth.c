/*-----------------------------------------------------------------------
Source Name: classoth.c
System     : Personnel/Payroll System.
Created  On: 10th Sept. 91.
Created  By: J. Prescott.

DESCRIPTION:
	The Classification Maintenance Screen is used to identify the 
	different classifications.  

MODIFICATIONS:        

Programmer     YY/MM/DD       Description of modification
------------------------------------------------------------------------*/
#define	MAIN		/* Main program. This is to declare Switches */
#define MAINFL		CLASSIFICATION		/* main file used */

#define	SYSTEM		"SETUP"	/* Sub System Name */
#define	MOD_DATE	"10-SEPT-91"		/* Progran Last Modified */

#include <stdio.h>
#include <cfomstrc.h>
#include <bfs_defs.h>
#include <bfs_pp.h>
#include <bfs_com.h>

/* User Interface define constants */
#ifdef ENGLISH
#define ADDREC		'A'
#define CHANGE		'C'
#define DELETE		'D'
#define INQUIRE		'I'
#define EXITOPT		'E'
#define	NEXT		'N'
#define	PREV		'P'

#define	YES		'Y'
#define NO		'N'
#define ADDITEMS	'A'
#define	LINEEDIT	'L'
#define HEADEREDIT	'H'
#define DELITEM		'D'
#define REACTITEM	'R'
#define	CANCEL		'C'

#define ACTIVE		"ACT"
#define INACTIVE	"DEL"
#else
#define ADDREC		'R'
#define CHANGE		'C'
#define DELETE		'E'
#define INQUIRE		'I'
#define EXITOPT		'F'
#define	NEXT		'S'
#define	PREV		'P'

#define	YES		'O'
#define NO		'N'
#define ADDITEMS	'A'
#define	LINEEDIT	'L'
#define HEADEREDIT	'H'
#define DELITEM		'D'
#define REACTITEM	'R'
#define	CANCEL		'A'

#define ACTIVE		"ACT"
#define INACTIVE	"ELI"
#endif

#define FOUND		0
#define NOTFOUND	1
#define NO_CHANGE	2

/* PROFOM Releted declarations */

#define	SCR_NAME	"classoth"	/* PROFOM screen Name */

#define	PAGESIZE	1		/* No of Items */
/* PROFOM Screen STH file */

/* Field PROFOM numbers */

#define FN_FLD		400	/* Fn: */

#define KEY_START	500	/* Key Start Field */
#define KEY_END		600	/* Key End Field */
#define CHG_FLD		700

#define HDR_ST_FLD	900	/* Desc. Field */
#define HDR_END_FLD	1200	/* Units/Year Field */

#define DESC_FLD	900	/* Description field */
#define POS_FLD		1000	/* Position Field */
#define YRINC_FLD	1100	/* Yearly Income Field */
#define UNITS_FLD	1200	/* Units/Year Field */

#define PAGE_FLD	1300	/* Page# Field */

#define	ITEM_ST_FLD	1500	/* Item Start Field */
#define ITEM_END_FLD	4200	/* Item End Field */

#define FUND_FLD	1500	/* Fund Field */
#define STATUS_FLD	1600	/* Status Field */
#define CPP_ACCT	1700	/* CPP Account Field */
#define CPP_KEY1	1800	/* CPP Key-1 Field */
#define CPP_KEY2	1900	/* CPP Key-2 Field */
#define CPP_KEY3	2000	/* CPP Key-3 Field */
#define CPP_KEY4	2100	/* CPP Key-4 Field */
#define CPP_KEY5	2200	/* CPP Key-5 Field */
#define CPP_KEY6	2300	/* CPP Key-6 Field */
#define CPP_KEY7	2400	/* CPP Key-7 Field */
#define CPP_KEY8	2500	/* CPP Key-8 Field */
#define CPP_KEY9	2600	/* CPP Key-9 Field */
#define CPP_KEY10	2700	/* CPP Key-10 Field */
#define CPP_KEY11	2800	/* CPP Key-11 Field */
#define CPP_KEY12	2900	/* CPP Key-12 Field */
#define UIC_ACCT	3000	/* UIC Account Field */
#define UIC_KEY1	3100	/* UIC Key-1 Field */
#define UIC_KEY2	3200	/* UIC Key-2 Field */
#define UIC_KEY3	3300	/* UIC Key-3 Field */
#define UIC_KEY4	3400	/* UIC Key-4 Field */
#define UIC_KEY5	3500	/* UIC Key-5 Field */
#define UIC_KEY6	3600	/* UIC Key-6 Field */
#define UIC_KEY7	3700	/* UIC Key-7 Field */
#define UIC_KEY8	3800	/* UIC Key-8 Field */
#define UIC_KEY9	3900	/* UIC Key-9 Field */
#define UIC_KEY10	4000	/* UIC Key-10 Field */
#define UIC_KEY11	4100	/* UIC Key-11 Field */
#define UIC_KEY12	4200	/* UIC Key-12 Field */

#define	END_FLD		4400	/* Last Field of the screen */

/* area.sth - header for C structure generated by PROFOM EDITOR */

typedef	struct	{	/* Start Fld 1500, Endfld 4200 */

	short	s_fund;		/* 1500 NUMERIC 999 */
	char	s_status[4];	/* 1600 STRING XXX */
	char	s_cpp_acct[19];	/* 1700 STRING X(19) */
	long	s_cpp_keys[NO_KEYS]; /* 1800 - 2900 NUMERIC 99999 */
	char	s_uic_acct[19];	/* 3000 STRING X(19) */
	long	s_uic_keys[NO_KEYS]; /* 3100 - 4200 NUMERIC 99999 */

}	S_item ;

typedef struct	{

	char	s_pgname[11];	/* 100 STRING X(10) */
	long	s_rundate;	/* 300 DATE YYYYFMMFDD */
	char	s_fn[2];	/* 400 STRING X */
	char	s_class_cd[7];	/* 500 STRING X(6) */
	long	s_eff_date;	/* 600 DATE YYYYFMMFDD */
	short	s_field;	/* 600 NUMERIC 99 */

	char	s_desc[21];	/* 900 STRING X(20) */
	char	s_position[7];	/* 1000 STRING X(6) */
	double	s_yr_income;	/* 1100 NUMERIC 999,999.99 */
	double	s_unit_yr;	/* 1200 NUMERIC 999,999.99 */
	short	s_page;		/* 1300 NUMERIC 99 */

	char	s_dummy[2];	/* 1400 STRING XXX */

	S_item	s_items[PAGESIZE] ;	/* Start Fld 1500, End Fld 4200  */

	char	s_mesg[78];	/* 4300 STRING X(77) */
	char	s_resp[2];	/* 4400 STRING X */
} s_struct;

static	s_struct  s_sth,image;	/* PROFOM Screen Structure */
static	struct  stat_rec  sr;		/* PROFOM status rec */

static	char 	e_mesg[100];  		/* dbh will return err msg in this */

int	Validation() ;
int	WindowHelp() ;

int	Argc;
char	**Argv;

typedef struct Page {
	S_item	Items[PAGESIZE] ;	/* Items Information */
	struct	Page	*PrevPage ;	/* ptr to previous page */
	struct	Page	*NextPage ;	/* ptr to next page */
	char	I_Status[2];	/* item status ie A(DD) C(hange) */
	short	NoItems;		/* number of Items on the page */
	short	Pageno;			/* Page number */
}	Page;

static	Page	*FirstPage,		/* Address of First Page */
		*CurPage,		/* Address of Current Page */
		*CurLast,		/* Address of Curr. record last page */
		*LastPage;		/* Address of Last Page of Memory
					   Allocated */

static	Pa_rec	pa_rec;
static	Gl_rec	gl_rec;
static	Position pos_rec;		/* Position record */
static	Class	 class_rec, pre_class;	/* Area record */
static	Class_item class_item, pre_class_item;
static  Emp_emp	 emp_rec;
static	Sch_rec  school;
static	Pay_param pay_param;
static	Gl_acct	gl_acct;

void	free() ;
char	*malloc() ;

main(argc,argv)
int argc;
char *argv[];
{
	int 	retval;

	/* These two are passed to execute() when it is called */
	Argc = argc;
	Argv = argv;

	retval = Initialize(argc,argv);	/* Initialization routine */

	if (retval == NOERROR) retval = Process();

	CloseRtn();			/* return to menu */
	if (retval != NOERROR) exit(-1);
	exit(0);
}

/*-------------------------------------------------------------------*/
/* Initialize PROFOM */

Initialize(argc, argv)
int	argc ;
char	*argv[] ;
{
	int	err ;

	/*
	*	Initialize DBH Environment
	*/
	strncpy(SYS_NAME,SYSTEM,50);	/* Sub system name */
	strncpy(CHNG_DATE,MOD_DATE,10);	/* Modification Date */

	proc_switch(argc, argv, MAINFL) ; 	/* Process Switches */

	/*
	*	Initialize PROFOM & Screen
	*/
	strcpy(sr.termnm,terminal);	/* Copy Terminal Name */
	fomin(&sr);
	ret(err_chk(&sr)) ;		/* Check for PROFOM Error */
	fomcf(1,1);			/* Enable Snap screen option */

	err = InitScreen() ;		/* Initialize Screen */
	if(NOERROR != err) return(err) ;

	/*
	*	Get The Parameter Record
	*/
	err = get_param(&pa_rec, BROWSE, 1, e_mesg) ;
	if(err == ERROR) {
		DispError((char *)&s_sth,e_mesg);
		return(ERROR) ;
	}
	else if(err == UNDEF) {
#ifdef ENGLISH
		DispError((char *)&s_sth,"Parameters Are Not Set Up ...");
#else
		DispError((char *)&s_sth,"Parametres ne sont pas etablis... ");
#endif
		return(ERROR) ;
	}

	/*
	*	Get The Payroll Parameter Record
	*/
	err = get_pay_param(&pay_param, BROWSE, 1, e_mesg) ;
	if(err == ERROR) {
		DispError((char *)&s_sth,e_mesg);
		return(ERROR) ;
	}
	else if(err == UNDEF) {
#ifdef ENGLISH
		DispError((char *)&s_sth,"Payroll Parameter is Not Set Up ...");
#else
		DispError((char *)&s_sth,"Payroll Parametres ne sont pas etablis... ");
#endif
		return(ERROR) ;
	}
	FirstPage = NULL;
	LastPage = NULL;

	return(NOERROR) ;
}	/* Initialize() */

/*--------------------------------------------------------------------------*/
/* Close nessary files and environment before exiting program               */

CloseRtn() 
{
	/* Free the linked list for the end */
	for( ;LastPage != FirstPage ; ) {
		LastPage = LastPage->PrevPage;
		free((char *)LastPage->NextPage);
		LastPage->NextPage = NULL;
	}
	if(FirstPage != NULL) {
		free((char *)FirstPage);
	}

	FirstPage = LastPage = NULL;

	/* Set terminal back to normal mode from PROFOM */
	fomcs();
	fomrt();

	close_dbh();	/* Close files */

	return(NOERROR);
}	/* CloseRtn() */
/*----------------------------------------------------------------*/
/* Initialize screen before going to process options */

InitScreen()
{
	int	err ;

	/* move screen name to Profom status structure */
	strcpy(sr.scrnam,NFM_PATH);
	strcat(sr.scrnam,SCR_NAME) ;

	strcpy(s_sth.s_pgname,PROG_NAME);

	s_sth.s_rundate = get_date();	/* get Today's Date in YYYYMMDD format*/
	s_sth.s_field = HV_SHORT ;
	s_sth.s_mesg[0] = HV_CHAR ;
	s_sth.s_resp[0] = HV_CHAR ;

	/* Move High Values to data fields and Display the screen */
	err = ClearScreen() ;
	if(NOERROR != err) return(err) ;

	return(NOERROR) ;
}	/* InitScreen() */
/*-------------------------------------------------------------------*/
/* Get Option from user and call corresponding function */

Process()
{
	int err;

	for( ; ; ){

		/* Get the Fn: option from the user */
		if((err = ReadFunction()) != NOERROR) return(err) ;

		err = ProcFunction() ;	/* Process Function */

		if(QUIT == err)		return(NOERROR) ;    /* Exit */
		if(NOACCESS == err)	fomen(e_mesg);	     /* security */
		if(PROFOM_ERR == err)	return(PROFOM_ERR);  /* PROFOM ERROR */
		if(DBH_ERR == err) {
			DispError((char *)&s_sth,e_mesg);
#ifdef ENGLISH
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"System Error... Iserror:",
				iserror, dberror, errno);
#else
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"Erreur du systeme... Iserror:",
				iserror, dberror, errno);
#endif
			DispError((char *)&s_sth,e_mesg);
			return(DBH_ERR); /* DBH ERROR */
		}
	}      /*   end of the for( ; ; )       */
}	/* Process() */
/*----------------------------------------------------------------*/
/* Display the Function (Fn:) options and get the option from the user */

ReadFunction()
{
	/* Display Fn: options */
#ifdef ENGLISH
	fomer("A(dd), C(hange), D(elete), I(nquire), N(ext), P(rev), E(xit)");
#else
	fomer("R(ajouter), C(hanger), I(nterroger), S(uivant), P(recedent), F(in)");
#endif
	/* Read Fn: field to get the option */
	sr.nextfld = FN_FLD ;
	fomrf( (char *)&s_sth );
	ret(err_chk(&sr));	/* Check for PROFOM error */

	return(NOERROR) ;
}	/* ReadFunction() */
/*----------------------------------------------------------------*/
/* Process the user selected Fn: option */

ProcFunction()
{
	int retval;

	switch (s_sth.s_fn[0]) {
	case ADDREC  :			/* ADD */
		CHKACC(retval,ADD,e_mesg);
		return( Add() ) ;
	case CHANGE  :			/* CHANGE */
		CHKACC(retval,UPDATE,e_mesg);
		return( Change() ) ;
	case DELETE  :			/* CHANGE */
		CHKACC(retval,UPDATE,e_mesg);
		return( Delete() ) ;
	case INQUIRE  :			/* Inquire */
		CHKACC(retval,BROWSE,e_mesg);
		return( Inquire() ) ;
	case NEXT  :			/* Next */
		CHKACC(retval,BROWSE,e_mesg);
		return( Next(FORWARD) ) ;
	case PREV  :			/* Previous */
		CHKACC(retval,BROWSE,e_mesg);
		return( Next(BACKWARD) ) ;
	case EXITOPT  :			/* Exit */
		return( QUIT ) ;
	}  /*   end of the switch statement */

	return(retval);
}	/* ProcFunction() */
/*----------------------------------------------------------------------*/
/* Adding.  Get the unique Key, accept details and update the files */
Add()
{
	int	err ;

	FirstPage = NULL;
	LastPage = NULL;
	CurLast = NULL;

	err = ReadKey();
	if(err != NOERROR) return(err) ;

	/* Clear The Screen */
	err = ClearScreen();
	if(err != NOERROR) return(err) ;

	err = GetDetails() ;
	if(PROFOM_ERR == err || DBH_ERR == err) return(err) ;
	if(err < 0 || CANCEL == err) {
		roll_back(e_mesg) ;	/* Unlock the locked Records */
		return(ClearScreen()) ;	/* Clear the Screen */
	}

	return(NOERROR);
}	/* Add() */
/*-----------------------------------------------------------------------*/
/* Change. Students Study halls and update the files if a day/semester   */
/* is changed to NO delete record.			  		 */
/*-----------------------------------------------------------------------*/
Change()
{
	int	err ;

	err = SelectRecord(UPDATE) ;
	if(NOERROR != err) return(err);

	for( ; ; ) {
		err = ConfirmItems() ;
		if(err != YES) {
			roll_back(e_mesg);
			break;
		}

		err = ProcItemUpdates(UPDATE) ;
		if(err==NOERROR) break;
		if(err==LOCKED) {
			roll_back(e_mesg) ;
			continue;
		}
		if (err < 0) {
			roll_back(e_mesg);
			return(err) ;
		}
	}

	return(NOERROR) ;
}	/* Change() */
/*-----------------------------------------------------------------------*/
/* Delete. Student Study Hall Records.  */
/*-----------------------------------------------------------------------*/
Delete()
{
	int	err ;

	err = SelectRecord(UPDATE) ;
	if(NOERROR != err) return(err) ;

	strcpy(emp_rec.ep_class,s_sth.s_class_cd);
	emp_rec.ep_numb[0] = '\0';
	flg_reset(EMP_EMP);
	err = get_n_emp_emp(&emp_rec,BROWSE,1,FORWARD,e_mesg);
	if(err == EFL || strcmp(emp_rec.ep_class,s_sth.s_class_cd) != 0) {
		for( ; ; ) {
			err = ConfirmItems() ;
			if(err != YES) {
				roll_back(e_mesg);
				break;
			}
	
			err = ProcItemUpdates(P_DEL) ;
			if(err==NOERROR) break;
			if(err==LOCKED) {
				roll_back(e_mesg) ;
				continue;
			}
			if (err < 0) {
				roll_back(e_mesg);
				return(err) ;
			}
		}
	}
	else {
		fomer("Classification Code Being use by an Employee. Cannot Delete.");
		get();
	}
	return(NOERROR) ;
}	/* Delete() */
/*-----------------------------------------------------------------------*/
/* Show Student Student halls base on users input */
Inquire()
{
	int	err ;

	err = SelectRecord(BROWSE) ;
	if(NOERROR != err) return(err) ;

	err = ConfirmItems() ;
	
	return(NOERROR) ;
}	/* Inquire() */
/*----------------------------------------------------------*/
/* Show the next or previous Students Study halls */

Next(direction)
int	direction ;
{
	int err;

	if(flg_start(CLASSIFICATION) != direction) {
		strcpy(class_rec.c_code,s_sth.s_class_cd);
		class_rec.c_date = s_sth.s_eff_date;
		if(direction == FORWARD) 
			class_rec.c_date++;
		else	class_rec.c_date--;

		flg_reset(CLASSIFICATION);
	}
	err = get_n_class(&class_rec,BROWSE,0,direction,e_mesg);
#ifndef ORACLE
	seq_over(CLASSIFICATION);
#endif

	if(ERROR == err) return(DBH_ERR);
	if(EFL == err) {
#ifdef ENGLISH
		fomen("No More Records....");
#else
		fomen("Plus de fiches....");
#endif
		get();
		flg_reset(CLASSIFICATION);
		return(NOERROR);
	}

	return(ShowScreen());
}	/* Next() */
/*----------------------------------------------------------------------*/
/* Get the Student Study Hall key from user. In ADD mode disable dup buffers, */
/* other modes enable dup buffers and show the current key as a default key */
/*----------------------------------------------------------------------*/
ReadKey()
{
	int	i;
	
	/* In Add mode turn off dup control for key fields.
	   Other modes reverse it */
	if(s_sth.s_fn[0] == ADDREC){	/* ADD */
		SetDupBuffers(KEY_START,KEY_END,0); /* Off Dup Control */
	}
	else {
		SetDupBuffers(KEY_START,KEY_END,1);
	}

#ifdef ENGLISH
	strcpy(s_sth.s_mesg,"Press ESC-F to Go Back to Fn:");
#else
	strcpy(s_sth.s_mesg,"Appuyer sur ESC-F pour retourner a Fn:");
#endif
	DispMesgFld((char *)&s_sth);

	s_sth.s_class_cd[0] = LV_CHAR;
	s_sth.s_eff_date = LV_LONG;

	i = ReadFields((char *)&s_sth,KEY_START, KEY_END,
		Validation, WindowHelp,1) ;
	if(PROFOM_ERR == i || DBH_ERR == i) return(i) ;
	if(RET_USER_ESC == i){
		
		ret( WriteFields((char *)&s_sth,KEY_START, KEY_END) ) ;

		s_sth.s_mesg[0] = HV_CHAR;
		DispMesgFld((char *)&s_sth);

		return(RET_USER_ESC) ;
	}

	s_sth.s_mesg[0] = HV_CHAR;
	DispMesgFld((char *)&s_sth);

	return(NOERROR);
}	/*  ReadKey() */
/*------------------------------------------------------------*/
/* Read the Area Details from the User */

GetDetails()
{
	int	i ;

	i = ReadHdr(ADD);
	if(NOERROR != i) return(i) ;

	i = AddItems();
	if(NOERROR != i) return(i) ;

	for( ; ; ) {
		i = ConfirmItems() ;
		if(i != YES) break;

		i = ProcItemUpdates(ADD) ;
		if(i < 0) {
			if(i == LOCKED) continue;
			break;
		}
		break;
	}
	if(i != NOERROR) return(i);
	return(NOERROR) ;
}	/* GetDetails() */
/*------------------------------------------------------------*/
ReadHdr(mode)
int	mode;
{
	int	retval;

	if(mode == ADD) {
		SetDupBuffers(HDR_ST_FLD,HDR_END_FLD,0);
	}
	else {
		SetDupBuffers(HDR_ST_FLD,HDR_END_FLD,1);
	}

#ifdef ENGLISH
	strcpy(s_sth.s_mesg,"Press ESC-F to Go Back to Fn:");
#else
	strcpy(s_sth.s_mesg,"Appuyer sur ESC-F pour retourner a Fn:");
#endif
	DispMesgFld((char *)&s_sth);

	InitHdr(LV_CHAR,LV_DOUBLE);

	retval = ReadFields((char *)&s_sth,HDR_ST_FLD,HDR_END_FLD,
		Validation,WindowHelp,1) ;
	if(PROFOM_ERR == retval || DBH_ERR == retval) return(retval) ;
	if(RET_USER_ESC == retval) {
		InitHdr(HV_CHAR,HV_DOUBLE);
		WriteFields((char *)&s_sth,HDR_ST_FLD,HDR_END_FLD);

	     	s_sth.s_mesg[0] = HV_CHAR ;
	     	DispMesgFld((char *)&s_sth);

		return(RET_USER_ESC) ;
	}

	return(NOERROR);
}
/*------------------------------------------------------------*/
/* Read Item Details from the User */

AddItems()
{
	int	i, err ;

	/* If the last node of po is Partial filled then Show Page */
	if(CurLast != NULL && CurLast->NoItems < PAGESIZE ) {
		ret( ShowItems(CurLast) ) ;
		i = CurLast->NoItems ;
		CurPage = CurLast ;
	}
	else {
		/* Calculate the page# */
		if(CurLast != NULL) {
			i = PAGESIZE ;
			CurPage = CurLast ;
		}
		else {
			strcpy(s_sth.s_dummy,"-");
			s_sth.s_page = 1 ;
			ret( WriteFields((char *)&s_sth,PAGE_FLD,PAGE_FLD+100));
			i = 0 ;
		}
	}


	for( ; ; ) {
		if( PAGESIZE == i) {	/* Page Full */

			/* Calculate the page# */
			s_sth.s_page = CurLast->Pageno + 1 ;

			ret( WriteFields((char *)&s_sth,PAGE_FLD, 
				(END_FLD - 200)) ) ;

			i = 0 ;
		}

		err = ReadItem(i,ADD) ;		/* Read Each Item Line */
		if(PROFOM_ERR == err || DBH_ERR == err) return(err) ;
		if(NOERROR != err) break ;	/* ESC-F */

		if(0 == i)	/* First Item in the Page */
			if((err = MakeFreshPage()) < 0) return(err) ;
		
		/* Copy the Item to List */
		scpy((char*)&(CurPage->Items[i]), (char*)&(s_sth.s_items[i]),
			sizeof(S_item)) ;

		CurPage->I_Status[0] = ADDITEMS;

		i++ ;

		CurPage->NoItems = i;
	}
	if(i == 0) 
		if((err=ShowItems(CurPage))<0) return(err) ;

	return(NOERROR) ;
}	/* AddItems() */
/*-----------------------------------------------------------------------*/
/*	Get the next node in linked list to add invoice items. If the
*	(Cur. invc last page) = (Last Page in linked List) or no
*	nodes in list, allocate node and add to linked list
*/

MakeFreshPage()
{
	Page	*tempptr ;

	/* If, no node is allocated yet or Current invoice used all the nodes,
	   then allocate new node */

	if( LastPage == NULL || CurLast == LastPage ){
		tempptr= (Page *)malloc((unsigned)sizeof(Page)) ;

		if( tempptr == NULL ){
			DispError((char*)&s_sth,"Memory Allocation Error");
			return(ERROR);
		}
		tempptr->NextPage = NULL ;

		if( LastPage == NULL ){	/* No node is allocated Yet */
			tempptr->PrevPage = NULL ;
			tempptr->Pageno = 1 ;
			FirstPage = tempptr ;
		}
		else {				/* Not a first node in list */
			tempptr->Pageno = LastPage->Pageno + 1 ;
			LastPage->NextPage = tempptr ;
			tempptr->PrevPage = LastPage ;
		}
		LastPage = tempptr ;
	}

	if(CurLast == NULL)
		CurLast = FirstPage ;
	else
		CurLast = CurLast->NextPage ;

	CurLast->NoItems = 0 ;
	CurPage = CurLast ;

	return(NOERROR);
}	/* MakeFreshPage() */
/*----------------------------------------------------------*/
/* Get the key and show the record */
SelectRecord(mode)
int	mode;
{
	int	err ;

	err = ReadKey();
	if(err != NOERROR) return(err) ;

	strcpy(class_rec.c_code,s_sth.s_class_cd);
	class_rec.c_date = s_sth.s_eff_date;
	err = get_class(&class_rec,mode,0,e_mesg);
	if(err < 0) {
		DispError((char *)&s_sth,e_mesg);
		return(err);
	}

	err = ShowScreen();
	if(err < 0) {
		return(err);
	}

	return(NOERROR);
}	/* SelectRecord() */
/*------------------------------------------------------------*/
ShowScreen()
{
	int	err ;


	err = ShowHdr();
	if(err < 0) {
		return(err);
	}

	/* Get area records i.e. Build list */
	err = BuildList();
	if(err < 0 && err != EFL) {
		return(err);
	}

	err = ShowItems(CurPage);
	if(err < 0) {
		return(err);
	}
	
	return(NOERROR);
}
/*------------------------------------------------------------*/
BuildList()
{
	int retval;
	int i;
	int j;
	CurLast = CurPage = NULL;
	i = 0;

	
	strcpy(class_item.ci_code,class_rec.c_code);
	class_item.ci_date = class_rec.c_date;
	class_item.ci_fund = 0;
	flg_reset(CLASS_ITEM);

	for( ; ; ) {
		retval = get_n_class_it(&class_item,BROWSE,0,FORWARD,e_mesg);
		if(retval < 0) {
			if(retval == EFL) break;
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}

		if(strcmp(class_item.ci_code,class_rec.c_code)!=0) { 
			break;
		}
		if(class_item.ci_date != class_rec.c_date) {
			break;
		}

		if(PAGESIZE == i) i = 0;
		if(i == 0) {
			if((retval = MakeFreshPage()) < 0) return(retval);
		}

		CurPage->Items[i].s_fund = class_item.ci_fund;
		strcpy(CurPage->Items[i].s_status,ACTIVE);
		strcpy(CurPage->Items[i].s_cpp_acct,class_item.ci_cpp_acct);
		strcpy(CurPage->Items[i].s_uic_acct,class_item.ci_uic_acct);

		for(j=0;j<NO_KEYS;j++) {
			CurPage->Items[i].s_cpp_keys[j] = 
					class_item.ci_cpp_keys[j];
			CurPage->Items[i].s_uic_keys[j] = 
					class_item.ci_uic_keys[j];
		}
		CurPage->I_Status[0] = ' ';
		CurPage->NoItems++;
		i++;
	}
	seq_over(CLASS_ITEM);


	if(CurLast != NULL) {
		CurPage = FirstPage;
	}

	if(retval == EFL) return(retval);
	return(NOERROR);
}
/*------------------------------------------------------------*/
ShowHdr() 
{
	int	retval;
	
	/* Copy Record to Screen */
	strcpy(s_sth.s_class_cd,class_rec.c_code);
	s_sth.s_eff_date = class_rec.c_date;
	
	strcpy(s_sth.s_desc,class_rec.c_desc);
	strcpy(s_sth.s_position,class_rec.c_pos);
	s_sth.s_yr_income = class_rec.c_yrly_inc;
	s_sth.s_unit_yr = class_rec.c_units;

	ret( WriteFields((char *)&s_sth, KEY_START, HDR_END_FLD) );
	
	return(NOERROR);
}
/*------------------------------------------------------------*/
/* Show all the items on the current page 		      */
ShowItems(pageptr)
Page	*pageptr ;
{
	int	i ;


	if(pageptr != NULL) {
		/* Copy the items to screen */
		scpy((char*)s_sth.s_items, (char*)pageptr->Items,
			(pageptr->NoItems * sizeof(S_item)) );

		s_sth.s_page   = pageptr->Pageno ;
		strcpy(s_sth.s_dummy,"-");
		i = pageptr->NoItems ;
	}
	else {
		s_sth.s_page = HV_SHORT ;
		s_sth.s_dummy[0] = HV_CHAR;
		i = 0 ;
	}

	/* Move High Values to remaining Items */
	for( ; i < PAGESIZE ; i++ )
		InitItem(HV_CHAR,HV_SHORT,HV_LONG);

	ret( WriteFields((char *)&s_sth, PAGE_FLD, (END_FLD - 200)) );

	return(NOERROR) ;
}	/* ShowItems() */
/*-----------------------------------------------------------------------*/ 
/* Process all the items in the link list and write any changes to the   */
/* file.								 */
/*-----------------------------------------------------------------------*/ 
ProcItemUpdates(mode)
int	mode;
{
	Page	*temppage;
	int	i;
	int	retval;
	int	write_mode;

	scpy((char *)&pre_class,(char *)&class_rec,sizeof(class_rec));
	
	/* Write Header */
	strcpy(class_rec.c_code,s_sth.s_class_cd);
	class_rec.c_date = s_sth.s_eff_date;
	strcpy(class_rec.c_desc,s_sth.s_desc);
	class_rec.c_yrly_inc = s_sth.s_yr_income;
	class_rec.c_units = s_sth.s_unit_yr;
	strcpy(class_rec.c_pos,s_sth.s_position);

	retval = put_class(&class_rec,mode,e_mesg);
	if(retval < 0) {
		DispError((char *)&s_sth,e_mesg);
		roll_back(e_mesg);
		return(retval);
	}

	if(mode != ADD) {
		retval = rite_audit((char*)&s_sth,CLASSIFICATION,mode,(char*)&class_rec,
			(char*)&pre_class,e_mesg);
		if(retval==LOCKED) {
			DispError((char *)&s_sth,e_mesg);
			roll_back(e_mesg) ;
			return(LOCKED) ;
		}
		if(retval < 0 ){
			DispError((char *)&s_sth,"ERROR: Saving Records"); 
			DispError((char *)&s_sth,e_mesg);
			roll_back(e_mesg);
			return(retval);
		}
	}


	if(CurLast != NULL) {
	   for(temppage=FirstPage; temppage!=NULL;temppage=temppage->NextPage) {
	      for(i =0; i< temppage->NoItems; i++) {
		 retval = GetMode(temppage,i,mode,&write_mode);
		 if(write_mode == NOOP) continue;
		 retval = WriteRecords(temppage,i,write_mode);
  		 if(retval < 0) {
			if(retval == LOCKED) return(LOCKED);
		   	break;
		 }
	      }
	      if(temppage == CurLast) break;
	   }
	}
	return(NOERROR);
}
/*-----------------------------------------------------------------------*/ 
GetMode(temppage,item_no,mode,write_mode)
Page	*temppage;
int	item_no;
int	mode;
int	*write_mode;
{
	if(mode == ADD) {
		if(strcmp(temppage->Items[item_no].s_status,INACTIVE)==0) { 
			*write_mode = NOOP;
		}
		else {
			*write_mode = ADD;
		}
	}
	else if(mode == UPDATE) {
		if(strcmp(temppage->Items[item_no].s_status,INACTIVE)==0) {
			*write_mode = P_DEL;
		}
		else if(temppage->I_Status[0] == ADDITEMS) {
			*write_mode = ADD;
		}
		else if(temppage->I_Status[0] == CHANGE) {
			*write_mode = UPDATE;
		}
		else if(temppage->I_Status[0] == ' ') {
			*write_mode = NOOP;
		}
	}
	else if(mode == P_DEL) {
		*write_mode = P_DEL;
	}

	return(NOERROR);
}
/*-----------------------------------------------------------------------*/ 
/* Write the Area record to the file.			 		 */ 
/*-----------------------------------------------------------------------*/ 
WriteRecords(temppage,item_no,mode)
Page	*temppage;
int	item_no;
int	mode;
{
	int	retval;
	int	i;

	scpy((char *)&pre_class_item,(char *)&class_item,sizeof(class_item));

	strcpy(class_item.ci_code,s_sth.s_class_cd);
	class_item.ci_date = s_sth.s_eff_date;
	if(mode != ADD) {
		retval = get_class_it(&class_item,UPDATE,0,e_mesg) ;
		if(retval < 0) {
			DispError((char *)&s_sth,e_mesg);
			roll_back(e_mesg);
			return(retval);
		}
	}
	class_item.ci_fund = temppage->Items[item_no].s_fund;
	strcpy(class_item.ci_cpp_acct,temppage->Items[item_no].s_cpp_acct);
	strcpy(class_item.ci_uic_acct,temppage->Items[item_no].s_uic_acct);


	/* If system is not intergrated with General Ledger there is no need
	   to update account file 					     */
/*
	if( pay_param.pr_up_gl[0] == 'Y') {
		if(temppage->Items[item_no].s_cpp_acct[0] == '\0') {
			retval = UpdateCPPAcct(temppage,item_no,mode);
		}
		else{	
			retval = UpdateAccount(temppage,item_no,temppage->Items[item_no].s_cpp_acct,mode, "C");
		}

		if(retval < 0) {
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}
		if(temppage->Items[item_no].s_uic_acct[0] == '\0') {
			retval = UpdateUICAcct(temppage,item_no,mode);
		}
		else{	
			retval = UpdateAccount(temppage,item_no,temppage->Items[item_no].s_uic_acct,mode, "U");
		}

		if(retval < 0) {	
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}
	}
*/

	for(i=0;i<NO_KEYS;i++) {
		class_item.ci_cpp_keys[i] = 
			temppage->Items[item_no].s_cpp_keys[i];
		class_item.ci_uic_keys[i] = 
			temppage->Items[item_no].s_uic_keys[i];
	}

	retval = put_class_it(&class_item,mode,e_mesg) ;
	if(retval < 0) {
		DispError((char *)&s_sth,e_mesg);
		roll_back(e_mesg);
		return(retval);
	}

	if(mode != ADD) {
		retval = rite_audit((char*)&s_sth,CLASS_ITEM,mode,(char*)&class_item,
			(char*)&pre_class_item,e_mesg);
		if(retval==LOCKED) {
			DispError((char *)&s_sth,e_mesg);
			roll_back(e_mesg) ;
			return(LOCKED) ;
		}
		if(retval < 0 ){
			DispError((char *)&s_sth,"ERROR: Saving Records"); 
			DispError((char *)&s_sth,e_mesg);
			roll_back(e_mesg);
			return(retval);
		}
	}

	retval = commit(e_mesg) ;
	if(retval < 0) {
		DispError((char *)&s_sth,"ERROR: Saving Records"); 
		DispError((char *)&s_sth,e_mesg);
		roll_back(e_mesg);
		return(retval);
	}
	return(NOERROR);
}
/****************************************************************************/
UpdateCPPAcct(temppage,item_no,mode) 
Page	*temppage;
int	item_no;
int	mode;
{
	int	i,	retval;
	int	ch_mod;
	/*  If changing from account to keys the Payroll GL account record 
	    set up for school zero must be deleted */
	if(mode == UPDATE) {
		gl_acct.gl_fund = temppage->Items[item_no].s_fund;
		gl_acct.gl_cc = 0;
		gl_acct.gl_type[0] = 'C';
		gl_acct.gl_earn[0] = '\0';
		gl_acct.gl_class[0] = '\0';
		retval = get_glacct(&gl_acct,UPDATE,0,e_mesg);
		if(retval >= 0) {
			retval = put_glacct(&gl_acct,P_DEL,e_mesg);
			if(retval < 0) {
				DispError((char *)&s_sth,e_mesg);
				roll_back(e_mesg);
				return(retval);
			}
		}
	}
	school.sc_numb = 0;
	flg_reset(SCHOOL);

	for( ;; ) {   /* For each Cost Center */
		retval = get_n_sch(&school,BROWSE,0,FORWARD,e_mesg);
		if(retval < 0 ) {
			if(retval == EFL) break;
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}
		gl_acct.gl_fund = temppage->Items[item_no].s_fund;
		gl_acct.gl_cc = school.sc_numb;
		gl_acct.gl_type[0] = 'C';
		gl_acct.gl_earn[0] = '\0';
		gl_acct.gl_class[0] = '\0';
		if(mode == UPDATE || mode == P_DEL) {
			retval = get_glacct(&gl_acct,UPDATE,0,e_mesg);
			if(retval < 0)  {
				if(retval == EFL || retval == UNDEF) 
					if(mode == UPDATE)
						ch_mod = ADD;
					else
						continue;
				else {
					DispError((char *)&s_sth,e_mesg);
					return(retval);
				}
			}
			else
				ch_mod = mode;
		}
		retval = 0;
		if( mode == UPDATE ) {
			retval = NO_CHANGE;
			for(i=0 ; i < NO_KEYS ; i++) {
				if(temppage->Items[item_no].s_cpp_keys[i] != class_item.ci_cpp_keys[i]) {
					retval = GetNewAcct(temppage,item_no,"C");
					break;
				}
			}
		}
		else  {
			if( mode == ADD ) {
				retval = GetNewAcct(temppage,item_no,"C");
			}
		}
					/* No Change in Keys */
		if(retval == NO_CHANGE) continue; 

		if(retval == NOTFOUND) 
			continue; 	/* No G/L Acct for the CC# */

		strcpy(gl_acct.gl_acct, gl_rec.accno);
			
		retval = put_glacct(&gl_acct,ch_mod,e_mesg);
		if(retval < 0) {
			DispError((char *)&s_sth,e_mesg);
			roll_back(e_mesg);
			return(retval);
		}
	}
	return(NOERROR);
}	/* UpdateCPPAcct */
/****************************************************************************/
UpdateUICAcct(temppage,item_no,mode) 
Page	*temppage;
int	item_no;
int	mode;
{
	int	i,	retval;
	int	ch_mod;
	/*  If changing from account to keys the Payroll GL account record 
	    set up for school zero must be deleted */
	if(mode == UPDATE) {
		gl_acct.gl_fund = temppage->Items[item_no].s_fund;
		gl_acct.gl_cc = 0;
		gl_acct.gl_type[0] = 'U';
		gl_acct.gl_earn[0] = '\0';
		gl_acct.gl_class[0] = '\0';
		retval = get_glacct(&gl_acct,UPDATE,0,e_mesg);
		if(retval >= 0) {
			retval = put_glacct(&gl_acct,P_DEL,e_mesg);
			if(retval < 0) {
				DispError((char *)&s_sth,e_mesg);
				roll_back(e_mesg);
				return(retval);
			}
		}
		retval = 0;
	}
	school.sc_numb = 0;
	flg_reset(SCHOOL);

	for( ;; ) {   /* For each Cost Center */
		retval = get_n_sch(&school,BROWSE,0,FORWARD,e_mesg);
		if(retval < 0 ) {
			if(retval == EFL) break;
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}
		gl_acct.gl_fund = temppage->Items[item_no].s_fund;
		gl_acct.gl_cc = school.sc_numb;
		gl_acct.gl_type[0] = 'U';
		gl_acct.gl_earn[0] = '\0';
		gl_acct.gl_class[0] = '\0';
		if(mode == UPDATE || mode == P_DEL) {
			retval = get_glacct(&gl_acct,UPDATE,0,e_mesg);
			if(retval < 0)  {
				if(retval == EFL || retval == UNDEF) { 
					if(mode == UPDATE)
						ch_mod = ADD;
					else
						continue;
				}
				else {
					DispError((char *)&s_sth,e_mesg);
					return(retval);
				}
			}
			else
				ch_mod = mode;
		}
		retval = 0;
		if( mode == UPDATE ) {
			retval = NO_CHANGE;
			for(i=0 ; i < NO_KEYS ; i++) {
				if(temppage->Items[item_no].s_uic_keys[i] != class_item.ci_uic_keys[i]) {
					retval = GetNewAcct(temppage,item_no,"U");
					break;
				}
			}
		}
		else  {
			if( mode == ADD ) {
				retval = GetNewAcct(temppage,item_no,"U");
			}
		}
					/* No Change in Keys */
		if(retval == NO_CHANGE) continue; 

		if(retval == NOTFOUND) 
			continue; 	/* No G/L Acct for the CC# */

		strcpy(gl_acct.gl_acct, gl_rec.accno);
			
		retval = put_glacct(&gl_acct,ch_mod,e_mesg);
		if(retval < 0) {
			DispError((char *)&s_sth,e_mesg);
			roll_back(e_mesg);
			return(retval);
		}
	}
	return(NOERROR);
}	/* UpdateUICAcct */
/***************************************************************************/
/*  Not using keys only a gl account number but if changed must be updated */
UpdateAccount(temppage,item_no,accno,mode,type)
Page	*temppage;
int	item_no;
char	*accno;
int	mode;
char	*type;
{
	int	retval;
	gl_acct.gl_fund = temppage->Items[item_no].s_fund;
	gl_acct.gl_cc = 0;
	gl_acct.gl_type[0] = type[0];
	gl_acct.gl_earn[0] = '\0';
	gl_acct.gl_class[0] = '\0';
	flg_reset(GLACCT);
	for( ;; ) {
		retval = get_n_glacct(&gl_acct,UPDATE,0,FORWARD,e_mesg);
		if(retval < 0)  {
			if(retval == EFL) break;
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}
		if(temppage->Items[item_no].s_fund != gl_acct.gl_fund) break;
		if(gl_acct.gl_type[0] != type[0]) continue;
		retval = put_glacct(&gl_acct,P_DEL,e_mesg);
		if(retval < 0) {
			DispError((char *)&s_sth,e_mesg);
			roll_back(e_mesg);
			return(retval);
		}
	}
	gl_acct.gl_fund = temppage->Items[item_no].s_fund;
	gl_acct.gl_cc = 0;
	gl_acct.gl_type[0] = type[0];
	gl_acct.gl_earn[0] = '\0';
	gl_acct.gl_class[0] = '\0';
	strcpy(gl_acct.gl_acct, accno);
		
	retval = put_glacct(&gl_acct,ADD,e_mesg);
	if(retval < 0) {
		DispError((char *)&s_sth,e_mesg);
		roll_back(e_mesg);
		return(retval);
	}
	return(NOERROR);
}
/*---------------------------------------------------------------*/
/* Read Sequentially through the glmast file to get G/L Account   */
GetNewAcct(temppage,item_no,type)
Page	*temppage;
int	item_no;
char	type[2];
{
	int	account_flg;		/* Found/NotFound G/L Account */
	int	retval, i;

	gl_rec.reccod = 99;
	gl_rec.funds = temppage->Items[item_no].s_fund;
	gl_rec.sect = 0;
	gl_rec.accno[0] = '\0';
	flg_reset(GLMAST);

	for( ;; ) {
		retval = get_n_gl(&gl_rec,BROWSE,2,FORWARD,e_mesg);
		if(retval < 0) {
			if(retval == EFL) { 
				return(NOTFOUND);
			}
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}
		if( gl_rec.funds != temppage->Items[item_no].s_fund ) {
			return(NOTFOUND);
		}
		account_flg = FOUND;
		for(i=0;i < NO_KEYS; i++) {
			if(type[0] == 'C') {
				if(pay_param.pr_cpp_exp[i][0] == 'Y') {
					if(gl_rec.keys[i] != temppage->Items[item_no].s_cpp_keys[i]) {
						account_flg = NOTFOUND;
						break;
					}
				}
			}
			if(type[0] == 'U') {
				if(pay_param.pr_uic_exp[i][0] == 'Y') {
					if(gl_rec.keys[i] != temppage->Items[item_no].s_uic_keys[i]) {
						account_flg = NOTFOUND;
						break;
					}
				}
			}
		}
		if(account_flg == NOTFOUND) continue;
		if(gl_rec.keys[pay_param.pr_cost-1] != school.sc_numb) 
			continue;
		
		return(FOUND);
	}
}

/*------------------------------------------------------------*/
/* Read details of given item# */
/*------------------------------------------------------------*/
ReadItem(item_no,mode)
int	item_no ;
int	mode ;
{
	int	i;
	int	st_fld ;
	int	end_fld ;

	if(mode == ADD) {
		SetDupBuffers(ITEM_ST_FLD, END_FLD - 200,0);
	}
	else {
		SetDupBuffers(ITEM_ST_FLD, END_FLD - 200,1);
	
	}

#ifdef ENGLISH
	strcpy(s_sth.s_mesg,"Press ESC-F to Terminate");
#else
	strcpy(s_sth.s_mesg,"Appuyer sur ESC-F pour terminer");
#endif
	DispMesgFld((char *)&s_sth);

	st_fld  = ITEM_ST_FLD ;
	end_fld  = ITEM_END_FLD ;
	InitItem(LV_CHAR,LV_SHORT,LV_LONG);
	if(mode == ADD) {
		strcpy(s_sth.s_items[0].s_status,ACTIVE);
	}
	i = ReadFields((char *)&s_sth,st_fld,end_fld,Validation,WindowHelp,1) ;
	if(PROFOM_ERR == i || DBH_ERR == i) return(i) ;
	if(RET_USER_ESC == i) {
		if(mode == ADD) {
			InitItem(HV_CHAR,HV_SHORT,HV_LONG);
			WriteFields((char *)&s_sth,st_fld,end_fld);
			return(RET_USER_ESC);
		}
		/* When user gives ESC-F while changing fields, assumption is
		* he completed his changes, and remaining fields are same as
		* old. But, at this point STH will be having low values in the 
		* remaining fields. So move the old values form the linked list.
		*/

		i = CopyBack((char *)&s_sth,(char *)&image,sr.curfld, END_FLD);
		if(i == PROFOM_ERR) return(i);

		return(RET_USER_ESC) ;
	}

	return(NOERROR) ;
}	/* ReadItem() */
/*----------------------------------------------------------------*/
/* Set Duplication buffers for fields 				  */
SetDupBuffers( firstfld, lastfld, value )
int	firstfld, lastfld;	/* field numbers range */
int	value;			/* ENABLE or DISABLE */
{
	int i ;

	for( i=firstfld; i<=lastfld; i+=100 )
		fomca1( i, 19, value);
	if( value==0 )
		return(0);
	sr.nextfld = firstfld;
	sr.endfld = lastfld;
	fomud( (char *)&s_sth );
	ret( err_chk(&sr) );

	return( 0 );
}
/*----------------------------------------------------------------*/
/* Validation function() for Key and Header fields when PROFOM returns
  RET_VAL_CHK */

Validation()
{
	int	retval;
	int	i;

	switch(sr.curfld){
	case KEY_START:
		Right_Justify_Numeric(s_sth.s_class_cd,
			sizeof(s_sth.s_class_cd)-1);
		strcpy(class_rec.c_code,s_sth.s_class_cd);
		class_rec.c_date = 0;
		flg_reset(CLASSIFICATION);
		retval = get_n_class(&class_rec,BROWSE,0,FORWARD,e_mesg);
		if(s_sth.s_fn[0] != ADDREC) {
			if(retval < 0) {
				fomer("Classification Code Does not Exist");
				s_sth.s_class_cd[0] = LV_CHAR;
				return(ERROR);
			}
			if(strcmp(class_rec.c_code,s_sth.s_class_cd) != 0) {
				fomer("Classification Code Does not Exist");
				s_sth.s_class_cd[0] = LV_CHAR;
				return(ERROR);
			}
		}
		break;
	case KEY_END:
		if(s_sth.s_eff_date == 0) {
			fomer("Invalid Date. Please Re-Enter.");
			s_sth.s_eff_date = LV_LONG;
			return(ERROR);
		}

		strcpy(class_rec.c_code,s_sth.s_class_cd);
		class_rec.c_date = s_sth.s_eff_date;
		retval = get_class(&class_rec,BROWSE,0,e_mesg);

		if(s_sth.s_fn[0] != ADDREC) {
			if(retval < 0) {
				fomer("Date Does not Exist for Classification Code");
				s_sth.s_eff_date = LV_LONG;
				return(ERROR);
			}
		}
		else {
			if(retval != UNDEF) {
				fomer("Classification Already Exists");
				s_sth.s_eff_date = LV_LONG;
				return(ERROR);
			}
		}
		break;
	case DESC_FLD:
		if(s_sth.s_desc[0] == '\0') {
			fomer("This is a Required Field");
			return(ERROR);
		}
		break;
	case POS_FLD:
		Right_Justify_Numeric(s_sth.s_position,
			sizeof(s_sth.s_position)-1);
		strcpy(pos_rec.p_code,s_sth.s_position);
		retval = get_position(&pos_rec,BROWSE,0,e_mesg);
		if(retval < 0) {
			fomer("Invalid Position Code");
			s_sth.s_position[0] = LV_CHAR;
			return(ERROR);
		}
		break;
	case YRINC_FLD:
	case UNITS_FLD:
		break;
	case FUND_FLD:
		if(CheckFund(s_sth.s_items[0].s_fund)<0) {
			s_sth.s_items[0].s_fund = LV_SHORT;
			return(ERROR);
		}
		break;
	case CPP_ACCT:
		if(s_sth.s_items[0].s_cpp_acct[0] != '\0') {
			if(acnt_chk(s_sth.s_items[0].s_cpp_acct) < 0) {
				fomer("Invalid Account Number");
				s_sth.s_items[0].s_cpp_acct[0] = LV_CHAR;
				return(ERROR);
			}
			if(pa_rec.pa_glmast[0] == YES) {
			   gl_rec.funds = s_sth.s_items[0].s_fund;
			   strcpy(gl_rec.accno,s_sth.s_items[0].s_cpp_acct);
			   gl_rec.reccod = 99;
			   retval = get_gl(&gl_rec,BROWSE,0,e_mesg);
			   if(retval < 0) {
				fomer(e_mesg);
				s_sth.s_items[0].s_cpp_acct[0]=LV_CHAR;
				return(ERROR);
			   }
			   for(i=0;i<NO_KEYS;i++){
				s_sth.s_items[0].s_cpp_keys[i] = gl_rec.keys[i];
	 		   }
			}
			else {
				for(i=0;i<NO_KEYS;i++){
					s_sth.s_items[0].s_cpp_keys[i] = 0;
				}
			}
		}
		else {
			sr.curfld += 100;
		}
		break;
	case CPP_KEY1:
	case CPP_KEY2:
	case CPP_KEY3:
	case CPP_KEY4:
	case CPP_KEY5:
	case CPP_KEY6:
	case CPP_KEY7:
	case CPP_KEY8:
	case CPP_KEY9:
	case CPP_KEY10:
	case CPP_KEY11:
	case CPP_KEY12:
		break;
	case UIC_ACCT:
		if(s_sth.s_items[0].s_uic_acct[0] != '\0') {
			if(acnt_chk(s_sth.s_items[0].s_uic_acct) < 0)  {
				fomer("Invalid Account Number");
				s_sth.s_items[0].s_uic_acct[0] = LV_CHAR;
				return(ERROR);
			}
			if(pa_rec.pa_glmast[0] == YES) {
			   gl_rec.funds = s_sth.s_items[0].s_fund;
			   strcpy(gl_rec.accno,s_sth.s_items[0].s_uic_acct);
			   gl_rec.reccod = 99;
			   retval = get_gl(&gl_rec,BROWSE,0,e_mesg);
			   if(retval < 0) {
				fomer(e_mesg);
				s_sth.s_items[0].s_uic_acct[0]=LV_CHAR;
				return(ERROR);
			   }
			   for(i=0;i<NO_KEYS;i++){
				s_sth.s_items[0].s_uic_keys[i] = gl_rec.keys[i];
	 		   }
			}
			else {
			   for(i=0;i<NO_KEYS;i++){
				s_sth.s_items[0].s_uic_keys[i] = 0;
			   }
			}
		}
		else {
			sr.curfld += 100;
		}

		break;
	case UIC_KEY1:
	case UIC_KEY2:
	case UIC_KEY3:
	case UIC_KEY4:
	case UIC_KEY5:
	case UIC_KEY6:
	case UIC_KEY7:
	case UIC_KEY8:
	case UIC_KEY9:
	case UIC_KEY10:
	case UIC_KEY11:
	case UIC_KEY12:
		break;
	default:
#ifdef ENGLISH
		sprintf(e_mesg,"No Validity Check for Field#  %d",sr.curfld);
		
#else
		sprintf(e_mesg,"Pas de controle de validite pour le Champ#  %d",sr.curfld);
#endif
		fomen(e_mesg);
		get();
		return(ERROR) ;
	}	/* Switch sr.curfld */

	return(NOERROR) ;
}	/* Validation() */
/*----------------------------------------------------------------*/
/* Show Help Windows, if applicable, when user gives ESC-H in key
   and header fields */

WindowHelp()
{
	int	retval ;
	int	item_no;
	short	reccod;
	int	i;

	switch(sr.curfld){
	case KEY_START:
		retval = class_hlp(s_sth.s_class_cd,
				&s_sth.s_eff_date,7,13);
		if(retval == DBH_ERR) return(retval);
		if(retval >= 0) redraw();
		if(retval == 0) return(ERROR);
		if(retval < 0) return(ERROR);
		strcpy(class_rec.c_code,s_sth.s_class_cd);
		class_rec.c_date = s_sth.s_eff_date;
		retval = get_class(&class_rec,BROWSE,0,e_mesg);
		if(retval < 0) {
			fomer(e_mesg);
			s_sth.s_class_cd[0] = LV_CHAR;
			return(ERROR);
		}
		break;
	case KEY_END:
		retval = class_hlp(s_sth.s_class_cd,
				&s_sth.s_eff_date,7,13);
		if(retval == DBH_ERR) return(retval);
		if(retval >= 0) redraw();
		if(retval == 0) return(ERROR);
		if(retval < 0) return(ERROR);
		strcpy(class_rec.c_code,s_sth.s_class_cd);
		class_rec.c_date = s_sth.s_eff_date;
		retval = get_class(&class_rec,BROWSE,0,e_mesg);
		if(retval < 0) {
			fomer(e_mesg);
			s_sth.s_eff_date = LV_LONG;
			return(ERROR);
		}
		break;
	case POS_FLD:
		retval = position_hlp(s_sth.s_position,7,13);
		if(retval == DBH_ERR) return(retval);
		if(retval >= 0) redraw();
		if(retval == 0) return(ERROR);
		if(retval < 0) return(ERROR);
		break;
	case CPP_ACCT:
		if(pa_rec.pa_glmast[0] == YES) {
			retval = gl_hlp(s_sth.s_items[0].s_fund,
				s_sth.s_items[0].s_cpp_acct,&reccod, 7, 13 );
			if(retval == DBH_ERR) return(retval) ;
			if(retval >=0 ) redraw();
			if(retval < 1) return(ERROR) ;	/* Not Selected */
			if(reccod != 99) {
#ifdef ENGLISH
				fomer("Select records with 99 as Record Code only");
#else
				fomer("Choisir les fiches avec 99 seulement comme code de fiche");
#endif
				s_sth.s_items[0].s_cpp_acct[0] = LV_CHAR ;
				return(ERROR) ;
			}
			gl_rec.funds = s_sth.s_items[0].s_fund;
			strcpy(gl_rec.accno,s_sth.s_items[0].s_cpp_acct);
			gl_rec.reccod = reccod;
			retval = get_gl(&gl_rec,BROWSE,0,e_mesg);
			if(retval < 0) {
				fomer(e_mesg);
				s_sth.s_items[0].s_cpp_acct[0]=LV_CHAR;
				return(ERROR);
			}

			for(i=0;i<NO_KEYS;i++){
				s_sth.s_items[0].s_cpp_keys[i] = gl_rec.keys[i];
			}
		}
		break;
	case UIC_ACCT:
		if(pa_rec.pa_glmast[0] == YES) {
			retval = gl_hlp(s_sth.s_items[0].s_fund,
				s_sth.s_items[0].s_uic_acct,&reccod, 7, 13 );
			if(retval == DBH_ERR) return(retval) ;
			if(retval >=0 ) redraw();
			if(retval < 1) return(ERROR) ;	/* Not Selected */
			if(reccod != 99) {
#ifdef ENGLISH
				fomer("Select records with 99 as Record Code only");
#else
				fomer("Choisir les fiches avec 99 seulement comme code de fiche");
#endif
				s_sth.s_items[0].s_uic_acct[0] = LV_CHAR ;
				return(ERROR) ;
			}
			gl_rec.funds = s_sth.s_items[0].s_fund;
			strcpy(gl_rec.accno,s_sth.s_items[0].s_uic_acct);
			gl_rec.reccod = reccod;
			retval = get_gl(&gl_rec,BROWSE,0,e_mesg);
			if(retval < 0) {
				fomer(e_mesg);
				s_sth.s_items[0].s_uic_acct[0]=LV_CHAR;
				return(ERROR);
			}

			for(i=0;i<NO_KEYS;i++){
				s_sth.s_items[0].s_uic_keys[i] = gl_rec.keys[i];
			}
		}
		break;
	default :
		fomer("No Help Window for This Field");
	}	/* Switch sr.curfld */

	return(NOERROR) ;
}	/* HdrAndKeyWindowHelp() */
/*-----------------------------------------------------------------------*/
CheckFund(fund)
short	fund;
{
	int	retval;
	int	i;
	Page	*temppage;
	Ctl_rec	ctl_rec;

	if(fund == 0) {
		fomer("This is a Required Field");
		return(ERROR);
	}

	if(pa_rec.pa_glmast[0] == YES) {
		ctl_rec.fund = fund;
		retval = get_ctl(&ctl_rec,BROWSE,0,e_mesg);
		if(retval < 0 && retval != UNDEF) {
			DispError((char *)&s_sth);
			return(retval);
		}
		if(retval == UNDEF) {
			fomer("Fund Does not Exist");
			return(ERROR);
		}
	}
	/* check to see if item is already in list */
	if(CurLast != NULL) {
	   for(temppage=FirstPage; temppage!=NULL;temppage=temppage->NextPage) {
	      for(i =0; i< temppage->NoItems; i++) {
			/* if same page as shown on screen */
			if(temppage->Pageno == s_sth.s_page) {
				continue;
			}
			if(temppage->Items[0].s_fund == fund) {
				fomer("Fund Already Entered on Screen");
				return(ERROR);
			}
	      }
	      if(temppage == CurLast) break;
	   }
	}

	return(NOERROR);
}
/*-----------------------------------------------------------------------*/
/* Take the confirmation from user for the items part of the screen      */
/*-----------------------------------------------------------------------*/
ConfirmItems()
{
	int	err ;

	/* Options:
	     YSLNPC
	*/

	for( ; ; ) {
	    if(s_sth.s_fn[0] == DELETE) {
#ifdef ENGLISH
			err = GetOption((char *)&s_sth,"Y(es), C(ancel)","YC");
#else
			err = GetOption((char *)&s_sth,"O(ui), A(nnul)","OA");
#endif
	    }
	    else if(s_sth.s_fn[0] != INQUIRE) {
#ifdef ENGLISH
			err = GetOption((char *)&s_sth,
		"Y(es), A(dd), H(eader), L(ine), D(el), R(eactivate), N(ext), P(rev), C(ancel)"
		,"YAHLDRNPC");
#else
			err = GetOption((char *)&s_sth,
		"O(ui), S(creen edit), L(ine edit), S(uiv), P(rec), A(nnul)"
		,"OSLA");
#endif
	    }
	    else {
#ifdef ENGLISH
			err = GetOption((char *)&s_sth,
		"Y(es), N(ext), P(rev)","YNP");
#else
			err = GetOption((char *)&s_sth,
		"O(ui), S(uiv), P(rec)" ,"OSP");
#endif
	    }
	    switch(err) {
	    case  YES  :
		return(YES);
	    case  ADDITEMS:
		err = AddItems();
		break;
	    case  HEADEREDIT:
		err = HeaderEdit();
		break;
	    case  LINEEDIT  :
		err = LineEdit();
		break ;
	    case  DELITEM:
	    case  REACTITEM:
		err = ChangeStatus(err);
		break;
	    case  NEXT:
		if(CurPage == CurLast || CurLast == NULL) {
#ifdef ENGLISH
			fomer("No More Pages....");
#else
			fomer("Plus de pages....");
#endif
			continue;
		}
		CurPage = CurPage->NextPage ;
		err = ShowItems(CurPage);
		break;
	    case  PREV:
		if(CurLast == NULL || CurPage == FirstPage) {
#ifdef ENGLISH
			fomer("No More Pages....");
#else
			fomer("Plus de pages....");
#endif
			continue;
		}
		CurPage = CurPage->PrevPage ;
		err = ShowItems(CurPage);
		break;
	    case  CANCEL :
#ifdef ENGLISH
		err = GetOption((char *)&s_sth,
				"Confirm the Cancel (Y/N)?", "YN") ;
#else
		err = GetOption((char *)&s_sth,
				"Confirmer l'annulation (O/N)?", "ON") ;
#endif
		if(err == YES) return(CANCEL) ;
		break ;
	    }	/* switch err */

	    if(err == PROFOM_ERR) return(err) ;
	    if(err == DBH_ERR) return(err) ;
	}	/* for(; ; ) */
}	/* ConfirmItems() */
/*---------------------------------------------------------------------*/
/* Change Header.  Allows editing of the students on the screen        */
/*---------------------------------------------------------------------*/
HeaderEdit()
{
     	int i;
	int retval;

	/* make copy of screen incase user presses ESC-F */
	scpy((char *)&image,(char *)&s_sth,sizeof(s_sth));

#ifdef ENGLISH
	strcpy(s_sth.s_mesg,"Press ESC-F to Terminate");
#else
	strcpy(s_sth.s_mesg,"Appuyer sur ESC-F pour terminer");
#endif
	DispMesgFld((char *)&s_sth);

	if(SetDupBuffers(HDR_ST_FLD, HDR_END_FLD,1)<0) return(PROFOM_ERR);

	retval = ReadHdr(UPDATE);
	if(retval != NOERROR && retval != RET_USER_ESC) {
		return(retval);
	}

	if(retval == RET_USER_ESC) 
		return(retval);

     	s_sth.s_mesg[0] = HV_CHAR ;
     	DispMesgFld((char *)&s_sth);

	if(SetDupBuffers(HDR_ST_FLD, HDR_END_FLD,0)<0) return(PROFOM_ERR);

	return(NOERROR);
}	/* HeaderEdit() */

/*---------------------------------------------------------------------*/
/* Change Line items.  Allows editing of the students on the screen    */
/*---------------------------------------------------------------------*/
LineEdit()
{
     	int i;
	int retval;

	/* make copy of screen incase user presses ESC-F */
	scpy((char *)&image,(char *)&s_sth,sizeof(s_sth));

#ifdef ENGLISH
	strcpy(s_sth.s_mesg,"Press ESC-F to Terminate");
#else
	strcpy(s_sth.s_mesg,"Appuyer sur ESC-F pour terminer");
#endif
	DispMesgFld((char *)&s_sth);

	if(SetDupBuffers(ITEM_ST_FLD, END_FLD - 200,1)<0) return(PROFOM_ERR);

	for(i=0;i<CurPage->NoItems;i++) {
		if(strcpy(CurPage->Items[i].s_status,INACTIVE)==0) {
			fomer("Item Has a Deleted Status");
			continue;
		}
		retval = ReadItem(i,UPDATE);
		if(retval != NOERROR && retval != RET_USER_ESC) {
			return(retval);
		}

		if(retval == RET_USER_ESC) 
			return(retval);

		scpy((char*)&(CurPage->Items[i]), 
		     (char*)&(s_sth.s_items[i]),sizeof(S_item)) ;
		if(s_sth.s_fn[0] == CHANGE) {
			CurPage->I_Status[0] = CHANGE;
		}
	}

     	s_sth.s_mesg[0] = HV_CHAR ;
     	DispMesgFld((char *)&s_sth);

	if(SetDupBuffers(ITEM_ST_FLD, END_FLD-200,0)<0) return(PROFOM_ERR);

	return(NOERROR);
}	/* LineEdit() */
/*------------------------------------------------------------------------*/
/*------------------------------------------------------------------------*/
ChangeStatus(status)
int	status;
{
	int	retval;
	int	st_fld, end_fld;

	if ((strcmp(s_sth.s_items[0].s_status,INACTIVE)!=0)&&
		(strcmp(s_sth.s_items[0].s_status,ACTIVE)!=0))
	  {
		fomer ("No items on screen");
		return(NOERROR);
	}

	if(status == DELITEM) {
		
		if(strcmp(s_sth.s_items[0].s_status,INACTIVE)==0) {
			fomer("Item is Already Deleted");
		}
		else {
			strcpy(s_sth.s_items[0].s_status,INACTIVE);
		}
	}
	else {
		if(strcmp(s_sth.s_items[0].s_status,ACTIVE)==0) {
			fomer("Item is Already Active");
		}
		else {
			strcpy(s_sth.s_items[0].s_status,ACTIVE);
		}
	}
	/* Update Linked List *
	scpy((char*)&(CurPage->Items[s_sth.s_field -1]), 
	     (char*)&(s_sth.s_items[s_sth.s_field -1]),sizeof(S_item)) ;
	*/
		
	/* Update Linked List */
	strcpy (CurPage->Items[0].s_status,
		 s_sth.s_items[0].s_status);

	ret(WriteFields((char *)&s_sth,STATUS_FLD,STATUS_FLD));
	
	return(NOERROR);
}
/*------------------------------------------------------------------------*/
/* Move High values to all data fields and clear the screen */

ClearScreen()
{
	int	i;

	/* Move High Values to Hedaer part */
	s_sth.s_page = HV_SHORT;
	s_sth.s_dummy[0] = HV_CHAR;
	
	InitHdr(HV_CHAR,HV_DOUBLE);

	/* Move High Values to The one item */
	InitItem(HV_CHAR,HV_SHORT,HV_LONG);

	ret( WriteFields((char *)&s_sth,HDR_ST_FLD, (END_FLD - 200)) );

	return(NOERROR);
}	/* ClearScreen() */
/*-------------------------------------------------------------------------*/
InitHdr(t_char,t_double)
char	t_char;
double	t_double;
{
	s_sth.s_desc[0] = t_char;
	s_sth.s_position[0] = t_char;
	s_sth.s_yr_income = t_double;
	s_sth.s_unit_yr = t_double;

	return(NOERROR);
}
/*-------------------------------------------------------------------------*/
/* Initialize Given screen item with either Low values or High values */

InitItem(t_char, t_short, t_long)
char	t_char ;
short	t_short ;
long	t_long ;
{
	int	i;

	s_sth.s_items[0].s_fund = t_short ;
	if(t_char == HV_CHAR) {
		s_sth.s_items[0].s_status[0] = t_char ;
	}
	s_sth.s_items[0].s_cpp_acct[0] = t_char ;
	s_sth.s_items[0].s_uic_acct[0] = t_char ;
	for(i=0;i<NO_KEYS;i++) {
		s_sth.s_items[0].s_cpp_keys[i] = t_long ;
		s_sth.s_items[0].s_uic_keys[i] = t_long ;
	}

	return(NOERROR) ;
}	/* Inititem() */
/*-------------------- E n d   O f   P r o g r a m ---------------------*/
