/*-----------------------------------------------------------------------
Source Name: reg_pen.c
System     : Personnel/Payroll.
Created  On: 20th Oct 91.
Created  By: Andre Cormier

DESCRIPTION:

MODIFICATIONS:        

Programmer     YY/MM/DD       Description of modification
------------------------------------------------------------------------*/
#define	MAIN		/* Main program. This is to declare Switches */
#define MAINFL		REG_PEN			/* main file used */

#define	SYSTEM		"Setup"			/* Sub System Name */
#define	MOD_DATE	"20-OCT-91" 		/* Progran Last Modified */

#include <stdio.h>
#include <cfomstrc.h>
#include <bfs_defs.h>
#include <bfs_pp.h>
#include <bfs_com.h>

/* User Interface define constants */
#ifdef ENGLISH
#define ADDREC		'A'
#define CHANGE		'C'
#define DELETE		'D'
#define INQUIRE		'I'
#define EXITOPT		'E'
#define	NEXT		'N'
#define	PREV		'P'

#define	YES		'Y'
#define NO		'N'
#define	LINEEDIT	'L'
#define SCREENEDIT	'S'
#define	CANCEL		'C'

#define	FIXED		'F'
#define	PERCENT		'P'

#else
#define ADDREC		'R'
#define CHANGE		'C'
#define DELETE		'E'
#define INQUIRE		'I'
#define EXITOPT		'F'
#define	NEXT		'S'
#define	PREV		'P'

#define	YES		'O'
#define NO		'N'
#define	LINEEDIT	'L'
#define SCREENEDIT	'S'
#define	CANCEL		'A'

#define	FIXED		'F'
#define	PERCENT		'P'

#endif

#define	FOUND		0
#define	NOTFOUND	1
#define	NO_CHANGE	2

/* PROFOM Releted declarations */

#define	SCR_NAME	"reg_pen"	/* PROFOM screen Name */

#define MAX_FIELD	28		/* Maximum field # to edit */

/* PROFOM Screen STH file */

/* Field PROFOM numbers */
#define	FN_FLD		400	/* Fn: */
#define	KEY_START	500	/* Registered Pension  Code: */
#define	KEY_END		600	/* Pay Period Code: */
#define	CHG_FLD		700	/* Field: */

#define DESC_FLD	900	/*  Description: 			*/
#define SEC_CODE_FLD 	1000	/*  Second Code 			*/
#define REG_NUM_FLD 	1100	/*  Registration Number 		*/
#define PAC_FLD 	1200	/*  Pension Adjustable Calculation	*/
#define	TYPE_FLD	1300	/*  Type				*/
#define PER_RATE_FLD1	1400	/*  Percentage Rate 1			*/
#define AMOUNT_FLD	1500	/*  Amount				*/
#define PER_RATE_FLD2	1600	/*  Percentage Rate 2			*/
#define AMOUNT2_FLD	1700	/*  Amount				*/
#define PER_RATE_FLD3	1800	/*  Percentage Rate 3			*/
#define EMPLOYEE_SH_FLD	1900	/*  Employee Share			*/
#define EMPLOYER_SH_FLD	2000	/*  Employer Share			*/
#define MIN_EARNING_FLD	2100	/*  Minimum Earnings			*/
#define YR_MAX_EAR_FLD	2200	/*  Maximum Year Contribution		*/
#define DED_PP_FLD1	2300	/*  Deduction Montly Pay Period 1	*/
#define DED_PP_FLD2	2400	/*  Deduction Montly Pay Period 2	*/
#define DED_PP_FLD3	2500	/*  Deduction Montly Pay Period 3	*/
#define DED_PP_FLD4	2600	/*  Deduction Montly Pay Period 4	*/
#define DED_PP_FLD5	2700	/*  Deduction Montly Pay Period 5	*/
#define FUND_NUM_FLD	2800	/*  Fund Number				*/
#define LIABILITY_FLD	2900	/*  Liability G/L Account		*/
#define DUMMY_FLD	3000	/*  Display line for keys		*/
#define KEY_FLD1	3100	/*  Key 1				*/
#define KEY_FLD2	3200	/*  Key 2				*/
#define KEY_FLD3	3300	/*  Key 3				*/
#define KEY_FLD4	3400	/*  Key 4				*/
#define KEY_FLD5	3500	/*  Key 5				*/
#define KEY_FLD6	3600	/*  Key 6				*/
#define KEY_FLD7	3700	/*  Key 7				*/
#define KEY_FLD8	3800	/*  Key 8				*/
#define KEY_FLD9	3900	/*  Key 9				*/
#define KEY_FLD10	4000	/*  Key 10				*/
#define KEY_FLD11	4100	/*  Key 11				*/
#define KEY_FLD12	4200	/*  Key 12				*/


#define START_FLD	900	/* First Field on screen 		*/
#define	END_FLD		4400	/* Last Field of the screen 		*/
/* bargain.sth - header for C structure generated by PROFOM EDITOR */

typedef struct	{

	char	s_pgname[11];		/* 100 STRING X(10)		*/
	long	s_rundate;		/* 300 DATE YYYYFMMFDD 		*/
	char	s_fn[2];		/* 400 STRING X 		*/
	char	s_reg_pen_code[7];	/* 500 STRING X(6) 		*/
	char	s_pp_code[7];		/* 600 STRING X(6) 		*/
	short	s_field;		/* 700 NUMERIC 99 		*/
	char	s_desc[31];		/* 900 STRING X(30)		*/
	char	s_sec_code[3];		/* 1000 STRING X(2)		*/
	char	s_reg_num[13];		/* 1100 STRING X(12)		*/
	short	s_pac;			/* 1200 NUMERIC 99		*/
	char	s_type[3];		/* 1300 STRING XX		*/
	double	s_per_rate1;		/* 1400 NUMERIC 999.99		*/
	double	s_amount;		/* 1500 NUMERIC 99F999.99	*/
	double	s_per_rate2;		/* 1600 NUMERIC 999.99		*/
	double	s_amount2;		/* 1500 NUMERIC 99F999.99	*/
	double	s_per_rate3;		/* 1700 NUMERIC 999.99		*/
	double	s_employee_sh;		/* 1800 NUMERIC 999.99		*/
	double	s_employer_sh;		/* 1900 NUMERIC 999.99		*/
	double	s_min_earnings;		/* 2000 NUMERIC 99F999.99	*/
	double	s_max_cont;		/* 2100 NUMERIC 9F999F999.99	*/
	char	s_ded_mon_pp[5][2];	/* 2200 - 2600 STRING X		*/
	short	s_fund_num;		/* 2700 NUMERIC 9		*/
	char	s_lia_acc[19];		/* 2800 STRING X(18)		*/
	char	s_dummy[2];		/* 2900 STRING X		*/
	long	s_key[12];		/* 3000 - 4100 NUMERIC 9(5)	*/

	char	s_mesg[78];		/* 4200 STRING X(77) */
	char	s_resp[2];		/* 4300 STRING X */
} s_struct;

static	s_struct  s_sth,image;		/* PROFOM Screen Structure */
static	struct  stat_rec  sr;		/* PROFOM status rec */

static	char 	e_mesg[100];  		/* dbh will return err msg in this */

static	Pay_param	pay_param;
static	Gl_rec		gl_rec;
static	Pay_per		pay_per;
static	Reg_pen		reg_pen,pre_reg_pen;
static	Ctl_rec		ctl_rec;
static	Gl_acct		gl_acct;
static	Sch_rec		school;

int	Validation() ;
int	WindowHelp();
int	Argc;
char	**Argv;

void	free() ;
char	*malloc() ;

main(argc,argv)
int argc;
char *argv[];
{
	int 	retval;

	/* These two are passed to execute() when it is called */
	Argc = argc;
	Argv = argv;

	retval = Initialize(argc,argv);	/* Initialization routine */

	if (retval == NOERROR) retval = Process();

	CloseRtn();			/* return to menu */
	if (retval != NOERROR) exit(-1);
	exit(0);

}	/* main() */

/*-------------------------------------------------------------------*/
/* Initialize PROFOM */

Initialize(argc, argv)
int	argc ;
char	*argv[] ;
{
	int	err ;

	/*
	*	Initialize DBH Environment
	*/
	strncpy(SYS_NAME,SYSTEM,50);	/* Sub system name */
	strncpy(CHNG_DATE,MOD_DATE,10);	/* Modification Date */

	proc_switch(argc, argv, MAINFL) ; 	/* Process Switches */

	/*
	*	Initialize PROFOM & Screen
	*/
	strcpy(sr.termnm,terminal);	/* Copy Terminal Name */
	fomin(&sr);
	ret(err_chk(&sr)) ;		/* Check for PROFOM Error */
	fomcf(1,1);			/* Enable Snap screen option */

	err = InitScreen() ;		/* Initialize Screen */
	if(NOERROR != err) return(err) ;

	/*
	*	Get The Parameter Record
	*/
	err = get_pay_param(&pay_param, BROWSE, 1, e_mesg) ;
	if(err == ERROR) {
		DispError((char *)&s_sth,e_mesg);
		return(ERROR) ;
	}
	s_sth.s_sec_code[0] = HV_CHAR;

	return(NOERROR) ;

}	/* Initialize() */

/*--------------------------------------------------------------------------*/
/* Close nessary files and environment before exiting program               */

CloseRtn() 
{
	/* Set terminal back to normal mode from PROFOM */
	fomcs();
	fomrt();

	close_dbh();	/* Close files */

	return(NOERROR);

}	/* CloseRtn() */

/*----------------------------------------------------------------*/
/* Initialize screen before going to process options */

InitScreen()
{
	int	err ;

	/* move screen name to Profom status structure */
	strcpy(sr.scrnam,NFM_PATH);
	strcat(sr.scrnam,SCR_NAME) ;

	strcpy(s_sth.s_pgname,PROG_NAME);

	s_sth.s_rundate = get_date();	/* get Today's Date in YYYYMMDD format*/
	s_sth.s_field = HV_SHORT ;
	s_sth.s_mesg[0] = HV_CHAR ;
	s_sth.s_resp[0] = HV_CHAR ;

	/* Initialize Key Fields. So that, if user selectes 'N' option
	   immediately after invoking program, then he gets the first
	   record in the file */

	s_sth.s_reg_pen_code[0] = '\0';
	s_sth.s_pp_code[0] = '\0';

	/* Move High Values to data fields and Display the screen */
	err = ClearScreen() ;
	if(NOERROR != err) return(err) ;

	return(NOERROR) ;

}	/* InitScreen() */

/*-------------------------------------------------------------------*/
/* Get Option from user and call corresponding function */

Process()
{
	int err;

	for( ; ; ){

		/* Get the Fn: option from the user */
		if((err = ReadFunction()) != NOERROR) return(err) ;

		err = ProcFunction() ;	/* Process Function */

		if(QUIT == err)		return(NOERROR) ;    /* Exit */
		if(NOACCESS == err)	fomen(e_mesg);	     /* security */
		if(PROFOM_ERR == err)	return(PROFOM_ERR);  /* PROFOM ERROR */
		if(DBH_ERR == err) {
			DispError((char *)&s_sth,e_mesg);
#ifdef ENGLISH
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"System Error... Iserror:",
				iserror, dberror, errno);
#else
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"Erreur du systeme... Iserror:",
				iserror, dberror, errno);
#endif
			DispError((char *)&s_sth,e_mesg);
			return(DBH_ERR); /* DBH ERROR */
		}
	}      /*   end of the for( ; ; )       */

}	/* Process() */

/*----------------------------------------------------------------*/
/* Display the Function (Fn:) options and get the option from the user */

ReadFunction()
{
	/* Display Fn: options */
#ifdef ENGLISH
	fomer("A(dd), C(hange), D(elete), I(nquire), N(ext), P(rev), E(xit)");
#else
	fomer("R(ajouter), C(hanger), E(liminer), I(nterroger), S(uivant), P(recedent), F(in)");
#endif
	/* Read Fn: field to get the option */
	sr.nextfld = FN_FLD ;
	fomrf( (char *)&s_sth );
	ret(err_chk(&sr));	/* Check for PROFOM error */

	return(NOERROR) ;

}	/* ReadFunction() */

/*----------------------------------------------------------------*/
/* Process the user selected Fn: option */

ProcFunction()
{
	int	retval;

	switch (s_sth.s_fn[0]) {
	case ADDREC  :			/* ADD */
		CHKACC(retval,ADD,e_mesg);
		return( Add() ) ;
	case CHANGE  :			/* CHANGE */
		CHKACC(retval,UPDATE,e_mesg);
		return( Change() ) ;
	case DELETE  :			/* CHANGE */
		CHKACC(retval,UPDATE,e_mesg);
		return( Delete() ) ;
	case INQUIRE  :			/* Inquire */
		CHKACC(retval,BROWSE,e_mesg);
		return( Inquire() ) ;
	case NEXT  :			/* Next */
		CHKACC(retval,BROWSE,e_mesg);
		return( Next(FORWARD) ) ;
	case PREV  :			/* Previous */
		CHKACC(retval,BROWSE,e_mesg);
		return( Next(BACKWARD) ) ;
	case EXITOPT  :			/* Exit */
		return( QUIT ) ;
	}  /*   end of the switch statement */

	return(NOERROR);

}	/* ProcFunction() */

/*----------------------------------------------------------------------*/
/* Adding.  Get the unique Key, accept details and update the files */
Add()
{
	int	err ;

	for( ;; ) {
		err = ReadKey();
		if(err != NOERROR) return(err) ;
		strcpy(reg_pen.rg_code,s_sth.s_reg_pen_code);
		strcpy(reg_pen.rg_pp_code,s_sth.s_pp_code);
		err = get_reg_pen(&reg_pen,BROWSE,0,e_mesg);
		if(err == UNDEF) break;
		if(err == NOERROR) {
			fomen("Register Pension Already Exist");
			continue;
		}
		if(err < 0)  {
			fomen(e_mesg);
			get();
			return(err);
		}
	}

	/* Clear The Screen */
	err = ClearScreen();
	if(err != NOERROR) return(err) ;

	err = GetDetails() ;
	if(PROFOM_ERR == err || DBH_ERR == err) return(err) ;
	if(err < 0 || CANCEL == err) {
		roll_back(e_mesg) ;	/* Unlock the locked Records */
		return(ClearScreen()) ;	/* Clear the Screen */
	}

	return(NOERROR);

}	/* Add() */

/*-----------------------------------------------------------------------*/
/* Change. Students Study halls and update the files if a day/semester   */
/* is changed to NO delete record.			  		 */
/*-----------------------------------------------------------------------*/
Change()
{
	int	err ;

	err = SelectRecord() ;
	if(NOERROR != err) return(err) ;

	for( ; ; ) {
		err = Confirm() ;
		if(err != YES) {
			roll_back(e_mesg);
			break;
		}

		err = WriteRecords(UPDATE) ;
		if(err==NOERROR) break;
		if(err==LOCKED) {
			roll_back(e_mesg) ;
			continue;
		}
		if (err < 0) {
			roll_back(e_mesg);
			return(err) ;
		}
	}

	return(NOERROR) ;

}	/* Change() */

/*-----------------------------------------------------------------------*/
/* Delete. Student Study Hall Records.  */
/*-----------------------------------------------------------------------*/
Delete()
{
	int	err ;

	err = SelectRecord() ;
	if(NOERROR != err) return(err) ;

	for( ; ; ) {
		err = Confirm() ;
		if(err != YES) {
			roll_back(e_mesg);
			break;
		}

		err = WriteRecords(P_DEL) ;
		if(err==NOERROR) break;
		if(err==LOCKED) {
			roll_back(e_mesg) ;
			continue;
		}
		if (err < 0) {
			roll_back(e_mesg);
			return(err) ;
		}
	}

	return(NOERROR) ;

}	/* Delete() */

/*-----------------------------------------------------------------------*/
/* Show Student Student halls base on users input */
Inquire()
{
	int	err ;

	err = SelectRecord() ;
	if(NOERROR != err) return(err) ;

	return(NOERROR) ;

}	/* Inquire() */

/*----------------------------------------------------------*/
/* Show the next or previous Students Study halls */

Next(direction)
int	direction ;
{
	int retval;

	strcpy(reg_pen.rg_code,s_sth.s_reg_pen_code);
	strcpy(reg_pen.rg_pp_code,s_sth.s_pp_code);
	if (flg_start(REG_PEN) != direction) {
		inc_str(reg_pen.rg_pp_code, sizeof(reg_pen.rg_pp_code)-1, 
			direction);
		flg_reset(REG_PEN);
	}

	retval = get_n_reg_pen(&reg_pen, BROWSE, 0, direction, e_mesg);
#ifndef ORACLE
	seq_over(REG_PEN);
#endif
	if(ERROR == retval)return(DBH_ERR) ;
	if(EFL == retval) {
		fomen("No More Records....");
		get();
		return(NOERROR) ;
	}

	retval = ShowScreen(BROWSE);

	return(NOERROR) ;

}	/* Next() */

/*------------------------------------------------------------*/
/* Allows User to Add Record to File */
/*------------------------------------------------------------*/
GetDetails()
{
	int	i ;
	int	err;

	err = ReadScreen(ADD);
	if(PROFOM_ERR == err || DBH_ERR == err) return(err) ;
	if(RET_USER_ESC == err){
		return(RET_USER_ESC) ;
	}

	for( ; ; ) {
		i = Confirm() ;
		if(i != YES) break;

		i = WriteRecords(ADD) ;
		if(i < 0) {
			if(i == LOCKED) continue;
		}
		break;
	}
	if(i != NOERROR) return(i);
	return(NOERROR) ;

}	/* GetDetails() */

/*------------------------------------------------------------*/
/*------------------------------------------------------------*/
ReadScreen(mode)
int	mode;
{
	int err;

	scpy((char *)&image,(char *)&s_sth,sizeof(image));

	if(mode == ADD) {
		SetDupBuffers(START_FLD,END_FLD,0); /* Off Dup Control */
	}
	else {
		SetDupBuffers(START_FLD,END_FLD,1); /* Off Dup Control */
	}
	
	InitFields(LV_CHAR,LV_SHORT,LV_LONG,LV_DOUBLE);

#ifdef ENGLISH
	strcpy(s_sth.s_mesg,"Press ESC-F to Terminate Edit");
#else
	strcpy(s_sth.s_mesg,"Appuyer sur ESC-F pour terminer l'ajustement");
#endif
	DispMesgFld((char *)&s_sth);

	for(;;) {
		err = ReadFields((char *)&s_sth,START_FLD, END_FLD-200,
			Validation, WindowHelp,1) ;
		if(PROFOM_ERR == err || DBH_ERR == err) return(err) ;
		if(RET_USER_ESC == err){
			if(mode == ADD) {
				InitFields(HV_CHAR,HV_SHORT,HV_LONG,HV_DOUBLE);
				ret(WriteFields((char *)&s_sth,START_FLD,END_FLD-200));
			}
			/* When user gives ESC-F while changing fields,
			   assumption is he completed his changes, and remaining
			   fields are same as old. But, at this point STH will
			   be having low values in the remaining fields. So move
			   the old values form the linked list.  */

			switch(sr.curfld){
			case LIABILITY_FLD:
				s_sth.s_lia_acc[0] = LV_CHAR;
				continue;
			default:		
				err = CopyBack((char *)&s_sth,(char *)&image,
					sr.curfld, END_FLD);
				if(err == PROFOM_ERR) return(err);
				break;
			}
		}
		s_sth.s_mesg[0] = HV_CHAR;
		DispMesgFld((char *)&s_sth);

		break;
	}
	
	return(NOERROR);

}	/* ReadScreen() */

/*----------------------------------------------------------*/
/* Get the key and show the record */
SelectRecord()
{
	int	err ;

	err = ReadKey();
	if(err != NOERROR) return(err) ;

	err = ShowScreen(BROWSE);

	return(NOERROR);

}	/* SelectRecord() */

/*----------------------------------------------------------------------*/
/* Get the Student Study Hall key from user. In ADD mode disable dup buffers, */
/* other modes enable dup buffers and show the current key as a default key */
ReadKey()
{
	int	i;
	char	hold_reg_pen[7];
	char	hold_pp[7];
	
	/* In Add mode turn off dup control for key fields.
	   Other modes reverse it */
	if(s_sth.s_fn[0] == ADDREC){	/* ADD */
		SetDupBuffers(KEY_START,KEY_END,0); /* Off Dup Control */
	}
	else {
		SetDupBuffers(KEY_START,KEY_END,1);
	}

#ifdef ENGLISH
	strcpy(s_sth.s_mesg,"Press ESC-F to Go Back to Fn:");
#else
	strcpy(s_sth.s_mesg,"Appuyer sur ESC-F pour retourner a Fn:");
#endif
	DispMesgFld((char *)&s_sth);

	strcpy(hold_reg_pen,s_sth.s_reg_pen_code);
	strcpy(hold_pp,s_sth.s_pp_code);

	s_sth.s_reg_pen_code[0] = LV_CHAR;
	s_sth.s_pp_code[0] = LV_CHAR;

	i = ReadFields((char *)&s_sth,KEY_START, KEY_END,
		Validation, WindowHelp,1) ;
	if(PROFOM_ERR == i || DBH_ERR == i) return(i) ;
	if(RET_USER_ESC == i){
		strcpy(s_sth.s_reg_pen_code,hold_reg_pen);
		strcpy(s_sth.s_pp_code,hold_pp);
		
		ret( WriteFields((char *)&s_sth,KEY_START, KEY_END) ) ;

		s_sth.s_mesg[0] = HV_CHAR;
		DispMesgFld((char *)&s_sth);

		return(RET_USER_ESC) ;
	}

	s_sth.s_mesg[0] = HV_CHAR;
	DispMesgFld((char *)&s_sth);

	return(NOERROR);

}	/*  ReadKey() */

/*-----------------------------------------------------------------------*/ 
/* Check to see if record is to be added, changed or deleted .		 */
/*-----------------------------------------------------------------------*/ 
WriteRecords(mode)
int mode;
{
	int	i,retval;

	strcpy(reg_pen.rg_code,s_sth.s_reg_pen_code);
	strcpy(reg_pen.rg_pp_code,s_sth.s_pp_code);
	if(mode != ADD) {
		retval = get_reg_pen(&reg_pen,UPDATE,0,e_mesg);
		if(retval < 0) {
			fomer(e_mesg);
			return(retval);
		}
	}

	strcpy(reg_pen.rg_code,s_sth.s_reg_pen_code);
	strcpy(reg_pen.rg_pp_code,s_sth.s_pp_code);
	strcpy(reg_pen.rg_desc,s_sth.s_desc);
	reg_pen.rg_pac = s_sth.s_pac;
	strcpy(reg_pen.rg_dd_code,s_sth.s_sec_code);
	strcpy(reg_pen.rg_reg_num,s_sth.s_reg_num);
	strcpy(reg_pen.rg_type,s_sth.s_type);

	if(s_sth.s_per_rate1 == HV_DOUBLE)
		reg_pen.rg_perc1 = 0.00;
	else
		reg_pen.rg_perc1 = s_sth.s_per_rate1;

	if(s_sth.s_per_rate2 == HV_DOUBLE)
		reg_pen.rg_perc2 = 0.00;
	else
		reg_pen.rg_perc2 = s_sth.s_per_rate2;

	if(s_sth.s_per_rate3 == HV_DOUBLE)
		reg_pen.rg_perc3 = 0.00;
	else
		reg_pen.rg_perc3 = s_sth.s_per_rate3;

	if(s_sth.s_amount == HV_DOUBLE)
		reg_pen.rg_amount = 0.00;
	else
		reg_pen.rg_amount = s_sth.s_amount;

	if(s_sth.s_amount2 == HV_DOUBLE)
		reg_pen.rg_amount2 = 0.00;
	else
		reg_pen.rg_amount2 = s_sth.s_amount2;

	reg_pen.rg_employer_sh = s_sth.s_employer_sh;
	reg_pen.rg_min_earn = s_sth.s_min_earnings;
	reg_pen.rg_max_contr = s_sth.s_max_cont;
	for(i = 0;i < 5;i++) {
		strcpy(reg_pen.rg_ded_pp[i],s_sth.s_ded_mon_pp[i]);
	}
	reg_pen.rg_fund = s_sth.s_fund_num;
	strcpy(reg_pen.rg_lia_acct,s_sth.s_lia_acc);
	for(i = 0;i < 12;i++) {
		reg_pen.rg_exp_acct[i] = s_sth.s_key[i];
	}

	/* If system is not intergrated with General Ledger there is no need
	   to update account file 					     */
/*

	if( pay_param.pr_up_gl[0] == 'Y') {
		retval = UpdateAcct(mode);
		if(retval < 0) {
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}
	}
*/

	retval = put_reg_pen(&reg_pen,mode,e_mesg);
	if(retval < 0) {
		DispError((char *)&s_sth,e_mesg);
		roll_back(e_mesg);
		return(retval);
	}

	if(mode != ADD) {
		retval = rite_audit((char*)&s_sth,REG_PEN,mode,(char*)&reg_pen,
			(char*)&pre_reg_pen,e_mesg);
		if(retval==LOCKED) {
			DispError((char *)&s_sth,e_mesg);
			roll_back(e_mesg) ;
			return(LOCKED) ;
		}
		if(retval < 0 ){
#ifdef	ENGLISH
			DispError((char *)&s_sth,"ERROR in Saving Records"); 
#else
			DispError((char *)&s_sth,
					"ERREUR en conservant les fiches");
#endif
			DispError((char *)&s_sth,e_mesg);
			roll_back(e_mesg);
			return(retval);
		}
	}

	retval = commit(e_mesg) ;
	if(retval < 0) {
#ifdef ENGLISH
		DispError((char *)&s_sth,"ERROR in Saving Records"); 
#else
		DispError((char *)&s_sth,"ERREUR en conservant les fiches");
#endif
		DispError((char *)&s_sth,e_mesg);
		roll_back(e_mesg);
		return(retval);
	}

	return(NOERROR);

}	/* WriteRecords90 */

/*----------------------------------------------------------------*/
/* Set Duplication buffers for fields 				  */
SetDupBuffers( firstfld, lastfld, value )
int	firstfld, lastfld;	/* field numbers range */
int	value;			/* ENABLE or DISABLE */
{
	int i ;
	
	for( i=firstfld; i<=lastfld; i+=100 )
		fomca1( i, 19, value);
	if( value==0 )
		return(0);
	sr.nextfld = firstfld;
	sr.endfld = lastfld;
	fomud( (char *)&s_sth );
	ret( err_chk(&sr) );

	return(NOERROR);

}	/* SetDupBuffers() */

/*----------------------------------------------------------------*/
/* Validation function() for Key and Header fields when PROFOM returns
  RET_VAL_CHK */

Validation()
{
	int	i, retval;

	switch(sr.curfld){
	case KEY_START:
		Right_Justify_Numeric(s_sth.s_reg_pen_code,
			sizeof(s_sth.s_reg_pen_code)-1);
		break;
	case KEY_END:
		Right_Justify_Numeric(s_sth.s_pp_code,
			sizeof(s_sth.s_pp_code)-1);
		strcpy(pay_per.pp_code,s_sth.s_pp_code);
		pay_per.pp_year = 0;
		flg_reset(PAY_PERIOD);

		retval = get_n_pay_per(&pay_per,BROWSE,0,FORWARD,e_mesg);
		if(retval < 0 || strcmp(pay_per.pp_code,
				        s_sth.s_pp_code)!=0) {
			fomer("Pay Period Code Does not Exist");
			s_sth.s_reg_pen_code[0] = LV_CHAR;
			s_sth.s_pp_code[0] = LV_CHAR;
			sr.curfld -= 100 ;
			return(ERROR);
		}
		seq_over(PAY_PERIOD);
		strcpy(reg_pen.rg_code,s_sth.s_reg_pen_code);
		strcpy(reg_pen.rg_pp_code,s_sth.s_pp_code);
		flg_reset(REG_PEN);
		retval = get_n_reg_pen(&reg_pen,BROWSE,0,FORWARD,e_mesg);
		if(s_sth.s_fn[0] != ADDREC) {
			if(retval < 0) {
				fomer("Registration Pension Code Does not Exist");
				s_sth.s_reg_pen_code[0] = LV_CHAR;
				s_sth.s_pp_code[0] = LV_CHAR;
				sr.curfld -= 100;
				return(ERROR);
			}
			if(strcmp(reg_pen.rg_code, s_sth.s_reg_pen_code) != 0 ||
			   strcmp(reg_pen.rg_pp_code, s_sth.s_pp_code) != 0) {
				fomer("Registration Pension Code Does not Exist");
				s_sth.s_reg_pen_code[0] = LV_CHAR;
				s_sth.s_pp_code[0] = LV_CHAR;
				sr.curfld -= 100;
				return(ERROR);
			}
		}
		break;
	case	DESC_FLD:
		if(s_sth.s_desc[0] == '\0') {
			fomer("This is a Required Field");
			return(ERROR);
		}
		break;
	case	SEC_CODE_FLD:
	case	REG_NUM_FLD:
	case	PAC_FLD:
		break;

	case 	TYPE_FLD:
		if((strcmp(s_sth.s_type,"1A")== 0)||
			(strcmp(s_sth.s_type,"1B")== 0)||
			(strcmp(s_sth.s_type,"1C")== 0)||
			(strcmp(s_sth.s_type,"1D")== 0)||
			(strcmp(s_sth.s_type,"2A")== 0)||
			(strcmp(s_sth.s_type,"2B")== 0)) {
				s_sth.s_amount = HV_DOUBLE;
				s_sth.s_per_rate2 = HV_DOUBLE;
				s_sth.s_per_rate3 = HV_DOUBLE;
				s_sth.s_per_rate1 = LV_DOUBLE;
		}
		else {
			if(strcmp(s_sth.s_type,"3A")== 0) {
					s_sth.s_amount = LV_DOUBLE;
					s_sth.s_per_rate2 = LV_DOUBLE;
					s_sth.s_per_rate3 = HV_DOUBLE;
					s_sth.s_per_rate1 = LV_DOUBLE;
			}
			else {
			  if((strcmp(s_sth.s_type,"4A")== 0) ||
				(strcmp(s_sth.s_type,"4B")== 0)) {
				s_sth.s_amount = LV_DOUBLE;
				s_sth.s_per_rate2 = HV_DOUBLE;
				s_sth.s_per_rate3 = HV_DOUBLE;
				s_sth.s_per_rate1 = HV_DOUBLE;
			  }
			  else
			    if(strcmp(s_sth.s_type,"5A") == 0){
				s_sth.s_per_rate1 = LV_DOUBLE;
				s_sth.s_amount = LV_DOUBLE;
				s_sth.s_per_rate2 = LV_DOUBLE;
				s_sth.s_amount2 = LV_DOUBLE;
				s_sth.s_per_rate3 = LV_DOUBLE;
			  }
			  else {	
				fomen("Invalid Type - Please Re-Enter");
				s_sth.s_type[0] = LV_CHAR;
				return(ERROR);
			  }
			}
		}
		break;
	case	AMOUNT_FLD:
		break;

	case	PER_RATE_FLD1:
	case	PER_RATE_FLD2:
	case	PER_RATE_FLD3:
		if (sr.curfld == PER_RATE_FLD1) {
			if(s_sth.s_per_rate1  < 0.00 ) {
				fomer("This Field Must be greather than or equal to 0");
				s_sth.s_per_rate1 = LV_DOUBLE;
				return(ERROR);
			}
			if(s_sth.s_per_rate1 > 100.00) {
				fomer("This Field Must be Less than or equal to 100");
				s_sth.s_per_rate1 = LV_DOUBLE;
				return(ERROR);
			}
		}
		if (sr.curfld == PER_RATE_FLD2) {
			if(s_sth.s_per_rate2  < 0.00 ) {
				fomer("This Field Must be greather than or equal to 0");
				s_sth.s_per_rate2 = LV_DOUBLE;

				return(ERROR);
			}
			if(s_sth.s_per_rate2 > 100.00) {
				fomer("This Field Must be Less than or equal to 100");
				s_sth.s_per_rate2 = LV_DOUBLE;
				return(ERROR);
			}
		}
		if (sr.curfld == PER_RATE_FLD3) {
			if(s_sth.s_per_rate3  < 0.00 ) {
				fomer("This Field Must be greather than or equal to 0");
				s_sth.s_per_rate3 = LV_DOUBLE;
				return(ERROR);
			}
			if(s_sth.s_per_rate3 > 100.00) {
				fomer("This Field Must be Less than or equal to 100");
				s_sth.s_per_rate3 = LV_DOUBLE;
				return(ERROR);
			}
		}
		break;
	case 	EMPLOYEE_SH_FLD:
		if(s_sth.s_employee_sh  < 0.00 ) {
			fomer("This Field Must be greather than or equal to 0");
			s_sth.s_employee_sh = LV_DOUBLE;
			return(ERROR);
		}
		if(s_sth.s_employee_sh > 100.00) {
			fomer("This Field Must be Less than or equal to 100");
			s_sth.s_employee_sh = LV_DOUBLE;
			return(ERROR);
		}
		s_sth.s_employer_sh = (100.00 - s_sth.s_employee_sh);
		WriteFields((char *)&s_sth, EMPLOYER_SH_FLD, EMPLOYER_SH_FLD);
		break;
	case	MIN_EARNING_FLD:
	case	YR_MAX_EAR_FLD:

		break;

	case	DED_PP_FLD1:
		if (s_sth.s_ded_mon_pp[0][0] != 'Y' &&
		    s_sth.s_ded_mon_pp[0][0] != 'N') {
			fomen("Must enter Y or N");
			get();
			s_sth.s_ded_mon_pp[0][0] = LV_CHAR;
			return(ERROR);
		}
		if(s_sth.s_ded_mon_pp[0][0] == 'N') {
			for(i=1;i<5;i++)
				s_sth.s_ded_mon_pp[i][0] = 'N' ;
		}
		sr.curfld+=100;
		break;
	case	DED_PP_FLD2:
		if (s_sth.s_ded_mon_pp[1][0] != 'Y' &&
		    s_sth.s_ded_mon_pp[1][0] != 'N') {
			fomen("Must enter Y or N");
			get();
			s_sth.s_ded_mon_pp[1][0] = LV_CHAR;
			return(ERROR);
		}
		if(s_sth.s_ded_mon_pp[1][0] == 'N') {
			for(i=2;i<5;i++)
				s_sth.s_ded_mon_pp[i][0] = 'N' ;
		}
		sr.curfld+=100;
		break;
	case	DED_PP_FLD3:
		if (s_sth.s_ded_mon_pp[1][0] != 'Y' &&
		    s_sth.s_ded_mon_pp[1][0] != 'N') {
			fomen("Must enter Y or N");
			get();
			s_sth.s_ded_mon_pp[2][0] = LV_CHAR;
			return(ERROR);
		}
		if(s_sth.s_ded_mon_pp[2][0] == 'N') {
			for(i=3;i<5;i++)
				s_sth.s_ded_mon_pp[i][0] = 'N' ;
		}
		sr.curfld+=100;
		break;
	case	DED_PP_FLD4:
		if (s_sth.s_ded_mon_pp[1][0] != 'Y' &&
		    s_sth.s_ded_mon_pp[1][0] != 'N') {
			fomen("Must enter Y or N");
			get();
			s_sth.s_ded_mon_pp[3][0] = LV_CHAR;
			return(ERROR);
		}
		if(s_sth.s_ded_mon_pp[3][0] == 'N') {
			for(i=4;i<5;i++)
				s_sth.s_ded_mon_pp[i][0] = 'N' ;
		}
		sr.curfld+=100;
		break;
	case	DED_PP_FLD5:
		if (s_sth.s_ded_mon_pp[1][0] != 'Y' &&
		    s_sth.s_ded_mon_pp[1][0] != 'N') {
			fomen("Must enter Y or N");
			get();
			s_sth.s_ded_mon_pp[4][0] = LV_CHAR;
			return(ERROR);
		}
		sr.curfld+=100;
		break;

	case	FUND_NUM_FLD:
		ctl_rec.fund = 000;
		flg_reset(CONTROL);
		for(;;) {
			retval=get_n_ctl(&ctl_rec,BROWSE,0,FORWARD,e_mesg);
			if (retval == EFL) {
				fomen("Fund Number does not Exist");
				s_sth.s_fund_num = LV_SHORT;
				return(ERROR);	
			}

			if(ctl_rec.fund != s_sth.s_fund_num) 
				continue;
			break;
		}
		break;
	case	LIABILITY_FLD:
		Right_Justify_Numeric(s_sth.s_lia_acc,sizeof(gl_rec.accno)-1);
		gl_rec.funds = s_sth.s_fund_num;
		strcpy(gl_rec.accno,s_sth.s_lia_acc);
		gl_rec.reccod = 99;
		retval=get_gl(&gl_rec,BROWSE,0,e_mesg);
		if (retval != 0) {
			fomen("Liability Account Number does not Exist");
			s_sth.s_lia_acc[0] = LV_CHAR;
			return(ERROR);	
		}

		break;

	case	KEY_FLD1:
	case	KEY_FLD2:
	case	KEY_FLD3:
	case	KEY_FLD4:
	case	KEY_FLD5:
	case	KEY_FLD6:
	case	KEY_FLD7:
	case	KEY_FLD8:
	case	KEY_FLD9:
	case	KEY_FLD10:
	case	KEY_FLD11:
	case	KEY_FLD12:
		break;

	default :
#ifdef ENGLISH
		sprintf(e_mesg,"No Validity Check For Field#  %d",sr.curfld);
#else
		sprintf(e_mesg,"Pas de controle de validite pour le Champ#  %d",sr.curfld);
#endif
		fomen(e_mesg);
		get();
		return(ERROR) ;
	}	/* Switch sr.curfld */

	return(NOERROR) ;

}	/* Validation() */
/*----------------------------------------------------------------*/
/* Show Help Windows, if applicable, when user gives ESC-H in key
   and header fields */

WindowHelp()
{
	int	retval ;

	switch(sr.curfld){
	case KEY_START:
		retval = reg_pen_hlp(s_sth.s_reg_pen_code,s_sth.s_pp_code,7,13);
		if(retval == DBH_ERR) return(retval);
		if(retval >= 0) redraw();
		if(retval == 0) return(ERROR);
		if(retval < 0) return(ERROR);
		strcpy(reg_pen.rg_code,s_sth.s_reg_pen_code);
		strcpy(reg_pen.rg_pp_code,s_sth.s_pp_code);
		retval = get_reg_pen(&reg_pen,BROWSE,0,e_mesg);
		if(s_sth.s_fn[0] == ADDREC) {
			if(retval != UNDEF) {
				fomer("Registration Pension Code Already Exist");
				s_sth.s_reg_pen_code[0] = LV_CHAR;
				s_sth.s_pp_code[0] = LV_CHAR;
				return(ERROR);
			}
		}
		else {
			if(retval < 0)  {
				fomer(e_mesg);
				s_sth.s_reg_pen_code[0] = LV_CHAR;
				s_sth.s_pp_code[0] = LV_CHAR;
				return(ERROR);
			}
			SetDupBuffers(KEY_START, KEY_END, 1);
			s_sth.s_pp_code[0] = LV_CHAR ;
		}
		break;
	case KEY_END:
		retval = payper_hlp(s_sth.s_pp_code,7,13);
		if(retval == DBH_ERR) return(retval);
		if(retval >= 0) redraw();
		if(retval == 0) return(ERROR);
		if(retval < 0) return(ERROR);

		strcpy(reg_pen.rg_code,s_sth.s_reg_pen_code);
		strcpy(reg_pen.rg_pp_code,s_sth.s_pp_code);
		flg_reset(REG_PEN);
		retval = get_n_reg_pen(&reg_pen,BROWSE,0,FORWARD,e_mesg);
		if(s_sth.s_fn[0] != ADDREC) {
			if(retval < 0) {
				fomer("Registration Pension Code Does not Exist");
				s_sth.s_reg_pen_code[0] = LV_CHAR;
				s_sth.s_pp_code[0] = LV_CHAR;
				sr.curfld -= 100;
				return(ERROR);
			}
			if(strcmp(reg_pen.rg_code, s_sth.s_reg_pen_code) != 0 ||
			   strcmp(reg_pen.rg_pp_code, s_sth.s_pp_code) != 0) {
				fomer("Registration Pension Code Does not Exist");
				s_sth.s_reg_pen_code[0] = LV_CHAR;
				s_sth.s_pp_code[0] = LV_CHAR;
				sr.curfld -= 100;
				return(ERROR);
			}
		}
		break;
	default :
		fomer("No Help Window For This Field");
	}	/* Switch sr.curfld */

	return(NOERROR) ;

}	/* WindowHelp() */

/*-----------------------------------------------------------------------*/
/* Take the confirmation from user for the header part */

Confirm()
{
	int	err ;

	/* Options:
	   Add      - YALSNPC
	   Change   - YALSNPC
	   Delete   - YC
	*/

	for( ; ; ) {
	    switch(s_sth.s_fn[0]) {
	    case  ADDREC :		/* Add */
#ifdef ENGLISH
		err = GetOption((char *)&s_sth,
		"Y(es), S(creen Edit), L(ine edit), C(ancel)"
		,"YASLC");
#else
		err = GetOption((char *)&s_sth,
		"O(ui), S(creen edit), L(ine edit), A(nnul)"
		,"ORSLA");
#endif
		break ;
	    case  CHANGE :		/* Change */
#ifdef ENGLISH
		err = GetOption((char *)&s_sth,
		"Y(es), S(creen edit), L(ine edit), C(ancel)","YSLC");
#else
		err = GetOption((char *)&s_sth,
		"O(ui), S(creen edit), L(ine edit), A(nnul)","OSLA");
#endif
		break ;
	    case  DELETE :		/* Delete */
#ifdef ENGLISH
		err = GetOption((char *)&s_sth,"Y(es), C(ancel)","YC");
#else
		err = GetOption((char *)&s_sth,"O(ui), A(nnul)","OA");
#endif
		break ;
	    }
	    if(err == PROFOM_ERR) return(err) ;

	    switch(err) {
	    case  YES  :
		return(YES);
	    case  SCREENEDIT:
		err = ReadScreen(UPDATE);
		break;
	    case  LINEEDIT  :
		err = ChangeFields();
		break ;
	    case  CANCEL :
#ifdef ENGLISH
		err = GetOption((char *)&s_sth,
				"Confirm the Cancel (Y/N)?", "YN") ;
#else
		err = GetOption((char *)&s_sth,
				"Confirmer l'annulation (O/N)?", "ON") ;
#endif
		if(err == YES) return(CANCEL) ;
		break ;
	    }	/* switch err */

	    if(err == PROFOM_ERR) return(err) ;
	    if(err == DBH_ERR) return(err) ;
	}	/* for(; ; ) */

}	/* Confirm() */

/*-----------------------------------------------------------*/
ChangeFields()
{
	int	i, retval ;
	int	fld_no, end_fld;

	/* Get The Field to Be Modified */
#ifdef	ENGLISH
	strcpy(s_sth.s_mesg,"Enter RETURN to Terminate Edit");
#else
	strcpy(s_sth.s_mesg,"Appuyer sur RETURN pour terminer l'ajustement");
#endif
	DispMesgFld((char *)&s_sth); ;
        
     	for (; ;) {
		s_sth.s_field = LV_SHORT;
		retval = ReadFields((char *)&s_sth,CHG_FLD,CHG_FLD,
			(int (*)())NULL,(int (*)())NULL, 1);

		if (retval < 0) return(-1);
		if (retval == RET_USER_ESC) break;	/* User enter ESC-F */

       		if (s_sth.s_field == 0 ) break;  /* Finished changing fields */

		if (s_sth.s_field > MAX_FIELD) {
			fomen("Invalid Field Number");
			get();
			continue;
		}

		SetDupBuffers(START_FLD, END_FLD - 200, 1);

		switch(s_sth.s_field) {
		case 1:
			fld_no = end_fld = DESC_FLD;
			break;
		case 2:
			fld_no = end_fld = SEC_CODE_FLD;
			break;
		case 3:
			fld_no = end_fld = REG_NUM_FLD;
			break;
		case 4:
			fld_no = end_fld = PAC_FLD;
			break;
		case 5:
			fld_no = TYPE_FLD;
			end_fld = PER_RATE_FLD3;
			s_sth.s_type[0] = LV_CHAR;
			break;
		case 6:
			if(s_sth.s_per_rate1 != HV_DOUBLE) 
				fld_no = end_fld = PER_RATE_FLD1;
			else
				continue;
			break;
		case 7:
			if(s_sth.s_amount != HV_DOUBLE) 
				fld_no = end_fld = AMOUNT_FLD;
			else
				continue;
			break;
		case 8:
			if(s_sth.s_per_rate2 != HV_DOUBLE) 
				fld_no = end_fld = PER_RATE_FLD2;
			else
				continue;
			break;
		case 9:
			if(s_sth.s_per_rate3 != HV_DOUBLE) 
				fld_no = end_fld = PER_RATE_FLD3;
			else
				continue;
			break;
		case 10:
			fld_no = end_fld = EMPLOYEE_SH_FLD;
			break;
		case 12:
			fld_no = end_fld = MIN_EARNING_FLD;
			break;
		case 13:
			fld_no = end_fld = YR_MAX_EAR_FLD;
			break;
		case 14:
			for (i = 0;i < 5;i++)
				s_sth.s_ded_mon_pp[i][0] = LV_CHAR;
			fld_no = DED_PP_FLD1;
			end_fld = DED_PP_FLD5;
			break;
		case 15:
			s_sth.s_fund_num = LV_SHORT;
			s_sth.s_lia_acc[0] = LV_CHAR;
			fld_no = FUND_NUM_FLD;
			end_fld = LIABILITY_FLD;
			break;
		case 16:
			fld_no = end_fld = LIABILITY_FLD;
			break;
		case 17:
			fld_no = end_fld = KEY_FLD1;
			break;
		case 18:
			fld_no = end_fld = KEY_FLD2;
			break;
		case 19:
			fld_no = end_fld = KEY_FLD3;
			break;
		case 20:
			fld_no = end_fld = KEY_FLD4;
			break;
		case 21:
			fld_no = end_fld = KEY_FLD5;
			break;
		case 22:
			fld_no = end_fld = KEY_FLD6;
			break;
		case 23:
			fld_no = end_fld = KEY_FLD7;
			break;
		case 24:
			fld_no = end_fld = KEY_FLD8;
			break;
		case 25:
			fld_no = end_fld = KEY_FLD9;
			break;
		case 26:
			fld_no = end_fld = KEY_FLD10;
			break;
		case 27:
			fld_no = end_fld = KEY_FLD11;
			break;
		case 28:
			fld_no = end_fld = KEY_FLD12;
			break;
		default:
			fomen("Invalid Field Number");
			get();
			continue;
		} /* switch */

		for(;;) {

			retval = ReadFields((char *)&s_sth,fld_no, end_fld,
				Validation, WindowHelp,1) ;

			if(retval==DBH_ERR||retval==PROFOM_ERR) return(retval);

			if(retval == RET_USER_ESC) {
				if(sr.curfld == LIABILITY_FLD) {
					sr.curfld -= 100;
					continue;
				}
			}
			break;
		}
	}
     	s_sth.s_field = HV_SHORT ;
	if ( WriteFields((char *)&s_sth,CHG_FLD, CHG_FLD) < 0 ) return(-1);

     	s_sth.s_mesg[0] = HV_CHAR ;
     	DispMesgFld((char *)&s_sth);

	if(SetDupBuffers(START_FLD, END_FLD-200, 0)<0) return(PROFOM_ERR);

	return(NOERROR);

}	/* ChangeFields() */

/*-----------------------------------------------------------*/
/* Move Header to Screen Hdr Fields */
ShowScreen(mode)
int	mode;
{
	int	i;

	strcpy(s_sth.s_reg_pen_code,reg_pen.rg_code);
	strcpy(s_sth.s_pp_code,reg_pen.rg_pp_code);
	strcpy(s_sth.s_desc,reg_pen.rg_desc);
	strcpy(s_sth.s_sec_code,reg_pen.rg_dd_code);
	strcpy(s_sth.s_reg_num,reg_pen.rg_reg_num);
	s_sth.s_pac = reg_pen.rg_pac;
	strcpy(s_sth.s_type,reg_pen.rg_type);

	if(reg_pen.rg_perc1 > 0.00) 
		s_sth.s_per_rate1 = reg_pen.rg_perc1;
	else
		s_sth.s_per_rate1 = HV_DOUBLE;

	if(reg_pen.rg_perc2 > 0.00) 
		s_sth.s_per_rate2 = reg_pen.rg_perc2;
	else
		s_sth.s_per_rate2 = HV_DOUBLE;

	if(reg_pen.rg_perc3 > 0.00) 
		s_sth.s_per_rate3 = reg_pen.rg_perc3;
	else
		s_sth.s_per_rate3 = HV_DOUBLE;

	if(reg_pen.rg_amount > 0.00) 
		s_sth.s_amount = reg_pen.rg_amount;
	else
		s_sth.s_amount = HV_DOUBLE;

	if(reg_pen.rg_amount2 > 0.00) 
		s_sth.s_amount2 = reg_pen.rg_amount2;
	else
		s_sth.s_amount2 = HV_DOUBLE;

	s_sth.s_employee_sh = (100 - reg_pen.rg_employer_sh);
	s_sth.s_employer_sh = reg_pen.rg_employer_sh;
	s_sth.s_min_earnings = reg_pen.rg_min_earn;
	s_sth.s_max_cont = reg_pen.rg_max_contr;
	for(i = 0;i < 5;i++) {
		strcpy(s_sth.s_ded_mon_pp[i],reg_pen.rg_ded_pp[i]);
	}
	s_sth.s_fund_num = reg_pen.rg_fund;
	strcpy(s_sth.s_lia_acc,reg_pen.rg_lia_acct);
	s_sth.s_dummy[0] = LV_CHAR;
	if(s_sth.s_dummy[0] == LV_CHAR) 
		s_sth.s_dummy[0] = ' ';
	for(i = 0;i < 12;i++) {
		s_sth.s_key[i] = reg_pen.rg_exp_acct[i];
	}

	ret( WriteFields((char *)&s_sth, KEY_START, END_FLD - 200) ) ;

	return(NOERROR) ;

}	/* ShowScreen() */

/*------------------------------------------------------------------------*/
/* Move High values to all data fields and clear the screen */

ClearScreen()
{
	/* Move High Values to Header part */
	InitFields(HV_CHAR, HV_SHORT, HV_LONG, HV_DOUBLE) ;

	ret( WriteFields((char *)&s_sth,START_FLD, (END_FLD - 200)) );

	return(NOERROR);

}	/* ClearScreen() */

/*-------------------------------------------------------------------------*/
/* Initialize Screen Header with either Low or High Values */

InitFields( t_char, t_short,t_long,t_double )
char	t_char ;
short	t_short ;
long	t_long;
double	t_double;
{
	int	i;

	s_sth.s_desc[0] = t_char;
	if(strcmp(pay_param.pr_prov,"NB") == 0) 
		s_sth.s_sec_code[0] = t_char;
	else
		s_sth.s_sec_code[0] = HV_CHAR;
	s_sth.s_reg_num[0] = t_char;
	s_sth.s_pac = t_short;
	s_sth.s_type[0] = t_char;

	s_sth.s_per_rate1 = HV_DOUBLE;
	s_sth.s_per_rate2 = HV_DOUBLE;
	s_sth.s_per_rate3 = HV_DOUBLE;
	s_sth.s_amount = HV_DOUBLE;
	s_sth.s_amount2 = HV_DOUBLE;

	s_sth.s_employee_sh = t_double;
	s_sth.s_employer_sh = t_double;
	s_sth.s_min_earnings = t_double;
	s_sth.s_max_cont = t_double;
	for(i = 0;i < 5;i++) {
		s_sth.s_ded_mon_pp[i][0] = t_char;
	}
	s_sth.s_fund_num = t_short;
	s_sth.s_lia_acc[0] = t_char;
	s_sth.s_dummy[0] = t_char;
	if(s_sth.s_dummy[0] == LV_CHAR) 
		s_sth.s_dummy[0] = ' ';
	for(i = 0;i < 12;i++) {
		s_sth.s_key[i] = t_long;
	}

	return(NOERROR) ;

}	/* InitFields() */



/****************************************************************************/
UpdateAcct(mode) 
int	mode;
{
	int	i,	retval;
	int	ch_mod;
	/*  If changing from account to keys the Payroll GL account record 
	    set up for school zero must be deleted */
	if(mode == UPDATE) {
		gl_acct.gl_fund = s_sth.s_fund_num;
		gl_acct.gl_cc = 0;
		gl_acct.gl_type[0] = 'R';
		strcpy(gl_acct.gl_earn,s_sth.s_reg_pen_code);
		gl_acct.gl_class[0] = '\0';
		retval = get_glacct(&gl_acct,UPDATE,0,e_mesg);
		if(retval >= 0) {
			retval = put_glacct(&gl_acct,P_DEL,e_mesg);
			if(retval < 0) {
				DispError((char *)&s_sth,e_mesg);
				roll_back(e_mesg);
				return(retval);
			}
		}
	}
	school.sc_numb = 0;
	flg_reset(SCHOOL);

	for( ;; ) {   /* For each Cost Center */
		retval = get_n_sch(&school,BROWSE,0,FORWARD,e_mesg);
		if(retval < 0 ) {

			if(retval == EFL) break;
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}
		gl_acct.gl_fund = s_sth.s_fund_num;
		gl_acct.gl_cc = school.sc_numb;
		gl_acct.gl_type[0] = 'R';
		strcpy(gl_acct.gl_earn,s_sth.s_reg_pen_code);
		gl_acct.gl_class[0] = '\0';
		if(mode == UPDATE || mode == P_DEL) {
			retval = get_glacct(&gl_acct,UPDATE,0,e_mesg);
			if(retval < 0)  {
				if(retval == EFL || retval == UNDEF) 
					if(mode == UPDATE)
						ch_mod = ADD;
					else
						continue;
				else {
					DispError((char *)&s_sth,e_mesg);
					return(retval);
				}
			}
			else
				ch_mod = mode;
		}
		retval = 0;
		if( mode == UPDATE ) {
			retval = NO_CHANGE;
			for(i=0 ; i < NO_KEYS ; i++) {
				if(s_sth.s_key[i] != reg_pen.rg_exp_acct[i]) {
					retval = GetNewAcct();
					break;
				}
			}
		}
		else  {
			if( mode == ADD ) {
				retval = GetNewAcct();
			}
			ch_mod = ADD;
		}
					/* No Change in Keys */
		if(retval == NO_CHANGE) continue; 

		if(retval == NOTFOUND) 
			continue; 	/* No G/L Acct for the CC# */

		strcpy(gl_acct.gl_acct, gl_rec.accno);
			
		retval = put_glacct(&gl_acct,ch_mod,e_mesg);
		if(retval < 0) {
			DispError((char *)&s_sth,e_mesg);
			roll_back(e_mesg);
			return(retval);
		}
	}
	return(NOERROR);
}	/* UpdateAcct */
/*---------------------------------------------------------------*/
/* Read Sequentially through the glmast file to get G/L Account   */
GetNewAcct()
{
	int	account_flg;		/* Found/NotFound G/L Account */
	int	retval, i;

	gl_rec.reccod = 99;
	gl_rec.funds = s_sth.s_fund_num;
	gl_rec.sect = 0;
	gl_rec.accno[0] = '\0';
	flg_reset(GLMAST);

	for( ;; ) {
		retval = get_n_gl(&gl_rec,BROWSE,2,FORWARD,e_mesg);
		if(retval < 0) {
			if(retval == EFL) { 
				return(NOTFOUND);
			}
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}
		if( gl_rec.funds != s_sth.s_fund_num ) {
			return(NOTFOUND);
		}
		account_flg = FOUND;
		for(i=0;i < NO_KEYS; i++) {
			if(pay_param.pr_reg_pen[i][0] == 'Y') {
				if(gl_rec.keys[i] != s_sth.s_key[i]) {
					account_flg = NOTFOUND;
					break;
				}
			}
		}
		if(account_flg == NOTFOUND) continue;
		if(gl_rec.keys[pay_param.pr_cost-1] != school.sc_numb) 
			continue;
		
		return(FOUND);
	}
}
/*-------------------- E n d   O f   P r o g r a m ---------------------*/
