/*-----------------------------------------------------------------------
Source ame: taxtbl.c
System     : Personnel/Payroll System.
Created  On: 21st Nov. 91.
Created  By: Andre Cormier 

DESCRIPTION:
	Program To input the Tax Table.

MODIFICATIONS:        

Programmer     YY/MM/DD       Description of modification
------------------------------------------------------------------------*/
#define	MAIN		/* Main program. This is to declare Switches */
#define MAINFL		TAX		/* main file used */

#define	SYSTEM		"TAXTBL"			/* Sub System Name */
#define	MOD_DATE	"21-NOV-91"		/* Progran Last Modified */

#include <stdio.h>
#include <cfomstrc.h>
#include <bfs_defs.h>
#include <bfs_com.h>
#include <bfs_pp.h>

/* User Interface define constants */
#ifdef ENGLISH
#define ADDREC		'A'
#define CHANGE		'C'
#define DELETE		'D'
#define INQUIRE		'I'
#define EXITOPT		'E'
#define	NEXT		'N'
#define	PREV		'P'

#define	YES		'Y'
#define NO		'N'
#define ADDITEMS	'A'
#define	LINEEDIT	'L'
#define SCREENEDIT	'S'
#define DELITEM		'D'
#define REACTITEM	'R'
#define	CANCEL		'C'

#define ACTIVE		"ACT"
#define INACTIVE		"DEL"
#else
#define ADDREC		'R'
#define CHANGE		'C'
#define DELETE		'E'
#define INQUIRE		'I'
#define EXITOPT		'F'
#define	NEXT		'S'
#define	PREV		'P'

#define	YES		'O'
#define NO		'N'
#define ADDITEMS	'A'
#define	LINEEDIT	'L'
#define SCREENEDIT	'S'
#define DELITEM		'D'
#define REACTITEM	'R'
#define	CANCEL		'A'

#define ACTIVE		"ACT"
#define INACTIVE		"ELI"
#endif

/* PROFOM Releted declarations */

#define	SCR_NAME	"taxtbl"	/* PROFOM screen Name */

#define	PAGESIZE	5		/* No of Items */
/* PROFOM Screen STH file */

/* Field PROFOM numbers */

#define FN_FLD		400	/* Fn: */

#define KEY_START	500	/* Key Start Field */
#define KEY_END		500	/* Key End Field */

#define CHG_FLD		600

#define PAGE_FLD	800	/* Page# Field */
#define DUMMY_FLD	900	/* Page# Field */
#define	ITEM_ST_FLD	1000	/* Item 1 Start Field */
#define	END_FLD		3600	/* Last Field of the screen */
#define	STEP		500	/* NO of fields diff. between 2 items */

/* Item Fields. These numbers are difference between that field
   and the 1st fld within the item */
#define LOW_AMNT_FLD	100
#define RATE_FLD	200
#define HIGH_AMNT_FLD	300
#define FED_CONST_FLD	400
#define STATUS_FLD	500

/* certif.sth - header for C structure generated by PROFOM EDITOR */

typedef	struct	{	/* Start Fld 900, Endfld 5300 and Step 300 */
	
	double	s_low_amnt;	/* 1000 NUMERIC 9,999,999.99 */
	double	s_rate;		/* 1100 NUMERIC 99.999 */
	double	s_high_amnt;	/* 1200 NUMERIC 9,999,999.99 */
	double	s_fed_const; 	/* 1300 NUMERIC 9,999,999.99 */
	char	s_status[4]; 	/* 1400 STRING X(3) */
}	S_item ;

typedef struct	{

	char	s_pgname[11];	/* 100 STRING X(10) */
	long	s_rundate;	/* 300 DATE YYYYFMMFDD */
	char	s_fn[2];	/* 400 STRING X */
	long	s_date;		/* 600 DATE YYYYFMMFDD */
	short	s_field;	/* 600 NUMERIC 99 */
	short	s_page;		/* 1100 NUMERIC 99 */
	char	s_dummy[2];

	S_item	s_items[PAGESIZE] ;	/* Start Fld 1000, End Fld 6900  */

	char	s_mesg[78];	/* 7000 STRING X(77) */
	char	s_resp[2];	/* 7100 STRING X */
} s_struct;

static	s_struct  s_sth,image;	/* PROFOM Screen Structure */
static	struct  stat_rec  sr;		/* PROFOM status rec */

static	char 	e_mesg[100];  		/* dbh will return err msg in this */

int	Validation() ;
int	WindowHelp() ;
double	D_Roundoff() ;

int	Argc;
char	**Argv;

typedef struct Page {
	S_item	Items[PAGESIZE] ;	/* Items Information */
	struct	Page	*PrevPage ;	/* ptr to previous page */
	struct	Page	*NextPage ;	/* ptr to next page */
	char	I_Status[PAGESIZE][2];	/* item status ie A(DD) C(hange) */
	short	NoItems;		/* number of Items on the page */
	short	Pageno;			/* Page number */
}	Page;

static	Page	*FirstPage,		/* Address of First Page */
		*CurPage,		/* Address of Current Page */
		*CurLast,		/* Address of Curr. record last page */
		*LastPage;		/* Address of Last Page of Memory
					   Allocated */

static	Tax	tax, pre_tax;		/* Tax Entry record */

void	free() ;
char	*malloc() ;
int 	first_time =0;
/*------------------------------------------------------------------------*/
main(argc,argv)
int argc;
char *argv[];
{
	int 	retval;

	/* These two are passed to execute() when it is called */
	Argc = argc;
	Argv = argv;

	retval = Initialize(argc,argv);	/* Initialization routine */

	if (retval == NOERROR) retval = Process();

	CloseRtn();			/* return to menu */
	if (retval < NOERROR) exit(-1);
	exit(0);
}

/*-------------------------------------------------------------------*/
/* Initialize PROFOM */

Initialize(argc, argv)
int	argc ;
char	*argv[] ;
{
	int	err ;

	/*
	*	Initialize DBH Environment
	*/
	strncpy(SYS_NAME,SYSTEM,50);	/* Sub system name */
	strncpy(CHNG_DATE,MOD_DATE,10);	/* Modification Date */

	proc_switch(argc, argv, MAINFL) ; 	/* Process Switches */

	/*
	*	Initialize PROFOM & Screen
	*/
	strcpy(sr.termnm,terminal);	/* Copy Terminal Name */
	fomin(&sr);
	ret(err_chk(&sr)) ;		/* Check for PROFOM Error */
	fomcf(1,1);			/* Enable Snap screen option */

	err = InitScreen() ;		/* Initialize Screen */
	if(NOERROR != err) return(err) ;

	FirstPage = '\0';
	LastPage = '\0';

	return(NOERROR) ;
}	/* Initialize() */

/*--------------------------------------------------------------------------*/
/* Close nessary files and environment before exiting program               */

CloseRtn() 
{
	/* Free the linked list for the end */
	for( ;LastPage != FirstPage ; ) {
		LastPage = LastPage->PrevPage;
		free((char *)LastPage->NextPage);
		LastPage->NextPage = '\0';
	}
	if(FirstPage != '\0') {
		free((char *)FirstPage);
	}

	FirstPage = LastPage = '\0';

	/* Set terminal back to normal mode from PROFOM */
	fomcs();
	fomrt();

	close_dbh();	/* Close files */

	return(NOERROR);
}	/* CloseRtn() */
/*----------------------------------------------------------------*/
/* Initialize screen before going to process options */

InitScreen()
{
	int	err ;

	/* move screen name to Profom status structure */
	strcpy(sr.scrnam,NFM_PATH);
	strcat(sr.scrnam,SCR_NAME) ;

	strcpy(s_sth.s_pgname,PROG_NAME);

	s_sth.s_rundate = get_date();	/* get Today's Date in YYYYMMDD format*/
	s_sth.s_field = HV_SHORT ;

	s_sth.s_date = HV_LONG ;

	s_sth.s_mesg[0] = HV_CHAR ;
	s_sth.s_resp[0] = HV_CHAR ;

	/* Move High Values to data fields and Display the screen */
	err = ClearScreen() ;
	if(NOERROR != err) return(err) ;

	return(NOERROR) ;
}	/* InitScreen() */
/*-------------------------------------------------------------------*/
/* Get Option from user and call corresponding function */

Process()
{
	int	err;
	s_sth.s_date = 0;

	for( ; ; ){
		FirstPage = '\0';	
		CurPage = '\0';
		CurLast = '\0';
		LastPage = '\0';

		/* Get the Fn: option from the user */
		err = ReadFunction();
		if(err < 0) return(err);

		err = ProcFunction() ;	/* Process Function */

		if(err == 1) continue;
		if(QUIT == err)		return(NOERROR) ;    /* Exit */
		if(NOACCESS == err)	fomen(e_mesg);	     /* security */
		if(PROFOM_ERR == err)	return(PROFOM_ERR);  /* PROFOM ERROR */
		if(DBH_ERR == err) {
			DispError((char *)&s_sth,e_mesg);
#ifdef ENGLISH
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"System Error... Iserror:",
				iserror, dberror, errno);
#else
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"Erreur du systeme... Iserror:",
				iserror, dberror, errno);
#endif
			DispError((char *)&s_sth,e_mesg);
			return(DBH_ERR); /* DBH ERROR */
		}
		FreeList();
	}      /*   end of the for( ; ; )       */
}	/* Process() */
/*----------------------------------------------------------------*/
/* Display the Function (Fn:) options and get the option from the user */

ReadFunction()
{
	/* Display Fn: options */
#ifdef ENGLISH
	fomer("A(dd), C(hange), D(elete), I(nquire), N(ext), P(rev), E(xit)");
#else
	fomer("R(ajouter), C(hanger), I(nterroger), S(uivant), P(recedent), F(in)");
#endif
	/* Read Fn: field to get the option */
	sr.nextfld = FN_FLD ;
	fomrf( (char *)&s_sth );
	ret(err_chk(&sr));	/* Check for PROFOM error */

	return(NOERROR) ;
}	/* ReadFunction() */
/*----------------------------------------------------------------*/
/* Process the user selected Fn: option */

ProcFunction()
{
	int retval;

	switch (s_sth.s_fn[0]) {
	case ADDREC  :			/* ADD */
		CHKACC(retval,ADD,e_mesg);
		retval= Add();
		if(retval < 0) return(retval);
		break;

	case CHANGE  :			/* CHANGE */
		CHKACC(retval,UPDATE,e_mesg);
		retval= Change();
		if(retval < 0) return(retval);
		break;

	case DELETE  :			/* CHANGE */
		CHKACC(retval,UPDATE,e_mesg);
		retval= Delete();
		if(retval < 0) return(retval);
		break;

	case INQUIRE  :			/* Inquire */
		CHKACC(retval,BROWSE,e_mesg);
		retval= Inquire();
		if(retval < 0) return(retval);
		break;

	case NEXT  :			/* Next */
		CHKACC(retval,BROWSE,e_mesg);
		retval= Next(FORWARD);
		if(retval < 0) return(retval);
		break;

	case PREV  :			/* Previous */
		CHKACC(retval,BROWSE,e_mesg);
		retval= Next(BACKWARD);
		if(retval < 0) return(retval);
		break;

	case EXITOPT  :			/* Exit */
		return( QUIT ) ;
	}  /*   end of the switch statement */

	return(NOERROR);
}	/* ProcFunction() */
/*----------------------------------------------------------------------*/
/* Adding.  Get the unique Key, accept details and update the files */
Add()
{
	int	err ;

	FirstPage = NULL;
	LastPage = NULL;
	CurLast = NULL;

	err = ReadKey();
	if(err == RET_USER_ESC) return(RET_USER_ESC) ;

	err = ClearScreen();
	if(err < 0) return(err) ;

	err = GetDetails();
	if(PROFOM_ERR == err || DBH_ERR == err) return(err) ;
	if(err < 0 || CANCEL == err) {
		roll_back(e_mesg) ;	
		return(ClearScreen()); 
	}

	return(NOERROR);
}	/* Add() */
/*----------------------------------------------------------------------*/
/* Get record to change, make changes and rewrite changes to file.	*/

Change()
{
	int	err ;

	err = SelectRecord() ;
	if(NOERROR != err) return(err);


	for( ; ; ) {
		err = ConfirmItems() ;
		if(err != YES) {
			roll_back(e_mesg);
			break;
		}

		err = ProcItemUpdates(UPDATE) ;
		if(err==NOERROR) break;
		if(err==LOCKED) {
			roll_back(e_mesg) ;
			continue;
		}
		if (err < 0) {
			roll_back(e_mesg);
			return(err) ;
		}
	}

	return(NOERROR) ;
}	/* Change() */
/*-----------------------------------------------------------------------*/
/* Delete. Employee's time entry Records.  */
/*-----------------------------------------------------------------------*/

Delete()
{
	int	err ;

	err = SelectRecord() ;
	if(NOERROR != err) return(err) ;
	
	for( ; ; ) {
		err = ConfirmItems() ;
		if(err != YES) {
			roll_back(e_mesg);
			break;
		}

		err = ProcItemUpdates(P_DEL) ;
		if(err==NOERROR) break;
		if(err==LOCKED) {
			roll_back(e_mesg) ;
			continue;
		}
		if (err < 0) {
			roll_back(e_mesg);
			return(err) ;
		}
	}

	return(NOERROR) ;
}	/* Delete() */
/*-----------------------------------------------------------------------*/
/* Show Employee time entry based on users input */

Inquire()
{
	int	err ;

	err = SelectRecord() ;
	if(NOERROR != err) return(err) ;

	err = ConfirmItems() ;
	
	return(NOERROR) ;
}	/* Inquire() */
/*----------------------------------------------------------*/
/* Show the next or previous Employees time entry           */

Next(direction)
int	direction ;
{
	int err;

	tax.tx_date = s_sth.s_date; /*	andre */
	tax.tx_low_amnt = 0;
	tax.tx_high_amnt = 0;
	if(flg_start(TAX) != direction) {
		if (direction == FORWARD) 
			tax.tx_low_amnt += 0.0001;
		else
			tax.tx_low_amnt -= 0.0001;
		flg_reset(TAX);
	}

	err = get_n_tax(&tax,BROWSE,0,direction,e_mesg);
	if(err < 0 && err != EFL) {
		DispError((char *)&s_sth,e_mesg);
		return(err);
	}

	if(err == EFL) {
		fomer("No More Records...");
		get();
		err = NOERROR;	
	}
	else {
		s_sth.s_date = tax.tx_date;

		ret( WriteFields((char *)&s_sth,KEY_START, KEY_END) ) ;

		/* Get time records i.e. Build list */
		err = BuildList();
		if(err < 0 && err != EFL) {
			return(err);
		}
	
		err = ShowItems(CurPage);
		if(err < 0) {
			return(err);
		}
	}

	return( err ) ;
}	/* Next() */
/*----------------------------------------------------------------------*/
/* Read employee number and pay date to read file 			*/

ReadKey()
{
	int	err;
	long	date;
	
	/* In Add mode turn off dup control for key fields.
	   Other modes reverse it */

	SetDupBuffers(KEY_START,KEY_END,0); /* Off Dup Control */

#ifdef ENGLISH
	strcpy(s_sth.s_mesg,"Press ESC-F to Go Back to Fn:");
#else
	strcpy(s_sth.s_mesg,"Appuyer sur ESC-F pour retourner a Fn:");
#endif
	DispMesgFld((char *)&s_sth);

	date = s_sth.s_date;
	s_sth.s_date = LV_LONG;

	err = ReadFields((char *)&s_sth,KEY_START, KEY_END,
		Validation, WindowHelp,1) ;
	if(PROFOM_ERR == err || DBH_ERR == err) return(err) ;
	if(RET_USER_ESC == err){
		s_sth.s_date = date;
		ret( WriteFields((char *)&s_sth,KEY_START, KEY_END) ) ;

		s_sth.s_mesg[0] = HV_CHAR;
		DispMesgFld((char *)&s_sth);

		return(RET_USER_ESC) ;
	}

	return(NOERROR);
}	/*  ReadKey() */
/*------------------------------------------------------------*/
/* Read the Area Details from the User */

GetDetails()
{
	int	err ;

	err = AddItems();
	if(NOERROR != err) return(err) ;

	for( ; ; ) {
		err = ConfirmItems() ;
		if(err != YES) break;

		err = ProcItemUpdates(ADD) ;
		if(err < 0) {
			if(err == LOCKED) continue;
			break;
		}
		break;
	}
	if(err != NOERROR) return(err);
	return(NOERROR) ;
}	/* GetDetails() */
/*------------------------------------------------------------*/
/* Read Item Details from the User */

AddItems()
{
	int	idex, err ;

	/* If the last node of po is Partial filled then Show Page */
	if(CurLast != NULL && CurLast->NoItems < PAGESIZE ) {
		ret( ShowItems(CurLast) ) ;
		idex = CurLast->NoItems ;
		CurPage = CurLast ;
	}
	else {
		/* Calculate the page# */
		if(CurLast != NULL) {
			idex = PAGESIZE ;
			CurPage = CurLast ;
		}
		else {
			s_sth.s_page = 1 ;
			s_sth.s_dummy[0] = ')';
			ret( WriteFields((char *)&s_sth,PAGE_FLD,PAGE_FLD+100));
			idex = 0 ;
		}
	}


	for( ; ; ) {
		if( PAGESIZE == idex) {	/* Page Full */

			/* Calculate the page# */
			s_sth.s_dummy[0] = ')';
			s_sth.s_page = CurLast->Pageno + 1 ;

			ret( WriteFields((char *)&s_sth,PAGE_FLD, 
				(END_FLD - 200)) ) ;

			err = ClearScreen();
			if(err < 0) return(err) ;

			idex = 0 ;
		}

		err = ReadItem(idex,ADD) ;	/* Read Each Item Line */

		if(err == RET_USER_ESC) break;	 /*andre */
		if(PROFOM_ERR == err || DBH_ERR == err) return(err) ;
		if(NOERROR != err) break ;	/* ESC-F */


		if(0 == idex)	/* First Item in the Page */
			if((err = MakeFreshPage()) < 0) return(err) ;
		
		/* Copy the Item to List */
		scpy((char*)&(CurPage->Items[idex]), (char*)&(s_sth.s_items[idex]),
			sizeof(S_item)) ;

		CurPage->I_Status[idex][0] = ADDITEMS;

		idex++ ;

		CurPage->NoItems = idex;

		if(s_sth.s_items[idex-1].s_high_amnt == 9999999.99) {
			break;
		}
	}
	if(idex == 0) 
		if((err=ShowItems(CurPage))<0) return(err) ;

	return(NOERROR) ;
}	/* AddItems() */
/*-----------------------------------------------------------------------*/
/*	Get the next node in linked list to add invoice items. If the
*	(Cur. invc last page) = (Last Page in linked List) or no
*	nodes in list, allocate node and add to linked list
*/

MakeFreshPage()
{
	Page	*tempptr ;

	/* If, no node is allocated yet or Current invoice used all the nodes,
	   then allocate new node */

	if( LastPage == '\0' || CurLast == LastPage ){
		tempptr= (Page *)malloc((unsigned)sizeof(Page)) ;

		if( tempptr == '\0' ){
			DispError((char*)&s_sth,"Memory Allocation Error");
			return(ERROR);
		}
		tempptr->NextPage = '\0' ;

		if( LastPage == '\0' ){	/* No node is allocated Yet */
			tempptr->PrevPage = '\0' ;
			tempptr->Pageno = 1 ;
			FirstPage = tempptr ;
		}
		else {				/* Not a first node in list */
			tempptr->Pageno = LastPage->Pageno + 1 ;
			LastPage->NextPage = tempptr ;
			tempptr->PrevPage = LastPage ;
		}
		LastPage = tempptr ;
	}

	if(CurLast == '\0')
		CurLast = FirstPage ;
	else
		CurLast = CurLast->NextPage ;

	CurLast->NoItems = 0 ;
	CurPage = CurLast ;

	return(NOERROR);
}	/* MakeFreshPage() */
/*----------------------------------------------------------*/
/* Get the key and show the record */

SelectRecord()
{
	int	err ;

	err = ReadKey();
	if(err == RET_USER_ESC) return(RET_USER_ESC) ;

	/* Get area records i.e. Build list */
	err = BuildList();
	if(err < 0 && err != EFL) {
		return(err);
	}
	if(err == 1) return(1);

	err = ShowItems(CurPage);
	if(err < 0) {
		return(err);
	}

	return(NOERROR);
}	/* SelectRecord() */
/*--------------------------------------------------------------*/
/* Read all time entry info for the key's given 		*/

BuildList()
{
	int retval;
	int idex, j ;
	CurLast = CurPage = '\0';
	idex = 0;

	tax.tx_date = s_sth.s_date;
	tax.tx_low_amnt = 0;
	tax.tx_high_amnt = 0;
	flg_reset(TAX);

	for( ; ; ) {
		retval = get_n_tax(&tax,BROWSE,0,FORWARD,e_mesg);
		if(retval < 0) {
			if(retval == EFL) break;
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}

		if( tax.tx_date != s_sth.s_date ) {
			break;
		}

		if(PAGESIZE == idex) idex = 0;
		if(idex == 0) {
			if((retval = MakeFreshPage()) < 0) return(retval);
		}

		CurPage->Items[idex].s_low_amnt = tax.tx_low_amnt;
		CurPage->Items[idex].s_high_amnt = tax.tx_high_amnt;
		CurPage->Items[idex].s_rate = tax.tx_rate;
		CurPage->Items[idex].s_fed_const = tax.tx_fed_const;

		strcpy(CurPage->Items[idex].s_status,ACTIVE);

		CurPage->I_Status[idex][0] = ' ';
		CurPage->NoItems++;
		idex++;
	}
	seq_over(TAX);

	if(CurLast != '\0') {
		CurPage = FirstPage;
	}

	if(retval == EFL) return(retval);
	return(NOERROR);
}
/*------------------------------------------------------------*/
/* Show all the items on the current page 		      */

ShowItems(pageptr)
Page	*pageptr ;
{
	int	idex, j, retval;

	if(pageptr != '\0') {
		/* Copy the items to screen */
		scpy((char*)s_sth.s_items, (char*)pageptr->Items,
			(pageptr->NoItems * sizeof(S_item)) );

		s_sth.s_dummy[0] = ')';
		s_sth.s_page   = pageptr->Pageno ;

		idex = pageptr->NoItems ;
	}
	else {
		s_sth.s_dummy[0] = HV_CHAR;
		s_sth.s_page = HV_SHORT ;
		idex = 0 ;
	}

	/* Move High Values to remaining Items */
	for( ; idex < PAGESIZE ; idex++ ){
		InitItem(idex,HV_DOUBLE,HV_CHAR);
	}

	ret( WriteFields((char *)&s_sth, PAGE_FLD, (END_FLD - 200)) );

	return(NOERROR) ;
}	/* ShowItems() */
/*-----------------------------------------------------------------------*/ 
/* Process all the items in the link list and write any changes to the   */
/* daily attendance file.						 */
/*-----------------------------------------------------------------------*/ 

ProcItemUpdates(mode)
int	mode;
{
	Page	*temppage;
	int	idex;
	int	retval;
	int	write_mode;

	if(CurLast != '\0') {
	   for(temppage=FirstPage; temppage!='\0';temppage=temppage->NextPage) {
	      for(idex =0; idex< temppage->NoItems; idex++) {
		 retval = GetMode(temppage,idex,mode,&write_mode);
		 if(write_mode == NOOP) {
			continue;
		 }
		 retval = WriteRecords(temppage,idex,write_mode);
  		 if(retval < 0) {
			if(retval == LOCKED) return(LOCKED);
		   	break;
		 }
	      }
	      if(temppage == CurLast) break;
	   }
	}
	return(NOERROR);
}
/*----------------------------------------------------------------------*/ 
/* Getting the mode which the record should be read to allow updates 	*/

GetMode(temppage,item_no,mode,write_mode)
Page	*temppage;
int	item_no;
int	mode;
int	*write_mode;
{
	if(mode == ADD) {
		if(strcmp(temppage->Items[item_no].s_status,INACTIVE)==0) {
			*write_mode = NOOP;
		}
		else {
			*write_mode = ADD;

		}
	}
	else if(mode == UPDATE) {
		if(strcmp(temppage->Items[item_no].s_status,INACTIVE)==0) {
			*write_mode = P_DEL;
		}
		else if(temppage->I_Status[item_no][0] == ADDITEMS) {
			*write_mode = ADD;
		}
		else if(temppage->I_Status[item_no][0] == CHANGE) {
			*write_mode = UPDATE;
		}
		else if(temppage->I_Status[item_no][0] == ' ') {
			*write_mode = NOOP;
		}
	}
	else if(mode == P_DEL) {
		*write_mode = P_DEL;
	}

	return(NOERROR);
}
/*-----------------------------------------------------------------------*/ 
/* Write the Time record to the file.			 		 */ 
/*-----------------------------------------------------------------------*/ 

WriteRecords(temppage,item_no,mode)
Page	*temppage;
int	item_no;
int	mode;
{
	int	j, retval;

	tax.tx_date = s_sth.s_date;
	tax.tx_low_amnt = temppage->Items[item_no].s_low_amnt ;
	tax.tx_high_amnt = temppage->Items[item_no].s_high_amnt ;
	tax.tx_rate = temppage->Items[item_no].s_rate ;
	tax.tx_fed_const = temppage->Items[item_no].s_fed_const ;
	if(mode != ADD) {
		scpy((char *)&pre_tax,(char *)&tax, sizeof(pre_tax));

		retval = get_tax(&tax,UPDATE,0,e_mesg) ;
		if(retval < 0) {
			DispError((char *)&s_sth,e_mesg);
			roll_back(e_mesg);
			return(retval);
		}

	}
	/* Move New Fields into record */
	tax.tx_date = s_sth.s_date;
	tax.tx_low_amnt = temppage->Items[item_no].s_low_amnt ;
	tax.tx_high_amnt = temppage->Items[item_no].s_high_amnt ;
	tax.tx_rate = temppage->Items[item_no].s_rate ;
	tax.tx_fed_const = temppage->Items[item_no].s_fed_const ;

	retval = put_tax(&tax,mode,e_mesg) ;
	if(retval < 0) {
		DispError((char *)&s_sth,e_mesg);
		roll_back(e_mesg);
		return(retval);
	}

	if(mode != ADD) {
		retval = rite_audit((char*)&s_sth,TAX,mode,(char*)&tax,
			(char*)&pre_tax,e_mesg);
		if(retval==LOCKED) {
			DispError((char *)&s_sth,e_mesg);
			roll_back(e_mesg) ;
			return(LOCKED) ;
		}
		if(retval < 0 ){
			DispError((char *)&s_sth,"ERROR: Saving Records"); 
			DispError((char *)&s_sth,e_mesg);
			roll_back(e_mesg);
			return(retval);
		}
	}

	retval = commit(e_mesg) ;
	if(retval < 0) {
		DispError((char *)&s_sth,"ERROR: Saving Records"); 
		DispError((char *)&s_sth,e_mesg);
		roll_back(e_mesg);
		return(retval);
	}
	return(NOERROR);
}
/*------------------------------------------------------------*/
/* Read details of given item# */
/*------------------------------------------------------------*/
ReadItem(item_no,mode)
int	item_no ;
int	mode ;
{
	int	err;
	int	st_fld ;
	int	end_fld ;

	if(mode == ADD) {
		SetDupBuffers(ITEM_ST_FLD, END_FLD - 200,0);
	}
	else {
		SetDupBuffers(ITEM_ST_FLD, END_FLD - 200,1);
	
	}

#ifdef ENGLISH
	strcpy(s_sth.s_mesg,"Press ESC-F to Terminate");
#else
	strcpy(s_sth.s_mesg,"Appuyer sur ESC-F pour terminer");
#endif
	DispMesgFld((char *)&s_sth);

	st_fld  = ITEM_ST_FLD ;
	end_fld  = END_FLD ;
	if(mode == ADD) {
		InitAddItem(item_no,LV_DOUBLE,LV_CHAR);
		strcpy(s_sth.s_items[item_no].s_status,ACTIVE);
	}
	else {
		s_sth.s_items[item_no].s_rate = LV_DOUBLE;
		s_sth.s_items[item_no].s_fed_const = LV_DOUBLE;
	}

	err = ReadFields((char*)&s_sth,st_fld,end_fld,Validation,WindowHelp,1) ;

	if(PROFOM_ERR == err || DBH_ERR == err) return(err) ;
	if(RET_USER_ESC == err) {
		if(mode == ADD) {
			InitItem(item_no,HV_DOUBLE,HV_CHAR);
			WriteFields((char *)&s_sth,st_fld,end_fld);
			return(RET_USER_ESC);
		}
		/* When user gives ESC-F while changing fields, assumption is
		* he completed his changes, and remaining fields are same as
		* old. But, at this point STH will be having low values in the 
		* remaining fields. So move the old values form the linked list.
		*/

		err = CopyBack((char*)&s_sth,(char *)&image,sr.curfld, END_FLD);
		if(err == PROFOM_ERR) return(err);

		return(RET_USER_ESC) ;
	}

	return(NOERROR) ;
}	/* ReadItem() */
/*----------------------------------------------------------------*/
/* Set Duplication buffers for fields 				  */
SetDupBuffers( firstfld, lastfld, value )
int	firstfld, lastfld;	/* field numbers range */
int	value;			/* ENABLE or DISABLE */
{
	int idex ;

	for( idex=firstfld; idex<=lastfld; idex+=100 )
		fomca1( idex, 19, value);
	if( value==0 )
		return(0);
	sr.nextfld = firstfld;
	sr.endfld = lastfld;
	fomud( (char *)&s_sth );
	ret( err_chk(&sr) );

	return( 0 );
}
/*----------------------------------------------------------------*/
/* Validation function() for Key and Header fields when PROFOM returns
  RET_VAL_CHK */

Validation()
{
	int	idex;
	int	retval;
	int	fld_no;
	int	item_no, st_fld;
	double	temp_calc;

	if(sr.curfld >= ITEM_ST_FLD) {	
		item_no = (sr.curfld - ITEM_ST_FLD) / STEP;
 		fld_no = (sr.curfld - ITEM_ST_FLD) % STEP + 100;

		st_fld = ITEM_ST_FLD + (STEP * item_no);

		switch(fld_no){	

		case	HIGH_AMNT_FLD:
			if(s_sth.s_items[item_no].s_high_amnt <= 
			   s_sth.s_items[item_no].s_low_amnt){
				s_sth.s_items[item_no].s_high_amnt = LV_DOUBLE;
				fomen("Invalid amount");
				return(ERROR);
			}

			break;

		default:
#ifdef ENGLISH
		sprintf(e_mesg,"No Validity Check for Field#  %d",sr.curfld);
#else
		sprintf(e_mesg,"Pas de controle de validite pour le Champ#  %d",sr.curfld);
#endif

			fomen(e_mesg);
			get();
			return(ERROR) ;
		}	/* Switch sr.curfld */

	}
	else {
		fld_no = sr.curfld;
		switch(fld_no){

		case	KEY_START:

			tax.tx_date = s_sth.s_date;
			tax.tx_low_amnt = 0;
			tax.tx_high_amnt = 0;

			flg_reset(TAX);

			retval = get_n_tax(&tax,BROWSE,0,FORWARD,e_mesg);

			if(s_sth.s_fn[0] == ADDREC) {
				if(s_sth.s_date == tax.tx_date && retval !=EFL){
					fomen("Date Already Exist");
					s_sth.s_date = LV_LONG;
					return(-1);
				}
			}
			else {
				if(s_sth.s_date!=tax.tx_date || retval==EFL){
					fomen("Date Does Not Exist");
					s_sth.s_date = LV_LONG;
					return(-1);

				}
			}
			break;


		default:
#ifdef ENGLISH
		sprintf(e_mesg,"No Validity Check for Field#  %d",sr.curfld);
#else
		sprintf(e_mesg,"Pas de controle de validite pour le Champ#  %d",sr.curfld);
#endif
			fomen(e_mesg);
			get();
			return(ERROR) ;
		}	/* Switch sr.curfld */
	}

	return(NOERROR) ;
}	/* Validation() */
/*----------------------------------------------------------------*/
/* Show Help Windows, if applicable, when user gives ESC-H in key
   and header fields */

WindowHelp()
{
	fomer("No Help Window for This Field");

	return(NOERROR) ;
}	/* HdrAndKeyWindowHelp() */
/*-----------------------------------------------------------------------*/
/* Take the confirmation from user for the items part of the screen      */
/*-----------------------------------------------------------------------*/

ConfirmItems()
{
	int	err ;

	/* Options:
	     YSLNPC
	*/

	for( ; ; ) {
	    if(s_sth.s_fn[0] == DELETE) {
#ifdef ENGLISH
			err = GetOption((char *)&s_sth,"Y(es), C(ancel)","YC");
#else
			err = GetOption((char *)&s_sth,"O(ui), A(nnul)","OA");
#endif 
	    }
	    else if(s_sth.s_fn[0] != INQUIRE) {
#ifdef ENGLISH
			err = GetOption((char *)&s_sth,
		"Y(es), A(dd), S(creen), L(ine), D(el), R(eactivate), N(ext), P(rev), C(ancel)"
		,"YASLDRNPC");
#else
			err = GetOption((char *)&s_sth,
		"O(ui), S(creen edit), L(ine edit), S(uiv), P(rec), A(nnul)"
		,"OSLA");
#endif
	    }
	    else {
#ifdef ENGLISH
			err = GetOption((char *)&s_sth,
		"Y(es), N(ext), P(rev)","YNP");
#else
			err = GetOption((char *)&s_sth,
		"O(ui), S(uiv), P(rec)" ,"OSP");
#endif
	    }
	    switch(err) {
	    case  YES  :
		return(YES);
	    case  ADDITEMS:
		err = AddItems();
		break;
	    case  SCREENEDIT:
		err = ScreenEdit();
		break;
	    case  LINEEDIT  :
		err = ChangeFields();
		break ;
	    case  DELITEM:
	    case  REACTITEM:
		err = ChangeStatus(err);
		break;
	    case  NEXT:
		if(CurPage == CurLast || CurLast == '\0') {
#ifdef ENGLISH
			fomer("No More Pages....");
#else
			fomer("Plus de pages....");
#endif
			continue;
		}
		CurPage = CurPage->NextPage ;
		err = ShowItems(CurPage);
		break;
	    case  PREV:
		if(CurLast == '\0' || CurPage == FirstPage) {
#ifdef ENGLISH
			fomer("No More Pages....");
#else
			fomer("Plus de pages....");
#endif
			continue;
		}
		CurPage = CurPage->PrevPage ;
		err = ShowItems(CurPage);
		break;
	    case  CANCEL :
#ifdef ENGLISH
		err = GetOption((char *)&s_sth,
				"Confirm the Cancel (Y/N)?", "YN") ;
#else
		err = GetOption((char *)&s_sth,
				"Confirmer l'annulation (O/N)?", "ON") ;
#endif
		if(err == YES) return(CANCEL) ;
		break ;
	    }	/* switch err */

	    if(err == PROFOM_ERR) return(err) ;
	    if(err == DBH_ERR) return(err) ;
	}	/* for(; ; ) */
}	/* ConfirmItems() */
/*---------------------------------------------------------------------*/
/* Change screen.  Allows editing of the students on the screen        */
/*---------------------------------------------------------------------*/

ScreenEdit()
{
     	int idex;
	int retval;

	/* make copy of screen incase user presses ESC-F */
	scpy((char *)&image,(char *)&s_sth,sizeof(s_sth));

#ifdef ENGLISH
	strcpy(s_sth.s_mesg,"Press ESC-F to Terminate");
#else
	strcpy(s_sth.s_mesg,"Appuyer sur ESC-F pour terminer");
#endif
	DispMesgFld((char *)&s_sth);

	if(SetDupBuffers(ITEM_ST_FLD, END_FLD - 200,1)<0) return(PROFOM_ERR);

	for(idex=0;idex<CurPage->NoItems;idex++) {
		if(strcmp(CurPage->Items[idex].s_status,INACTIVE) ==0){
			continue;
		}
		retval = ReadItem(idex,UPDATE);
		if(retval < 0 && retval != RET_USER_ESC) {
			return(retval);
		}

		if(retval == RET_USER_ESC) 
			return(retval);

		scpy((char*)&(CurPage->Items[idex]), 
		     (char*)&(s_sth.s_items[idex]),sizeof(S_item)) ;
		if(s_sth.s_fn[0] == CHANGE) {
			CurPage->I_Status[idex][0] = CHANGE;
		}
	}

     	s_sth.s_mesg[0] = HV_CHAR ;
     	DispMesgFld((char *)&s_sth);

	if(SetDupBuffers(ITEM_ST_FLD, END_FLD-200,0)<0) return(PROFOM_ERR);

	return(NOERROR);
}	/* ScreenEdit() */
/*-----------------------------------------------------------------------*/
/*                                                                       */
/* Changing fields. Accept fld of the student to be changed and read     */
/* that fld 		 */

ChangeFields()
{
	int retval;

	/* make copy screen every time field changed in case user */
	/* presses ESC-F */
	scpy((char*)&image,(char*)&s_sth, sizeof(s_sth));

	SetDupBuffers(ITEM_ST_FLD, END_FLD - 200, 2);

	/* Get The Field to Be Modified */
#ifdef	ENGLISH
	strcpy(s_sth.s_mesg,"Enter RETURN to Terminate Edit");
#else
	strcpy(s_sth.s_mesg,"Appuyer sur RETURN pour terminer l'ajustement");
#endif
	DispMesgFld((char *)&s_sth); ;
        
     	for (; ;) {
		s_sth.s_field = LV_SHORT;
		retval = ReadFields((char *)&s_sth,CHG_FLD,CHG_FLD,
			(int (*)())'\0',(int (*)())'\0', 1);

		if (retval < 0) return(-1);
		if (retval == RET_USER_ESC) break;	/* User enter ESC-F */

       		if (s_sth.s_field == 0 ) break;  /* Finished changing fields */

		if(strcmp(CurPage->Items[s_sth.s_field-1].s_status,INACTIVE)==0){
			fomer("Item Has a Deleted Status Cannot Edit");
			continue;
		}
		retval = ReadItem(s_sth.s_field - 1,UPDATE);
		if(retval < 0 && retval != RET_USER_ESC) {
			return(retval);
		}

		if(retval == RET_USER_ESC)
			continue;

		/* make copy screen every time field changed in case user */
		/* presses ESC-F */
		scpy((char*)&image,(char*)&s_sth, sizeof(s_sth));

		scpy((char*)&(CurPage->Items[s_sth.s_field -1]), 
		     (char*)&(s_sth.s_items[s_sth.s_field -1]),sizeof(S_item)) ;

		if(s_sth.s_fn[0] == CHANGE) {
			CurPage->I_Status[s_sth.s_field-1][0] = CHANGE;
		}
	}

     	s_sth.s_field = HV_SHORT ;
	if ( WriteFields((char *)&s_sth,CHG_FLD, CHG_FLD) < 0 ) return(-1);

     	s_sth.s_mesg[0] = HV_CHAR ;
     	DispMesgFld((char *)&s_sth);

	if(SetDupBuffers(ITEM_ST_FLD, END_FLD - 200, 0)<0) return(PROFOM_ERR);

	return(NOERROR);
}	/* ChangeFields() */
/*------------------------------------------------------------------------*/

ChangeStatus(status)
int	status;
{
	int	retval;
	int	st_fld, end_fld;

	/* Get The Field to Be Modified */
#ifdef	ENGLISH
	strcpy(s_sth.s_mesg,"Enter RETURN to Terminate Edit");
#else
	strcpy(s_sth.s_mesg,"Appuyer sur RETURN pour terminer l'ajustement");
#endif
	DispMesgFld((char *)&s_sth); ;
        
     	for (; ;) {
		s_sth.s_field = LV_SHORT;
		retval = ReadFields((char *)&s_sth,CHG_FLD,CHG_FLD,
			(int (*)())'\0',(int (*)())'\0', 1);

		if (retval < 0) return(-1);
		if (retval == RET_USER_ESC) break;	/* User enter ESC-F */

       		if (s_sth.s_field == 0 ) break;  /* Finished changing fields */

	
		st_fld  = ITEM_ST_FLD + (STEP * (s_sth.s_field-1)) + STATUS_FLD;
		end_fld  = ITEM_ST_FLD + (STEP * (s_sth.s_field-1))+STATUS_FLD;

		if(status == DELITEM) {
			if(strcmp(s_sth.s_items[s_sth.s_field-1].s_status,
			   INACTIVE)==0) {
				fomer("Item is Already Deleted");
			}
			else {
				strcpy(s_sth.s_items[s_sth.s_field-1].s_status,
			   		INACTIVE);
			}
		}
		else {
			if(strcmp(s_sth.s_items[s_sth.s_field-1].s_status,
			   ACTIVE)==0) {
				fomer("Item is Already Active");
			}
			else {
				strcpy(s_sth.s_items[s_sth.s_field-1].s_status,
			   		ACTIVE);
			}
		}
		/* Update Linked List */
		scpy((char*)&(CurPage->Items[s_sth.s_field -1]), 
		     (char*)&(s_sth.s_items[s_sth.s_field -1]),sizeof(S_item)) ;
		
		ret(WriteFields((char *)&s_sth,st_fld,end_fld));
	}

     	s_sth.s_field = HV_SHORT ;
	if ( WriteFields((char *)&s_sth,CHG_FLD, CHG_FLD) < 0 ) return(-1);

	return(NOERROR);
}
/*------------------------------------------------------------------------*/
/* Move High values to all data fields and clear the screen */

ClearScreen()
{
	int	idex;

	/* Move High Values to Hedaer part */
	s_sth.s_dummy[0] = HV_CHAR;
	s_sth.s_page = HV_SHORT;
	
	/* Move High Values to All items */
	for(idex = 0 ; idex < PAGESIZE ; idex++)
		InitItem(idex,HV_DOUBLE,HV_CHAR);

	ret( WriteFields((char *)&s_sth,ITEM_ST_FLD, (END_FLD - 200)) );

	return(NOERROR);
}	/* ClearScreen() */
/*-------------------------------------------------------------------------*/
/* Initialize Given screen item with either Low values or High values */

InitItem(item_no, t_double,t_char)
int	item_no ;
double 	t_double ;
char 	t_char ;
{
	int	idex;

	if(s_sth.s_fn[0] != CHANGE) {
		s_sth.s_items[item_no].s_low_amnt  = t_double;
		s_sth.s_items[item_no].s_high_amnt = t_double ;
		s_sth.s_items[item_no].s_status[0] = t_char ;
	}
	s_sth.s_items[item_no].s_rate = t_double ;
	s_sth.s_items[item_no].s_fed_const = t_double ;

	return(NOERROR) ;
}	/* Inititem() */
/*-------------------------------------------------------------------------*/
/* Initialize Given screen item with either Low values or High values */

InitAddItem(item_no, t_double,t_char)
int	item_no ;
double 	t_double ;
char 	t_char ;
{
	int	idex;

	if(item_no == 0 && s_sth.s_page == 1 )  {
		s_sth.s_items[item_no].s_low_amnt = LV_DOUBLE;
	}
	else{
		if(item_no == 0)  {
			s_sth.s_items[item_no].s_low_amnt = CurPage->
				Items[PAGESIZE-1].s_high_amnt + 0.01;
		}
		else {
			s_sth.s_items[item_no].s_low_amnt = 
				s_sth.s_items[item_no-1].s_high_amnt + 0.01;
		}
	}

	s_sth.s_items[item_no].s_high_amnt = t_double ;
	s_sth.s_items[item_no].s_rate = t_double ;
	s_sth.s_items[item_no].s_fed_const = t_double ;
	s_sth.s_items[item_no].s_status[0] = t_char ;

	return(NOERROR) ;
}	/* Inititem() */
/***********************************************************************/
/* Free the linked list */

static
FreeList()	
{
	int 	idex;

	/* clear the screen items from linked list */

	for(CurPage = FirstPage;CurPage;CurPage = CurPage->NextPage){

		for( idex=0; idex <= PAGESIZE; idex++) {
			if(idex >= CurPage->NoItems) break;
			CurPage->Items[idex].s_low_amnt = HV_SHORT;
		}
	}

	for( CurPage=LastPage; CurPage; CurPage=LastPage){
		LastPage=LastPage->PrevPage;
		free((char *)CurPage );
	}

	FirstPage = NULL;

	return(NOERROR);
}
/*-------------------- E n d   O f   P r o g r a m ---------------------*/
