/* newgencdr.c - generate C structure from form file */

#include <stdio.h>
#include "cfomfrm.h"
#include "cfomdef.h"
#include <fcntl.h>

#define FMXT	".nfm"	/* form file extention */
#define STXT	".sth"	/* C structure file extention */
#define MAXFNML	8	/* max file name length without extention */
#define VD_SZ	(3*fh.vdsize)	 /* size of var data blk to be allocd */

static 	struct  frmhdr	fh;		/* form file header area */
static	struct	frmfld	*fap = NULL;	/* ptr to array of fields */
static	struct	frmfld	*cf = NULL;	/* current field being accessed */
static	struct	fldinfo	*fiap = NULL;	/* ptr to array of internal items */
static	struct	fldinfo	*cfi = NULL;	/* current field's internal items */
static	char	*fvp=NULL;			/* ptr to variable data area */
static	int	fvoff=0,
		fd;		/* for reading form file */
static FILE	*ofl=NULL;		/* for output */
static	char	s[256],t[256],s2[256],t2[256];

extern struct frmhdr hdrrc;

char *malloc();


static onscrnsz()
{
 int count,val;
 char *ptr;
 count=0;
 ptr=fvp+cf->dmask;
 while(*ptr) {
    if((*ptr)=='(') {
         ptr++;
         sscanf(ptr,"%d",&val);
         ptr+=2;
         if(val>9)ptr++;
         count=count+val-1;
     }
    else 
         count++;
    ptr++;
  }
  return(count);
}



static fillconv()  /* Fill up some details about current field */
  {

   char *ptr;
  int mlength;
  cfi->Signed=0;
  cfi->decimals=0;
  cfi->type=FITYP_NUM;
  if(cf->fldtyp==TYP_DATE) {
     mlength=0;
    for(ptr=fvp+cf->imask;*ptr!='\0';ptr++)
                if(*ptr=='M' || *ptr=='m')mlength++;
                if(mlength==3) cfi->type=FITYP_NON;
  }

  if(cf->fldtyp==TYP_NUM) {
       for(ptr=fvp+cf->imask;*ptr!='\0' && *ptr!='.';ptr++)
                  if(*ptr=='s' || *ptr=='S') cfi->Signed=1;
      if(*ptr=='.') {
         for(ptr++;*ptr!='\0';ptr++)
                 if(*ptr != 'F') (cfi->decimals)++;
    }

}

  if(cf->fldtyp==TYP_STRING) cfi->type=FITYP_NON;
  return(0);

 } /* fillconv  */

gencdr(appstrng)
char	*appstrng;{

	register int i,j;

	strcpy(s,hdrrc.scrnnam);
	strcat(s,FMXT);
	if ((fd = open(s,(O_RDONLY))) == -1){	/* file not found */
		return(1);
		}
	if (read(fd,(char *)&(fh),FMH_SZ) != FMH_SZ){	/* read header */
		sprintf(s2,"read error on %s",s);
		return(2);
		}
	if ((fap = ((struct frmfld *) malloc((unsigned)fh.noflds * FMF_SZ))) == NULL)
				/* alloc for fields */
		return(3);
	if ((fiap = ((struct fldinfo *) malloc((unsigned)fh.noflds * FI_SZ))) == NULL)
				/* alloc for internal data */
		return(3);
	for (i = 0; i < fh.noflds; i++)	/* read fields */
		if (read(fd,(char *)(fap+i),FMF_SZ) != FMF_SZ){
			return(4);
			}
	if ((fvp = malloc((unsigned)VD_SZ)) == NULL)
			/* alloc for variable data */
		return(3);
	fvoff = fh.vdsize;	/* set free space offset */
	if (read(fd,(char *)(fvp),fh.vdsize) != fh.vdsize){ /* read var data */
		return(5);
		}
	close(fd);
	for (i=0; i<fh.noflds; i++){	/* set up internal data items */
		if ((fap+i)->fldclas == CL_PROM)
			continue;
		cf = fap+i;
		cfi = fiap+i;
		if ((j = onscrnsz()) <= 0)	/* on-screen-size = 0 */
			return(6);
		cfi->oscrnsz = j;
		fillconv();
		}
	strcpy(t,hdrrc.scrnnam);
	strcat(t,STXT);
	if ((ofl = fopen(t,"w")) == NULL){
		return(10);
		}
	fprintf(ofl,"/* %s - header for C structure generated by PROFOM EDITOR */\n\n",t);
	fprintf(ofl,"struct\t%s_struct\t{\n\n",appstrng);
	for (i=0; i<fh.noflds; i++){	/* loop thru fields */
		if ((fap+i)->fldclas == CL_PROM)
			continue;
		cf=fap+i;
		cfi=fiap+i;
		if (cf->fldnam != 0)
			strcpy(t2,cvelm(fldnam));
		else {
			strcpy(t2,appstrng);
			sprintf(s2,"%d",cf->fldno);
			strcat(t2,s2);
			}
		if (cfi->type == FITYP_NON){	/* non numeric field */
			fprintf(ofl,"\tchar\t%s[%d];",t2,cf->dfsize+1);
			}
		else if (cfi->decimals == 0) /* numeric field with no dec */
			/**** Changed by amar on 21-jun-89..
			if (cf->dfsize <= IMAXDIGITS)	* regular int *
				fprintf(ofl,"\tint\t%s;",t2);
			*****/
			/****/
			if (cf->dfsize <= SMAXDIGITS) {	/* regular int */
				if(cf->fldtyp == TYP_YN)
					fprintf(ofl,"\tint\t%s;",t2);
				else
					fprintf(ofl,"\tshort\t%s;",t2);
				}
			/*****/
			else	/* long int required */
				fprintf(ofl,"\tlong\t%s;",t2);
		else if (cf->dfsize <= FMAXDIGITS) {	/* regular float */
			printf("fmaxdigist: %d\n",FMAXDIGITS);
			getchar();
			fprintf(ofl,"\tfloat\t%s;",t2);
		}
		else	/* double required */
			fprintf(ofl,"\tdouble\t%s;",t2);
		fprintf(ofl,"\t/* ");
		switch (cf->fldtyp){
		case TYP_YN	: fprintf(ofl,"YES/NO %s ",cvelm(imask));
					break;
		case TYP_DATE	: fprintf(ofl,"DATE %s ",cvelm(imask));
					break;
		case TYP_NUM	: fprintf(ofl,"NUMERIC %s ",cvelm(imask));
					break;
		case TYP_STRING	: fprintf(ofl,"STRING %s ",cvelm(imask));
					break;
		default : return(11);
		}
		if (cf->fldnam != 0)
			fprintf(ofl,"field %d ",cf->fldno);
		fprintf(ofl,"*/\n");
		}
	fprintf(ofl,"\t};\n");
	fclose(ofl);
	if(free((char *) fap) == -1)   return(14);
	if(free((char *) fiap) == -1)  return(14);
	if(free((char *) fvp) == -1)   return(14);
	return(0);
	}
