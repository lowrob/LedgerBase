/*-----------------------------------------------------------------------
Source Name: tendyend.c
System     : Tendering.
Created  On: 7th April 92.
Created  By: Jonathan Prescott.

DESCRIPTION:
	Program to Transfer Tenders to History.

MODIFICATIONS:        

Programmer     YY/MM/DD       Description of modification

------------------------------------------------------------------------*/
#define	MAIN		/* Main program. This is to declare Switches */
#define MAINFL		CATALOGUE		/* main file used */

#define	SYSTEM		"TENDERING"	/* Sub System Name */
#define	MOD_DATE	"7-APR-92"		/* Progran Last Modified */

#include <stdio.h>
#include <cfomstrc.h>
#include <bfs_defs.h>
#include <bfs_recs.h>

#define	DELTA_AMT  0.005	/* To Check double values for zero */
#define	DELTA_QTY  0.00005	/* To Check double values for zero */

/* User Interface define constants */
#ifdef ENGLISH
#define	YES		'Y'
#define NO		'N'

#else
#define	YES		'O'
#define NO		'N'

#endif

/* PROFOM Releted declarations */

#define	SCR_NAME	"tendyend"	/* PROFOM screen Name */

/* PROFOM Screen STH file */

/* Field PROFOM numbers */

#define ST_FLD		100	/* First Field on Screen */
#define END_FLD		1300	/* Last Field on Screen */

#define TRANS_FLD	600	/* Transfer all Field */
#define CATEG1_FLD	700	/* Category start Field */
#define CATEG2_FLD	800	/* Category end Field */
#define ITMGRP1_FLD	900	/* Item Group start Field */
#define ITMGRP2_FLD	1000	/* Item Group end Field */
#define CAT1_FLD	1100	/* Catalogue start Field */
#define CAT2_FLD	1200	/* Catalogue end Field */
#define CONFIRM_FLD	1300	/* Confirmation Field */

/* tendyend.sth - header for C structure generated by PROFOM EDITOR */

typedef struct	{

	char	s_trans[2];	/* STRING X Field 600 */
	short	s_categ1;	/* NUMERIC 99 Field 700 */
	short	s_categ2;	/* NUMERIC 99 Field 800 */
	short	s_itmgrp1;	/* NUMERIC 9999 Field 900 */
	short	s_itmgrp2;	/* NUMERIC 9999 Field 1000 */
	long	s_cat1;		/* NUMERIC 9999999 Field 1100 */
	long	s_cat2;		/* NUMERIC 9999999 Field 1200 */
	char	s_confirm[2];	/* STRING X Field 1300 */
} s_struct;


static	s_struct  s_sth, image;	/* PROFOM Screen Structure */
static	struct  stat_rec  sr;		/* PROFOM status rec */

static	Pa_rec		pa_rec ;	/* Parameters Record */
static	Catalogue	catalogue,tmp_cat;	/* Catalogue */
static	Tend_Hist	tend_hist;
static	Bid		bid_rec;
static	PotBidder	pb_rec;

static	char 	e_mesg[100];  		/* dbh will return err msg in this */

int	Validation();
int	WindowHelp();
int	Argc;
char	**Argv;

main(argc,argv)
int argc;
char *argv[];
{
	int 	retval;

	/* These two are passed to execute() when it is called */
	Argc = argc;
	Argv = argv;

	retval = Initialize(argc,argv);	/* Initialization routine */

	if (retval == NOERROR) retval = Process();

	CloseRtn();			/* return to menu */
	if (retval != NOERROR) exit(-1);

	exit(0);
}

/*-------------------------------------------------------------------*/
/* Initialize PROFOM */

Initialize(argc, argv)
int	argc ;
char	*argv[] ;
{
	int	err ;

	/*
	*	Initialize DBH Environment
	*/
	strncpy(SYS_NAME,SYSTEM,50);	/* Sub system name */
	strncpy(CHNG_DATE,MOD_DATE,10);	/* Modification Date */

	proc_switch(argc, argv, MAINFL) ; 	/* Process Switches */

	/*
	*	Initialize PROFOM & Screen
	*/
	STRCPY(sr.termnm,terminal);	/* Copy Terminal Name */
	fomin(&sr);
	ret(err_chk(&sr)) ;		/* Check for PROFOM Error */
	fomcf(1,1);			/* Enable Snap screen option */

	err = InitScreen() ;		/* Initialize Screen */
	if(NOERROR != err) return(err) ;

	/*
	*	Get The Parameter Record
	*/
	err = get_param(&pa_rec, BROWSE, 1, e_mesg) ;
	if(err == ERROR) {
		fomer(e_mesg);
		get();
		return(ERROR) ;
	}
	else if(err == UNDEF) {
#ifdef ENGLISH
		fomer("Parameters Are Not Set Up ...");
#else
		fomer("Parametres ne sont pas etablis... ");
#endif
		get();
		return(ERROR) ;
	}
	if(pa_rec.pa_tendering[0] != YES) {
#ifdef ENGLISH
	     fomer("Tendering System Absent.  See Parameter Maintenance.");
#else
	     fomer("Systeme Soumission absent. Voir l'entretien des parametres.");
#endif
	     get();
	     return(ERROR);
	}
	return(NOERROR) ;
}	/* Initialize() */

/*--------------------------------------------------------------------------*/
/* Close nessary files and environment before exiting program               */

CloseRtn() 
{
	/* Set terminal back to normal mode from PROFOM */
	fomcs();
	fomrt();

	close_dbh();	/* Close files */

	return(NOERROR);
}	/* CloseRtn() */
/*----------------------------------------------------------------*/
/* Initialize screen before going to process options */

InitScreen()
{
	int	err ;

	/* move screen name to Profom status structure */
	STRCPY(sr.scrnam,NFM_PATH);
	strcat(sr.scrnam,SCR_NAME) ;

	s_sth.s_trans[0] = LV_CHAR;
	s_sth.s_categ1 = HV_SHORT;
	s_sth.s_categ2 = HV_SHORT;
	s_sth.s_itmgrp1 = HV_SHORT;
	s_sth.s_itmgrp2 = HV_SHORT;
	s_sth.s_cat1 = HV_LONG;
	s_sth.s_cat2 = HV_LONG;
	s_sth.s_confirm[0] = HV_CHAR;

	ret( WriteFields((char *)&s_sth,ST_FLD, END_FLD) );
	return(NOERROR) ;
}	/* InitScreen() */

/*-------------------------------------------------------------------*/
/* Get Option from user and call corresponding function */

Process()
{
	int retval;

	retval = ReadFields((char *)&s_sth,TRANS_FLD,TRANS_FLD,
		Validation, WindowHelp, 1) ;
	if(PROFOM_ERR == retval || DBH_ERR == retval) return(retval) ;

	if(s_sth.s_trans[0] == NO) {
		s_sth.s_categ1 = LV_SHORT;
		s_sth.s_categ2 = LV_SHORT;

	/* Remove the selecting of item group and catagorie, it don't work Louis
		s_sth.s_itmgrp1 = LV_SHORT;
		s_sth.s_itmgrp2 = LV_SHORT;
		s_sth.s_cat1 = LV_LONG;
		s_sth.s_cat2 = LV_LONG;
	************************************************************/

		retval = ReadFields((char *)&s_sth,CATEG1_FLD,CAT2_FLD,
			Validation, WindowHelp, 1) ;
		if(PROFOM_ERR == retval || DBH_ERR == retval) return(retval) ;
	}

	s_sth.s_confirm[0] = LV_CHAR;
	retval = ReadFields((char *)&s_sth,CONFIRM_FLD,CONFIRM_FLD,
		Validation, WindowHelp, 1) ;
	if(PROFOM_ERR == retval || DBH_ERR == retval) return(retval) ;

	if(s_sth.s_confirm[0] == YES) {
		retval = UpdateRecords();
		if(retval < 0) {
			fomer(e_mesg);
			return(retval);
		}
	}
	return(NOERROR);
}	/* ProcFunction() */
/*-----------------------------------------------------------------------*/ 
/* Update the records and write to files */

UpdateRecords()
{
	int	retval;
	int	mode;
	int	i;

	if(s_sth.s_trans[0] == YES) {
		catalogue.cat_num = 0;
	}
	else {
		catalogue.cat_num = s_sth.s_categ1 * 100000;
	}

	flg_reset(CATALOGUE);

	for( ; ; ) {
		retval = get_n_catalogue(&catalogue,UPDATE,0,FORWARD,e_mesg);
		if(retval == EFL) break;
		if(retval < 0) {
			fomer(e_mesg);
			get();
			roll_back(e_mesg);
			return(retval);
		}

		if(s_sth.s_trans[0] != YES) {
			if(catalogue.cat_num / 100000 > s_sth.s_categ2) break;
		/* Does not work
			if(catalogue.cat_num / 1000 < s_sth.s_itmgrp1 || 
			   catalogue.cat_num / 1000 > s_sth.s_itmgrp2) {
					continue;
			}
			if(catalogue.cat_num < s_sth.s_cat1 || 
			   catalogue.cat_num > s_sth.s_cat2) {
					continue;
			}
		********************************/
		}
		bid_rec.bid_cat_num = catalogue.cat_num;
		flg_reset(BID);
		for( ; ; ) {
			retval = get_n_bid(&bid_rec,UPDATE,4,FORWARD,e_mesg);
			if(retval == EFL) break;
			if(retval < 0) {
				fomer(e_mesg);
				get();
				roll_back(e_mesg);
				return(retval);
			}

			if(bid_rec.bid_cat_num != catalogue.cat_num) {
				break;
			}
			retval = put_bid(&bid_rec,P_DEL,e_mesg);
			if(retval < 0) {
				fomer(e_mesg);
				get();
				roll_back(e_mesg);
				return(retval);
			}
			inc_str(bid_rec.bid_supp_cd,
				sizeof(bid_rec.bid_supp_cd)-1,FORWARD);
		}
		pb_rec.pb_categ_num = catalogue.cat_num / 100000 ;
		flg_reset(POTBIDDER);
		for( ; ; ) {
			retval=get_n_potbidder(&pb_rec,UPDATE,0,FORWARD,e_mesg);
			if(retval == EFL) break;
			if(retval < 0) {
				fomer(e_mesg);
				get();
				roll_back(e_mesg);
				return(retval);
			}

			if(pb_rec.pb_categ_num != catalogue.cat_num / 100000) {
				break;
			}
			pb_rec.pb_select = 0;
			retval = put_potbidder(&pb_rec,UPDATE,e_mesg);
			if(retval < 0) {
				fomer(e_mesg);
				get();
				roll_back(e_mesg);
				return(retval);
			}
			pb_rec.pb_categ_num++;
		}	
		tend_hist.th_cat_num = catalogue.cat_num;
		retval = get_tendhist(&tend_hist,UPDATE,0,e_mesg);
		if(retval < 0 && retval != UNDEF) {
			fomer(e_mesg);
			get();
			roll_back(e_mesg);
			return(retval);
		}
		if(retval == UNDEF) {
			mode = ADD;
			/* Initialize all years of new Record */
			for(i=0;i<3;i++) {
				tend_hist.th_supp[i][0] = '\0';
				tend_hist.th_price[i] = 0.00;
				tend_hist.th_qty[i] = 0.00;
				tend_hist.th_min_dollar[i] = 0.00;
				tend_hist.th_date[i] = 0 ;
			}
		}
		else {
			mode = UPDATE;
		}

		/* 3 Years Ago */
		strcpy(tend_hist.th_supp[2],tend_hist.th_supp[1]);
		tend_hist.th_price[2] = tend_hist.th_price[1];
		tend_hist.th_qty[2] = tend_hist.th_qty[1];
		tend_hist.th_min_dollar[2] = tend_hist.th_min_dollar[1];
		tend_hist.th_date[2] = tend_hist.th_date[1];

		/* 2 Years Ago */
		strcpy(tend_hist.th_supp[1],tend_hist.th_supp[0]);
		tend_hist.th_price[1] = tend_hist.th_price[0];
		tend_hist.th_qty[1] = tend_hist.th_qty[0];
		tend_hist.th_min_dollar[1] = tend_hist.th_min_dollar[0];
		tend_hist.th_date[1] = tend_hist.th_date[0];
		

		/* Prev Year */
		strcpy(tend_hist.th_supp[0],catalogue.cat_awd_supp);
		tend_hist.th_price[0] = catalogue.cat_unit_price[0];
		tend_hist.th_qty[0] = catalogue.cat_qty[0];
		tend_hist.th_min_dollar[0] = catalogue.cat_min_dollar;
		tend_hist.th_date[0] = get_date();

		retval = put_tendhist(&tend_hist,mode,e_mesg);
		if(retval < 0) {
			fomer(e_mesg);
			get();
			roll_back(e_mesg);
			return(retval);
		}

		catalogue.cat_awd_supp[0] = LV_CHAR;
		catalogue.cat_min_dollar = 0.00;
		catalogue.cat_unit_price[1] = catalogue.cat_unit_price[0];
		catalogue.cat_qty[1] = catalogue.cat_qty[0];
		catalogue.cat_unit_price[0] = 0.00;
		catalogue.cat_qty[0] = 0.00;

		retval = put_catalogue(&catalogue,UPDATE,e_mesg);
		if(retval < 0) {
			fomer(e_mesg);
			get();
			roll_back(e_mesg);
			return(retval);
		}

		retval = commit(e_mesg) ;
		if(retval < 0) {
#ifdef ENGLISH
			fomer("ERROR in Saving Records"); 
#else
			fomer("ERREUR en conservant les fiches");
#endif
			get();
			fomer(e_mesg);
			get();
			return(retval);
		}
		catalogue.cat_num++;
	}

	return(NOERROR);
}	/* WriteRecords() */
/*----------------------------------------------------------------*/
/* Validation function() for Key and Header fields when PROFOM returns
  RET_VAL_CHK */

Validation()
{
	int	err, save_nextfld, save_endfld ;

	switch(sr.curfld){
	case	TRANS_FLD:	
		if(s_sth.s_trans[0] != NO && s_sth.s_trans[0] != YES) {
#ifdef ENGLISH
			fomer("Valid Options are Y or N");
#else
			fomer("Options valables sont O ou N");
#endif
			s_sth.s_trans[0] = LV_CHAR;
			return(ERROR);
		}
		break ;
	case	CATEG1_FLD:
		break ;
	case	CATEG2_FLD:
		if(s_sth.s_categ2 < s_sth.s_categ1) {
#ifdef ENGLISH
			fomer("Ending Category Must be Greater Than Starting Category");
#else
			fomer("Categorie finissante doit etre plus grande que la categorie debutante.");
#endif
			s_sth.s_categ2 = LV_SHORT;
		}
		break ;
	case	ITMGRP1_FLD:
		break ;
	case	ITMGRP2_FLD:
		if(s_sth.s_itmgrp2 < s_sth.s_itmgrp1) {
#ifdef ENGLISH
			fomer("Ending Item Group Must be Greater Than Starting Item Group");
#else
			fomer("Groupe d'article finissant doit etre plus grand que le groupe d'article debutant.");
#endif
			s_sth.s_itmgrp2 = LV_SHORT;
		}
		break ;
	case	CAT1_FLD:
		break ;
	case	CAT2_FLD:
		if(s_sth.s_cat2 < s_sth.s_cat1) {
#ifdef ENGLISH
			fomer("Ending Catalogue Must be Greater Than Starting Catalogue");
#else
			fomer("Catalogue finissant doit etre plus grand que le catalogue debutant.");
#endif
			s_sth.s_cat2 = LV_SHORT;
		}
		break ;
	case	CONFIRM_FLD:
		if(s_sth.s_confirm[0] != NO && s_sth.s_confirm[0] != YES) {
#ifdef ENGLISH
			fomer("Valid Options are Y or N");
#else
			fomer("Options valables sont O ou N");
#endif
			s_sth.s_confirm[0] = LV_CHAR;
			return(ERROR);
		}
		break ;
	default :
#ifdef ENGLISH
		sprintf(e_mesg,"No Validity Check For Field#  %d",sr.curfld);
#else
		sprintf(e_mesg,"Pas de controle de validite pour le Champ#  %d",sr.curfld);
#endif
		fomen(e_mesg);
		get();
		return(ERROR) ;
	}	/* Switch sr.curfld */

	return(NOERROR) ;
}	/* Validation() */
/*----------------------------------------------------------------*/
/* Show Help Windows, if applicable, when user gives ESC-H in key
   and header fields */

WindowHelp()
{
	int	err ;

/****
	switch(sr.curfld){
		break ;
	default :
#ifdef ENGLISH
		fomer("No Help Window For This Field");
#else
		fomer("Pas de fenetre d'assistance pour ce champ");
#endif
	}	* Switch sr.curfld */

	return(NOERROR) ;
}	/* WindowHelp() */
/*-------------------- E n d   O f   P r o g r a m ---------------------*/
