/*-----------------------------------------------------------------------
Source Name: award.c
System     : Tendering System.
Created On : 14th Apr. 92.
Created By : J. Prescott.

DESCRIPTION:

Used to Award Prices to Bids.

MODIFICATIONS:        

Programmer	YY/MM/DD	Description of modification
S. Whittaker	93/03/04	The program was not updating the category
				maintenance supplier properly.
S.Whittaker	93/05/28	Updated the rite_audit function to include
				passing the screen structure.

------------------------------------------------------------------------*/
#define	MAIN		/* Main program. This is to declare Switches */
#define MAINFL		BID	/* main file used */

#define	SYSTEM		"TENDERING"	/* Sub System Name */
#define	MOD_DATE	"14-APR-92"		/* Progran Last Modified */

#include <stdio.h>
#include <cfomstrc.h>
#include <bfs_defs.h>
#include <bfs_recs.h>

/* User Interface define constants */
#ifdef ENGLISH
#define AWARD		'A'
#define CHANGE		'C'
#define INQUIRE		'I'
#define EXITOPT		'E'
#define	NEXT		'N'
#define	PREV		'P'

#define	YES		'Y'
#define NO		'N'
#define AWARDITEM	'A'
#define	CANCEL		'C'

#define ACTIVE		"ACT"
#define DELETED		"DEL"

#define AWARD_STAT	"AWD"
#else
#define AWARD		'A'
#define CHANGE		'C'
#define INQUIRE		'I'
#define EXITOPT		'F'
#define	NEXT		'S'
#define	PREV		'P'

#define	YES		'O'
#define NO		'N'
#define AWARDITEM	'A'
#define	CANCEL		'A'

#define ACTIVE		"ACT"
#define DELETED		"ELI"

#define AWARD_STAT	"ATT"
#endif

/* PROFOM Releted declarations */

#define	SCR_NAME	"award"	/* PROFOM screen Name */

#define	PAGESIZE	7		/* No of Items */

#define NOOPTIONS	44	/* No options can be performed */

/* PROFOM Screen STH file */

/* Field PROFOM numbers */

#define FN_FLD		400	/* Fn: */

#define KEY_START	500	/* Key Start Field */
#define KEY_END		500	/* Key End Field */
#define CHG_FLD		600

#define CATEG_FLD	800	/* Category Description Field */
#define PAGE_FLD	1300	/* Page# Field */
#define	ITEM_ST_FLD	1700	/* Item 1 Start Field */
#define	END_FLD		5300	/* Last Field of the screen */
#define	STEP		500	/* NO of fields diff. between 2 items */

#define STATUS_FLD	400	/* Offset of Status in item line */

/* award.sth - header for C structure generated by PROFOM EDITOR */

typedef	struct	{	/* Start Fld 1700, Endfld 5100 and Step 500 */

	char	s_supp_cd[11];	/* 1700 STRING X(10) */
	char	s_sname[21];	/* 1800 STRING X(20) */
	char	s_desc[20];	/* 1900 STRING X(13) */
	double	s_bid_price;	/* 2000 NUMERIC 9999.9999 */
	char	s_status[4]; 	/* 2100 STRING X(3) */
}	S_item ;

typedef struct	{

	char	s_pgname[11];	/* 100 STRING X(10) */
	long	s_rundate;	/* 300 DATE YYYYFMMFDD */
	char	s_fn[2];	/* 400 STRING X */
	long	s_cat_num;	/* 500 NUMERIC 9999999 */
	short	s_field;	/* 600 NUMERIC 99 */

	char	s_categ_desc[41];/* 800 STRING X(40) */
	char	s_itmg_desc1[41];/* 900 STRING X(40) */
	char	s_itmg_desc2[41];/* 1000 STRING X(40) */
	char	s_itmg_desc3[41];/* 1100 STRING X(40) */
	char	s_item_desc[41]; /* 1200 STRING X(40) */
	short	s_page;		 /* 1300 NUMERIC 99 */
	char	s_dummy1[4];	/* dummy field */
	char	s_dummy2[3];	/* dummy field */
	char	s_dummy3[3];	/* dummy field */

	S_item	s_items[PAGESIZE] ;	/* Start Fld 1100, End Fld 7000  */

	char	s_mesg[78];	/* 7100 STRING X(77) */
	char	s_resp[2];	/* 7200 STRING X */
} s_struct;

static	s_struct  s_sth,image;	/* PROFOM Screen Structure */
static	struct  stat_rec  sr;		/* PROFOM status rec */

static	char 	e_mesg[100];  		/* dbh will return err msg in this */

int	Validation() ;
int	WindowHelp() ;

int	Argc;
char	**Argv;

typedef struct Page {
	S_item	Items[PAGESIZE] ;	/* Items Information */
	struct	Page	*PrevPage ;	/* ptr to previous page */
	struct	Page	*NextPage ;	/* ptr to next page */
	char	I_Status[PAGESIZE][2];	/* item status ie A(DD) C(hange) */
	short	NoItems;		/* number of Items on the page */
	short	Pageno;			/* Page number */
}	Page;

static	Page	*FirstPage,		/* Address of First Page */
		*CurPage,		/* Address of Current Page */
		*CurLast,		/* Address of Curr. record last page */
		*LastPage;		/* Address of Last Page of Memory
					   Allocated */

static	Pa_rec	pa_rec;	 	/* Parameter record */
static	Bid bid_rec, pre_bid;	/* Bid Record */
static	Catalogue catalogue;	/* Catalogue record */
static	Category category;	/* Category Record */
static	Item_grp item_grp;	/* Item Group Record */
static	Supplier supplier;	/* Supplier Record */

static	char chardate[11],projname[50],program[11],discfile[20];
static	int  logrec,outcntl,formno,code;
static  char *arayptr[5];
static	int first;
static  int firstN;

void	free() ;
/****
char	*malloc() ;
****/
int	award_cnt;

/* Used for Next/Prev Option */
static	long	cat_num;
static	double	cat_price;
static	char	cat_supp[11];

main(argc,argv)
int argc;
char *argv[];
{
	int 	retval;

	/* These two are passed to execute() when it is called */
	Argc = argc;
	Argv = argv;

	retval = Initialize(argc,argv);	/* Initialization routine */

	if (retval == NOERROR) retval = Process();

	CloseRtn();			/* return to menu */
	if (retval != NOERROR) exit(-1);
	exit(0);
}

/*-------------------------------------------------------------------*/
/* Initialize PROFOM */

Initialize(argc, argv)
int	argc ;
char	*argv[] ;
{
	int	err ;

	/*
	*	Initialize DBH Environment
	*/
	strncpy(SYS_NAME,SYSTEM,50);	/* Sub system name */
	strncpy(CHNG_DATE,MOD_DATE,10);	/* Modification Date */

	proc_switch(argc, argv, MAINFL) ; 	/* Process Switches */

	/*
	*	Initialize PROFOM & Screen
	*/
	strcpy(sr.termnm,terminal);	/* Copy Terminal Name */
	fomin(&sr);
	ret(err_chk(&sr)) ;		/* Check for PROFOM Error */
	fomcf(1,1);			/* Enable Snap screen option */

	err = InitScreen() ;		/* Initialize Screen */
	if(NOERROR != err) return(err) ;

	/*
	*	Get The Parameter Record
	*/
	err = get_param(&pa_rec, BROWSE, 1, e_mesg) ;
	if(err == ERROR) {
		DispError((char *)&s_sth,e_mesg);
		return(ERROR) ;
	}
	else if(err == UNDEF) {
#ifdef ENGLISH
		DispError((char *)&s_sth,"Parameters Are Not Set Up ...");
#else
		DispError((char *)&s_sth,"Parametres ne sont pas etablis... ");
#endif
		return(ERROR) ;
	}
	if(pa_rec.pa_tendering[0] != YES) {
#ifdef ENGLISH
	     DispError((char *)&s_sth,"Tendering System Absent.  See Parameter Maintenance.");
#else
	     DispError((char *)&s_sth,"Systeme Soumission absent. Voir l'entretien des parametres");
#endif
	     return(ERROR);
	}

	/* Setup Audit Report */
	logrec = formno = 1;
	outcntl = 7;
	firstN=0;
	first = 0;

	mkdate(get_date(),chardate);
	STRCPY(projname,FMT_PATH); 
	strcat(projname,"awd_audit");
	STRCPY(discfile,"awd_audit.dat");

	arayptr[0] = (char *) &bid_rec;
	arayptr[1] = (char *) &supplier;
	arayptr[2] = NULL;

	FirstPage = NULL;
	LastPage = NULL;

	return(NOERROR) ;
}	/* Initialize() */

/*--------------------------------------------------------------------------*/
/* Close nessary files and environment before exiting program               */

CloseRtn() 
{
	int err;

	FreeList();
	rpclose();

#ifdef ENGLISH
	err = GetOption((char *)&s_sth,"Do You Want Audit Report (Y/N)?","YN");
#else
	err = GetOption((char *)&s_sth,"Desirez-vous avoir un rapport de verification (O/N)?","ON");
#endif
	if(err == YES) {
#ifdef	i386
		system("lp -s -c -o nobanner awd_audit.dat");
#else
		system("lpr -b awd_audit.dat");
#endif
		unlink("awd_audit.dat");
	}
	/* Set terminal back to normal mode from PROFOM */
	fomcs();
	fomrt();

	close_dbh();	/* Close files */

	return(NOERROR);

}	/* CloseRtn() */

/*----------------------------------------------------------------*/

FreeList()
{
	int	err;
	Page	*TempPage;

	if(LastPage != NULL){
		for( ;LastPage != FirstPage; ){
			TempPage = LastPage->PrevPage;
			free((char *)LastPage);
			LastPage = TempPage;
		}
	}

	if(FirstPage != NULL){
		free((char *)FirstPage);
	}

	FirstPage = LastPage = NULL;
	return(NOERROR);
}

/*----------------------------------------------------------------*/
/* Initialize screen before going to process options */

InitScreen()
{
	int	err ;

	/* move screen name to Profom status structure */
	strcpy(sr.scrnam,NFM_PATH);
	strcat(sr.scrnam,SCR_NAME) ;

	strcpy(s_sth.s_pgname,PROG_NAME);

	s_sth.s_rundate = get_date();	/* get Today's Date in YYYYMMDD format*/
	s_sth.s_field = HV_SHORT ;
	s_sth.s_mesg[0] = HV_CHAR ;
	s_sth.s_resp[0] = HV_CHAR ;

	/* Move High Values to data fields and Display the screen */
	err = ClearScreen() ;
	if(NOERROR != err) return(err) ;

	return(NOERROR) ;
}	/* InitScreen() */
/*-------------------------------------------------------------------*/
/* Get Option from user and call corresponding function */

Process()
{
	int err;

	for( ; ; ){

		/* Get the Fn: option from the user */
		if((err = ReadFunction()) != NOERROR) return(err) ;

		err = ProcFunction() ;	/* Process Function */

		if(QUIT == err)		return(NOERROR) ;    /* Exit */
		if(NOACCESS == err)	fomen(e_mesg);	     /* security */
		if(PROFOM_ERR == err)	return(PROFOM_ERR);  /* PROFOM ERROR */
		if(DBH_ERR == err) {
			DispError((char *)&s_sth,e_mesg);
#ifdef ENGLISH
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"System Error... Iserror:",
				iserror, dberror, errno);
#else
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"Erreur du systeme... Iserror:",
				iserror, dberror, errno);
#endif
			DispError((char *)&s_sth,e_mesg);
			return(DBH_ERR); /* DBH ERROR */
		}
	}      /*   end of the for( ; ; )       */
}	/* Process() */
/*----------------------------------------------------------------*/
/* Display the Function (Fn:) options and get the option from the user */

ReadFunction()
{
	/* Display Fn: options */
#ifdef ENGLISH
	fomer("A(Ward Price), C(hange), I(nquire), N(ext), P(rev), E(xit)");
#else
	fomer("A(ttribuer), C(hanger), I(nterroger), S(uivant), P(recedent), F(in)");
#endif
	/* Read Fn: field to get the option */
	sr.nextfld = FN_FLD ;
	fomrf( (char *)&s_sth );
	ret(err_chk(&sr));	/* Check for PROFOM error */

	return(NOERROR) ;
}	/* ReadFunction() */
/*----------------------------------------------------------------*/
/* Process the user selected Fn: option */

ProcFunction()
{
	int retval;

	switch (s_sth.s_fn[0]) {
	case AWARD  :			/* ADD */
		CHKACC(retval,ADD,e_mesg);
		return( AwardPrice() ) ;
	case CHANGE  :			/* CHANGE */
		CHKACC(retval,UPDATE,e_mesg);
		return( AwardPrice() ) ;
	case INQUIRE  :			/* Inquire */
		CHKACC(retval,BROWSE,e_mesg);
		return( Inquire() ) ;
	case NEXT  :			/* Next */
		CHKACC(retval,BROWSE,e_mesg);
		return( Next(FORWARD) ) ;
	case PREV  :			/* Previous */
		CHKACC(retval,BROWSE,e_mesg);
		return( Next(BACKWARD) ) ;
	case EXITOPT  :			/* Exit */
		return( QUIT ) ;
	}  /*   end of the switch statement */

	return(retval);
}	/* ProcFunction() */
/*-----------------------------------------------------------------------*/
/* Change. Potential Bidders 						 */
/*-----------------------------------------------------------------------*/
AwardPrice()
{
	int	err ;

	err = SelectRecord() ;
	if(NOERROR != err) return(err);

	for( ; ; ) {
		err = ConfirmItems() ;
		if(err != YES) {
			roll_back(e_mesg);
			break;
		}

		err = ProcItemUpdates(UPDATE) ;
		if(err==NOERROR) break;
		if(err==LOCKED) {
			roll_back(e_mesg) ;
			continue;
		}
		if (err < 0) {
			roll_back(e_mesg);
			return(err) ;
		}
	}

	return(NOERROR) ;
}	/* Change() */
/*-----------------------------------------------------------------------*/
/* Show Potential Bidders */
Inquire()
{
	int	err ;

	err = SelectRecord() ;
	if(NOERROR != err) return(err) ;

	err = ConfirmItems() ;
	
	return(NOERROR) ;
}	/* Inquire() */
/*----------------------------------------------------------*/
/* Show the next or previous Potential Bidders */

Next(direction)
int	direction ;
{
	int err;

	firstN++;
	cat_num = s_sth.s_cat_num;	
	for( ; ; ) {
		/* Check whether file is in seq. read mode */
		bid_rec.bid_cat_num = cat_num ;
		if(flg_start(BID) != direction) {  
			if (direction == FORWARD) {
				bid_rec.bid_cat_num++; 
				bid_rec.bid_price =  0.00;
				bid_rec.bid_supp_cd[0] = '\0';
			}
			else {
				bid_rec.bid_cat_num--;
				bid_rec.bid_price =  HV_DOUBLE;
				strcpy(bid_rec.bid_supp_cd,"ZZZZZZZZZZ");
			}
		}
		else {
			if (direction == FORWARD) {
				bid_rec.bid_price = cat_price ; 
				strcpy(bid_rec.bid_supp_cd,cat_supp);
				inc_str(bid_rec.bid_supp_cd,
				sizeof(bid_rec.bid_supp_cd)-1,direction);
			}
			else {
				bid_rec.bid_price = cat_price ;
				strcpy(bid_rec.bid_supp_cd,cat_supp);
				inc_str(bid_rec.bid_supp_cd,
				sizeof(bid_rec.bid_supp_cd)-1,direction);
			}
		}
		flg_reset(BID);

		err = get_n_bid(&bid_rec,BROWSE,2,direction,e_mesg);
		if(err < 0 && err != EFL) {
			DispError((char *)&s_sth,e_mesg);
			return(err);
		}

		if(err == EFL) {

			fomer("No More Records...");
			get();
			return(NOERROR);	
		}
		else 
		if(strcmp(bid_rec.bid_status,AWARD_STAT)!=0){
			cat_num = bid_rec.bid_cat_num;	
			cat_price = bid_rec.bid_price ; 
			strcpy(cat_supp,bid_rec.bid_supp_cd);
			continue;
		}
		else{

			s_sth.s_cat_num = bid_rec.bid_cat_num;
			cat_num = bid_rec.bid_cat_num;	
			cat_price = bid_rec.bid_price ; 
			strcpy(cat_supp,bid_rec.bid_supp_cd);
	
			ret(WriteFields((char *)&s_sth,KEY_START,KEY_END));

			/* Get area records i.e. Build list */

			err = BuildList();
			if(err < 0 && err != EFL) {
				return(err);
			}
			if(firstN > 1){
				FreeList();
			}
			break;
		}
	}
	err = ShowHeader();
	if(err < 0) {
		return(err);
	}

	err = ShowItems(CurPage);
	if(err < 0) {
		return(err);
	}
	return( err ) ;
}	/* Next() */
/*----------------------------------------------------------------------*/
/* Get the Category key from user. In ADD mode disable dup buffers,     */
/* other modes enable dup buffers and show the current key as a default key */
/*----------------------------------------------------------------------*/
ReadKey()
{
	int	i;
	long	temp_cat_num;
	
	/* In Add mode turn off dup control for key fields.
	   Other modes reverse it */
	if(s_sth.s_fn[0] == AWARD){	/* ADD */
		SetDupBuffers(KEY_START,KEY_END,0); /* Off Dup Control */
	}
	else {
		SetDupBuffers(KEY_START,KEY_END,1);
	}

#ifdef ENGLISH
	strcpy(s_sth.s_mesg,"Press ESC-F to Go Back to Fn:");
#else
	strcpy(s_sth.s_mesg,"Appuyer sur ESC-F pour retourner a Fn:");
#endif
	DispMesgFld((char *)&s_sth);

	temp_cat_num = s_sth.s_cat_num;

	i = ReadFields((char *)&s_sth,KEY_START, KEY_END,
		Validation, WindowHelp,1) ;
	if(PROFOM_ERR == i || DBH_ERR == i) return(i) ;
	if(RET_USER_ESC == i){
		s_sth.s_cat_num = temp_cat_num;
		
		ret( WriteFields((char *)&s_sth,KEY_START, KEY_END) ) ;

		s_sth.s_mesg[0] = HV_CHAR;
		DispMesgFld((char *)&s_sth);

		return(RET_USER_ESC) ;
	}

	return(NOERROR);
}	/*  ReadKey() */
/*-----------------------------------------------------------------------*/
/*	Get the next node in linked list to add invoice items. If the
*	(Cur. invc last page) = (Last Page in linked List) or no
*	nodes in list, allocate node and add to linked list
*/

MakeFreshPage()
{
	Page	*tempptr ;

	/* If, no node is allocated yet or Current invoice used all the nodes,
	   then allocate new node */

	if( LastPage == NULL || CurLast == LastPage ){
		tempptr= (Page *)malloc((unsigned)sizeof(Page)) ;

		if( tempptr == NULL ){
			DispError((char*)&s_sth,"Memory Allocation Error");
			return(ERROR);
		}
		tempptr->NextPage = NULL ;

		if( LastPage == NULL ){	/* No node is allocated Yet */
			tempptr->PrevPage = NULL ;
			tempptr->Pageno = 1 ;
			FirstPage = tempptr ;
		}
		else {				/* Not a first node in list */
			tempptr->Pageno = LastPage->Pageno + 1 ;
			LastPage->NextPage = tempptr ;
			tempptr->PrevPage = LastPage ;
		}
		LastPage = tempptr ;
	}

	if(CurLast == NULL)
		CurLast = FirstPage ;
	else
		CurLast = CurLast->NextPage ;

	CurLast->NoItems = 0 ;
	CurPage = CurLast ;

	return(NOERROR);
}	/* MakeFreshPage() */
/*----------------------------------------------------------*/
/* Get the key and show the record */
SelectRecord()
{
	int	err ;

	err = ReadKey();
	if(err != NOERROR) return(err) ;

	/* Get area records i.e. Build list */
	err = BuildList();
	if(err < 0 && err != EFL) {
		return(err);
	}

	err = ShowHeader();
	if(err < 0) {
		return(err);
	}

	err = ShowItems(CurPage);
	if(err < 0) {
		return(err);
	}

	return(NOERROR);
}	/* SelectRecord() */
/*------------------------------------------------------------*/

BuildList()
{
	int retval;
	int i;

	CurLast = CurPage = NULL;
	i = 0;
	award_cnt = 0;

	bid_rec.bid_cat_num = s_sth.s_cat_num;	
	bid_rec.bid_price = 0.00;
	bid_rec.bid_supp_cd[0] = '\0';
	flg_reset(BID);

	for( ; ; ) {
		retval = get_n_bid(&bid_rec,BROWSE,2,FORWARD,e_mesg);
		if(retval < 0) {
			if(retval == EFL) break;
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}

		if(bid_rec.bid_cat_num != s_sth.s_cat_num){ 
			break;
		}
		if(strcmp(bid_rec.bid_status,AWARD_STAT) == 0) {
			award_cnt++;
		}

		if((s_sth.s_fn[0] == INQUIRE || s_sth.s_fn[0] == NEXT ||
		    s_sth.s_fn[0] == PREV) && 
		   strcmp(bid_rec.bid_status,AWARD_STAT) != 0) {
			continue;
		}

		if(PAGESIZE == i) i = 0;
		if(i == 0) {

			if((retval = MakeFreshPage()) < 0) return(retval);
		}

		strcpy(CurPage->Items[i].s_supp_cd,bid_rec.bid_supp_cd);
		strncpy(CurPage->Items[i].s_desc,bid_rec.bid_desc,19);
		CurPage->Items[i].s_bid_price = bid_rec.bid_price;
		strcpy(CurPage->Items[i].s_status,bid_rec.bid_status);

		strcpy(supplier.s_supp_cd,bid_rec.bid_supp_cd);
		retval = get_supplier(&supplier,BROWSE,0,e_mesg);
		if(retval < 0) {
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}	
		strncpy(CurPage->Items[i].s_sname,supplier.s_name,20);
		CurPage->I_Status[i][0] = ' ';
		CurPage->NoItems++;
		i++;
	}
	seq_over(BID);


	if(CurLast != NULL) {
		CurPage = FirstPage;
	}

	if(retval == EFL) return(retval);

	return(NOERROR);
}
/*------------------------------------------------------------*/
/* Show Header Descriptions */
ShowHeader()
{
	int	retval;

	category.categ_num = s_sth.s_cat_num / 100000;
	retval = get_category(&category,BROWSE,0,e_mesg);
	if(retval < 0) {
		DispError((char *)&s_sth,e_mesg);
		return(retval);
	}
	strcpy(s_sth.s_categ_desc,category.categ_desc);

	item_grp.itmgrp_num = s_sth.s_cat_num / 1000;
	retval = get_itemgrp(&item_grp,BROWSE,0,e_mesg);
	if(retval < 0) {
		DispError((char *)&s_sth,e_mesg);
		return(retval);
	}
	strcpy(s_sth.s_itmg_desc1,item_grp.itmgrp_desc1);
	strcpy(s_sth.s_itmg_desc2,item_grp.itmgrp_desc2);
	strcpy(s_sth.s_itmg_desc3,item_grp.itmgrp_desc3);

	catalogue.cat_num = s_sth.s_cat_num;
	retval = get_catalogue(&catalogue,BROWSE,0,e_mesg);
	if(retval < 0) {
		DispError((char *)&s_sth,e_mesg);
		return(retval);
	}
	strcpy(s_sth.s_item_desc,catalogue.cat_desc);

	ret( WriteFields((char *)&s_sth, CATEG_FLD, PAGE_FLD - 100) );
	return(NOERROR);
}	/* ShowHeader() */
/*------------------------------------------------------------*/
/* Show all the items on the current page 		      */
ShowItems(pageptr)
Page	*pageptr ;
{
	int	i ;


	if(pageptr != NULL) {
		/* Copy the items to screen */
		scpy((char*)s_sth.s_items, (char*)pageptr->Items,
			(pageptr->NoItems * sizeof(S_item)) );

		s_sth.s_page   = pageptr->Pageno ;
		strcpy(s_sth.s_dummy1,"---");
		s_sth.s_dummy2[0] = ' ';
		s_sth.s_dummy3[0] = ' ';

		i = pageptr->NoItems ;
	}
	else {
		s_sth.s_page = HV_SHORT ;
		s_sth.s_dummy1[0] = HV_CHAR;
		s_sth.s_dummy2[0] = HV_CHAR;
		s_sth.s_dummy3[0] = HV_CHAR;
		i = 0 ;
	}

	/* Move High Values to remaining Items */
	for( ; i < PAGESIZE ; i++ )
		InitItem(i, HV_CHAR, HV_DOUBLE);

	ret( WriteFields((char *)&s_sth, PAGE_FLD, (END_FLD - 200)) );

	return(NOERROR) ;
}	/* ShowItems() */
/*-----------------------------------------------------------------------*/ 
/* Process all the items in the link list and write any changes to the   */
/* daily attendance file.						 */
/*-----------------------------------------------------------------------*/ 
ProcItemUpdates(mode)
int	mode;
{
	Page	*temppage;
	int	i;
	int	retval;
	int	write_mode;

	if(CurLast != NULL) {
	   for(temppage=FirstPage; temppage!=NULL;temppage=temppage->NextPage) {
	      for(i = 0; i < temppage->NoItems; i++) {
		 retval = WriteRecords(temppage,i,UPDATE);
  		 if(retval < 0) {
			if(retval == LOCKED) return(LOCKED);
		   	break;
		 }
	      }
	      if(temppage == CurLast) break;
	   }
	}
	return(NOERROR);
}
/*-----------------------------------------------------------------------*/ 
/* Write the Area record to the file.			 		 */ 
/*-----------------------------------------------------------------------*/ 
WriteRecords(temppage,item_no,mode)
Page	*temppage;
int	item_no;
int	mode;
{
	int	retval;

	if(mode != ADD) {
		strcpy(bid_rec.bid_supp_cd,
			temppage->Items[item_no].s_supp_cd) ;
		bid_rec.bid_cat_num = s_sth.s_cat_num;
		retval = get_bid(&bid_rec,UPDATE,0,e_mesg) ;
		if(retval < 0) {
			DispError((char *)&s_sth,e_mesg);
			roll_back(e_mesg);
			return(retval);
		}
		scpy((char *)&pre_bid,(char *)&bid_rec,
			sizeof(pre_bid));
	}

/***   Always Update Mode 
	strcpy(bid_rec.bid_supp_cd,temppage->Items[item_no].s_supp_cd);
	bid_rec.bid_cat_num = s_sth.s_cat_num;
	bid_rec.bid_tend_num = s_sth.s_cat_num / 100000;
	bid_rec.bid_price = temppage->Items[item_no].s_bid_price;
	strcpy(bid_rec.bid_desc,temppage->Items[item_no].s_desc);
***/
	strcpy(bid_rec.bid_status,temppage->Items[item_no].s_status);

	if(scmp((char *)&pre_bid,(char *)&bid_rec,sizeof(pre_bid))==0) {
		return(NOERROR);
	}
	retval = put_bid(&bid_rec,mode,e_mesg) ;
	if(retval < 0) {
		DispError((char *)&s_sth,e_mesg);
		roll_back(e_mesg);
		return(retval);
	}

	if(mode != ADD) {
		retval = rite_audit((char*)&s_sth, BID,mode,(char*)&bid_rec,
			(char*)&pre_bid,e_mesg);
		if(retval==LOCKED) {
			DispError((char *)&s_sth,e_mesg);
			roll_back(e_mesg) ;
			return(LOCKED) ;
		}
		if(retval < 0 ){
			DispError((char *)&s_sth,"ERROR: Saving Records"); 
			DispError((char *)&s_sth,e_mesg);
			roll_back(e_mesg);
			return(retval);
		}
	}
	/*** Update Catalogue with description, bid_price && supplier ***/
	catalogue.cat_num = bid_rec.bid_cat_num;
	retval = get_catalogue(&catalogue,UPDATE,0,e_mesg);
	if(retval < 0) {
		DispError((char *)&s_sth,e_mesg);
		roll_back(e_mesg);
		return(retval);
	}
	if (strcmp(bid_rec.bid_status,AWARD_STAT)==0){
		strcpy(supplier.s_supp_cd,bid_rec.bid_supp_cd);
		retval = get_supplier(&supplier,BROWSE,0,e_mesg);
		if(retval < 0) {
			DispError((char *)&s_sth,e_mesg);
			return(retval);
		}	

		strcpy(catalogue.cat_awd_supp,bid_rec.bid_supp_cd);	
		if(strcmp(temppage->Items[item_no].s_desc,"AS SPECIFIED")!=0) {
			/* Use Bid desc as screen desc is truncated */
			strcpy(catalogue.cat_desc,bid_rec.bid_desc);
		}	
		catalogue.cat_min_dollar = supplier.s_min_dollar;
		catalogue.cat_unit_price[0] = bid_rec.bid_price;
		retval = put_catalogue(&catalogue,mode,e_mesg) ;
		if(retval < 0) {
			DispError((char *)&s_sth,e_mesg);
			roll_back(e_mesg);
			return(retval);
		}
	}
	retval = commit(e_mesg) ;
	if(retval < 0) {
		DispError((char *)&s_sth,"ERROR: Saving Records"); 
		DispError((char *)&s_sth,e_mesg);
		roll_back(e_mesg);
		return(retval);
	}

	if(first == 0) {
		retval = rpopen(projname,logrec,formno,outcntl,discfile,
					program,chardate);
		if(retval < 0){
			sprintf(e_mesg,"Rpopen code :%d \n",code);
			fomen(e_mesg);
			get();
			return(retval);
		}

	 	rpChangetitle(1, pa_rec.pa_co_name); 
		first = 1;
	}
	strcpy(supplier.s_name,temppage->Items[item_no].s_sname);
	rpline(arayptr);
	return(NOERROR);
}
/*----------------------------------------------------------------*/
/* Set Duplication buffers for fields 				  */
SetDupBuffers( firstfld, lastfld, value )
int	firstfld, lastfld;	/* field numbers range */
int	value;			/* ENABLE or DISABLE */
{
	int i ;

	for( i=firstfld; i<=lastfld; i+=100 )
		fomca1( i, 19, value);
	if( value==0 )
		return(0);
	sr.nextfld = firstfld;
	sr.endfld = lastfld;
	fomud( (char *)&s_sth );
	ret( err_chk(&sr) );

	return( 0 );
}
/*----------------------------------------------------------------*/
/* Validation function() for Key and Header fields when PROFOM returns
  RET_VAL_CHK */

Validation()
{
	int	retval;

	switch(sr.curfld){
	case KEY_START:
		bid_rec.bid_cat_num = s_sth.s_cat_num;
		bid_rec.bid_price = 0;
		bid_rec.bid_supp_cd[0] = '\0';
		flg_reset(BID);
		retval = get_n_bid(&bid_rec,BROWSE,2,FORWARD,e_mesg);
		if(retval < 0 && retval != EFL) {
			fomer(e_mesg);
			s_sth.s_cat_num = LV_LONG;
			return(ERROR);
		}
		if(retval == EFL){
			fomer("No Bids Have Been Entered For This Catalogue - Please Re-Enter");
			s_sth.s_cat_num = LV_LONG;
			return(ERROR);
		}
		bid_rec.bid_cat_num = s_sth.s_cat_num;
		strcpy(bid_rec.bid_status,AWARD_STAT);
		retval = get_bid(&bid_rec,BROWSE,3,e_mesg);
		if(retval < 0 && retval != UNDEF) {
			fomer(e_mesg);
			s_sth.s_cat_num = LV_LONG;
			return(ERROR);
		}
		if(s_sth.s_fn[0] == AWARD && retval != UNDEF) {
			fomer("Catalogue Number Has Already Been Awarded - Please Re-Enter");
			s_sth.s_cat_num = LV_LONG;
			return(ERROR);
		}
		if(s_sth.s_fn[0] == CHANGE && retval == UNDEF) {
			fomer("Catalogue Number Has Not Been Awarded - Please Re-Enter");
			s_sth.s_cat_num = LV_LONG;
			return(ERROR);
		}
		if(s_sth.s_fn[0] == INQUIRE && retval == UNDEF) {
			fomer("Catalogue Number Has Not Been Awarded - Please Re-Enter");
			s_sth.s_cat_num = LV_LONG;
			return(ERROR);
		}
		break;
	default:
#ifdef ENGLISH
		sprintf(e_mesg,"No Validity Check for Field#  %d",sr.curfld);
		
#else
		sprintf(e_mesg,"Pas de controle de validite pour le Champ#  %d",sr.curfld);
#endif
		fomen(e_mesg);
		get();
		return(ERROR) ;
	}	/* Switch sr.curfld */

	return(NOERROR) ;
}	/* Validation() */
/*----------------------------------------------------------------*/
/* Show Help Windows, if applicable, when user gives ESC-H in key
   and header fields */

WindowHelp()
{
	int	retval ;

	switch(sr.curfld){
	case KEY_START:
		retval = catalogue_hlp(&s_sth.s_cat_num,7,13);
		if(retval == DBH_ERR) return(retval);
		if(retval >= 0) redraw();
		if(retval == 0) return(ERROR);
		if(retval < 0) return(ERROR);
		bid_rec.bid_cat_num = s_sth.s_cat_num;
		bid_rec.bid_supp_cd[0] = '\0';
		flg_reset(BID);
		retval = get_n_bid(&bid_rec,BROWSE,2,FORWARD,e_mesg);
		if(retval < 0 && retval != EFL) {
			fomer(e_mesg);
			s_sth.s_cat_num = LV_LONG;
			return(ERROR);
		}
		if(retval == EFL || bid_rec.bid_cat_num != s_sth.s_cat_num){
			fomer("No Bids Have Been Entered For This Catalogue # - Please Re-Enter");
			s_sth.s_cat_num = LV_LONG;
			return(ERROR);
		}

		break;
	default :
		fomer("No Help Window for This Field");
	}	/* Switch sr.curfld */

	return(NOERROR) ;
}	/* WindowHelp() */
/*-----------------------------------------------------------------------*/
/* Take the confirmation from user for the items part of the screen      */
/*-----------------------------------------------------------------------*/
ConfirmItems()
{
	int	err ;

	/* Options:
	     YSLNPC
	*/

	for( ; ; ) {
	    if(s_sth.s_fn[0] == AWARD) {
#ifdef ENGLISH
			err = GetOption((char *)&s_sth,
		"Y(es), A(Ward), N(ext), P(rev), C(ancel)"
		,"YANPC");
#else
			err = GetOption((char *)&s_sth,
		"O(ui), A(ttr), S(uiv), P(rec), A(nnul)"
		,"OSLA");
#endif
	    }
	    else if(s_sth.s_fn[0] == CHANGE) {
#ifdef ENGLISH
			err = GetOption((char *)&s_sth,
		"Y(es), A(Change Award), N(ext), P(rev), C(ancel)"
		,"YANPC");
#else
			err = GetOption((char *)&s_sth,
		"O(ui), C(hanger att), S(uiv), P(rec), A(nnul)"
		,"OSLA");
#endif
	    }
	    else {
#ifdef ENGLISH
			err = GetOption((char *)&s_sth,
		"Y(es), N(ext), P(rev)","YNP");
#else
			err = GetOption((char *)&s_sth,
		"O(ui), S(uiv), P(rec)" ,"OSP");
#endif
	    }
	    switch(err) {
	    case  YES  :
		return(YES);
	    case  AWARDITEM:
		err = ChangeStatus();
		break;
	    case  NEXT:
		if(CurPage == CurLast || CurLast == NULL) {
#ifdef ENGLISH
			fomer("No More Pages....");
#else
			fomer("Plus de pages....");
#endif
			continue;
		}
		CurPage = CurPage->NextPage ;
		err = ShowItems(CurPage);
		break;
	    case  PREV:
		if(CurLast == NULL || CurPage == FirstPage) {
#ifdef ENGLISH
			fomer("No More Pages....");
#else
			fomer("Plus de pages....");
#endif
			continue;
		}
		CurPage = CurPage->PrevPage ;
		err = ShowItems(CurPage);
		break;
	    case  CANCEL :
#ifdef ENGLISH
		err = GetOption((char *)&s_sth,
				"Confirm the Cancel (Y/N)?", "YN") ;
#else
		err = GetOption((char *)&s_sth,
				"Confirmer l'annulation (O/N)?", "ON") ;
#endif
		if(err == YES) return(CANCEL) ;
		break ;
	    }	/* switch err */

	    if(err == PROFOM_ERR) return(err) ;
	    if(err == DBH_ERR) return(err) ;
	}	/* for(; ; ) */
}	/* ConfirmItems() */
/*------------------------------------------------------------------------*/
/*------------------------------------------------------------------------*/

ChangeStatus()
{
	int	retval;
	int	st_fld, end_fld;

	/* Get The Field to Be Modified */
#ifdef	ENGLISH
	strcpy(s_sth.s_mesg,"Enter RETURN to Terminate Edit");
#else
	strcpy(s_sth.s_mesg,"Appuyer sur RETURN pour terminer l'ajustement");
#endif
	DispMesgFld((char *)&s_sth); ;
        
     	for (; ;) {
		s_sth.s_field = LV_SHORT;
		retval = ReadFields((char *)&s_sth,CHG_FLD,CHG_FLD,
			(int (*)())NULL,(int (*)())NULL, 1);

		if (retval < 0) return(-1);
		if (retval == RET_USER_ESC) break;	/* User enter ESC-F */
		if (s_sth.s_field > CurPage->NoItems)
			continue;

       		if (s_sth.s_field == 0 ) break;  /* Finished changing fields */

	
		st_fld  = ITEM_ST_FLD + (STEP * (s_sth.s_field-1)) + STATUS_FLD;
		end_fld  = ITEM_ST_FLD + (STEP * (s_sth.s_field-1))+STATUS_FLD;

		if(strcmp(s_sth.s_items[s_sth.s_field-1].s_status,
			AWARD_STAT)==0){
			fomer("Item is Already Awarded");
		}
		else {
			/* Scan Linked List for Other Awarded Supplier */
			retval = ChangeAward();
			if(retval < 0) return(ERROR);

			strcpy(s_sth.s_items[s_sth.s_field-1].s_status,
		   		AWARD_STAT);
		}
		/* Update Linked List */
		scpy((char*)&(CurPage->Items[s_sth.s_field -1]), 
		     (char*)&(s_sth.s_items[s_sth.s_field -1]),sizeof(S_item)) ;
		
		ret(WriteFields((char *)&s_sth,st_fld,end_fld));
	}
     	s_sth.s_field = HV_SHORT ;
	if ( WriteFields((char *)&s_sth,CHG_FLD, CHG_FLD) < 0 ) return(-1);

	return(NOERROR);
}
/*------------------------------------------------------------------------*/
/*------------------------------------------------------------------------*/
ChangeAward()
{
	Page	*temppage;
	int	i;
	int	fld_no;
	int	display;

	display = 0;
	/* check to see if item is already in list */
	if(CurLast != NULL) {
	   for(temppage=FirstPage; temppage!=NULL;temppage=temppage->NextPage) {
	      for(i =0; i< temppage->NoItems; i++) {
			if(strcmp(temppage->Items[i].s_status,AWARD_STAT)==0) {
				strcpy(temppage->Items[i].s_status,"   ");
				display = 1;
				break;
			}
	      }
	      if(strcmp(temppage->Items[i].s_status,AWARD_STAT)==0) break;
	      if(temppage == CurLast) break;
	   }
	}
	if(temppage == CurPage && display == 1) {
		fld_no  = ITEM_ST_FLD + (STEP * i) + STATUS_FLD;
		strcpy(s_sth.s_items[i].s_status,temppage->Items[i].s_status);
		ret(WriteFields((char *)&s_sth,fld_no,fld_no));
	}
	return(NOERROR);
}
/*------------------------------------------------------------------------*/
/* Move High values to all data fields and clear the screen */
ClearScreen()
{
	int	i;

	/* Move High Values to Hedaer part */
	s_sth.s_categ_desc[0] = HV_CHAR;
	s_sth.s_itmg_desc1[0] = HV_CHAR;
	s_sth.s_itmg_desc2[0] = HV_CHAR;
	s_sth.s_itmg_desc3[0] = HV_CHAR;
	s_sth.s_item_desc[0] = HV_CHAR;

	s_sth.s_page = HV_SHORT;
	s_sth.s_dummy1[0] = HV_CHAR;
	s_sth.s_dummy2[0] = HV_CHAR;
	s_sth.s_dummy3[0] = HV_CHAR;

	/* Move High Values to All items */
	for(i = 0 ; i < PAGESIZE ; i++)
		InitItem(i,HV_CHAR, HV_DOUBLE);

	ret( WriteFields((char *)&s_sth,CATEG_FLD, (END_FLD - 200)) );

	return(NOERROR);
}	/* ClearScreen() */
/*-------------------------------------------------------------------------*/
/* Initialize Given screen item with either Low values or High values */

InitItem(item_no, t_char, t_double)
int	item_no ;
char	t_char ;
double	t_double ;
{
	int	i;

	s_sth.s_items[item_no].s_supp_cd[0] = t_char ;
	s_sth.s_items[item_no].s_sname[0] = t_char ;
	s_sth.s_items[item_no].s_desc[0] = t_char ;
	s_sth.s_items[item_no].s_bid_price = t_double ;
	s_sth.s_items[item_no].s_status[0] = t_char ;

	return(NOERROR) ;
}	/* Inititem() */
/*-------------------- E n d   O f   P r o g r a m ---------------------*/
