/*-----------------------------------------------------------------------
Source Name: catmaint.c
System     : Tendering.
Created  On: 7th April 92.
Created  By: Jonathan Prescott.

DESCRIPTION:
	Program to enter Catalogue Supplies.

MODIFICATIONS:        

Programmer	YY/MM/DD	Description of modification
S.Whittaker	93/02/23	When deleting a catalogue number
				the category and item would be delete
				on occasion.
S.Whittaker	93/05/28	Updated the rite_audit function to include
				passing the screen structure.
------------------------------------------------------------------------*/
#define	MAIN		/* Main program. This is to declare Switches */
#define MAINFL		CATALOGUE		/* main file used */

#define	SYSTEM		"TENDERING"	/* Sub System Name */
#define	MOD_DATE	"7-APR-92"		/* Progran Last Modified */

#include <stdio.h>
#include <cfomstrc.h>
#include <bfs_defs.h>
#include <bfs_recs.h>

#define	DELTA_AMT  0.005	/* To Check double values for zero */
#define	DELTA_QTY  0.00005	/* To Check double values for zero */

/* User Interface define constants */
#ifdef ENGLISH
#define ADDREC		'A'
#define CHANGE		'C'
#define DELETE		'D'
#define INQUIRE		'I'
#define EXITOPT		'E'
#define	NEXT		'N'
#define	PREV		'P'

#define	YES		'Y'
#define NO		'N'
#define	EDIT		'E'
#define	CANCEL		'C'

#else
#define ADDREC		'R'
#define CHANGE		'C'
#define DELETE		'E'
#define INQUIRE		'I'
#define EXITOPT		'F'
#define	NEXT		'S'
#define	PREV		'P'

#define	YES		'O'
#define NO		'N'
#define	EDIT		'M'
#define	CANCEL		'A'

#endif

/* No Update to Data File */
#define NO_WRITE	12

/* PROFOM Releted declarations */

#define	SCR_NAME	"catmaint"	/* PROFOM screen Name */

/* PROFOM Screen STH file */

/* Field PROFOM numbers */

/* HDR Fields */
#define	FN_FLD		400	/* Fn: */
#define	KEY_START	500	/* PO Number */
#define	KEY_END		500	/* PO Number */
#define	CHG_FLD		600	/* Field: */
#define END_FLD		2500	/* Resp Field */

#define	CATEG_NBR_FLD	800	/* Category Number: */
#define	CATEG_DESC_FLD	900	/* Category Desc: */
#define ITMG_NBR_FLD	1000 	/* Item Group Number: */
#define ITMG_DESC1_FLD	1100 	/* Item Group Desc 1: */
#define ITMG_DESC2_FLD	1200 	/* Item Group Desc 2: */
#define ITMG_DESC3_FLD	1300 	/* Item Group Desc 3: */
#define	ITEM_NBR_FLD	1400	/* Item Number: */
#define	ITEM_DESC_FLD	1500	/* Item Description: */
#define UOM_FLD		1600	/* Unit Of Measure: */
#define SUPPCD_FLD	1700	/* Supplier Code: */
#define MIN_FLD		1800	/* Min Dollar Requirement: */
#define CUR_UNIT_FLD	2000	/* Current Year Unit Price */
#define CUR_QTY_FLD	2100	/* Current Year Qty Price */
#define PRE_UNIT_FLD	2200	/* Previous Year Unit Price */
#define PRE_QTY_FLD	2300	/* Previous Year Qty Price */

#define MESG_FLD	2400	/* Message Field */
#define RESP_FLD	2500	/* Response Field */

#define CATE_SNO	1	/* Category Field Number */
#define ITMGRP_SNO	2	/* Item Group Field Number */
#define ITEM_SNO	3	/* Item Field Number */
#define UOM_SNO		4	/* UOM Field Number */
#define SUPP_SNO	5	/* Supplier Field Number */
#define MIN_SNO		6	/* Min Dollar Req Field Number */
#define CUNIT_SNO	7	/* Current Year Price Field Number */
#define CQTY_SNO	8	/* Current Year Qty Field Number */
#define PUNIT_SNO	9	/* Previous Year Price Field Number */
#define PQTY_SNO	10	/* Previous Year Qty Field Number */

/* catmaint.sth - header for C structure generated by PROFOM EDITOR */

typedef struct	{

	char	s_pgm[11];	/* STRING XXXXXXXXXX Field 100 */
	long	s_rundate;	/* DATE YYYYFMMFDD Field 300 */
	char	s_fn[2];	/* STRING X Field 400 */
	long	s_cat_num;	/* NUMERIC 999999 Field 500 */
	short	s_field;	/* NUMERIC 999 Field 600 */

	short	s_cate_num;	/* NUMERIC 99 Field 800 */
	char	s_cate_desc[41];/* STRING X(40) Field 900 */
	short   s_itmg_num;	/* NUMERIC 9999 Field 1000 */
	char    s_itmg_desc1[41];/* STRING X(40) Field 1100 */
	char    s_itmg_desc2[41];/* STRING X(40) Field 1200 */
	char    s_itmg_desc3[41];/* STRING X(40) Field 1300 */
	long    s_item_num;	 /* NUMERIC 9999 Field 1400 */
	char    s_item_desc[41]; /* STRING X(40) Field 1500 */
	char	s_uom[7];	 /* STRING X(6) Field 1600 */
	char	s_suppcd[11];	 /* STRING X(10) Field 1700 */
	double	s_min_dollar;	 /* NUMERIC 9999.99 Field 1800 */
	char	s_dummy[2];	 /* dummy field */
	double	s_cur_price;	 /* NUMERIC 9999.9999 Field 2000 */
	double	s_cur_qty;	 /* NUMERIC 9999.9999 Field 2100 */
	double	s_pre_price;	 /* NUMERIC 9999.9999 Field 2200 */
	double	s_pre_qty;	 /* NUMERIC 9999.9999 Field 2300 */

	char	s_mesg[78];	/* STRING X[77] Field 9600 */
	char	s_resp[2];	/* STRING X Field 9700 */
} s_struct;


double	D_Roundoff();

static	s_struct  s_sth, image;	/* PROFOM Screen Structure */
static	struct  stat_rec  sr;		/* PROFOM status rec */

static	Category	category;	/* Category */
static  Item_grp 	item_grp;	/* Item Group */
static	Catalogue	catalogue,tmp_cat;	/* Catalogue */
static	Pa_rec		pa_rec ;	/* Parameters Record */
static	Bid		bid;		/* Bid Record */

static	char 	e_mesg[100];  		/* dbh will return err msg in this */

int	Validation();
int	WindowHelp();
int	Argc;
char	**Argv;

main(argc,argv)
int argc;
char *argv[];
{
	int 	retval;

	/* These two are passed to execute() when it is called */
	Argc = argc;
	Argv = argv;

	retval = Initialize(argc,argv);	/* Initialization routine */

	if (retval == NOERROR) retval = Process();

	CloseRtn();			/* return to menu */
	if (retval != NOERROR) exit(-1);

	exit(0);
}

/*-------------------------------------------------------------------*/
/* Initialize PROFOM */

Initialize(argc, argv)
int	argc ;
char	*argv[] ;
{
	int	err ;

	/*
	*	Initialize DBH Environment
	*/
	strncpy(SYS_NAME,SYSTEM,50);	/* Sub system name */
	strncpy(CHNG_DATE,MOD_DATE,10);	/* Modification Date */

	proc_switch(argc, argv, MAINFL) ; 	/* Process Switches */

	/*
	*	Initialize PROFOM & Screen
	*/
	STRCPY(sr.termnm,terminal);	/* Copy Terminal Name */
	fomin(&sr);
	ret(err_chk(&sr)) ;		/* Check for PROFOM Error */
	fomcf(1,1);			/* Enable Snap screen option */

	err = InitScreen() ;		/* Initialize Screen */
	if(NOERROR != err) return(err) ;

	/*
	*	Get The Parameter Record
	*/
	err = get_param(&pa_rec, BROWSE, 1, e_mesg) ;
	if(err == ERROR) {
		DispError((char *)&s_sth,e_mesg);
		return(ERROR) ;
	}
	else if(err == UNDEF) {
#ifdef ENGLISH
		DispError((char *)&s_sth,"Parameters Are Not Set Up ...");
#else
		DispError((char *)&s_sth,"Parametres ne sont pas etablis... ");
#endif
		return(ERROR) ;
	}
	if(pa_rec.pa_tendering[0] != YES) {
#ifdef ENGLISH
	     DispError((char *)&s_sth,"Tendering System Absent.  See Parameter Maintenance.");
#else
	     DispError((char *)&s_sth,"Systeme Soumission absent. Voir l'entretien des parametres.");
#endif
	     return(ERROR);
	}
	return(NOERROR) ;
}	/* Initialize() */

/*--------------------------------------------------------------------------*/
/* Close nessary files and environment before exiting program               */

CloseRtn() 
{
	/* Set terminal back to normal mode from PROFOM */
	fomcs();
	fomrt();

	close_dbh();	/* Close files */

	return(NOERROR);
}	/* CloseRtn() */
/*----------------------------------------------------------------*/
/* Initialize screen before going to process options */

InitScreen()
{
	int	err ;

	/* move screen name to Profom status structure */
	STRCPY(sr.scrnam,NFM_PATH);
	strcat(sr.scrnam,SCR_NAME) ;

	STRCPY(s_sth.s_pgm,PROG_NAME);

	s_sth.s_rundate = get_date();	/* get Today's Date in YYYYMMDD format*/
	s_sth.s_field = HV_SHORT ;
	s_sth.s_mesg[0] = HV_CHAR ;
	s_sth.s_resp[0] = HV_CHAR ;

	/* Initialize Key Fields. So that, if user selectes 'N' option
	   immediately after invoking program, then he gets the first
	   record in the file */

	s_sth.s_cat_num = 0 ;

	/* Move High Values to data fields and Display the screen */
	err = ClearScreen() ;
	if(NOERROR != err) return(err) ;

	return(NOERROR) ;
}	/* InitScreen() */

/*-------------------------------------------------------------------*/
/* Get Option from user and call corresponding function */

Process()
{
	int err;

	for( ; ; ){

		/* Get the Fn: option from the user */
		if((err = ReadFunction()) != NOERROR) return(err) ;

		err = ProcFunction() ;	/* Process Function */

		if(QUIT == err)		return(NOERROR) ;    /* Exit */
		if(NOACCESS == err)	fomen(e_mesg);	     /* security */
		if(PROFOM_ERR == err)	return(PROFOM_ERR);  /* PROFOM ERROR */
		if(DBH_ERR == err) {
			DispError((char *)&s_sth,e_mesg);
#ifdef ENGLISH
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"System Error... Iserror:",
				iserror, dberror, errno);
#else
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"Erreur du systeme... Iserror:",
				iserror, dberror, errno);
#endif
			DispError((char *)&s_sth,e_mesg);
			return(DBH_ERR); /* DBH ERROR */
		}
	}      /*   end of the for( ; ; )       */
}	/* Process() */
/*----------------------------------------------------------------*/
/* Display the Function (Fn:) options and get the option from the user */

ReadFunction()
{
	/* Display Fn: options */
#ifdef ENGLISH
	fomer("A(dd), C(hange), D(elete), I(nquire), N(ext), P(rev), E(xit)");
#else
	fomer("R(ajouter), C(hanger), E(liminer), I(nterroger), S(uivant), P(recedent), F(in)");
#endif
	/* Read Fn: field to get the option */
	sr.nextfld = FN_FLD ;
	fomrf( (char *)&s_sth );
	ret(err_chk(&sr));	/* Check for PROFOM error */

	return(NOERROR) ;
}	/* ReadFunction() */
/*----------------------------------------------------------------*/
/* Process the user selected Fn: option */

ProcFunction()
{
	int retval;

	switch (s_sth.s_fn[0]) {
	case ADDREC :			/* Add Requisition */ 
		CHKACC(retval,ADD,e_mesg);
		return( AddRec() ) ;
	case CHANGE  :			/* CHANGE */
		CHKACC(retval,UPDATE,e_mesg);
		return( ChangeRec() ) ;
	case DELETE :
		CHKACC(retval,UPDATE,e_mesg);
		return( DeleteRec() ) ;
	case INQUIRE  :			/* Inquire Req */
		CHKACC(retval,BROWSE,e_mesg);
		return( InquireRec() ) ;
	case NEXT  :			/* Next Req */
		CHKACC(retval,BROWSE,e_mesg);
		return( NextRec(FORWARD) ) ;
	case PREV  :			/* Previous Req */
		CHKACC(retval,BROWSE,e_mesg);
		return( NextRec(BACKWARD) ) ;
	case EXITOPT  :			/* Exit */
		return( QUIT ) ;
	}  /*   end of the switch statement */

	return(retval);
}	/* ProcFunction() */
/*----------------------------------------------------------------------*/
/* Adding Catalogue Supplies. Get the unique Key, accept details and    */
/*   update the files */
AddRec()
{
	int	err ;

	err = GetUniqueKey();
	if(err != NOERROR) return(err) ;

	/* Clear The Screen */
	err = ClearScreen();
	if(err != NOERROR) return(err) ;

	err = GetDetails() ;
	if(PROFOM_ERR == err || DBH_ERR == err) return(err) ;
	if(err < 0 || CANCEL == err) {
		roll_back(e_mesg) ;	/* Unlock the locked Records */
		return(ClearScreen()) ;	/* Clear the Screen */
	}

	return(NOERROR);
}	/* AddRec() */
/*-----------------------------------------------------------------------*/
/* Change the Rec */

ChangeRec()
{
	int	err ;

	err = SelectRec(UPDATE) ;
	if(NOERROR != err) return(err) ;

	for( ; ; ) {
		err = FldEdit();

		err = Confirm() ;
		if(err != YES) {
			roll_back(e_mesg);
			return(err) ;
		}

		err = WriteRecords(UPDATE) ;
		if(err==NOERROR) break;
		if(err==LOCKED) {
			roll_back(e_mesg) ;
			continue;
		}
		if (err < 0) {
			roll_back(e_mesg);
			return(err) ;
		}
	}

	return(NOERROR) ;
}	/* ChangeRec() */
/*-----------------------------------------------------------------------*/
/* Delete the Records */

DeleteRec()
{
	int	err ;

	err = SelectRec(UPDATE) ;
	if(NOERROR != err) return(err) ;

	for( ; ; ) {
		err = Confirm() ;
		if(err != YES) {
			roll_back(e_mesg);
			return(err) ;
		}

		err = WriteRecords(P_DEL) ;
		if(err==NOERROR) break;
		if(err==LOCKED) {
			roll_back(e_mesg) ;
			continue;
		}
		if (err < 0) {
			roll_back(e_mesg);
			return(err) ;
		}
	}

	return(NOERROR) ;
}	/* DeleteRec() */
/*-----------------------------------------------------------------------*/
/* Show the user given keys Rec */

InquireRec()
{
	int	err ;

	err = SelectRec(BROWSE) ;
	if(NOERROR != err) return(err) ;

	err = Confirm() ;
	if(err < 0) return(err) ;

	return(NOERROR) ;
}	/* InquireRec() */
/*----------------------------------------------------------*/
/* Show the next or previous Req */

NextRec(direction)
int	direction ;
{
	int err;

	/* Check whether file is in seq. read mode */
	if(flg_start(CATALOGUE) != direction) {
		catalogue.cat_num = s_sth.s_cat_num ;
		if (direction == FORWARD)
			catalogue.cat_num++;
		else	catalogue.cat_num--;
		flg_reset(CATALOGUE);
	}

	err = get_n_catalogue(&catalogue, BROWSE, 0, direction, e_mesg);
#ifndef ORACLE
	seq_over(CATALOGUE);
#endif
	if(ERROR == err)return(DBH_ERR) ;
	if(EFL == err) {
#ifdef	ENGLISH
		fomen("No More Records....");
#else
		fomen("Plus de fiches....");
#endif
		get();
		flg_reset(CATALOGUE);
		return(NOERROR) ;
	}

	return( ShowRec() ) ;
}	/* NextReq() */
/*----------------------------------------------------------------------*/
/* Read the Req Key. Check whether the Req exists with this key */

GetUniqueKey()
{
	int retval,i;

	SetDupBuffers(KEY_START,KEY_END,2);	/* set dup buffer on */
	s_sth.s_cat_num = LV_LONG;

	i = ReadFields((char *)&s_sth,KEY_START,KEY_END,
			Validation,WindowHelp,1) ;
	if(PROFOM_ERR == i || DBH_ERR == i) return(i) ;
	if(RET_USER_ESC == i){
		/* copy back key fields */
		s_sth.s_cat_num = catalogue.cat_num ;

		ret(WriteFields((char *)&s_sth,KEY_START, KEY_END));

		s_sth.s_mesg[0] = HV_CHAR;
		DispMesgFld((char *)&s_sth);

		return(RET_USER_ESC) ;
	}

	if(WriteFields((char *)&s_sth,KEY_START,KEY_END)<0) return(-1);

	return(NOERROR) ;
}	/* GetUniqueKey() */
/*------------------------------------------------------------*/
/* Read the Req Details from the User */

GetDetails()
{
	int	i ;

	i = ReadScreen() ;
	if(NOERROR != i) return(i) ;

	for( ; ; ) {
		i = Confirm() ;
		if(i != YES) return(i);
	
		i = WriteRecords(ADD) ;
		if(i < 0) {
		 	if(i == LOCKED) continue;
		}
		else {
			break;
		}
	}
	if(i != NOERROR) return(i);

	return(NOERROR) ;
}	/* GetDetails() */
/*----------------------------------------------------------*/
/* Get the Req key and show the Req */

SelectRec(md)
int	md ;	/* UPDATE or BROWSE. UPDATE locks the Req */
{
	int	err ;

	for(; ;){
		err = ReadKey();
		if(err != NOERROR) return(err) ;

		catalogue.cat_num = s_sth.s_cat_num;
		err = get_catalogue(&catalogue,md,0,e_mesg);
		if(ERROR == err) return(DBH_ERR) ;
		if(err < 0) {		/* UNDEF or LOCKED */
			fomer(e_mesg) ;
			get() ;
			continue ;
		}
		else 	break;
	}
	return(ShowRec());
}	/* SelectRec() */
/*----------------------------------------------------------------------*/
/* Get the Req key from user. In ADD mode disable dup buffers, other
   modes enable dup buffers and show the current key as a default key */

ReadKey()
{
	int	i;
	long	cat_num;

	/* In Add mode turn off dup control for key fields.
	   Other modes reverse it */
	if(s_sth.s_fn[0] == ADDREC){	/* ADD */
		SetDupBuffers(KEY_START,KEY_END,0); /* Off Dup Control */
	}
	else {
		SetDupBuffers(KEY_START,KEY_END,2);
	}

	/* Store fields to copy back when user gives ESC-F */
	cat_num = s_sth.s_cat_num ;

	s_sth.s_cat_num = LV_LONG ;

#ifdef ENGLISH
	STRCPY(s_sth.s_mesg,"Press ESC-F to Go Back to Fn:");
#else
	STRCPY(s_sth.s_mesg,"Appuyer sur ESC-F pour retourner a Fn:");
#endif
	DispMesgFld((char *)&s_sth);

	i = ReadFields((char *)&s_sth,KEY_START,KEY_END,
		Validation,WindowHelp,1) ;
	if(PROFOM_ERR == i || DBH_ERR == i) return(i) ;
	if(RET_USER_ESC == i){
		/* copy back key fields */
		s_sth.s_cat_num = cat_num ;

		ret( WriteFields((char *)&s_sth,KEY_START, KEY_END) ) ;

		s_sth.s_mesg[0] = HV_CHAR;
		DispMesgFld((char *)&s_sth);

		return(RET_USER_ESC) ;
	}

	return(NOERROR);
}	/*  ReadKey() */
/*-----------------------------------------------------------------------*/ 
/* Update the records and write to files */

WriteRecords(mode)
int mode;
{
	int	err, err1, err2, err3, err4;
	int	i ;

	if((err1 = WriteCategory(mode))<0) {
		roll_back(e_mesg);
		DispError((char *)&s_sth,e_mesg) ;
		return(err) ;
	}
	if((err2 = WriteItemGroup(mode))<0) {
		roll_back(e_mesg);
		DispError((char *)&s_sth,e_mesg) ;
		return(err) ;
	}
	if((err3 = WriteCatalogue(mode))<0) {
		roll_back(e_mesg);
		DispError((char *)&s_sth,e_mesg) ;
		return(err) ;
	}
	if(mode == P_DEL) {
		if((err1 = WriteBid(mode))<0) {
			roll_back(e_mesg);
			DispError((char *)&s_sth,e_mesg) ;
			return(err) ;
		}
	}	
	
	/* No Updates to Any File */
	if(err1 == NO_WRITE && err2 == NO_WRITE && err3 == NO_WRITE) { 
		return(NOERROR);
	}

	err = commit(e_mesg) ;
	if(err < 0) {
#ifdef ENGLISH
		DispError((char *)&s_sth,"ERROR in Saving Records"); 
#else
		DispError((char *)&s_sth,"ERREUR en conservant les fiches");
#endif
		DispError((char *)&s_sth,e_mesg);
		return(err);
	}

	return(NOERROR);
}	/* WriteRecords() */
/*-----------------------------------------------------------------------*/ 
/* Update the Category file */
WriteCategory(mode)
int	mode;
{
	int	err,k;
	Category	tmp_category;
	Catalogue	tmp_catalogue;

	k=0;
	category.categ_num = s_sth.s_cate_num;
	err = get_category(&category,UPDATE,0,e_mesg);
	if(err < 0 && err != UNDEF) {
		return(err);
	}
	if(err != UNDEF) {
		scpy((char *)&tmp_category,(char *)&category,sizeof(category));
	}
	category.categ_num = s_sth.s_cate_num;
	strcpy(category.categ_desc,s_sth.s_cate_desc);

	if(err != UNDEF) {
		if(mode != P_DEL) {
			if(scmp((char *)&tmp_category,(char *)&category,
				sizeof(category)) == 0) {
					return(NO_WRITE) ;
			}
			else {
				mode = UPDATE;
			}
		}
		else {
			tmp_catalogue.cat_num = (s_sth.s_cate_num * 100000);
			flg_reset(CATALOGUE);
			for(;;){
				err = get_n_catalogue(&tmp_catalogue,BROWSE,0,
					FORWARD,e_mesg);
				if(err < 0 && err != EFL) {
					return(err);
				} 
				if(tmp_catalogue.cat_num/100000 != 
					s_sth.s_cate_num || err == EFL) break;
				k++;
			}
			/* if(err != EFL && 
			   tmp_catalogue.cat_num / 100000 == s_sth.s_cate_num &&
			   tmp_catalogue.cat_num != s_sth.s_cat_num) {
				return(NO_WRITE);
			}*/
		}
	}
	if(mode == P_DEL && k >= 2)
		return(NO_WRITE);
	err = put_category(&category, mode,e_mesg) ;
	if(err < 0) {
		return(err) ;
	}

	if(mode != ADD) {
		err = rite_audit((char*)&s_sth,CATEGORY,mode,(char*)&category,
			(char*)&tmp_category,e_mesg);
		if(err==LOCKED) {
			return(LOCKED) ;
		}
		if(err != NOERROR ){
#ifdef	ENGLISH
			DispError((char *)&s_sth,"ERROR in Saving Records"); 
#else
			DispError((char *)&s_sth,"ERREUR en conservant les fiches");
#endif
			return(err);
		}
	}
	return(NOERROR);
}	/* WriteCategory() */
/*-----------------------------------------------------------------------*/ 
/* Update the Item Group file */
WriteItemGroup(mode)
int	mode;
{
	int	err,k;
	Item_grp	tmp_item_grp;
	Catalogue	tmp_catalogue;

	k=0;
	item_grp.itmgrp_num = s_sth.s_itmg_num;
	err = get_itemgrp(&item_grp,UPDATE,0,e_mesg);
	if(err < 0 && err != UNDEF) {
		return(err);
	}

	if(err != UNDEF) {
		scpy((char *)&tmp_item_grp,(char *)&item_grp,sizeof(item_grp));
	}
	item_grp.itmgrp_num = s_sth.s_itmg_num;
	strcpy(item_grp.itmgrp_desc1,s_sth.s_itmg_desc1);
	strcpy(item_grp.itmgrp_desc2,s_sth.s_itmg_desc2);
	strcpy(item_grp.itmgrp_desc3,s_sth.s_itmg_desc3);

	if(err != UNDEF) {
		if(mode != P_DEL) {
			if(scmp((char *)&tmp_item_grp,(char *)&item_grp,
				sizeof(item_grp)) == 0) {
					return(NO_WRITE) ;
			}
			else {
				mode = UPDATE;
			}
		}
		else {
			tmp_catalogue.cat_num = (s_sth.s_itmg_num * 1000);
			flg_reset(CATALOGUE);
			for(;;){
				err = get_n_catalogue(&tmp_catalogue,BROWSE,0,
					FORWARD,e_mesg);
				if(err < 0 && err != EFL) {
					return(err);
				}
				if(tmp_catalogue.cat_num/1000 
					!=s_sth.s_itmg_num || err==EFL) break;
				k++;
			}
		}
	}
	if(mode == P_DEL && k >= 2)
		return(NO_WRITE);
	err = put_itemgrp(&item_grp, mode,e_mesg) ;
	if(err < 0) {
		return(err) ;
	}

	if(mode != ADD) {
		err = rite_audit((char*)&s_sth,ITEM_GROUP,mode,(char*)&item_grp,
			(char*)&tmp_item_grp,e_mesg);
		if(err==LOCKED) {
			return(LOCKED) ;
		}
		if(err != NOERROR ){
#ifdef	ENGLISH
			DispError((char *)&s_sth,"ERROR in Saving Records"); 
#else
			DispError((char *)&s_sth,"ERREUR en conservant les fiches");
#endif
			return(err);
		}
	}
	return(NOERROR);
}	/* WriteItemGroup() */
/*-----------------------------------------------------------------------*/ 
/* Update the Catalogue file */
WriteCatalogue(mode)
int	mode;
{
	int	err;
	Catalogue	tmp_cat;

	if(mode != ADD) {
		scpy((char *)&tmp_cat,(char *)&catalogue,sizeof(catalogue));
	}

	catalogue.cat_num = s_sth.s_cat_num;
	strcpy(catalogue.cat_desc,s_sth.s_item_desc);
	strcpy(catalogue.cat_uom,s_sth.s_uom);
	if(s_sth.s_suppcd[0] != HV_CHAR && 
	   strcmp(s_sth.s_suppcd,"          ")!=0) {
		strcpy(catalogue.cat_awd_supp,s_sth.s_suppcd);
	}
	else {
		catalogue.cat_awd_supp[0] = LV_CHAR;
	}
	catalogue.cat_min_dollar = s_sth.s_min_dollar;
	catalogue.cat_unit_price[0] = s_sth.s_cur_price;
	catalogue.cat_qty[0] =  s_sth.s_cur_qty;
	catalogue.cat_unit_price[1] = s_sth.s_pre_price;
	catalogue.cat_qty[1] =  s_sth.s_pre_qty;

	if(mode == CHANGE) {
		if(scmp((char *)&tmp_cat,(char *)&catalogue,
			sizeof(catalogue))==0) {
			return(NO_WRITE);
		}
	}

	err = put_catalogue(&catalogue, mode,e_mesg) ;
	if(err < 0) {
		return(err) ;
	}

	if(mode != ADD) {
		err = rite_audit((char*)&s_sth,CATALOGUE,mode,(char*)&catalogue,
			(char*)&tmp_cat,e_mesg);
		if(err==LOCKED) {
			return(LOCKED) ;
		}
		if(err != NOERROR ){
#ifdef	ENGLISH
			DispError((char *)&s_sth,"ERROR in Saving Records"); 
#else
			DispError((char *)&s_sth,"ERREUR en conservant les fiches");
#endif
			return(err);
		}
	}

	return(NOERROR);
}	/* WriteCatalogue() */
/*------------------------------------------------------------*/
WriteBid(mode)
int	mode;
{
	int	retval;

	bid.bid_cat_num = catalogue.cat_num;
	bid.bid_supp_cd[0] = '\0';
	flg_reset(BID);

	for(;;){
		retval = get_n_bid(&bid,UPDATE,4,FORWARD,e_mesg);
		if(retval == EFL) break;
		if(retval < 0) {
			return(retval);
		}

		if(bid.bid_cat_num != catalogue.cat_num) break;

		retval = put_bid(&bid,P_DEL,e_mesg);
		if(retval < 0) {
			return(retval);
		}
		inc_str(bid.bid_supp_cd, sizeof(bid.bid_supp_cd)-1, FORWARD);
	}
	return(NOERROR);
}
/*------------------------------------------------------------*/
/* Get the Screen details from user */

ReadScreen()
{
	int	i, err ;
	
	SetDupBuffers(CATEG_NBR_FLD,PRE_QTY_FLD,0);

#ifdef ENGLISH
	STRCPY(s_sth.s_mesg,"Press ESC-F to Go Back to Fn:");
#else
	STRCPY(s_sth.s_mesg,"Appuyer sur ESC-F pour retourner a Fn:");
#endif
	DispMesgFld((char *)&s_sth);

	/* Setup Category Number, Item Group Number, and Item Number */
	s_sth.s_cate_num = s_sth.s_cat_num / 100000;
	s_sth.s_itmg_num = s_sth.s_cat_num / 1000;
	s_sth.s_item_num = s_sth.s_cat_num;
	/* Get Description Defaults */
	category.categ_num = s_sth.s_cate_num;
	err = get_category(&category,UPDATE,0,e_mesg);
	if(err < 0 && err != UNDEF) {
		DispError((char *)&s_sth,e_mesg);
		return(err);
	}
	if(err !=UNDEF) {
		strcpy(s_sth.s_cate_desc,category.categ_desc);
		SetDupBuffers(CATEG_DESC_FLD,CATEG_DESC_FLD,2);
	}
	item_grp.itmgrp_num = s_sth.s_itmg_num;
	err = get_itemgrp(&item_grp,UPDATE,0,e_mesg);
	if(err < 0 && err != UNDEF) {
		DispError((char *)&s_sth,e_mesg);
		return(err);
	}
	if(err!=UNDEF) {
		strcpy(s_sth.s_itmg_desc1,item_grp.itmgrp_desc1); 
		strcpy(s_sth.s_itmg_desc2,item_grp.itmgrp_desc2); 
		strcpy(s_sth.s_itmg_desc3,item_grp.itmgrp_desc3); 
		SetDupBuffers(ITMG_DESC1_FLD,ITMG_DESC3_FLD,2);
	}	


	/* Turn off Dup Control */
	SetDupBuffers(ITEM_DESC_FLD,END_FLD - 200,0);

	/* Initialize Header fields with Low values */
	InitScr(LV_CHAR, LV_SHORT, LV_LONG, LV_DOUBLE) ;

	i = ReadFields((char *)&s_sth,CATEG_NBR_FLD,END_FLD - 200,
		Validation, WindowHelp, 1) ;
	if(PROFOM_ERR == i || DBH_ERR == i) return(i) ;
	if(RET_USER_ESC == i) {	/* ESC-F */
		InitScr(HV_CHAR,HV_SHORT,HV_LONG,HV_DOUBLE) ;

		ret(WriteFields((char *)&s_sth,CATEG_NBR_FLD, END_FLD - 200));

		s_sth.s_mesg[0] = HV_CHAR ;
		DispMesgFld((char *)&s_sth) ;

		return(ERROR) ;
	}

	return(NOERROR) ;
}	/* ReadScreen() */
/*----------------------------------------------------------------*/
/* Set Duplication buffers for fields 				  */
SetDupBuffers( firstfld, lastfld, value )
int	firstfld, lastfld;	/* field numbers range */
int	value;			/* ENABLE or DISABLE */
{
	int i ;

	for( i=firstfld; i<=lastfld; i+=100 )
		fomca1( i, 19, value);
	if( value==0 )
		return(0);
	sr.nextfld = firstfld;
	sr.endfld = lastfld;
	fomud( (char *)&s_sth );
	ret( err_chk(&sr) );

	return( 0 );
}
/*----------------------------------------------------------------*/
/* Validation function() for Key and Header fields when PROFOM returns
  RET_VAL_CHK */

Validation()
{
	int	err, save_nextfld, save_endfld ;

	switch(sr.curfld){
	case	KEY_START	:	/* req number */
		catalogue.cat_num = s_sth.s_cat_num;
		err = get_catalogue(&catalogue,BROWSE,0,e_mesg);
		if(err < 0 && err != UNDEF ) {
			DispError((char *)&s_sth,e_mesg);
			return(ERROR);
		}
		if(s_sth.s_fn[0] == ADDREC) {
			if(err != UNDEF) {
#ifdef ENGLISH
				fomer("Catalogue Number Already Exist - Please Re-Enter");
#else
				fomer("Numero de catalogue existe deja - S.V.P. reessayer.");
#endif
				s_sth.s_cat_num = LV_LONG;
				return(ERROR);
			}
		}
		else {
			if(err == UNDEF) {
#ifdef ENGLISH
				fomer("Catalogue Number Does Not Exist - Please Re-Enter");
#else
				fomer("Numero de catalogue existe deja - S.V.P. reessayer.");
#endif
				s_sth.s_cat_num = LV_LONG;
				return(ERROR);
			}
		}
		break ;
	default :
#ifdef ENGLISH
		sprintf(e_mesg,"No Validity Check For Field#  %d",sr.curfld);
#else
		sprintf(e_mesg,"Pas de controle de validite pour le Champ#  %d",sr.curfld);
#endif
		fomen(e_mesg);
		get();
		return(ERROR) ;
	}	/* Switch sr.curfld */

	return(NOERROR) ;
}	/* Validation() */
/*----------------------------------------------------------------*/
/* Show Help Windows, if applicable, when user gives ESC-H in key
   and header fields */

WindowHelp()
{
	int	retval ;

	switch(sr.curfld){
	case	KEY_START:	/* Supplier Cd: */
		if(s_sth.s_fn[0] != ADDREC) {
			retval = catalogue_hlp(&s_sth.s_cat_num,7,13);
			if(retval == DBH_ERR) return(retval);
			if(retval >= 0) redraw();
			if(retval == 0) return(ERROR);
			if(retval < 0) return(ERROR);
		}
		break ;
	default :
#ifdef ENGLISH
		fomer("No Help Window For This Field");
#else
		fomer("Pas de fenetre d'assistance pour ce champ");
#endif
	}	/* Switch sr.curfld */

	return(NOERROR) ;
}	/* WindowHelp() */
/*-----------------------------------------------------------------------*/
/* Take the confirmation from user for the header part */

Confirm()
{
	int	err ;

	/* Options:
	   Add, Change     - YEC
	   Inquire, Delete - YC
	*/

	for( ; ; ) {
		if(s_sth.s_fn[0] != DELETE && s_sth.s_fn[0] != INQUIRE) {
#ifdef ENGLISH
			err = GetOption((char *)&s_sth,
					"Y(es), E(dit), C(ancel)", "YEC");
#else
			err = GetOption((char *)&s_sth,
					"O(ui), M(odifier), A(nnuler)", "OMA");
#endif
		}
		else {
#ifdef ENGLISH
			err = GetOption((char *)&s_sth,"Y(es), C(ancel)","YC");
#else
			err = GetOption((char *)&s_sth,"O(ui), A(nnuler)","OA");
#endif
		}
		if(err == PROFOM_ERR) return(err) ;

		switch(err) {
		case  YES :
			return(YES) ;
		case  EDIT  :
			err = FldEdit();
			break ;
		case  CANCEL :
#ifdef ENGLISH
			err = GetOption((char *)&s_sth,
					"Confirm the Cancel (Y/N)?", "YN") ;
#else
			err = GetOption((char *)&s_sth,
					"Confirmer l'annulation (O/N)?", "ON") ;
#endif
			if(err == YES) return(CANCEL) ;
			break ;
		}	/* switch err */

		if(err == PROFOM_ERR) return(err) ;
		if(err == DBH_ERR) return(err) ;
	}	/* for(; ; ) */
}	/* Confirm() */
/*-----------------------------------------------------------------------*/
/* Show Catalogue information on Screen */
ShowRec()
{
	int	err ;

	category.categ_num = catalogue.cat_num / 100000;
	err = get_category(&category,BROWSE,0,e_mesg);
	if(ERROR == err) return(DBH_ERR) ;
	if(err < 0) {		/* UNDEF or LOCKED */
		fomer(e_mesg) ;
		get() ;
		return(err) ;
	}

	item_grp.itmgrp_num = catalogue.cat_num / 1000;
	err = get_itemgrp(&item_grp,BROWSE,0,e_mesg);
	if(ERROR == err) return(DBH_ERR) ;
	if(err < 0) {		/* UNDEF or LOCKED */
		fomer(e_mesg) ;
		get() ;
		return(err) ;
	}

	s_sth.s_cat_num = catalogue.cat_num;
	s_sth.s_cate_num = category.categ_num;
	strcpy(s_sth.s_cate_desc,category.categ_desc); 
	s_sth.s_itmg_num = item_grp.itmgrp_num;
	strcpy(s_sth.s_itmg_desc1,item_grp.itmgrp_desc1); 
	strcpy(s_sth.s_itmg_desc2,item_grp.itmgrp_desc2); 
	strcpy(s_sth.s_itmg_desc3,item_grp.itmgrp_desc3); 
	s_sth.s_item_num =  catalogue.cat_num;
	strcpy(s_sth.s_item_desc,catalogue.cat_desc); 
	strcpy(s_sth.s_uom,catalogue.cat_uom);
	strcpy(s_sth.s_suppcd,catalogue.cat_awd_supp);
	s_sth.s_min_dollar = catalogue.cat_min_dollar;
	s_sth.s_cur_price = catalogue.cat_unit_price[0];
	s_sth.s_cur_qty = catalogue.cat_qty[0];
	s_sth.s_pre_price = catalogue.cat_unit_price[1];
	s_sth.s_pre_qty = catalogue.cat_qty[1];
	s_sth.s_dummy[0] = ' ' ;

	ret( WriteFields((char *)&s_sth, KEY_START, END_FLD-200) ) ;
}	/* ShowRec() */
/*------------------------------------------------------------------------*/
/* Move High values to all data fields and clear the screen */

ClearScreen()
{
	int	i;

	/* Move High Values Screen */
	InitScr(HV_CHAR, HV_SHORT, HV_LONG, HV_DOUBLE) ;

	s_sth.s_dummy[0] = HV_CHAR ;

	ret( WriteFields((char *)&s_sth,CATEG_NBR_FLD, END_FLD) );

	return(NOERROR);
}	/* ClearScreen() */
/*-------------------------------------------------------------------------*/
/* Initialize Screen Header with either Low or High Values */

InitScr( t_char, t_short, t_long, t_double )
char	t_char ;
short	t_short ;
long	t_long ;
double	t_double ;
{
	/* Alway Default to break up of Catalogue Number */
	if(t_short != LV_SHORT) {
		s_sth.s_cate_num  = t_short;	
		s_sth.s_itmg_num = t_short;
		s_sth.s_item_num = t_long;
	}
	s_sth.s_cate_desc[0] = t_char;
	s_sth.s_itmg_desc1[0] = t_char;
	s_sth.s_itmg_desc2[0] = t_char;
	s_sth.s_itmg_desc3[0] = t_char;
	s_sth.s_item_desc[0] = t_char;
	s_sth.s_uom[0] = t_char;
	if(t_char == HV_CHAR) {
		s_sth.s_suppcd[0] = t_char;
	}
	else {
		strcpy(s_sth.s_suppcd,"          ");
	}
	if(t_double == HV_DOUBLE) {
		s_sth.s_min_dollar = t_double;
		s_sth.s_cur_price = t_double;
		s_sth.s_cur_qty = t_double;
	}
	else {
		s_sth.s_min_dollar = 0.00;
		s_sth.s_cur_price = 0.00;
		s_sth.s_cur_qty = 0.00;
	}
	if(t_char == LV_CHAR) {
		s_sth.s_dummy[0] = ' ';
	}
	s_sth.s_pre_price = t_double;
	s_sth.s_pre_qty = t_double;

	return(NOERROR) ;
}	/* InitScr() */
/*-------------------------------------------------------------------------*/
FldEdit()
{
     	int i, retval;
	int st_fld, end_fld;

	
	SetDupBuffers(CATEG_NBR_FLD,END_FLD,2);

	/* Get The Field to Be Modified */
#ifdef	ENGLISH
	STRCPY(s_sth.s_mesg,"Enter RETURN to terminate Edit");
#else
	STRCPY(s_sth.s_mesg,"Appuyer sur RETURN pour terminer l'ajustement");
#endif
	DispMesgFld((char *)&s_sth) ;
        
     	for (; ;) {
		s_sth.s_field = LV_SHORT;
		retval = ReadFields((char *)&s_sth,CHG_FLD, CHG_FLD,
			(int (*)())NULL,(int (*)())NULL, 1);

		if (retval < 0) return(-1);
		if (retval == RET_USER_ESC) break;	/* User enter ESC-F */

       		if (s_sth.s_field == 0 ) break;	/* Finished changing fields */

		if(s_sth.s_field > PQTY_SNO) continue ;

		/* make copy of screen structure */
		scpy((char *)&image,(char *)&s_sth,sizeof(s_sth));

		/* Non-editable in change mode */
		if(s_sth.s_fn[0] == CHANGE && (s_sth.s_field == SUPP_SNO ||
		   (s_sth.s_field > MIN_SNO && s_sth.s_field != PQTY_SNO))) {
			fomer("Cannot Edit Specified Field");
			continue;
		}
		switch(s_sth.s_field) {
			case CATE_SNO:
				st_fld = end_fld = CATEG_DESC_FLD;
				break;
			case ITMGRP_SNO:
				s_sth.s_itmg_desc1[0] = LV_CHAR;
				s_sth.s_itmg_desc2[0] = LV_CHAR;
				s_sth.s_itmg_desc3[0] = LV_CHAR;
				st_fld = ITMG_DESC1_FLD;
				end_fld = ITMG_DESC3_FLD;
				break;
			case ITEM_SNO:
				st_fld = end_fld = ITEM_DESC_FLD;
				break;
			case UOM_SNO:
				st_fld = end_fld = UOM_FLD;
				break;
			case SUPP_SNO:
				st_fld = end_fld = SUPPCD_FLD;
				break;
			case MIN_SNO:
				st_fld = end_fld = MIN_FLD;
				break;
			case CUNIT_SNO:
				st_fld = end_fld = CUR_UNIT_FLD;
				break;
			case CQTY_SNO:
				st_fld = end_fld = CUR_QTY_FLD;
				break;
			case PUNIT_SNO:
				st_fld = end_fld = PRE_UNIT_FLD;
				break;
			case PQTY_SNO:
				st_fld = end_fld = PRE_QTY_FLD;
				break;
		}

		i = ReadFields((char *)&s_sth,st_fld,end_fld,
			Validation,WindowHelp,1) ;
		if(PROFOM_ERR == i || DBH_ERR == i) return(i) ;
		if(RET_USER_ESC == i){
		/* When user gives ESC-F while changing fields, assumption is
		* he completed his changes, and remaining fields are same as
		* old. But, at this point STH will be having low values in the 
		* remaining fields. So move the old values form the linked list.
		*/
			i = CopyBack((char *)&s_sth,(char *)&image,
					sr.curfld,end_fld);
			if(i == PROFOM_ERR) return(i);

			return(RET_USER_ESC) ;
		}
	}
     	s_sth.s_field = HV_SHORT ;
	if ( WriteFields((char *)&s_sth,CHG_FLD, CHG_FLD) < 0 ) return(-1);

     	s_sth.s_mesg[0] = HV_CHAR ;
     	DispMesgFld((char *)&s_sth);

     	return(NOERROR);

}
/*-------------------- E n d   O f   P r o g r a m ---------------------*/
