/******************************************************************************
		Sourcename    : tendreputl.c
		System        : Budgetary Financial system.
		Module        : Tendering reports
		Created on    : 92-04-20
		Created  By   : J Prescott.
		Cobol sources : 

HISTORY:
 Date           Programmer     Description of modification
____/__/__      __________     ___________________________

Calls for the user:	( Check for the value returned: -1 on error )

int	AddMenuItem( char *name, int (* fnptr)() );
int	Initialize( char *terminalname , char *heading );
int	Process();
int	GetCategRange(short *, short * );
int	GetResponse( char *, char * );
int	HideMessage();
int	GetOutputon( char * );
int	GetFilename( char * );
int	GetPrinter( short * );
int	GetNbrCopies( short * );
int	Confirm();		returns 1 for Yes, and 0 for anyother input

The programmer should make calls for appending menuitems in the following order.
		AddMenuItem( menuname, functionpointer );( max. 9 options )
		Initialize( screenheading );
		Process();	 for menu item selection
		{	Any "Get...." calls }
		Confirm();	It clears the screen and resets terminal
A maximum of 19 menuitems can be added, excluding one for Quitting the screen
which is automatically appended by the system.

For all the calls starting with "Get", user can pass any default values by 
initialising the corresponding variables before passing their address(es)
as parameters. The program doesnot do any validation except that it disallows
user's entry of end value ( range limit ) if it is smaller than starting value.

The last call should be "Confirm()",  which clears the profom screen and resets
the terminal characteristics

******************************************************************************/
#include <stdio.h>

#include <bfs_defs.h>
#include <cfomstrc.h>

#ifdef ENGLISH
#define PRINTER 'P'
#define DISPLAY 'D'
#define FILE_IO	'F'
#define YES	'Y'
#define NO	'N'

#define SCHL_OPT  'S'
#define WAREHOUSE 'W'
#define LABEL	'L'
#define REPORT	'R'
#define AWARD	'A'
#define UNAWARD 'U'

#define PREV	'P'
#define ALL	'A'
#else
#define PRINTER 'I'
#define DISPLAY 'A'
#define FILE_IO	'D'
#define YES	'O'
#define NO	'N'

#define SCHL_OPT  'C'
#define WAREHOUSE 'P'
#define LABEL	'E'
#define REPORT	'R'
#define AWARD	'A'
#define UNAWARD 'N'

#define PREV	'P'
#define ALL	'T'
#endif

#define SCREEN_NAME	"tendrep"
#define EXIT		12
#define PATH_FILE_SIZE	50
#define STARTLINENUM	18
#define LOW 		-1
#define HIGH 		 1
#define HL_CHAR(VAL)	VAL==HIGH ? HV_CHAR : LV_CHAR
#define ESC_F		sr.retcode==RET_USER_ESC && \
			(sr.escchar[0]=='F'||sr.escchar[0]=='f')
#define	OPTIONLEN	34
#define MAXOPTIONS	20
#define MAXQUERYLINES	7

#define CATEG_NO        0
#define TENDER_NO	0
#define ITEMGRP_NO      1
#define DELIVER_NO      2
#define RPT_LAB_NO	2
#define ITEM_NO		3
#define CAT_NO		3
#define SUPP_NO		4
#define RPTQTY_NO	5
#define RPTCATEG_NO	5
#define LABUP_NO	5
#define RPTITMGRP_NO	6
#define YCALC_NO	6
#define AWD_UNAWD_NO	6
#define YEAR_NO		6
#define SELECT_NO	6

#define CATEGNO1	3000
#define CATEGNO2	3100

#define TENDERNO1	3200
#define TENDERNO2	3300

#define ITEMGRP1	3400
#define ITEMGRP2	3500

#define DELIVER		3600 

#define ITEMNO1		3700
#define ITEMNO2		3800

#define SUPPCD1		3900
#define SUPPCD2		4000

#define RPT_QTY		4100
#define RPT_CATEG	4200
#define RPT_ITMGRP	4300

#define CATALOGUE1	4400
#define CATALOGUE2	4500

#define YEND_CALC	4600

#define PRNT_LABELS	4700
#define NO_LABELS	4800

#define AWD_UNAWD	4900

#define YEAR_FLD	5000

#define NO_SELECT	5100

#define MESSAGE		9500
#define RESPONSE	9600

/* tendrep.sth - header for C structure generated by PROFOM EDITOR */

static struct	s_struct	{
	char	s_progname[11];	/* 100 program name */
	char	s_scrhdg[18];	/* 200 */
	long	s_rundt;	/* 300 DATE YYYYFMMFDD */
	char	s_item[MAXOPTIONS][OPTIONLEN];	/* 400 - 2300 options */
	short	s_option;	/* 2400 user's input */
	char	s_outputon[2];	/* 2600 report output on D / F / P */
	char	s_filename[16];	/* 2700 name of file if option is F */
	short	s_printer;	/* 2800 printer# if option is P */
	short	s_nbrcopies;	/* 2900 page length in no of lines */
	short	s_categ_no1;	/* 3000 starting category number */
	short	s_categ_no2;	/* 3100 ending category number */
	short	s_tender_no1;	/* 3200 starting tender number */
	short	s_tender_no2;	/* 3300 ending tender number */
	short	s_item_grp1;	/* 3400 starting Item Group */
	short	s_item_grp2;	/* 3500 ending Item Group */
	char	s_delivery[2];	/* 3600 Delivery To */
	long	s_item_no1;	/* 3700 starting Item Number */
	long	s_item_no2;	/* 3800 ending Item Number */
	char	s_suppcd1[11];	/* 3900 starting supplier code */
	char	s_suppcd2[11];	/* 4000 ending supplier code */
	char	s_rpt_qty[2];	/* 4100 Report on Quantities */
	char	s_rpt_categ[2];	/* 4200 Report on Category */
	char	s_rpt_itmgrp[2];/* 4300 Report on Item Group */
	long	s_cat_no1;	/* 4400 starting Catalogue Number */
	long	s_cat_no2;	/* 4500 ending Catalogue Number */
	char	s_yend_calc[2];	/* 4600 Year End Calculations */
	char	s_prnt_lab[2];	/* 4700 Print Labels or Report */
	short	s_no_up;	/* 4800 Number of Labels Across */
	char	s_awd_unawd[2];	/* 4900 Awarded/Unawarded Suppliers */	
	char	s_year[2];	/* 5000 Awards Year */	
	short	s_select;	/* 5100 No. of Suppliers to select */

	char	s_mesg[78];	/* 9500 message field */
	char	s_resp[2];	/* 9600 response field */
}	s_rec;

typedef struct{
	char	name[OPTIONLEN];
	int	(* fnptr)();
	int	mainflno;
}Menu;

struct stat_rec 	sr;		/* profom status record */

static int		line[MAXQUERYLINES];/* for positioning key queries */
static short		call_no;
static short		totaloptions;
static int retval;	/* Global variable to store function values */
static Menu	menu[MAXOPTIONS];
static	int	initialised ;
static char	txt[80];

extern e_mesg[80];  	/* to store error messages */

static
CleanExit()/* clear and exit the screen , close files & exit program */
{
	fomcs();
	fomrt();
	exit(0);
}
Initialize( terminal,heading )	/* initialize profom and screen */
char *terminal;
char *heading;	
{
	if((retval = InitProfom(terminal))<0 ){	/* initialize profom */
		fomcs();
		fomrt();
		return(retval);
	}
	if((retval = InitScreen(heading))<0 ){		/* initialize screen */
		fomcs();
		fomrt();
		return(retval);
	}
	initialised = 1 ;
	return(0);
}	
static
InitProfom(terminal)	/* initialize profom */
char *terminal;
{
	if ( initialised ) return(0) ;
	STRCPY( sr.termnm, terminal );
	fomin( &sr );		/* initialize the screen */
	ret( err_chk(&sr) );	/* if profom error return */
	return(0);
}
static
InitScreen(heading)		/* initialize the screen */
char 	*heading;
{
	/* initialize the profom screen variables */
	STRCPY( sr.scrnam, NFM_PATH );
	strcat( sr.scrnam, SCREEN_NAME );

	/* initialize the fields of the profom screen */
	if( initialised==0 ){
		if( FillScrHdg(heading)<0 ) 	return(-1);
		if( FillMenu()<0 ) 		return(-1);
		if( FillOption(HIGH)<0 )	return(-1);
	}
	/* Move highs to inquiry area and write entire screen */
	if((retval = ClearInquiryArea())<0 )
		return(retval);

	fomcf( 1,1 ) ;		/* Enable snap screen */
	return(0);
}

/* Fill the screen heading fields, the program name and the date */
static
FillScrHdg(heading)
char *heading;
{
	STRCPY( s_rec.s_progname, PROG_NAME );
	STRCPY( s_rec.s_scrhdg, heading );
	s_rec.s_rundt = get_date();
	return(0);
}

/* Add a menu item to the array of report menu items */
AddMenuItem( menuname, fnptr, mainflno )
char	*menuname;
int	(* fnptr)();
int	mainflno;
{
	if( totaloptions==0 ){ /* no options added to array yet */
#ifdef ENGLISH
		STRCPY( menu[totaloptions].name, "RETURN TO PREVIOUS MENU" );
#else
		STRCPY( menu[totaloptions].name, "RETOURNER AU MENU PRECEDENT");
#endif
		menu[totaloptions].fnptr = NULL;
		totaloptions++;
	}

	if( totaloptions>=MAXOPTIONS )	/* array can't accomodate any more */ 
		return(-1);
	if( menuname==NULL )		/* menu name can't be null */
		return(-1);
	STRCPY( menu[totaloptions].name, menuname );
	menu[totaloptions].fnptr = fnptr;	/* copy function pointer */
	menu[totaloptions].mainflno = mainflno;  /* copy file used */
	
	totaloptions++;

	return(totaloptions-1);
}
/* Fill Menu Options with the proper names */
static
FillMenu()
{
	short	i;

	for( i=0; i<totaloptions; i++ )
		STRCPY( s_rec.s_item[i], menu[i].name );
	for( i=totaloptions; i<MAXOPTIONS; i++ )
		s_rec.s_item[i][0] = HV_CHAR;
	return(0);
}
static
FillOption( value )
short value;
{
	s_rec.s_option = value * HV_SHORT;
	return(0);
}
/* Fill output details with high or low values */
static
FillOutputDetails( value )
short value;
{
	s_rec.s_outputon[0] = HL_CHAR(value);
	s_rec.s_filename[0] = HL_CHAR(value);
	s_rec.s_printer = HV_SHORT * value;
	s_rec.s_nbrcopies = HV_SHORT * value;
	return(0);
}
static
FillCategNbr( val1, val2 )
short	val1, val2;
{
	s_rec.s_categ_no1 = HV_SHORT * val1 ;
	s_rec.s_categ_no2 = HV_SHORT * val2 ;
	return(0);
}
static
FillTenderNbr( val1, val2 )
short	val1, val2;
{
	s_rec.s_tender_no1 = HV_SHORT * val1 ;
	s_rec.s_tender_no2 = HV_SHORT * val2 ;
	return(0);
}

static
FillItemGroup( val1, val2 )
short	val1, val2;
{
	s_rec.s_item_grp1 = HV_SHORT * val1 ;
	s_rec.s_item_grp2 = HV_SHORT * val2 ;
	return(0);
}

static
FillDelivery( val1 )
short	val1;
{
	s_rec.s_delivery[0] = HL_CHAR( val1 );
	return(0);
}

static
FillItemNo( val1, val2 )
short	val1, val2;
{
	s_rec.s_item_no1 = HV_LONG * val1 ;
	s_rec.s_item_no2 = HV_LONG * val2 ;
	return(0);
}

static
FillSuppcd( val1, val2 )
short	val1, val2;
{
	s_rec.s_suppcd1[0] = HL_CHAR( val1 );
	s_rec.s_suppcd2[0] = HL_CHAR( val2 );

	return(0);
}

static
FillRptonQty( val1 )
short	val1;
{
	s_rec.s_rpt_qty[0] = HL_CHAR( val1 );
	return(0);
}

static
FillRptonCategory( val1 )
short	val1;
{
	s_rec.s_rpt_categ[0] = HL_CHAR( val1 );
	return(0);
}

static
FillRptonItemGrp( val1 )
short	val1;
{
	s_rec.s_rpt_itmgrp[0] = HL_CHAR( val1 );
	return(0);
}

static
FillCatalogue( val1, val2 )
short	val1, val2;
{
	s_rec.s_cat_no1 = HV_LONG * val1 ;
	s_rec.s_cat_no2 = HV_LONG * val2 ;
	return(0);
}

static
FillYendCalc( val1 )
short	val1;
{
	s_rec.s_yend_calc[0] = HL_CHAR( val1 );
	return(0);
}

static
FillPrntLabels( val1 )
short	val1;
{
	s_rec.s_prnt_lab[0] = HL_CHAR( val1 );
	return(0);
}

static
FillNoUp( val1 )
short	val1;
{
	s_rec.s_no_up = HV_SHORT * val1 ;
	return(0);
}

static
FillAwardUnaward( val1 )
short	val1;
{
	s_rec.s_awd_unawd[0] = HL_CHAR( val1 );
	return(0);
}

static
FillYear( val1 )
short	val1;
{
	s_rec.s_year[0] = HL_CHAR( val1 );
	return(0);
}

static
FillSelect( val1 )
short	val1;
{
	s_rec.s_select = HV_SHORT * val1 ;
	return(0);
}

/* Fill the message and response fields with high or low values */
static
FillMsgRespFields( value )
short value;
{
	s_rec.s_mesg[0] = HL_CHAR( value );
	s_rec.s_resp[0] = HL_CHAR( value );

	return(0);
}
/* Accept user's option and call the corresponding routine in a loop */
Process(terminal, heading)
char	*terminal ;
char	*heading  ;
{
	int	field;
	short	prev_option;

	if((retval = Initialize(terminal, heading)) <0)
		return(retval); 
	call_no = 0;	/* No get calls made yet */
	prev_option = -1;

	for( ; ; ){
		mainfileno = -1 ;

		for( ; ; ) {
			fomca1(2400,19,2); /* enable dup control */

			sr.nextfld = sr.endfld = 2400;
			fomud( (char *)&s_rec);
			ret(err_chk(&sr));	/* Check for PROFOM error */
			s_rec.s_option=LV_SHORT;

			retval = ReadOption();
			if( retval<0 )
				return(retval);

			if(prev_option != -1) {
				/* Turn off Highlight option. */
				field = 400+(prev_option*100);
				fomca1( field, 9, 5 );
			}

			if( s_rec.s_option>=totaloptions ){
#ifdef ENGLISH
				fomer("Invalid option");
#else
				fomer("Option invalide");
#endif
				continue;
			}

			/* Highlight option. Dehighlight in Confirm() */
			field = 400+(s_rec.s_option*100);
			fomca1( field, 9, 3 );

			if(prev_option != s_rec.s_option) {
#ifdef ENGLISH
				fomer("Enter RETURN to confirm");
#else
				fomer("Appuyer sur RETURN pour confirmer");
#endif
				prev_option = s_rec.s_option;
			}
			else if(sr.fillcode == FIL_DUP) {
					break;
			}
			else {
#ifdef ENGLISH
				fomer("Enter RETURN to confirm");
#else
				fomer("Appuyer sur RETURN pour confirmer");
#endif
				prev_option = s_rec.s_option;
			}
		}
		if( s_rec.s_option==0 ){   /* option 0 is reserved to quit */
			fomcs();
			fomrt();
			return(0);
		}

		if((retval = CheckAccess(menu[s_rec.s_option].mainflno,
				BROWSE,e_mesg))<0)
			return(retval);	

		mainfileno = menu[s_rec.s_option].mainflno ;

		/* if a corresponding function exists, call it  */
		if(menu[s_rec.s_option].fnptr ){
			if((retval=(*menu[s_rec.s_option].fnptr)())<0 )
				return(retval);
			fomst();
			s_rec.s_option=LV_SHORT;
			sr.nextfld = sr.endfld = 2400;
			fomud( (char *)&s_rec);
			ret(err_chk(&sr));	/* Check for PROFOM error */
		}
		else {	/* there isn't corr. function,  return value */
			s_rec.s_option=LV_SHORT;
			sr.nextfld = sr.endfld = 2400;
			fomud( (char *)&s_rec);
			ret(err_chk(&sr));	/* Check for PROFOM error */
			return (s_rec.s_option);
		}

		if((retval = ClearInquiryArea())<0 )
			return(retval);
	}
}

/*	The following Get....() calls display default values given as parameter 
*	and fill up the variable with the value entered by the user 
*	The fields for accepting input are positioned in the order in which
*	they are called. For this, they make use of variable 'call_no'
*/

GetCategRange( categnbr1, categnbr2 )
short *categnbr1, *categnbr2;
{
	int	retval=0;

	if( line[CATEG_NO]==0 )	/* no Category call made yet */
		line[CATEG_NO] = STARTLINENUM + call_no++;
	fomca2( CATEGNO1,1, line[CATEG_NO], 1 );
	fomca2( CATEGNO1,2, line[CATEG_NO], 17 );
	fomca2( CATEGNO2,1, line[CATEG_NO], 43 );
	fomca2( CATEGNO2,2, line[CATEG_NO], 48 );

	s_rec.s_categ_no1 = 1;

	fomca1( CATEGNO1, 19, 2 );
	sr.nextfld = CATEGNO1;
	sr.endfld = CATEGNO1;
	fomud( (char *)&s_rec);

	s_rec.s_categ_no1 = LV_SHORT;
	s_rec.s_categ_no2 = 0;
	retval = ReadFields( CATEGNO1, CATEGNO2 );
	if( retval!=EXIT && retval>=0 ){
		*categnbr1 = s_rec.s_categ_no1;
	}

	if(s_rec.s_categ_no1 != 1) 
		s_rec.s_categ_no2 = *categnbr1;
	else 	
		s_rec.s_categ_no2 = 99;

	fomca1( CATEGNO2, 19, 2 );
	sr.nextfld = CATEGNO2;
	sr.endfld = CATEGNO2;
	fomud( (char *)&s_rec);
	s_rec.s_categ_no2 = LV_SHORT;
	retval = ReadFields( CATEGNO2, CATEGNO2 );
	if( retval!=EXIT && retval>=0 ){
		*categnbr2 = s_rec.s_categ_no2;
	}
	fomca1( CATEGNO1, 19, 0 );
	fomca1( CATEGNO2, 19, 0 );

	return(retval);
}

GetTenderRange( tender1, tender2 )
short *tender1, *tender2;
{
	int	retval=0;

	if( line[TENDER_NO]==0 )	/* no Category call made yet */
		line[TENDER_NO] = STARTLINENUM + call_no++;
	fomca2( TENDERNO1,1, line[TENDER_NO], 1 );
	fomca2( TENDERNO1,2, line[TENDER_NO], 17 );
	fomca2( TENDERNO2,1, line[TENDER_NO], 43 );
	fomca2( TENDERNO2,2, line[TENDER_NO], 48 );

	s_rec.s_tender_no1 = 1;

	fomca1( TENDERNO1, 19, 2 );
	sr.nextfld = TENDERNO1;
	sr.endfld = TENDERNO1;
	fomud( (char *)&s_rec);

	s_rec.s_tender_no1 = LV_SHORT;
	s_rec.s_tender_no2 = 0;
	retval = ReadFields( TENDERNO1, TENDERNO2 );
	if( retval!=EXIT && retval>=0 ){
		*tender1 = s_rec.s_tender_no1;
	}

	if(s_rec.s_tender_no1 == 1) 
		s_rec.s_tender_no2 = 99;
	else 
		s_rec.s_tender_no2 = *tender1;

	fomca1( TENDERNO2, 19, 2 );
	sr.nextfld = TENDERNO2;
	sr.endfld = TENDERNO2;
	fomud( (char *)&s_rec);

	s_rec.s_tender_no2 = LV_SHORT;
	retval = ReadFields( TENDERNO2, TENDERNO2 );
	if( retval!=EXIT && retval>=0 ){
		*tender2 = s_rec.s_tender_no2;
	}
	fomca1( TENDERNO1, 19, 0 );
	fomca1( TENDERNO2, 19, 0 );

	return(retval);
}


GetItemGrpRange( itmgrp1, itmgrp2 )
short *itmgrp1, *itmgrp2;
{
	int	retval=0;

	if( line[ITEMGRP_NO]==0 )	/* no Category call made yet */
		line[ITEMGRP_NO] = STARTLINENUM + call_no++;
	fomca2( ITEMGRP1,1, line[ITEMGRP_NO], 1 );
	fomca2( ITEMGRP1,2, line[ITEMGRP_NO], 17 );
	fomca2( ITEMGRP2,1, line[ITEMGRP_NO], 43 );
	fomca2( ITEMGRP2,2, line[ITEMGRP_NO], 48 );

	s_rec.s_item_grp1 = 1;

	fomca1( ITEMGRP1, 19, 2 );
	sr.nextfld = ITEMGRP1;
	sr.endfld = ITEMGRP1;
	fomud( (char *)&s_rec);

	s_rec.s_item_grp1 = LV_SHORT;
	s_rec.s_item_grp2 = 0;
	retval = ReadFields( ITEMGRP1, ITEMGRP2 );
	if( retval!=EXIT && retval>=0 ){
		*itmgrp1 = s_rec.s_item_grp1;
	}


	if(s_rec.s_item_grp1 == 1) 
		s_rec.s_item_grp2 = 9999;
	else
		s_rec.s_item_grp2 = *itmgrp1;

	fomca1( ITEMGRP2, 19, 2 );
	sr.nextfld = ITEMGRP2;
	sr.endfld = ITEMGRP2;
	fomud( (char *)&s_rec);
	s_rec.s_item_grp2 = LV_SHORT;
	retval = ReadFields( ITEMGRP2, ITEMGRP2 );
	if( retval!=EXIT && retval>=0 ){
		*itmgrp2 = s_rec.s_item_grp2;
	}
	fomca1( ITEMGRP1, 19, 0 );
	fomca1( ITEMGRP2, 19, 0 );

	return(retval);
}

GetDelivery( delivery )
char *delivery;
{
	int	retval=0;

	if( line[DELIVER_NO]==0 )	/* no Category call made yet */
		line[DELIVER_NO] = STARTLINENUM + call_no++;
	fomca2( DELIVER,1, line[DELIVER_NO], 1 );
	fomca2( DELIVER,2, line[DELIVER_NO], 55 );

	strcpy(s_rec.s_delivery,delivery);
	fomca1( DELIVER, 19, 2 );
	sr.nextfld = DELIVER;
	sr.endfld = DELIVER;
	fomud( (char *)&s_rec);
	s_rec.s_delivery[0] = LV_CHAR;
	retval = ReadFields( DELIVER, DELIVER );
	if( retval!=EXIT && retval>=0 ){
		strcpy(delivery,s_rec.s_delivery);
	}
	fomca1( DELIVER, 19, 0 );

	return(retval);
}

GetItemNoRange( itemno1, itemno2 )
long *itemno1, *itemno2;
{
	int	retval=0;

	if( line[ITEM_NO]==0 )	/* no Category call made yet */
		line[ITEM_NO] = STARTLINENUM + call_no++;
	fomca2( ITEMNO1,1, line[ITEM_NO], 1 );
	fomca2( ITEMNO1,2, line[ITEM_NO], 17 );
	fomca2( ITEMNO2,1, line[ITEM_NO], 43 );
	fomca2( ITEMNO2,2, line[ITEM_NO], 48 );

	s_rec.s_item_no1 = 1;

	fomca1( ITEMNO1, 19, 2 );
	sr.nextfld = ITEMNO1;
	sr.endfld = ITEMNO1;
	fomud( (char *)&s_rec);

	s_rec.s_item_no1 = LV_LONG;
	s_rec.s_item_no2 = 0;
	retval = ReadFields( ITEMNO1, ITEMNO2 );
	if( retval!=EXIT && retval>=0 ){
		*itemno1 = s_rec.s_item_no1;
	}

	if(s_rec.s_item_no1 == 1) 
		s_rec.s_item_no2 = 9999999;
	else
		s_rec.s_item_no2 = *itemno1;

	fomca1( ITEMNO2, 19, 2 );
	sr.nextfld = ITEMNO2;
	sr.endfld = ITEMNO2;
	fomud( (char *)&s_rec);
	s_rec.s_item_no2 = LV_LONG;
	retval = ReadFields( ITEMNO2, ITEMNO2 );
	if( retval!=EXIT && retval>=0 ){
		*itemno2 = s_rec.s_item_no2;
	}
	fomca1( ITEMNO1, 19, 0 );
	fomca1( ITEMNO2, 19, 0 );

	return(retval);
}

GetSuppRange( suppcd1, suppcd2 )
char *suppcd1, *suppcd2;
{
	int	retval=0;

	if( line[SUPP_NO]==0 )	/* no Category call made yet */
		line[SUPP_NO] = STARTLINENUM + call_no++;
	fomca2( SUPPCD1,1, line[SUPP_NO], 1 );
	fomca2( SUPPCD1,2, line[SUPP_NO], 17 );
	fomca2( SUPPCD2,1, line[SUPP_NO], 43 );
	fomca2( SUPPCD2,2, line[SUPP_NO], 48 );


	strcpy(s_rec.s_suppcd1,"         1");

	fomca1( SUPPCD1, 19, 2 );
	sr.nextfld = SUPPCD1;
	sr.endfld = SUPPCD1;
	fomud( (char *)&s_rec);

	s_rec.s_suppcd1[0] = LV_CHAR;
	s_rec.s_suppcd2[0] = ' ';
	retval = ReadFields( SUPPCD1, SUPPCD2 );
	if( retval!=EXIT && retval>=0 ){
		strcpy(suppcd1,s_rec.s_suppcd1);
	}

	if(strcmp(s_rec.s_suppcd1,"         1")==0) 
		strcpy(s_rec.s_suppcd2,"ZZZZZZZZZZ");
	else
		strcpy(s_rec.s_suppcd2,suppcd1);

	fomca1( SUPPCD2, 19, 2 );
	sr.nextfld = SUPPCD2;
	sr.endfld = SUPPCD2;
	fomud( (char *)&s_rec);
	s_rec.s_suppcd2[0] = LV_CHAR;
	retval = ReadFields( SUPPCD2, SUPPCD2 );
	if( retval!=EXIT && retval>=0 ){
		strcpy(suppcd2,s_rec.s_suppcd2);
	}
	fomca1( SUPPCD1, 19, 0 );
	fomca1( SUPPCD2, 19, 0 );

	return(retval);
}

GetRptonQty( resp )
char *resp;
{
	int	retval=0;

	if( line[RPTQTY_NO]==0 )	/* no Category call made yet */
		line[RPTQTY_NO] = STARTLINENUM + call_no++;
	fomca2( RPT_QTY,1, line[RPTQTY_NO], 1 );
	fomca2( RPT_QTY,2, line[RPTQTY_NO], 46 );

	strcpy(s_rec.s_rpt_qty,resp);
	fomca1( RPT_QTY, 19, 2 );
	sr.nextfld = RPT_QTY;
	sr.endfld = RPT_QTY;
	fomud( (char *)&s_rec);
	s_rec.s_rpt_qty[0] = LV_CHAR;
	retval = ReadFields( RPT_QTY, RPT_QTY );
	if( retval!=EXIT && retval>=0 ){
		strcpy(resp,s_rec.s_rpt_qty);
	}
	fomca1( RPT_QTY, 19, 0 );

	return(retval);
}

GetRptonCategory( resp )
char *resp;
{
	int	retval=0;

	if( line[RPTCATEG_NO]==0 )	/* no Category call made yet */
		line[RPTCATEG_NO] = STARTLINENUM + call_no++;
	fomca2( RPT_CATEG,1, line[RPTCATEG_NO], 1 );
	fomca2( RPT_CATEG,2, line[RPTCATEG_NO], 44 );

	strcpy(s_rec.s_rpt_categ,resp);
	fomca1( RPT_CATEG, 19, 2 );
	sr.nextfld = RPT_CATEG;
	sr.endfld = RPT_CATEG;
	fomud( (char *)&s_rec);
	s_rec.s_rpt_categ[0] = LV_CHAR;
	retval = ReadFields( RPT_CATEG, RPT_CATEG );
	if( retval!=EXIT && retval>=0 ){
		strcpy(resp,s_rec.s_rpt_categ);
	}
	fomca1( RPT_CATEG, 19, 0 );

	return(retval);
}

GetRptonItemGrp( resp )
char *resp;
{
	int	retval=0;

	if( line[RPTITMGRP_NO]==0 )	/* no Category call made yet */
		line[RPTITMGRP_NO] = STARTLINENUM + call_no++;
	fomca2( RPT_ITMGRP,1, line[RPTITMGRP_NO], 1 );
	fomca2( RPT_ITMGRP,2, line[RPTITMGRP_NO], 46 );

	strcpy(s_rec.s_rpt_itmgrp,resp);
	fomca1( RPT_ITMGRP, 19, 2 );
	sr.nextfld = RPT_ITMGRP;
	sr.endfld = RPT_ITMGRP;
	fomud( (char *)&s_rec);
	s_rec.s_rpt_itmgrp[0] = LV_CHAR;
	retval = ReadFields( RPT_ITMGRP, RPT_ITMGRP );
	if( retval!=EXIT && retval>=0 ){
		strcpy(resp,s_rec.s_rpt_itmgrp);
	}
	fomca1( RPT_ITMGRP, 19, 0 );

	return(retval);
}

GetCatalogueRange( catno1, catno2 )
long *catno1, *catno2;
{
	int	retval=0;

	if( line[CAT_NO]==0 )	/* no Category call made yet */
		line[CAT_NO] = STARTLINENUM + call_no++;
	fomca2( CATALOGUE1,1, line[CAT_NO], 1 );
	fomca2( CATALOGUE1,2, line[CAT_NO], 17 );
	fomca2( CATALOGUE2,1, line[CAT_NO], 43 );
	fomca2( CATALOGUE2,2, line[CAT_NO], 48 );

	s_rec.s_cat_no1 = 1;

	fomca1( CATALOGUE1, 19, 2 );
	sr.nextfld = CATALOGUE1;
	sr.endfld = CATALOGUE1;
	fomud( (char *)&s_rec);

	s_rec.s_cat_no1 = LV_LONG;
	s_rec.s_cat_no2 = 0;
	retval = ReadFields( CATALOGUE1, CATALOGUE2 );
	if( retval!=EXIT && retval>=0 ){
		*catno2 = s_rec.s_cat_no2;
	}
	
	if(s_rec.s_cat_no1 == 1)
		s_rec.s_cat_no2 = 9999999;
	else
		s_rec.s_cat_no2 = *catno1;

	fomca1( CATALOGUE2, 19, 2 );
	sr.nextfld = CATALOGUE2;
	sr.endfld = CATALOGUE2;
	fomud( (char *)&s_rec);
	s_rec.s_cat_no2 = LV_LONG;
	retval = ReadFields( CATALOGUE2, CATALOGUE2 );
	if( retval!=EXIT && retval>=0 ){
		*catno2 = s_rec.s_cat_no2;
	}
	fomca1( CATALOGUE1, 19, 0 );
	fomca1( CATALOGUE2, 19, 0 );

	return(retval);
}

GetYendCalc( resp )
char *resp;
{
	int	retval=0;

	if( line[YCALC_NO]==0 )	/* no Category call made yet */
		line[YCALC_NO] = STARTLINENUM + call_no++;
	fomca2( YEND_CALC,1, line[YCALC_NO], 1 );
	fomca2( YEND_CALC,2, line[YCALC_NO], 43 );

	strcpy(s_rec.s_yend_calc,resp);
	fomca1( YEND_CALC, 19, 2 );
	sr.nextfld = YEND_CALC;
	sr.endfld = YEND_CALC;
	fomud( (char *)&s_rec);
	s_rec.s_yend_calc[0] = LV_CHAR;
	retval = ReadFields( YEND_CALC, YEND_CALC );
	if( retval!=EXIT && retval>=0 ){
		strcpy(resp,s_rec.s_yend_calc);
	}
	fomca1( YEND_CALC, 19, 0 );

	return(retval);
}

GetPrntLabel( resp )
char *resp;
{
	int	retval=0;

	if( line[RPT_LAB_NO]==0 )	/* no Category call made yet */
		line[RPT_LAB_NO] = STARTLINENUM + call_no++;
	fomca2( PRNT_LABELS,1, line[RPT_LAB_NO], 1 );
	fomca2( PRNT_LABELS,2, line[RPT_LAB_NO], 48 );

	strcpy(s_rec.s_prnt_lab,resp);
	fomca1( PRNT_LABELS, 19, 2 );
	sr.nextfld = PRNT_LABELS;
	sr.endfld = PRNT_LABELS;
	fomud( (char *)&s_rec);
	s_rec.s_prnt_lab[0] = LV_CHAR;
	retval = ReadFields( PRNT_LABELS, PRNT_LABELS );
	if( retval!=EXIT && retval>=0 ){
		strcpy(resp,s_rec.s_prnt_lab);
	}
	fomca1( PRNT_LABELS, 19, 0 );

	return(retval);
}

GetNbrup( nbrlabels )
short	*nbrlabels;
{
	int	retval;

	if( line[LABUP_NO]==0 )	/* no Category call made yet */
		line[LABUP_NO] = STARTLINENUM + call_no++;
	fomca2( NO_LABELS,1, line[LABUP_NO], 1 );
	fomca2( NO_LABELS,2, line[LABUP_NO], 23 );

	s_rec.s_no_up = *nbrlabels;
	fomca1( NO_LABELS, 19, 2);
	sr.nextfld = NO_LABELS;
	sr.endfld = NO_LABELS;
	fomud( (char *)&s_rec);
	s_rec.s_no_up = LV_SHORT;
	retval = ReadFields(NO_LABELS,NO_LABELS);
	if( retval != EXIT && retval>=0 )
		*nbrlabels = s_rec.s_no_up;
	fomca1( NO_LABELS, 19, 0);
	return( retval );
}

GetAwdUnawd( resp )
char *resp;
{
	int	retval=0;

	if( line[AWD_UNAWD_NO]==0 )	/* no Category call made yet */
		line[AWD_UNAWD_NO] = STARTLINENUM + call_no++;
	fomca2( AWD_UNAWD,1, line[AWD_UNAWD_NO], 1 );
	fomca2( AWD_UNAWD,2, line[AWD_UNAWD_NO], 50 );

	strcpy(s_rec.s_awd_unawd,resp);
	fomca1( AWD_UNAWD, 19, 2 );
	sr.nextfld = AWD_UNAWD;
	sr.endfld = AWD_UNAWD;
	fomud( (char *)&s_rec);
	s_rec.s_awd_unawd[0] = LV_CHAR;
	retval = ReadFields( AWD_UNAWD, AWD_UNAWD );
	if( retval!=EXIT && retval>=0 ){
		strcpy(resp,s_rec.s_awd_unawd);
	}
	fomca1( AWD_UNAWD, 19, 0 );

	return(retval);
}

GetYear( resp )
char *resp;
{
	int	retval=0;

	if( line[YEAR_NO]==0 )	/* no Category call made yet */
		line[YEAR_NO] = STARTLINENUM + call_no++;
	fomca2( YEAR_FLD,1, line[YEAR_NO], 1 );
	fomca2( YEAR_FLD,2, line[YEAR_NO], 61 );

	strcpy(s_rec.s_year,resp);
	fomca1( YEAR_FLD, 19, 2 );
	sr.nextfld = YEAR_FLD;
	sr.endfld = YEAR_FLD;
	fomud( (char *)&s_rec);
	s_rec.s_year[0] = LV_CHAR;
	retval = ReadFields( YEAR_FLD, YEAR_FLD );
	if( retval!=EXIT && retval>=0 ){
		strcpy(resp,s_rec.s_year);
	}
	fomca1( YEAR_FLD, 19, 0 );

	return(retval);
}

GetSelect( resp )
short *resp;
{
	int	retval=0;

	if( line[SELECT_NO]==0 )	/* no Category call made yet */
		line[SELECT_NO] = STARTLINENUM + call_no++;
	fomca2( NO_SELECT,1, line[SELECT_NO], 1 );
	fomca2( NO_SELECT,2, line[SELECT_NO], 29 );

	s_rec.s_select = *resp;
	fomca1( NO_SELECT, 19, 2 );
	sr.nextfld = NO_SELECT;
	sr.endfld = NO_SELECT;
	fomud( (char *)&s_rec);
	s_rec.s_select = LV_SHORT;
	retval = ReadFields( NO_SELECT, NO_SELECT );
	if( retval!=EXIT && retval>=0 ){
		*resp = s_rec.s_select;
	}
	fomca1( NO_SELECT, 19, 0 );

	return(retval);
}

Confirm()	/* returns 1 for yes, 0 for no, -1 for error */
{		/* Clears the profom screen when user's response is 'Y' */
	int	field;
	char	valans[3];

#ifdef ENGLISH
	if((retval = DisplayMessage("Confirm (Y/N)?"))<0 )
		return(retval);
	strcpy(valans, "YN");
#else
	if((retval = DisplayMessage("Confirmer (O/N)?"))<0 )
		return(retval);
	strcpy(valans, "ON");
#endif
	if((retval = GetResponse(s_rec.s_resp, valans))<0 ) 
		return(retval);

	field = 400 + (s_rec.s_option * 100);

	if( s_rec.s_resp[0]==YES ){
		fflush(stdout) ;
		fomcs();
		fomrt();
		return(1);
	}
	/* Dehighlight the option which is highlighted in Process() */
	fomca1( field, 9, 5 );

	return( HideMessage() );
}

static
ClearInquiryArea()
{
	short i;

	call_no = 0;	/* Reset the call_no */
	for( i=0; i<MAXQUERYLINES; i++ )/* so that next time fields can be */
		line[i] = 0;	/* repositioned for next routine calls */
	if(FillOutputDetails(HIGH)<0 )
		return(-1);
	if(FillCategNbr(HIGH,HIGH)<0)
		return(-1);
	if(FillTenderNbr(HIGH,HIGH)<0)
		return(-1);
	if(FillItemGroup(HIGH,HIGH)<0)
		return(-1);
	if(FillDelivery(HIGH)<0)
		return(-1);
	if(FillItemNo(HIGH,HIGH)<0)
		return(-1);
	if(FillSuppcd(HIGH,HIGH)<0)
		return(-1);
	if(FillRptonQty(HIGH)<0)
		return(-1);
	if(FillRptonCategory(HIGH)<0)
		return(-1);
	if(FillRptonItemGrp(HIGH)<0)
		return(-1);
	if(FillCatalogue(HIGH,HIGH)<0)
		return(-1);
	if(FillYendCalc(HIGH)<0)
		return(-1);
	if(FillPrntLabels(HIGH)<0)
		return(-1);
	if(FillNoUp(HIGH)<0)
		return(-1);
	if(FillAwardUnaward(HIGH)<0)
		return(-1);
	if(FillYear(HIGH)<0)
		return(-1);
	if(FillSelect(HIGH)<0)
		return(-1);
	if(FillMsgRespFields(HIGH)<0 )
		return(-1);
	return(WriteFields(1,0));
}
static
ReadOption()
{
	s_rec.s_option = LV_SHORT;
	return( ReadFields( 2400, 2400 ) );
	
}
static
ReadFields(start,end)	/* read fields whose numbers range from start to end */
int start, end;		/* start and end fields */
{
	int retval;

	sr.nextfld = start;
	sr.endfld = end;
	for( ; ; ){
		fomrd( (char *)&s_rec );
		ret(err_chk(&sr));
		if( sr.retcode==RET_USER_ESC || sr.retcode==RET_VAL_CHK ){
			if( ESC_F ) return(EXIT);
			retval=Validate();
			if( retval<0 || retval==EXIT)	return(retval);
			continue;
		}
		break;
	}
	return(0);
}
static
WriteFields( start,end )/* write fields whose numbers range from start to end */
int start, end;
{
	sr.nextfld = start;
	sr.endfld = end;
	fomwr( (char *)&s_rec );
	ret( err_chk(&sr) );
	return(0);
}
static
Validate()	/* Validate the values entered by the user */
{
	int	retval;

	switch( sr.curfld ){
		case 2400:	/* menu option */
/*** Do not validate here 
			if( s_rec.s_option<0 || s_rec.s_option>=totaloptions ){
#ifdef ENGLISH
				fomer("Invalid option");
#else
				fomer("Option invalide");
#endif
				s_rec.s_option = LV_SHORT;
			}
***/
			break;
		case 2600:	/* output on */
			if( s_rec.s_outputon[0]!= DISPLAY &&
			    s_rec.s_outputon[0]!= PRINTER &&
			    s_rec.s_outputon[0]!= FILE_IO   ){
#ifdef ENGLISH
				fomer("D(isplay), P(rinter), F(ile)");
#else
				fomer("A(fficher), I(mprimante), D(ossier)");
#endif
				s_rec.s_outputon[0] = LV_CHAR;
			}
			break;
		case 2700:	/* Filename */
			break;
		case 2800:	/* Printer */
			break;
		case 2900:	/* Number of copies */
			if(s_rec.s_nbrcopies == 0) {
#ifdef ENGLISH
				fomer("No. of Copies can't be Zero");
#else
				fomer("Nombre de copies ne peut etre zero");
#endif
				s_rec.s_nbrcopies = LV_SHORT;
			}
			break;
		case CATEGNO1:	/* start Category number */
			break;
		case CATEGNO2:	/* end Category number */
			if( s_rec.s_categ_no2 < s_rec.s_categ_no1 ){
#ifdef ENGLISH
				fomer("Ending Category no. can't be less than starting Category no.");
#else
				fomer("Numero de categorie finissant ne peut etre moins que le numero de categorie debutant.");
#endif
				s_rec.s_categ_no2 = LV_LONG;
			}
			break;
		case ITEMGRP1:	/* start Item Group */
			break;
		case ITEMGRP2:	/* end Item Group */
			if( s_rec.s_item_grp2 < s_rec.s_item_grp1 ){
#ifdef ENGLISH
				fomer("Ending Item Group. can't be less than starting Item Group.");
#else
				fomer("Groupe d'article finissant ne peut etre moins que le groupe d'article debutant.");
#endif
				s_rec.s_item_grp2 = LV_SHORT;
			}
			break;
		case DELIVER:
			if( s_rec.s_delivery[0] != SCHL_OPT &&
			    s_rec.s_delivery[0] != WAREHOUSE){
#ifdef ENGLISH
				fomer("Valid Options are S or W");
#else
				fomer("Options valables sont C ou P");
#endif
				s_rec.s_delivery[0] = LV_CHAR;
			}
			break;
		case ITEMNO1:	/* start Item No */
			break;
		case ITEMNO2:	/* end Item No */
			if( s_rec.s_item_no2 < s_rec.s_item_no1 ){
#ifdef ENGLISH
				fomer("Ending Item No. can't be less than starting Item No.");
#else
				fomer("Numero d'article finissant ne peut etre moins que le numero d'article debutant.");
#endif
				s_rec.s_item_no2 = LV_LONG;
			}
			break;
		case SUPPCD1:	/* start Supplier Code */
			if(s_rec.s_suppcd1[0] == '\0') {
				sr.curfld+=100;
			}
			Right_Justify_Numeric(s_rec.s_suppcd1,
						sizeof(s_rec.s_suppcd1)-1);
			break;
		case SUPPCD2:	/* end Supplier Code */
			Right_Justify_Numeric(s_rec.s_suppcd2,
						sizeof(s_rec.s_suppcd2)-1);
			if(strcmp(s_rec.s_suppcd2,s_rec.s_suppcd1) < 0){
#ifdef ENGLISH
				fomer("Ending Supplier can't be less than starting Supplier.");
#else
				fomer("Fournisseur finissant ne peut etre avant le fournisseur debutant.");
#endif
				s_rec.s_suppcd2[0] = LV_CHAR;
			}
			break;
		case RPT_QTY:
			if( s_rec.s_rpt_qty[0] != YES &&
			    s_rec.s_rpt_qty[0] != NO){
#ifdef ENGLISH
				fomer("Valid Options are Y or N");
#else
				fomer("Options valables sont O ou N");
#endif
				s_rec.s_rpt_qty[0] = LV_CHAR;
			}
			break;
		case RPT_CATEG:
			if( s_rec.s_rpt_categ[0] != YES &&
			    s_rec.s_rpt_categ[0] != NO){
#ifdef ENGLISH
				fomer("Valid Options are Y or N");
#else
				fomer("Options valables sont O ou N");
#endif
				s_rec.s_rpt_categ[0] = LV_CHAR;
			}
			break;
		case RPT_ITMGRP:
			if( s_rec.s_rpt_itmgrp[0] != YES &&
			    s_rec.s_rpt_itmgrp[0] != NO){
#ifdef ENGLISH
				fomer("Valid Options are Y or N");
#else
				fomer("Options valables sont O ou N");
#endif
				s_rec.s_rpt_itmgrp[0] = LV_CHAR;
			}
			break;
		case CATALOGUE1:	/* start Item No */
			break;
		case CATALOGUE2:	/* end Item No */
			if( s_rec.s_cat_no2 < s_rec.s_cat_no1 ){
#ifdef ENGLISH
				fomer("Ending Catalogue. can't be less than starting Catalogue.");
#else
				fomer("Catalogue finissant ne peut etre moins que le catalogue debutant.");
#endif
				s_rec.s_cat_no2 = LV_LONG;
			}
			break;
		case YEND_CALC:
			if( s_rec.s_yend_calc[0] != YES &&
			    s_rec.s_yend_calc[0] != NO){
#ifdef ENGLISH
				fomer("Valid Options are Y or N");
#else
				fomer("Options valables sont O ou N");
#endif
				s_rec.s_yend_calc[0] = LV_CHAR;
			}
			break;
		case PRNT_LABELS:
			if( s_rec.s_prnt_lab[0] != LABEL &&
			    s_rec.s_prnt_lab[0] != REPORT){
#ifdef ENGLISH
				fomer("Valid Options are L or R");
#else
				fomer("Options valables sont E ou R");
#endif
				s_rec.s_prnt_lab[0] = LV_CHAR;
			}
			break;
		case NO_LABELS:
			if(s_rec.s_no_up < 1 || s_rec.s_no_up > 3) {
#ifdef ENGLISH
				fomer("No Of Labels Across must be between 1 and 3");
#else
				fomer("Nombre d'etiquettes de large doit etre entre 1 et 4");
#endif
				s_rec.s_no_up = LV_SHORT;
			}
			break;
		case AWD_UNAWD:
			if( s_rec.s_awd_unawd[0] != AWARD &&
			    s_rec.s_awd_unawd[0] != UNAWARD){
#ifdef ENGLISH
				fomer("Valid Options are A or U");
#else
				fomer("Options valables sont A ou N");
#endif
				s_rec.s_awd_unawd[0] = LV_CHAR;
			}
			break;
		case YEAR_FLD:
			if( s_rec.s_year[0] != '3' &&
			    s_rec.s_year[0] != '2' &&
			    s_rec.s_year[0] != PREV &&
			    s_rec.s_year[0] != ALL){
#ifdef ENGLISH
				fomer("Valid Options are 3,2,P or A");
#else
				fomer("Options valables sont 3, 2, P, T");
#endif
				s_rec.s_year[0] = LV_CHAR;
			}
			break;
		case NO_SELECT:
			if(s_rec.s_select == 0) {
#ifdef ENGLISH
				fomer("Cannot be Zero");
#else
				fomer("Ne peut etre zero");
#endif
				s_rec.s_select = LV_SHORT;
			}
			break;
	}
	sr.nextfld = sr.curfld;
	return(0);
}
DisplayMessage(mesg)	/* Display the given message in the message field */
char *mesg;
{
	STRCPY( s_rec.s_mesg, mesg );
	return( WriteFields(MESSAGE,MESSAGE) );
	
}
HideMessage()	/* Hide the message field */
{
	if( FillMsgRespFields(HIGH)<0 )	return(-1);
	return( WriteFields(MESSAGE,RESPONSE) );
}
GetResponse( respchar, answers )
char *respchar;
char *answers;
{
	int	retval;
	int	i;

	for(;;){
		s_rec.s_resp[0] = LV_CHAR;
		retval = ReadFields( RESPONSE, RESPONSE );
		if( retval==EXIT && retval<0 )
			break;
		for(i=0;i<(strlen(answers));i++){
			if(s_rec.s_resp[0] == answers[i]){
				respchar[0] = s_rec.s_resp[0];
				return(NOERROR);
			}
		}
#ifdef ENGLISH
		fomer("Invalid option");
#else
		fomer("Option invalide");
#endif
	}
	return( retval );
}
GetOutputon( outputon )
char	*outputon;
{
	int	retval;

#ifdef ENGLISH
	fomer("D(isplay), P(rinter), F(ile)");
#else
	fomer("A(fficher), I(mprimante), D(ossier)");
#endif
	STRCPY( s_rec.s_outputon, outputon );
	fomca1( 2600, 19, 2 );
	sr.nextfld = 2600;
	sr.endfld = 2600;
	fomud( (char *)&s_rec);
	s_rec.s_outputon[0] = LV_CHAR;
	retval = ReadFields(2600,2600);
	if( retval!=EXIT && retval>=0 )
		*outputon = s_rec.s_outputon[0];
	fomca1( 2600, 19, 0 );
	return( retval );
}
GetFilename( filename )
char	*filename;
{
	int	retval;

	STRCPY( s_rec.s_filename, filename );
	fomca1( 2700, 19, 2 );
	sr.nextfld = 2700;
	sr.endfld = 2700;
	fomud( (char *)&s_rec);
	s_rec.s_filename[0] = LV_CHAR;
	retval = ReadFields(2700,2700);
	if( retval!=EXIT && retval>=0 )
		strcpy( filename , s_rec.s_filename ) ;
	fomca1( 2700, 19, 0 );
	return( retval );
}
GetPrinter( printer )
short	*printer;
{
	int	retval;

	s_rec.s_printer = *printer ;
	fomca1( 2800, 19, 2 );
	sr.nextfld = 2800;
	sr.endfld = 2800;
	fomud( (char *)&s_rec);
	s_rec.s_printer = LV_SHORT;
	retval = ReadFields(2800,2800);
	if( retval!=EXIT && retval>=0 )
		*printer = s_rec.s_printer;
	fomca1( 2800, 19, 0 );
	return( retval );
}

GetNbrCopies( copies )
short	*copies;
{
	int	retval;

	s_rec.s_nbrcopies = *copies ;
	fomca1( 2900, 19, 2 );
	sr.nextfld = 2900;
	sr.endfld = 2900;
	fomud( (char *)&s_rec);
	s_rec.s_nbrcopies = LV_SHORT;
	retval = ReadFields(2900,2900);
	if( retval!=EXIT && retval>=0)
		*copies = s_rec.s_nbrcopies;
	fomca1( 2900, 19, 0 );
	return( retval );
}

