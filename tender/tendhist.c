/*-----------------------------------------------------------------------
Source Name: tendhist.c
System     : Tendering.
Created  On: 1th May 92.
Created  By: Jonathan Prescott.

DESCRIPTION:
	Program to View Tendering History.

MODIFICATIONS:        

Programmer	YY/MM/DD	Description of modification
S.Whittaker	93/05/28	Updated the rite_audit function to include
				passing the screen structure.

------------------------------------------------------------------------*/
#define	MAIN		/* Main program. This is to declare Switches */
#define MAINFL		TENDHIST		/* main file used */

#define	SYSTEM		"TENDERING"	/* Sub System Name */
#define	MOD_DATE	"1-MAY-92"		/* Progran Last Modified */

#include <stdio.h>
#include <cfomstrc.h>
#include <bfs_defs.h>
#include <bfs_recs.h>

#define	DELTA_AMT  0.005	/* To Check double values for zero */
#define	DELTA_QTY  0.00005	/* To Check double values for zero */

/* User Interface define constants */
#ifdef ENGLISH
#define DELETE		'D'
#define INQUIRE		'I'
#define EXITOPT		'E'
#define	NEXT		'N'
#define	PREV		'P'

#define	YES		'Y'
#define NO		'N'
#define	CANCEL		'C'

#else
#define DELETE		'E'
#define INQUIRE		'I'
#define EXITOPT		'F'
#define	NEXT		'S'
#define	PREV		'P'

#define	YES		'O'
#define NO		'N'
#define	CANCEL		'A'

#endif

/* PROFOM Releted declarations */

#define	SCR_NAME	"tendhist"	/* PROFOM screen Name */

/* PROFOM Screen STH file */

/* Field PROFOM numbers */

/* HDR Fields */
#define	FN_FLD		400	/* Fn: */
#define	KEY_START	500	/* PO Number */
#define	KEY_END		500	/* PO Number */
#define	CHG_FLD		600	/* Field: */
#define ST_FLD		800	/* First Field of Screen */
#define END_FLD		2700	/* Resp Field */

#define MESG_FLD	2600	/* Message Field */
#define RESP_FLD	2700	/* Response Field */

#define NO_ITEMS	3

/* tendhist.sth - header for C structure generated by PROFOM EDITOR */

typedef struct  {
	char	s_dummy[2];	/* STRING X Field 800 */
	char	s_supplier[11];	/* STRING X(10) Field 900 */
	double	s_unit_price;	/* NUMERIC 9999.9999 Field 1000 */
	double	s_qty;		/* NUMERIC 9999.9999 Field 1100 */
	double	s_min_dollar;	/* NUMERIC 9999.99 Field 1200 */
	long	s_date;		/* NUMERIC 9999/99/99 Field 1400 */
} S_Years;

typedef struct	{

	char	s_pgm[11];	/* STRING XXXXXXXXXX Field 100 */
	long	s_rundate;	/* DATE YYYYFMMFDD Field 300 */
	char	s_fn[2];	/* STRING X Field 400 */
	long	s_cat_num;	/* NUMERIC 999999 Field 500 */

	S_Years s_years[NO_ITEMS]; /* Fields 800 to 2500 */

	char	s_mesg[78];	/* STRING X[77] Field 2600 */
	char	s_resp[2];	/* STRING X Field 2700 */
} s_struct;


static	s_struct  s_sth, image;	/* PROFOM Screen Structure */
static	struct  stat_rec  sr;	/* PROFOM status rec */

static	Pa_rec		pa_rec ;	/* Parameters Record */
static	Tend_Hist	tend_hist, pre_hist;	/* Tender History Record */

static	char 	e_mesg[100];  		/* dbh will return err msg in this */

int	Validation();
int	WindowHelp();
int	Argc;
char	**Argv;

main(argc,argv)
int argc;
char *argv[];
{
	int 	retval;

	/* These two are passed to execute() when it is called */
	Argc = argc;
	Argv = argv;

	retval = Initialize(argc,argv);	/* Initialization routine */

	if (retval == NOERROR) retval = Process();

	CloseRtn();			/* return to menu */
	if (retval != NOERROR) exit(-1);

	exit(0);
}

/*-------------------------------------------------------------------*/
/* Initialize PROFOM */

Initialize(argc, argv)
int	argc ;
char	*argv[] ;
{
	int	err ;

	/*
	*	Initialize DBH Environment
	*/
	strncpy(SYS_NAME,SYSTEM,50);	/* Sub system name */
	strncpy(CHNG_DATE,MOD_DATE,10);	/* Modification Date */

	proc_switch(argc, argv, MAINFL) ; 	/* Process Switches */

	/*
	*	Initialize PROFOM & Screen
	*/
	STRCPY(sr.termnm,terminal);	/* Copy Terminal Name */
	fomin(&sr);
	ret(err_chk(&sr)) ;		/* Check for PROFOM Error */
	fomcf(1,1);			/* Enable Snap screen option */

	err = InitScreen() ;		/* Initialize Screen */
	if(NOERROR != err) return(err) ;

	/*
	*	Get The Parameter Record
	*/
	err = get_param(&pa_rec, BROWSE, 1, e_mesg) ;
	if(err == ERROR) {
		DispError((char *)&s_sth,e_mesg);
		return(ERROR) ;
	}
	else if(err == UNDEF) {
#ifdef ENGLISH
		DispError((char *)&s_sth,"Parameters Are Not Set Up ...");
#else
		DispError((char *)&s_sth,"Parametres ne sont pas etablis... ");
#endif
		return(ERROR) ;
	}
	if(pa_rec.pa_tendering[0] != YES) {
#ifdef ENGLISH
	     DispError((char *)&s_sth,"Tendering System Absent.  See Parameter Maintenance.");
#else
	     DispError((char *)&s_sth,"Systeme Soumission absent. Voir l'entretien des parametres.");
#endif
	     return(ERROR);
	}
	return(NOERROR) ;
}	/* Initialize() */

/*--------------------------------------------------------------------------*/
/* Close nessary files and environment before exiting program               */

CloseRtn() 
{
	/* Set terminal back to normal mode from PROFOM */
	fomcs();
	fomrt();

	close_dbh();	/* Close files */

	return(NOERROR);
}	/* CloseRtn() */
/*----------------------------------------------------------------*/
/* Initialize screen before going to process options */

InitScreen()
{
	int	err ;

	/* move screen name to Profom status structure */
	STRCPY(sr.scrnam,NFM_PATH);
	strcat(sr.scrnam,SCR_NAME) ;

	STRCPY(s_sth.s_pgm,PROG_NAME);

	s_sth.s_rundate = get_date();	/* get Today's Date in YYYYMMDD format*/
	s_sth.s_mesg[0] = HV_CHAR ;
	s_sth.s_resp[0] = HV_CHAR ;

	/* Initialize Key Fields. So that, if user selectes 'N' option
	   immediately after invoking program, then he gets the first
	   record in the file */

	s_sth.s_cat_num = 0 ;

	/* Move High Values to data fields and Display the screen */
	err = ClearScreen() ;
	if(NOERROR != err) return(err) ;

	return(NOERROR) ;
}	/* InitScreen() */

/*-------------------------------------------------------------------*/
/* Get Option from user and call corresponding function */

Process()
{
	int err;

	for( ; ; ){

		/* Get the Fn: option from the user */
		if((err = ReadFunction()) != NOERROR) return(err) ;

		err = ProcFunction() ;	/* Process Function */

		if(QUIT == err)		return(NOERROR) ;    /* Exit */
		if(NOACCESS == err)	fomen(e_mesg);	     /* security */
		if(PROFOM_ERR == err)	return(PROFOM_ERR);  /* PROFOM ERROR */
		if(DBH_ERR == err) {
			DispError((char *)&s_sth,e_mesg);
#ifdef ENGLISH
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"System Error... Iserror:",
				iserror, dberror, errno);
#else
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"Erreur du systeme... Iserror:",
				iserror, dberror, errno);
#endif
			DispError((char *)&s_sth,e_mesg);
			return(DBH_ERR); /* DBH ERROR */
		}
	}      /*   end of the for( ; ; )       */
}	/* Process() */
/*----------------------------------------------------------------*/
/* Display the Function (Fn:) options and get the option from the user */

ReadFunction()
{
	/* Display Fn: options */
#ifdef ENGLISH
	fomer("D(elete), I(nquire), N(ext), P(rev), E(xit)");
#else
	fomer("E(liminer), I(nterroger), S(uivant), P(recedent), F(in)");
#endif
	/* Read Fn: field to get the option */
	sr.nextfld = FN_FLD ;
	fomrf( (char *)&s_sth );
	ret(err_chk(&sr));	/* Check for PROFOM error */

	return(NOERROR) ;
}	/* ReadFunction() */
/*----------------------------------------------------------------*/
/* Process the user selected Fn: option */

ProcFunction()
{
	int retval;

	switch (s_sth.s_fn[0]) {
	case DELETE :
		CHKACC(retval,UPDATE,e_mesg);
		return( DeleteRec() ) ;
	case INQUIRE  :			/* Inquire Req */
		CHKACC(retval,BROWSE,e_mesg);
		return( InquireRec() ) ;
	case NEXT  :			/* Next Req */
		CHKACC(retval,BROWSE,e_mesg);
		return( NextRec(FORWARD) ) ;
	case PREV  :			/* Previous Req */
		CHKACC(retval,BROWSE,e_mesg);
		return( NextRec(BACKWARD) ) ;
	case EXITOPT  :			/* Exit */
		return( QUIT ) ;
	}  /*   end of the switch statement */

	return(retval);
}	/* ProcFunction() */
/*-----------------------------------------------------------------------*/
/* Delete the Records */

DeleteRec()
{
	int	err ;

	err = SelectRec(UPDATE) ;
	if(NOERROR != err) return(err) ;

	for( ; ; ) {
		err = Confirm() ;
		if(err != YES) {
			roll_back(e_mesg);
			return(err) ;
		}

		err = WriteRecords(P_DEL) ;
		if(err==NOERROR) break;
		if(err==LOCKED) {
			roll_back(e_mesg) ;
			continue;
		}
		if (err < 0) {
			roll_back(e_mesg);
			return(err) ;
		}
	}

	return(NOERROR) ;
}	/* DeleteRec() */
/*-----------------------------------------------------------------------*/
/* Show the user given keys Rec */

InquireRec()
{
	int	err ;

	err = SelectRec(BROWSE) ;
	if(NOERROR != err) return(err) ;

	err = Confirm() ;
	if(err < 0) return(err) ;

	return(NOERROR) ;
}	/* InquireRec() */
/*----------------------------------------------------------*/
/* Show the next or previous Req */

NextRec(direction)
int	direction ;
{
	int err;

	/* Check whether file is in seq. read mode */
	if(flg_start(TENDHIST) != direction) {
		tend_hist.th_cat_num = s_sth.s_cat_num ;
		if (direction == FORWARD)
			tend_hist.th_cat_num++;
		else	tend_hist.th_cat_num--;
		flg_reset(TENDHIST);
	}

	err = get_n_tendhist(&tend_hist, BROWSE, 0, direction, e_mesg);
#ifndef ORACLE
	seq_over(TENDHIST);
#endif
	if(ERROR == err)return(DBH_ERR) ;
	if(EFL == err) {
#ifdef	ENGLISH
		fomen("No More Records....");
#else
		fomen("Plus de fiches....");
#endif
		get();
		flg_reset(TENDHIST);
		return(NOERROR) ;
	}

	return( ShowRec() ) ;
}	/* NextReq() */
/*----------------------------------------------------------*/
/* Get the Req key and show the Req */

SelectRec(md)
int	md ;	/* UPDATE or BROWSE. UPDATE locks the Req */
{
	int	err ;

	for(; ;){
		err = ReadKey();
		if(err != NOERROR) return(err) ;

		tend_hist.th_cat_num = s_sth.s_cat_num;
		err = get_tendhist(&tend_hist,md,0,e_mesg);
		if(ERROR == err) return(DBH_ERR) ;
		if(err < 0) {		/* UNDEF or LOCKED */
			fomer(e_mesg) ;
			get() ;
			continue ;
		}
		else 	break;
	}
	return(ShowRec());
}	/* SelectRec() */
/*----------------------------------------------------------------------*/
/* Get the Req key from user. In ADD mode disable dup buffers, other
   modes enable dup buffers and show the current key as a default key */

ReadKey()
{
	int	i;
	long	cat_num;

	/* In Add mode turn off dup control for key fields.
	   Other modes reverse it */
	SetDupBuffers(KEY_START,KEY_END,2);

	/* Store fields to copy back when user gives ESC-F */
	cat_num = s_sth.s_cat_num ;

	s_sth.s_cat_num = LV_LONG ;

#ifdef ENGLISH
	STRCPY(s_sth.s_mesg,"Press ESC-F to Go Back to Fn:");
#else
	STRCPY(s_sth.s_mesg,"Appuyer sur ESC-F pour retourner a Fn:");
#endif
	DispMesgFld((char *)&s_sth);

	i = ReadFields((char *)&s_sth,KEY_START,KEY_END,
		Validation,WindowHelp,1) ;
	if(PROFOM_ERR == i || DBH_ERR == i) return(i) ;
	if(RET_USER_ESC == i){
		/* copy back key fields */
		s_sth.s_cat_num = cat_num ;

		ret( WriteFields((char *)&s_sth,KEY_START, KEY_END) ) ;

		s_sth.s_mesg[0] = HV_CHAR;
		DispMesgFld((char *)&s_sth);

		return(RET_USER_ESC) ;
	}

	return(NOERROR);
}	/*  ReadKey() */
/*-----------------------------------------------------------------------*/ 
/* Update the records and write to files */

WriteRecords(mode)
int mode;
{
	int	err;

	scpy((char *)&pre_hist,(char *)&tend_hist,sizeof(tend_hist));
	
	err = put_tendhist(&tend_hist,mode,e_mesg);
	if(err < 0) {
		DispError((char *)&s_sth,e_mesg);
		return(err);
	}

	err = rite_audit((char*)&s_sth,TENDHIST,mode,(char*)&tend_hist,
		(char*)&pre_hist,e_mesg);
	if(err==LOCKED) {
		return(LOCKED) ;
	}
	if(err != NOERROR ){
#ifdef	ENGLISH
		DispError((char *)&s_sth,"ERROR in Saving Records"); 
#else
		DispError((char *)&s_sth,"ERREUR en conservant les fiches");
#endif
		return(err);
	}

	err = commit(e_mesg) ;
	if(err < 0) {
#ifdef ENGLISH
		DispError((char *)&s_sth,"ERROR in Saving Records"); 
#else
		DispError((char *)&s_sth,"ERREUR en conservant les fiches");
#endif
		DispError((char *)&s_sth,e_mesg);
		return(err);
	}

	return(NOERROR);
}	/* WriteRecords() */
/*----------------------------------------------------------------*/
/* Set Duplication buffers for fields 				  */
SetDupBuffers( firstfld, lastfld, value )
int	firstfld, lastfld;	/* field numbers range */
int	value;			/* ENABLE or DISABLE */
{
	int i ;

	for( i=firstfld; i<=lastfld; i+=100 )
		fomca1( i, 19, value);
	if( value==0 )
		return(0);
	sr.nextfld = firstfld;
	sr.endfld = lastfld;
	fomud( (char *)&s_sth );
	ret( err_chk(&sr) );

	return( 0 );
}
/*----------------------------------------------------------------*/
/* Validation function() for Key and Header fields when PROFOM returns
  RET_VAL_CHK */

Validation()
{
	int	err, save_nextfld, save_endfld ;

	switch(sr.curfld){
	case	KEY_START	:	/* req number */
		tend_hist.th_cat_num = s_sth.s_cat_num;
		err = get_tendhist(&tend_hist,BROWSE,0,e_mesg);
		if(err < 0 && err != UNDEF ) {
			DispError((char *)&s_sth,e_mesg);
			return(ERROR);
		}
		if(err == UNDEF) {
#ifdef ENGLISH
			fomer("No History For This Catalogue Number - Please Re-Enter");
#else
			fomer("Aucune historique pour ce numero de catalogue - S.V.P. reessayer.");
#endif
			s_sth.s_cat_num = LV_LONG;
			return(ERROR);
		}
		break ;
	default :
#ifdef ENGLISH
		sprintf(e_mesg,"No Validity Check For Field#  %d",sr.curfld);
#else
		sprintf(e_mesg,"Pas de controle de validite pour le Champ#  %d",sr.curfld);
#endif
		fomen(e_mesg);
		get();
		return(ERROR) ;
	}	/* Switch sr.curfld */

	return(NOERROR) ;
}	/* Validation() */
/*----------------------------------------------------------------*/
/* Show Help Windows, if applicable, when user gives ESC-H in key
   and header fields */

WindowHelp()
{
	int	err ;

	switch(sr.curfld){
	case	KEY_START	:	/* Catalogue Number: */
		break ;
	default :
#ifdef ENGLISH
		fomer("No Help Window For This Field");
#else
		fomer("Pas de fenetre d'assistance pour ce champ");
#endif
	}	/* Switch sr.curfld */

	return(NOERROR) ;
}	/* WindowHelp() */
/*-----------------------------------------------------------------------*/
/* Take the confirmation from user for the header part */

Confirm()
{
	int	err ;

	/* Options:
	   Add, Change     - YEC
	   Inquire, Delete - YC
	*/

	for( ; ; ) {
#ifdef ENGLISH
		err = GetOption((char *)&s_sth,"Y(es), C(ancel)","YC");
#else
		err = GetOption((char *)&s_sth,"O(ui), A(nnuler)","OA");
#endif
		if(err == PROFOM_ERR) return(err) ;

		switch(err) {
		case  YES :
			return(YES) ;
		case  CANCEL :
#ifdef ENGLISH
			err = GetOption((char *)&s_sth,
					"Confirm the Cancel (Y/N)?", "YN") ;
#else
			err = GetOption((char *)&s_sth,
					"Confirmer l'annulation (O/N)?", "ON") ;
#endif
			if(err == YES) return(CANCEL) ;
			break ;
		}	/* switch err */

		if(err == PROFOM_ERR) return(err) ;
		if(err == DBH_ERR) return(err) ;
	}	/* for(; ; ) */
}	/* Confirm() */
/*-----------------------------------------------------------------------*/
/* Show Catalogue information on Screen */
ShowRec()
{
	int	i;

	s_sth.s_cat_num = tend_hist.th_cat_num;

	for(i=0;i<NO_ITEMS;i++) {
		s_sth.s_years[i].s_dummy[0] = ' ';
		strcpy(s_sth.s_years[i].s_supplier,tend_hist.th_supp[i]);
		s_sth.s_years[i].s_unit_price = tend_hist.th_price[i];
		s_sth.s_years[i].s_qty	= tend_hist.th_qty[i];
		s_sth.s_years[i].s_min_dollar = tend_hist.th_min_dollar[i];
		s_sth.s_years[i].s_date = tend_hist.th_date[i];
	}

	ret( WriteFields((char *)&s_sth, KEY_START, END_FLD-200) ) ;
}	/* ShowRec() */
/*------------------------------------------------------------------------*/
/* Move High values to all data fields and clear the screen */

ClearScreen()
{
	int	i;

	/* Move High Values Screen */
	for(i=0;i<NO_ITEMS;i++) {
		InitScr(i,HV_CHAR, HV_LONG, HV_DOUBLE) ;
	}

	ret( WriteFields((char *)&s_sth,ST_FLD, END_FLD) );

	return(NOERROR);
}	/* ClearScreen() */
/*-------------------------------------------------------------------------*/
/* Initialize Screen Header with either Low or High Values */

InitScr(item_no,t_char, t_long, t_double )
int	item_no;
char	t_char ;
long	t_long ;
double	t_double ;
{
	s_sth.s_years[item_no].s_dummy[0] = t_char;
	s_sth.s_years[item_no].s_supplier[0] = t_char;
	s_sth.s_years[item_no].s_unit_price = t_double;
	s_sth.s_years[item_no].s_qty	= t_double;
	s_sth.s_years[item_no].s_min_dollar = t_double;
	s_sth.s_years[item_no].s_date = t_long;
	
	return(NOERROR) ;
}	/* InitScr() */
/*-------------------- E n d   O f   P r o g r a m ---------------------*/
