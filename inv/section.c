/******************************************************************************
		Sourcename    : section.c
		System        : Budgetary Financial system.
		Module        : Inventory system
		Sub-Module    : Stock section Maintenance
		Created on    : 89-09-11
		Created  By   : K HARISH.
		Cobol sources : 

HISTORY:
 Date           Programmer     Description of modification
____/__/__      __________     ___________________________
1991/01/10	F.Tao	       changed main process for proper exit.
About the program:

	This program allows the user to classify the stock into different
	sections, the number of which may not exceed 15. The data is stored
	in a fixed length stock section file.
		The stock sections are numbered 1 to 15 (max.). The user can
	add new sections by using Add option and entering the names of the
	sections, or change the existing section names by using Change option. 
	Deletion of the sections is not allowed.
		This program is to be executed first when inventory database
	is being built, as the stock master maintenance program will refer to
	stock section file, when master records are added.
	
******************************************************************************/
#include <stdio.h>

#define MAIN
#define MAINFL	SECTION

#include <bfs_defs.h>
#include <bfs_recs.h>
#include <cfomstrc.h>

#define SYSTEM		"INVENTORY"
#define MOD_DATE	"23-JAN-90"
#define SCREEN_NAME	"section"
#define LOW 		-1
#define HIGH 		 1
#define ESCAPE		12
#define TOT_ST_SECT	15	/* max. number of stock sections */
#define ADD_MODE	16
#define INQ_MODE	17
#define RANDOM  	18
#define SEQUENTIAL	19
#define DELTA_AMT	0.0001
#define HL_CHAR(VAL)	(VAL==HIGH) ? HV_CHAR : LV_CHAR
#define ESC_F		sr.retcode==RET_USER_ESC && \
			(sr.escchar[0]=='F'||sr.escchar[0]=='f')

#ifdef ENGLISH
#define ADDREC		'A'
#define CHANGE		'C'
#define EXITOPT		'E'

#define EDIT		'E'
#define CANCEL		'C'
#define YES		'Y'
#define NO		'N'
#else
#define ADDREC		'R'
#define CHANGE		'C'
#define EXITOPT		'F'

#define EDIT		'M'
#define CANCEL		'A'
#define YES		'O'
#define NO		'N'
#endif

/* section.sth - header for C structure generated by PROFOM EDITOR */

struct	se_struct	{
	char	s_progname[11];		/* 100 program name */
	long	s_rundt;		/* 300 system date */
	char	s_fn[2];		/* 400 function/option */
	short	s_field;		/* 500 field# used for editing */
	char	s_hdg[2];		/* 700 heading for section names */
	char	s_name[15][36];		/* 800 to 2200 section names */
	char	s_mesg[78];		/* 2300 message field */
	char	s_resp[2];		/* 2400 user's response */
};

St_sect	section;		/* Section file record */
struct se_struct	s_rec;		/* screen record */
struct stat_rec 	sr;		/* profom status record */
Pa_rec	pa_rec;			/* parameter file record */

int	mode;	/* used to write the section record */
int retval;	/* Global variable to store function values */
char e_mesg[80]; /* to store error messages */

/* Initialize profom fields, call entry procedures */
main( argc, argv )
int argc;
char *argv[];
{
	strncpy( SYS_NAME, SYSTEM, 50 ); /* Module name */
	strncpy( CHNG_DATE, MOD_DATE, 10 );/* Last date of change */
	proc_switch( argc,argv,MAINFL );	/* process the switches */

	if( Initialize()<0 )
		exit(-1);

	if( get_param(&pa_rec,BROWSE,1,e_mesg)<1 ){
		fomen(e_mesg);
		get();
		exit(-1);
	}
	if( pa_rec.pa_stores[0]!=YES ){
#ifdef ENGLISH
		fomen("Inventory system absent. See Parameter Maintenance");
#else
		fomen("Systeme inventaire absent. Voir l'entretien des parametres");
#endif
		get();
		exit(0);
	}
	retval = Process();

	CleanExit();
}
CleanExit()
{
	/* clear and exit the screen , close files & exit program */
	fomcs();
	fomrt();
	roll_back(e_mesg); /* needed to clear locked records */
	close_dbh();
	exit(retval);
}
Initialize()
{
	/* initialize the fields and the profom screen */
	if( InitProfom()<0 ){
		fomcs();
		fomrt();
		return(-1);
	}
	if( InitScreen()<0 )
		CleanExit();
	return(0);
}
/* initialize the profom */
InitProfom()
{
	/* initialize the profom screen variables */
	STRCPY( sr.scrnam, NFM_PATH );
	strcat( sr.scrnam, SCREEN_NAME );
	STRCPY( sr.termnm, terminal );

	fomin( &sr );		/* initialize profom */
	ret( err_chk(&sr) );	/* if profom error return */
	fomcf(1,1);		/* Enable snap-screen option */
	return(0);
}
/* Initialize the screen */
InitScreen()
{
	STRCPY( s_rec.s_progname, PROG_NAME );
	s_rec.s_rundt = get_date();
	s_rec.s_field = HV_SHORT;
	if( FillItemFlds()<0 ) return(-1);
	s_rec.s_mesg[0] = HV_CHAR;
	s_rec.s_resp[0] = HV_CHAR;
	if( WriteFields(1,0)<0 )	return(-1);

	return(0);
}
/*
 	Check if the section file has already some entries 
	if so, display the section names already entered
	move high values into the remaining fields
*/
	
FillItemFlds()
{
	short	i;

	s_rec.s_hdg[0] = ' ';	/* Space character to hide mask */

	/* Check if section file has already some entries */
	retval = get_section( &section, UPDATE, 1, e_mesg );
	switch( retval ){
		case LOCKED:	/* file locked by some other user */
		case ERROR:
			fomen(e_mesg);
			get();
			return(-1);
		case UNDEF:	/* section file record does not exist */
			mode = ADD;	/* file will be saved in this mode */
			section.no_of_sections = 0;
			for( i=0; i<TOT_ST_SECT; i++ )
				s_rec.s_name[i][0] = HV_CHAR;
			break;
		default:	/* no error */
			mode = UPDATE;	/* file will be saved in this mode */

			/* copy existing section names into the screen file */
			for( i=0; i<section.no_of_sections; i++ )
				STRCPY( s_rec.s_name[i], section.name[i] );

			/* move high values into the remaining of 15 */
			for( ; i<TOT_ST_SECT; i++ )
				s_rec.s_name[i][0] = HV_CHAR;
			break;
	}
	return(0);
}
/* Accept user's option and call the corresponding routine in a loop */
Process()
{
	for( ; ; ){
		/* Added by F.Tao, Consulted by P.Ralph, 01/11/91 */
		if( FillItemFlds()<0 ) return(-1);
		/* Read user's option */
		if( ReadFunction()<0 ) return(-1);

		switch( s_rec.s_fn[0] ){
			case ADDREC:	/* Add section names and exit */
				CHKACC(retval,ADD,e_mesg);
			/*	return( AddSections() );	*/
	/* changed by F.Tao, 01/10/90	*/
				retval = AddSections();
				break;
	/*		if( AddSections() < 0) return(-1);        */
			case CHANGE:	/* Change section names and exit */
				CHKACC(retval,UPDATE,e_mesg);
			/*	return( ChangeFields() );	*/
		/*	if ( ChangeFields()  < 0 ) return(-1);  */
	/* changed by F.Tao, 01/10/90	*/
				retval = ChangeFields();
				break;
			case EXITOPT:	/* exit */
				return(0);
			default:
				break;
		}
		if( retval<0 ){
			fomen(e_mesg);
			get();
			return(retval);
		}
		if( retval==DBH_ERR )
			return(retval);
	}
}
ReadFunction()	/* Display options at the bottom and read entry */
{
#ifdef ENGLISH
	fomer("A(dd), C(hange), E(xit)");
#else
	fomer("R(ajouter), C(hanger), F(in)");
#endif
	sr.nextfld = 400;	/* Fn field number */
	fomrf( (char *)&s_rec );
	ret( err_chk(&sr) );
	return(0);
}
DisplayMessage(mesg)	/* Display the given message in the message field */
char *mesg;
{
	STRCPY( s_rec.s_mesg, mesg );
	if( WriteFields(2300,2300)<0 )	return(-1);
	return(0);
}
HideMessage()	/* Hide the message & response fields */
{
	s_rec.s_mesg[0] = HV_CHAR;
	s_rec.s_resp[0] = HV_CHAR;
	if( WriteFields(2300,2400)<0 ) return(-1);
	return(0);
}
/* Add section names */
AddSections()
{
	int	fld_no;		/* to store the profom field# */

    for( ; ; ){
	/*	Calculate the profom field# for the next entry */
	fld_no=section.no_of_sections*100 + 800;

	/* allow addition if the max. limit on no-of-sections isn't exceeded */
	if( section.no_of_sections<TOT_ST_SECT ){
		s_rec.s_name[section.no_of_sections][0] = LV_CHAR;
		retval = ReadFields( fld_no, fld_no );
		if( retval<0 )
			return(-1);
		else if( retval==ESCAPE ){	/* user aborted entry */
			s_rec.s_name[section.no_of_sections][0] = HV_CHAR;
			if( WriteFields( fld_no, fld_no )<0 )
				return(-1);
			break;
		}
		else{			/* valid entry is made */
			STRCPY(section.name[section.no_of_sections],
				s_rec.s_name[section.no_of_sections] );
			section.no_of_sections++;
		}
	}
	else{		/* max. limit is reached or exceeded */
#ifdef ENGLISH 
		fomen("Can't add any more sections. Press any key");
#else
		fomen("Ne peut pas ajouter d'autres sections. Appuyer sur une touche");
#endif
		get();
		break;
	}
    }
   return( ChangeFields() );   
}

ChangeFields()
{
    for( ; ; ){
#ifdef ENGLISH
	if( DisplayMessage("Y(es), E(dit), C(ancel)")<0 )
#else
	if( DisplayMessage("M(odifier champs), A(nnuler), O(ui)")<0 )
#endif
		return(-1);
	sr.nextfld = 2400;
	fomrf( (char *)&s_rec );
	ret( err_chk(&sr) );
	switch( s_rec.s_resp[0] ){
		case EDIT:
			if( EditSection()<0 )
				return(-1);
			break;
		case CANCEL:
#ifdef ENGLISH
			if( DisplayMessage("Confirm the Cancel (Y/N)?")<0 )
#else
			if( DisplayMessage("Confirmer l'annulation (O/N)?")<0 )
#endif
				return(-1);
			for( ; ; ){
				sr.nextfld = 2400;
				fomrf( (char *)&s_rec );
				ret( err_chk(&sr) );
				if( s_rec.s_resp[0]==YES||s_rec.s_resp[0]==NO)
					break;
			}
			if( s_rec.s_resp[0]==YES ){
				roll_back(e_mesg);
				return(HideMessage());
			}
			else
				break;
		case YES:
			if( WriteRecord()<0 )
				return(-1);
			return(HideMessage());
		default:
			break;
	}
    }
}
/* 	Change existing section name */
EditSection()
{
	int	fld_no;	/* to store profom field# */

	for( ; ; ){
#ifdef	ENGLISH
		STRCPY(s_rec.s_mesg,"Enter RETURN to terminate Edit");
#else
		STRCPY(s_rec.s_mesg,"Appuyer sur RETURN pour terminer l'ajustement");
#endif
		if( WriteFields( 2300, 2300 )<0 ) return(-1) ;

		/* Read the no. of section whose name has to be changed */
		s_rec.s_field = LV_SHORT;
		if( (retval=ReadFields(500,500))<0 || retval==ESCAPE )
			break; 

		/* Calculate the profom field# from the user's entry */
		fld_no = (s_rec.s_field-1)*100 + 800;

		/* for the field to be edited, do the following */
		fomca1( fld_no, 19, 2 );	/* Enable dup buffers */
		fomca1( fld_no, 10, 0 );	/* Disable user escape */
		sr.nextfld = sr.endfld = fld_no;	/* Update dup buf */
		fomud( (char *)&s_rec );

		/*  Read the new name for the section */
		s_rec.s_name[s_rec.s_field-1][0] = LV_CHAR;
		retval = ReadFields( fld_no, fld_no );
		if( retval<0 )
			return(-1);
		else
			STRCPY(section.name[s_rec.s_field-1],
				s_rec.s_name[s_rec.s_field-1] );
		
		/* for the field edited, do the following */
		fomca1( fld_no, 19, 0 );	/* Disable dup buffers */
		fomca1( fld_no, 10, 1 );	/* Enable user escape */
	}
	s_rec.s_field = HV_SHORT;
	if( WriteFields(500,500)<0 )
		return(-1);

	return(0);
}
/* 	Write the section record into the section file */
WriteRecord()
{
	int	i;

	/* Move nulls to unused fields of the section record */
	for( i=section.no_of_sections; i<TOT_ST_SECT; i++ )
			section.name[i][0] = '\0';

	/* Write the record   mode is set in FillItemFields */
	if( put_section(&section,mode,1,e_mesg)<0 ){	
		fomen(e_mesg);	get();
		sprintf(e_mesg,"dberror: %d, iserror: %d, errno:%d",
				dberror, iserror, errno );
		fomen(e_mesg);
		get();
		roll_back(e_mesg);
		return(-1);
	}
	/* Commit the write to database */
	if( commit(e_mesg)<0 ){
		fomen(e_mesg);
		get();
		return(-1);
	}
	return(0);
}
ReadFields(start,end)	/* read fields whose numbers range from start to end */
int start, end;		/* start and end fields */
{
	int retval;

	sr.nextfld = start;
	sr.endfld = end;
	for( ; ; ){
		fomrd( (char *)&s_rec );
		ret(err_chk(&sr));
		if( sr.retcode==RET_USER_ESC || sr.retcode==RET_VAL_CHK ){
			if( ESC_F ) return( ESCAPE );
			retval=Validate();
			if(retval<0 || retval==ESCAPE)
				return(retval);
			else
				continue;
		}
		break;
	}
	return(0);
}
WriteFields( start,end )/* write fields whose numbers range from start to end */
int start, end;
{
	sr.nextfld = start;
	sr.endfld = end;
	fomwr( (char *)&s_rec );
	ret( err_chk(&sr) );
	return(0);
}
/* 	Validate user's entry */
Validate()
{
	switch( sr.curfld ){
		case 500:	/* field# field for editing */
			if( sr.fillcode==FIL_OMITTED )
				return( ESCAPE );
			else if( s_rec.s_field>section.no_of_sections ){
#ifdef ENGLISH
				fomer("Invalid section number");
#else
				fomer("Numero de section invalide"); 
#endif
				s_rec.s_field = LV_SHORT;
			}
			break;
		default:
			break;
	}
	sr.nextfld = sr.curfld;

	return(0);
}
