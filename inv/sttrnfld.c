/******************************************************************************
		Sourcename    : sttran.c
		System        : Budgetary Financial System.
		Subsystem     : Inventory System 
		Module        : Inventory Transactions 
		Created on    : 89-06-13
		Created  By   : K HARISH.
		Cobol sources : 

HISTORY:
 Date           Programmer     Description of modification
____/__/__      __________     ___________________________
1990/11/23	peter ralph	Right Justify numeric supplier code

1990/12/18	M. Cormier	Added Rounding for items defined as doubles
				and which might have calculations on them.
				The Rounding is done before a "put" function.
				The files affected are: stmast, st_tran,
							alloc_rec, gl_rec,
							tr_hdr and tr_item.
1991/01/24	F.Tao		When updating current credit field in GL,
				should put negative amount to it.

1991/02/06	P. Ralph	Default fund to 1
1992/10/27      A.Cormier       Change cost center number from a 2 digits to 
                                a 4 digits
******************************************************************************/
#include <stdio.h>

#define MAIN
#define MAINFL	STTRAN

#include <bfs_defs.h>
#include <bfs_recs.h>
#include <cfomstrc.h>

#define SYSTEM		"INVENTORY"
#define MOD_DATE	"22-JAN-90"
#define SCREEN_NAME	"sttrnfld"
#define LOW 		-1
#define HIGH 		 1
#define ESCAPE		12
#define	DUPENABLE	2
#define	DUPDISABLE	0
#define RANDOM  	18
#define SEQUENTIAL	19
#define PATH_FILE_SIZE	50

#define ALL_POS		0
#define ONE_PO		1

#define MAX_PO		6
#define	DELTA_DIFF	0.001
#define HL_CHAR(VAL)	(VAL==HIGH) ? HV_CHAR : LV_CHAR
#define ESC_F		(sr.retcode==RET_USER_ESC && \
			(sr.escchar[0]=='F'||sr.escchar[0]=='f'))
#define ESC_H		(sr.retcode==RET_USER_ESC && \
			(sr.escchar[0]=='H'||sr.escchar[0]=='h'))
#define NO_HLP_WIN	(sr.curfld!=1000 && sr.curfld!=1100 && sr.curfld!=1400\
			&& sr.curfld!=1600 && sr.curfld!=1700)
#define PRESENT		1
#define ABSENT		0

#define AL	1	/* allocations to cost centres */
#define OR	2	/* orders */
#define RE	3	/* receipts from supplier */
#define RS	4	/* returns to supplier */
#define IS	5	/* issues to cost centre */
#define RT	6	/* returns from cost centres */
#define AD	7	/* positive adjustments, increasing stock on hand */
#define WO	8	/* negative adjustments, decreasing stock on hand */

#ifdef ENGLISH
#define ALLOC	"AL"	/* allocations to cost centres */
#define ORDER	"OR"	/* orders */
#define RECPT	"RE"	/* receipts from supplier */
#define RETSUP	"RS"	/* returns to supplier */
#define ISSUE	"IS"	/* issues to cost centre */
#define RETURN	"RT"	/* returns from cost centres */
#define ADJUST	"AD"	/* positive adjustments, increasing stock on hand */
#define WRTOFF	"WO"	/* negative adjustments, decreasing stock on hand */

#define	ADDREC		'A'
#define NEXT		'N'
#define PREV		'P'
#define INQUIRE		'I'
#define EXITOPT		'E'

#define EDIT		'E'
#define CANCEL		'C'
#define YES		'Y'
#define NO		'N'
#else	/* FRENCH */
#define ALLOC	"AL"	/* allocations to cost centres */
#define ORDER	"CM"	/* orders */
#define RECPT	"RC"	/* receipts from supplier */
#define RETSUP	"RF"	/* returns to supplier */
#define ISSUE	"EM"	/* issues to cost centre */
#define RETURN	"RV"	/* returns from cost centres */
#define ADJUST	"AJ"	/* positive adjustments, increasing stock on hand */
#define WRTOFF	"RD"	/* negative adjustments, decreasing stock on hand */

#define	ADDREC		'R'
#define NEXT		'S'
#define PREV		'P'
#define INQUIRE		'I'
#define EXITOPT		'F'

#define EDIT		'M'
#define CANCEL		'A'
#define YES		'O'
#define NO		'N'
#endif

#define FN_FLD		400
#define TRDATE_FLD	500
#define TYPE_FLD	600
#define SNO_FLD		700 

#define	FUND_FLD	900
#define	FUND2_FLD	950

#define STCK_FLD	1000
#define SUPP_FLD	1100
#define REF_FLD		1200
#define PONO_FLD	1300

#define LOC_FLD		1400
#define PERIOD_FLD 	1500
#define DBACCT_FLD	1600
#define CRACCT_FLD	1700
#define QTY_FLD		1800
#define AMT_FLD		1900
#define REMARK_FLD	2000
#define ITEM_ST		2100
#define ITEM_END	4500

#define MESG_FLD	4600
#define RESP_FLD	4700

/* sttran.sth - header for C structure generated by PROFOM EDITOR */
typedef struct {
	long	s_po;
	double	s_ord_qty;
	double 	s_recv_qty;
	double	s_diff;
} S_Items;

struct	tr_struct	{
	char	s_progname[11];	/* program name 100 STRING */
	long	s_rundt;	/* current date 300 DATE YYYYFMMFDD */
	char	s_fn[2];	/* function/option 400 STRING */
	long	s_trdate;	/* transaction date 500 DATE YYYYFMMFDD */
	char	s_trtype[3];	/* transaction type 600 STRING */
	short	s_trsno;	/* transaction sl. no 700 NUMERIC 999 */
	short	s_fund;		/* fund assoc with stock (Db Acct) 900 */
	short	s_fund2;	/* fund assoc with stock (Cr Acct) 950 */
	char	s_stcode[11];	/* stock item code 1000 STRING */
	char	s_supp_cd[11];	/* supplier code 1100 NUMERIC 99 */
	char	s_ref[13];	/* PO/Invoice reference 1200 STRING */
	long	s_po_no;	/* PO Number 1300 NUMERIC*/	
	short	s_locno;	/* Location number 1400 NUMERIC 999 */
	short	s_period;	/* Period 1500 NUMERIC 99 */
	char	s_dbacc[19];	/* Acct to be debited 1600 STRING */
	char	s_cracc[19];	/* Acct to be credited 1700 STRING */
	double	s_qty;		/* Qty of Xaction 1800 NUMERIC 999999.9999 */
	double	s_amount;	/* Value of Xaction 1900 NUMERIC 99999999.99 */
	char	s_remarks[31];	/* Remarks 2000 STRING */
	char	s_dummy[3];

	S_Items s_items[MAX_PO];

	char	s_mesg[77];	/* Message field 4000 STRING */
	char	s_resp[2];	/* Response field 4100 STRING */
};
struct tr_struct	s_rec;		/* screen record */
St_mast		st_mast;	/* stock master record */
St_tran		st_tran,st_tmp; /* stock transaction record */
Gl_rec 		gl_rec;		/* GL master record */
struct stat_rec 	sr;		/* profom status record */
Pa_rec		pa_rec;		/* parameter file record */
Ctl_rec		ctl_rec;	/* control file record */
Alloc_rec	alloc_rec;	/* allocation file record */
Sch_rec		sch_rec;	/* School/Cost-center record */
Tr_hdr		tr_hdr, tr_tmp;	/* Gl transaction header record */
Tr_item		tr_item;	/* Gl transaction item record */
Supplier	supplier;	/* Supplier record */

int aps_system;		/* Flag to indicate presence of APS system */
int 	mode, 		/* Mode of reading or writing a record */
	tr_opt;		/* Transaction type flag */
double	alloc_qty;	/* Variable used in Issue type Xactions */
int retval;		/* Global variable to store function values */
char e_mesg[80]; 	/* to store error messages */
int	AllocationRecord;	/* Flag to indicate whether allocation
				record is present for an issue */

long	fund1_seq_no;   /* stores the trheader seqno */
char	Crfund_dtf[19], Dbfund_dtf[19];	/* stores duetofrom acct# */

short	Dbacc_sect, Cracc_sect;	/* Buffers to store section of db & cr accts */
short	Dbdue_sect, Crdue_sect;	/* Buffers to store section of db & cr accts 
					for due to and from accounts */

double D_Roundoff();

/* Initialize profom fields, call entry procedures */
main( argc, argv )
int argc;
char *argv[];
{
	strncpy( SYS_NAME, SYSTEM, 50 ); 	/* Module name */
	strncpy( CHNG_DATE, MOD_DATE, 10 );	/* Last date of change */
	proc_switch( argc,argv,MAINFL );	/* process the switches */

	if( Initialize( terminal )<0 )		/* Init profom environment */
		exit( -1) ;
	retval = Process();
	CleanExit();
}
CleanExit()
{
	/* clear and exit the screen , close files & exit program */
	close_dbh();
	fomcs();
	fomrt();
	exit(retval);
	return(0);
}
Initialize(terminal)
char *terminal;
{
	/* initialize the profom screen variables */
	STRCPY( sr.scrnam, NFM_PATH );
	strcat( sr.scrnam, SCREEN_NAME );
	STRCPY( sr.termnm, terminal );

	/* initialize the fields and the profom screen */
	if( InitScrhdg()<0 ) return(-1);
	if( FillKeyFields( HIGH )<0 ) return(-1);
	if(FillFundFlds(HIGH)<0 ) return(-1);
	if(FillAcctFlds(HIGH)<0 ) return(-1);
	if( FillNonkeyFlds( HIGH )<0 ) return(-1);
	if( FillMsgRespFlds( HIGH )<0 ) return(-1);
	if( InitProfom()<0 ){
		fomcs();
		fomrt();
		return(-1);
	}
	return(0);
}
/* initialize profom environment and screen */
InitProfom()
{
	fomin( &sr );		/* initialize the screen */
	ret( err_chk(&sr) );	/* if profom error return */
	if( WriteFields(1,0)<0 )	return(-1);
	fomcf(1,1);		/* enable snap-screen option */
	return(0);
}
/* Fill the screen heading fields, the program name and the date */
InitScrhdg()
{
	STRCPY( s_rec.s_progname, PROG_NAME );
	s_rec.s_rundt = get_date();
	return(0);
}
/* Fill the keyfields with high or low values */
FillKeyFields( value )
short value;
{
	s_rec.s_trdate 		= HV_LONG * value;
	s_rec.s_trtype[0] 	= HL_CHAR(value);
	s_rec.s_trsno 		= HV_SHORT * value;

	return(0);
}
/* Fill the Fund fields with high/low values */
FillFundFlds( value ) 
short	value;
{
	s_rec.s_fund 		= HV_SHORT * value ;
	s_rec.s_fund2		= HV_SHORT * value ;

	return(0);
}
/* Fill the Account fields with high/low values */
FillAcctFlds( value ) 
short	value;
{
	s_rec.s_dbacc[0] 	= HL_CHAR(value);
	s_rec.s_cracc[0] 	= HL_CHAR(value);

	return(0);
}
/* Fill the non key fields with high/low values */
FillNonkeyFlds( value )
short value;
{
	int	i;

	s_rec.s_stcode[0] 	= HL_CHAR(value);
	s_rec.s_supp_cd[0] 	= HL_CHAR(value);
	s_rec.s_ref[0] 		= HL_CHAR(value);
	s_rec.s_po_no		= HV_LONG * value;
	s_rec.s_locno 		= HV_SHORT * value ;
	s_rec.s_period 		= HV_SHORT * value ;
	s_rec.s_qty 		= HV_DOUBLE * value ;
	s_rec.s_amount 		= HV_DOUBLE * value ;
	s_rec.s_remarks[0] 	= HL_CHAR(value);
	if(value == HIGH)  
		s_rec.s_dummy[0] = HV_CHAR;
	else 
		s_rec.s_dummy[0] = ' ';

	if(value == HIGH) {
		for(i=0;i<MAX_PO;i++) {
			s_rec.s_items[i].s_po = HV_LONG ;
			s_rec.s_items[i].s_ord_qty = HV_DOUBLE ;
			s_rec.s_items[i].s_recv_qty = HV_DOUBLE ;
			s_rec.s_items[i].s_diff = HV_DOUBLE ;
		}
	}
	return(0);
}
/* Fill the message and response fields with high or low values */
FillMsgRespFlds( value )
short value;
{
	s_rec.s_mesg[0] = HL_CHAR(value);
	s_rec.s_resp[0] = HL_CHAR(value);

	return(0);
}
DispError()
{
	if(DisplayMessage(e_mesg)<0)
		return(-1);
#ifdef ENGLISH
	fomen("Press any key");
#else
	fomen("Appuyer sur une touche");
#endif
	get();
	sprintf(e_mesg,"iserror: %d, dberror: %d, errno: %d",
			iserror, dberror, errno );
	if(DisplayMessage(e_mesg)<0)
		return(-1);
#ifdef ENGLISH
	fomen("Press any key");
#else
	fomen("Appuyer sur une touche");
#endif
	get();
	return(HideMessage());
}
/* Accept user's option and call the corresponding routine in a loop */
Process()
{

	if( get_param(&pa_rec, BROWSE, 1, e_mesg) < 1 ){
		DispError();
		return(-1);
	}
	if( pa_rec.pa_aps[0]==YES )	/* aps system present */
		aps_system = PRESENT;
	else
		aps_system = ABSENT;	/* aps system absent */

	/* init key fields to 0, useful if Next/Prev is selected first */
	s_rec.s_trdate = 0;
	s_rec.s_trtype[0] = '\0';
	s_rec.s_trsno = 0;

	/* Read & process options in a loop until user quits */
	for( ; ; ){
		if( ReadFunction()<0 ) return(-1);
		switch( s_rec.s_fn[0] ){
			case ADDREC:	/* add a transaction list */
				CHKACC(retval,ADD,e_mesg);
				if( ClearScreen()<0 )	return(-1);
				if( (retval=SetDupBuffers(FUND_FLD,REMARK_FLD,0))<0 )
					return(retval);
			/* enable dup buffers for debit & credit acc field */
				if( (retval=SetDupBuffers(DBACCT_FLD,CRACCT_FLD,2))<0 )
					return(retval);
				retval = AddRecord();
				roll_back(e_mesg);
				if( retval<0 ) return(-1);
			/* disable dup buffers for debit & credit acc field */
				if( (retval=SetDupBuffers(DBACCT_FLD,REMARK_FLD,0))<0 )
					return(retval);
				break;
			case NEXT:	/* show next Xaction list in sequence */
				if( Inquiry(SEQUENTIAL,FORWARD)<0 ) return(-1);
				break;
			case PREV:	/* show prev Xaction list in sequence */
				if( Inquiry(SEQUENTIAL,BACKWARD)<0 ) return(-1);
				break;
			case INQUIRE:	/* show selected Xaction list */
				if( Inquiry(RANDOM,0)<0 ) return(-1);
				break;
			case EXITOPT:	/* exit */
				return(0);
			default:
				break;
		}
		if( retval<0 ){
			fomen(e_mesg);
			get();
		}
		if( retval==DBH_ERR )
			return(retval);
	}
}
SetDupBuffers( firstfld, lastfld, value )
int	firstfld, lastfld;	/* field numbers range */
int	value;			/* ENABLE or DISABLE */
{
	int i;

	for( i=firstfld; i<=lastfld; i+=100 )
		fomca1( i, 19, value);
	sr.nextfld = firstfld;
	sr.endfld = lastfld;
	fomud( (char *)&s_rec );
	ret( err_chk(&sr) );

	return( 0 );
}
ReadFunction()	/* Display options at the bottom and read user's entry */
{
#ifdef ENGLISH
	fomer("A(dd), N(ext), P(rev), I(nquire), E(xit)");
#else
	fomer("R(ajouter), S(uivant), P(recedent), I(nterroger), F(in)");
#endif
	sr.nextfld = FN_FLD;	/* Fn field number */
	fomrf( (char *)&s_rec );
	ret( err_chk(&sr) );
	return(0);
}
/* 	Depending on the transaction type chosen, suppress the fields 
	which are not required
*/
MaskByType()
{
	int	i;

	switch( tr_opt ){
	   case AL:			/* ALLOCATIONS */
		s_rec.s_supp_cd[0] = HV_CHAR;
		s_rec.s_ref[0] = HV_CHAR;
		s_rec.s_cracc[0] = HV_CHAR;
		break;
	   case RE:			/* RECEIPTS */
	   case RS:			/* RETURNS TO SUPPLIER */
		s_rec.s_fund = HV_SHORT;
		s_rec.s_fund2 = HV_SHORT;
		if( aps_system == ABSENT ){
			s_rec.s_supp_cd[0] = HV_CHAR;
			s_rec.s_ref[0] = HV_CHAR;
		}
		if( aps_system == PRESENT ){
			s_rec.s_amount = HV_DOUBLE;
			s_rec.s_dbacc[0] = HV_CHAR;
			s_rec.s_cracc[0] = HV_CHAR;
		}
		s_rec.s_locno = HV_SHORT;
		break;
	   case OR:			/* ORDERS */
		s_rec.s_supp_cd[0] = HV_CHAR;
		s_rec.s_ref[0] = HV_CHAR;
		s_rec.s_locno = HV_SHORT;
		s_rec.s_dbacc[0] = HV_CHAR;
		s_rec.s_cracc[0] = HV_CHAR;
		break;
	   case IS:			/* ISSUES */
	   case RT:			/*  RETURNS from costcentre */ 
		s_rec.s_supp_cd[0] = HV_CHAR;
		s_rec.s_ref[0] = HV_CHAR;
		break;
	   case AD:			/* ADJUSTMENTS */
	   case WO:			/* WRITEOFFS */ 
		s_rec.s_supp_cd[0] = HV_CHAR;
		s_rec.s_ref[0] = HV_CHAR;
		s_rec.s_locno = HV_SHORT;
		break;
	}
	if(tr_opt != RE) {
		s_rec.s_po_no = HV_LONG;
		s_rec.s_dummy[0] = HV_CHAR;
		for(i=0;i<MAX_PO;i++) {
			s_rec.s_items[i].s_po = HV_LONG ;
			s_rec.s_items[i].s_ord_qty = HV_DOUBLE ;
			s_rec.s_items[i].s_recv_qty = HV_DOUBLE ;
			s_rec.s_items[i].s_diff = HV_DOUBLE ;
		}
	}
	return(0);
}
AddRecord()		/* Add a transaction record */
{
	if(SetDupBuffers(TRDATE_FLD,SNO_FLD,0)<0) /* Disable key dup buffers */
		return(-1);
	/* Read key fields */
	if( (retval=ReadKeyFields())<0 )	return(retval);
	if(retval==ESCAPE){
		if(ClearScreen()<0)	return(-1);
		return(retval);
	}

	/* Read the required non key fields, depending on transaction type */
	if( FillNonkeyFlds(LOW)<0 ) return(-1);
	if( MaskByType()<0 )	return(-1);


	/* Show current period always */
	s_rec.s_period = pa_rec.pa_cur_period;
	fomca1( PERIOD_FLD,19,2 );
	sr.nextfld = sr.endfld = PERIOD_FLD;
	fomud( (char *)&s_rec );
	if(	tr_opt==AL || 
		tr_opt==OR || 
		( aps_system==PRESENT && (tr_opt==RE || tr_opt==RS ))
	  )
		;
	else
		s_rec.s_period = LV_SHORT;

	fund_default();

	if( (retval=ReadFields(FUND_FLD,REMARK_FLD))<0 )
		return(retval);
	if(retval==ESCAPE){
		if(ClearScreen()<0)	return(-1);
		return(retval);
	}

	/* Allow user to edit or confirm entries before saving the records */
	for( ; ; ) {
		if( (retval=EditFlds())<0 )	return(retval);
		if( retval==ESCAPE ){
			if(ClearScreen()<0)	return(-1);
			return(retval);
		}

		/* Write the records */
		retval = WriteSession();
		unlock_file(GLTRHDR);
		close_file(GLTRHDR);
		if(retval < 0) {
			if(retval == LOCKED) continue;
			return(-1);
		}
		break;
	}
	return(0);
}
MakeSerialNo()	/* Generate the next serial no. (part of the key) */
{
#ifdef ORACLE
	long	sno, get_maxsno();
#endif
	/* Read the file on the main key from the end of file, in the 
	   reverse direction, and determine the new serial number */

	st_tran.st_date = s_rec.s_trdate ;
	STRCPY( st_tran.st_type, s_rec.s_trtype );

#ifndef ORACLE
	/* Move highs to serial no, and access previous record in sequence */
	st_tran.st_seq_no = HV_SHORT;
	flg_reset(STTRAN);
	retval = get_n_sttran( &st_tran,BROWSE,0,BACKWARD,e_mesg );
	seq_over( STTRAN );
	if( retval==ERROR ){
		DispError();
		return(-1);
	}

	/* If the key changed or end of file is reached */
	if( st_tran.st_date!=s_rec.s_trdate ||
	    strcmp( st_tran.st_type, s_rec.s_trtype ) ||
	    retval==EFL ){
		st_tran.st_date = s_rec.s_trdate;
		STRCPY( st_tran.st_type,s_rec.s_trtype );
		st_tran.st_seq_no = 1;
	}
	else  /* The new serial# is one greater than that of the record read */
		st_tran.st_seq_no++;
#else
	/* get next sequential transaction number */
	sno = get_maxsno(STTRAN,(char *)&st_tran,0,-1,e_mesg);
	if(sno < 0) {
		DispError();
		return(-1);
	}
	st_tran.st_seq_no = sno + 1;
#endif
	s_rec.s_trsno = st_tran.st_seq_no;
	return(0);
}
ReadKeyFields()	/* Read the fund and stock item code */
{
	int retval;

	s_rec.s_trdate = s_rec.s_rundt;	/* Display system date as default */
	if( WriteFields( TRDATE_FLD, TRDATE_FLD )<0 )	
		return(-1);
	fomca1( TRDATE_FLD, 19, 2 );		/* Enable dup buffer for date */
	sr.nextfld = sr.endfld = TRDATE_FLD;
	fomud( (char *)&s_rec );	/* Update dup buffers */
	if( FillKeyFields( LOW )<0 )	/* Allow user to change date */
		return(-1);
	retval = ReadFields(TRDATE_FLD,TYPE_FLD); /*Read date and trans type*/
	if( retval<0 || retval==ESCAPE )	return( retval );
	fomca1( TRDATE_FLD, 19, 0 );		/* Disable dup buffer for date */
	
	if( MakeSerialNo()<0 )		/* Generate new serial # */
		return(-1);
	if( WriteFields(SNO_FLD,SNO_FLD)<0 )	return(-1);
	return(0);
}
ReadFields(start,end)	/* read the given range of fields */
int start, end;		/* start and end profom field numbers */
{
	int retval;

	sr.nextfld = start;
	sr.endfld = end;
	for( ; ; ){	/* Do in a loop */
		fomrd( (char *)&s_rec );	/* Profom call */
		ret(err_chk(&sr));		/* Check for profom error */
		if( sr.retcode==RET_USER_ESC || sr.retcode==RET_VAL_CHK ){
		    if( sr.retcode==RET_USER_ESC ){
			if( sr.escchar[0]=='F' || sr.escchar[0]=='f' )
				return( ESCAPE );
			else if( sr.escchar[0]=='H' || sr.escchar[0]=='h' ){
				if( NO_HLP_WIN )
					continue;
			}
			else
				continue;
		    }
		    retval=Validate();
		    if(retval<0 || retval==ESCAPE)
			return(retval);
		    else
			continue;
		}
		break;
	}
	return(0);
}
WriteFields( start,end )/* write fields whose numbers range from start to end */
int start, end;
{
	sr.nextfld = start;
	sr.endfld = end;
	fomwr( (char *)&s_rec );
	ret( err_chk(&sr) );
	return(0);
}
ClearScreen()	/* clear the screen except fn field and screen heading */
{
	/****
		if(FillKeyFields(HIGH)<0 ) return(-1);
	****/
	if(FillFundFlds(HIGH)<0 ) return(-1);
	if(FillAcctFlds(HIGH)<0 ) return(-1);
	if(FillNonkeyFlds(HIGH)<0 ) return(-1);
	if(FillMsgRespFlds(HIGH)<0 ) return(-1);

	if( WriteFields(TRDATE_FLD,RESP_FLD)<0 ) return(-1);
	
	return(0);
}
Validate()	/* Validate the values entered by the user */
{
	int index;
	char	*str, c;
	double	dbltemp;
	short	reccod;

	switch( sr.curfld ){
		case TRDATE_FLD:	/* transaction date */
			if( s_rec.s_trdate>s_rec.s_rundt ){
#ifdef ENGLISH
				fomer("Cannot accept future date");
#else
				fomer("Ne peut pas accepter une date ulterieure");
#endif
				s_rec.s_trdate = LV_LONG;	
			}
			break;
		case TYPE_FLD:	/* transaction type */
		/* No ORDER Xaction can be added manually if APS present */
			if( s_rec.s_fn[0]==ADDREC && aps_system==PRESENT &&
				strcmp(s_rec.s_trtype,ALLOC) &&
				strcmp(s_rec.s_trtype,RECPT) &&
				strcmp(s_rec.s_trtype,RETSUP) &&
				strcmp(s_rec.s_trtype,ISSUE) &&
				strcmp(s_rec.s_trtype,RETURN) &&
				strcmp(s_rec.s_trtype,WRTOFF) &&
				strcmp(s_rec.s_trtype,ADJUST) 
			    ){   
#ifdef ENGLISH
	fomer("ALloc, REceipt, Return to Supplier, ISsue, ReTurns, WriteOff, ADjust");
#else
	fomer("ALloc, ReCu, Renvoi au Fournisseur, EMission, RenVoi, RaDiation, AJuster");
#endif
				s_rec.s_trtype[0] = LV_CHAR;
				break;
			}
			/* Allow ORDER transactions in other cases */
			else if( strcmp(s_rec.s_trtype,ALLOC) &&
				strcmp(s_rec.s_trtype,ORDER) &&
				strcmp(s_rec.s_trtype,RECPT) &&
				strcmp(s_rec.s_trtype,RETSUP) &&
				strcmp(s_rec.s_trtype,ISSUE) &&
				strcmp(s_rec.s_trtype,RETURN) &&
				strcmp(s_rec.s_trtype,WRTOFF) &&
				strcmp(s_rec.s_trtype,ADJUST) 
			){
#ifdef ENGLISH
fomer("ALloc, ORder, REceipt, Return to Supplier, ISsue, ReTurns, WriteOff, ADjust");
#else
fomer("ALloc, CoMmande, ReCu, Renvoi au Fourn, EMissions, RenVoi, RaDiation, AJuster");
#endif
				s_rec.s_trtype[0] = LV_CHAR;
				break;
			}
			SetTranOption();
			break;
		case SNO_FLD:	/* transaction serial no */
			break;
		case FUND_FLD:	/* fund code */
			/* Try to read a control file record on this fund# */
			ctl_rec.fund = s_rec.s_fund;
			index = get_ctl( &ctl_rec, BROWSE, 0, e_mesg );
			if( index==ERROR ){
				DispError();
				return(-1);
			}
			else if( index!=NOERROR ){
				fomer(e_mesg);
				s_rec.s_fund = LV_SHORT;
			}
			else
				fomer( ctl_rec.desc );
			break;

		case FUND2_FLD:	/* fund2 code */
			/* Try to read a control file record on this fund# */
			ctl_rec.fund = s_rec.s_fund2;
			index = get_ctl( &ctl_rec, BROWSE, 0, e_mesg );
			if( index==ERROR ){
				DispError();
				return(-1);
			}
			else if( index!=NOERROR ){
				fomer(e_mesg);
				s_rec.s_fund2 = LV_SHORT;
			}
			else {
				fomer( ctl_rec.desc );
			}
			break;
		case STCK_FLD:	/* stock item code */
			if( ESC_H ){
				retval = stock_hlp( s_rec.s_fund,s_rec.s_stcode,
						7,13 );
				if( retval==DBH_ERR )
					return( retval );
				else if( retval>=0 )
					redraw();
				if( retval==0 )
					break;
			}
			/* Try to read a stock master record on this code */
			st_mast.st_fund = 1;
			STRCPY( st_mast.st_code, s_rec.s_stcode );
			retval = get_stmast( &st_mast, UPDATE, 0, e_mesg );
			if( retval==ERROR ){
				DispError();
				return(retval);
			}
			if( retval!=NOERROR ){
				fomer(e_mesg);
				s_rec.s_stcode[0] = LV_CHAR; 
				break;
			} 
			else
				fomer( st_mast.st_desc );

			if( s_rec.s_resp[0]==EDIT ) /* Editing of entries */
				break;

			/* If entries are made the first time, 
			   display the appropriate account# s */
			retval=DispAccounts();
			if( retval<0 || retval==ESCAPE )
				return(retval);
			sr.nextfld = SUPP_FLD;
			sr.endfld = REMARK_FLD;
			break; 
		case SUPP_FLD:	/* Supplier No */
			Right_Justify_Numeric(s_rec.s_supp_cd,
					(sizeof(s_rec.s_supp_cd)-1));
			if( ESC_H ){
				retval = supp_hlp( s_rec.s_supp_cd,6,13 );
				if( retval==DBH_ERR )
					return( retval );
				else if( retval>=0 )
					redraw();
				if( retval==0 )
					break;
			}
			STRCPY( supplier.s_supp_cd, s_rec.s_supp_cd );
			if( get_supplier(&supplier,BROWSE,0,e_mesg)!=NOERROR ){
				fomer(e_mesg);
				s_rec.s_supp_cd[0] = LV_CHAR;
			}
			else
				fomer( supplier.s_name );
			break;
		case REF_FLD:
			if(tr_opt==RE) {
				if(ShowPos(ALL_POS)<0) return(ERROR);
			}
			break;
		case PONO_FLD:
			if(ShowPos(ONE_PO)<0) return(ERROR);
			break;
		case LOC_FLD:	/* Location number */
			if( ESC_H ){
				retval = sch_hlp( &s_rec.s_locno,6,13 );
				if( retval==DBH_ERR )
					return( retval );
				else if( retval>=0 )
					redraw();
				if( retval==0 )
					break;
			}
			/* Try to read a school record on this number */
			sch_rec.sc_numb = s_rec.s_locno;
			retval = get_sch( &sch_rec, BROWSE, 0, e_mesg );
			if( retval==ERROR ){
				DispError();
				return(-1);
			}
			else if( retval==UNDEF ){
				fomer(e_mesg);
				s_rec.s_locno = LV_SHORT;
			}
			else
				fomer( sch_rec.sc_name );
			break;
		case PERIOD_FLD:	/* period */
			/* period should be currently open */
			if( s_rec.s_period < 1 || s_rec.s_period < 
				pa_rec.pa_cur_period-pa_rec.pa_open_per || 
			    s_rec.s_period > pa_rec.pa_cur_period ){
#ifdef ENGLISH
				fomer("Period invalid or not open");
#else
				fomer("Periode invalide ou pas ouverte");
#endif
				s_rec.s_period = LV_SHORT;
				break;
			}
			break;
		case DBACCT_FLD:	/* Debit Account Number */
			if( ESC_H ){
			   retval = gl_hlp(s_rec.s_fund, s_rec.s_dbacc, &reccod,
					7, 15 );
			   if( retval<0 )	/* error */
					return( retval );
			   if( retval==0 ){	/* nothing selected  */
					redraw(); /* remove hlp window*/
					break;
			   }
			   else if( retval==1 ){/* selected */
					/* check for reccod compatibility */
				if( reccod!=99 ){
				   redraw();
#ifdef ENGLISH
				   fomer("Invalid Record code: Try again");
#else
				   fomer("Code de fiche invalide: Ressayer");
#endif
				   s_rec.s_dbacc[0]=LV_CHAR;
				   sr.nextfld = sr.curfld;
				   break;
				}
				else 
					redraw();
			   }
			}
					/* Check if the account# is numeric */
			else if( acnt_chk(s_rec.s_dbacc)==ERROR ){
#ifdef ENGLISH
				fomer("Invalid Account number");
#else
				fomer("Numero de compte invalide");
#endif
				s_rec.s_dbacc[0] = LV_CHAR;
				break;
			}

			/* Check if Gl master record exists */
			retval = ChkMastKey(s_rec.s_dbacc,&gl_rec); 
			if( retval==ERROR )	return(-1);
			if( retval!=NOERROR )
				s_rec.s_dbacc[0]=LV_CHAR;
			else
				fomer(gl_rec.desc);
			break;
		case CRACCT_FLD:	/* Credit Account Number */
			if( ESC_H ){
			   retval = gl_hlp(s_rec.s_fund2, s_rec.s_cracc, &reccod,
					7, 15 );
			   if( retval<0 )	/* error */
					return( retval );
			   if( retval==0 ){	/* nothing selected  */
					redraw(); /* remove hlp window*/
					break;
			   }
			   else if( retval==1 ){/* selected */
					/* check for reccod compatibility */
				if( reccod!=99 ){
				   redraw();
#ifdef ENGLISH
				   fomer("Invalid Record code: Try again");
#else
				   fomer("Code de fiche invalide: Ressayer");
#endif
				   s_rec.s_cracc[0]=LV_CHAR;
				   sr.nextfld = sr.curfld;
				   break;
				}
				else 
					redraw();
			   }
			}
					/* Check if the account# is numeric */
			else if( acnt_chk(s_rec.s_cracc)==ERROR ){
#ifdef ENGLISH
				fomer("Invalid Account number");
#else
				fomer("Numero de compte invalide");
#endif
				s_rec.s_cracc[0] = LV_CHAR;
				break;
			}

			/* Check if Gl master record exists */
			retval = ChkMastKey(s_rec.s_cracc,&gl_rec); 
			if( retval==ERROR )	return(-1);
			if( retval!=NOERROR )
				s_rec.s_cracc[0]=LV_CHAR;
			else
				fomer(gl_rec.desc);
			break;
		case QTY_FLD:	/* quantity of transaction */
			if( s_rec.s_qty < DELTA_DIFF && 
			    s_rec.s_qty > -DELTA_DIFF &&
			    tr_opt!=AD ) {
#ifdef ENGLISH
				fomer("Qty too small to be accepted");
#else
				fomer("Quantite trop petit pour etre accepte");
#endif
				s_rec.s_qty = LV_DOUBLE;
				break;
			}

			/* Check if the entered quantity can be allowed */
			retval = CheckQuantity();
			if( retval<0 || retval==ESCAPE )
				return(retval);
			break;
		case AMT_FLD:	/* Value of stock */
			dbltemp = s_rec.s_amount+gl_rec.comdat+gl_rec.ytd;
			if( s_rec.s_amount<DELTA_DIFF && tr_opt!=AD ){
#ifdef ENGLISH
				fomer("Amount too small to be accepted");
#else
				fomer("Montant trop petit pour etre accepte");
#endif
				s_rec.s_amount = LV_DOUBLE;
			}
			/* If allocation is being done, warn the user if
			   allocation value exceeds budget amount */
			else if( tr_opt==AL && s_rec.s_qty>0.0 && 
							dbltemp>gl_rec.budcur ){
#ifdef ENGLISH
				DisplayMessage("Not Enough Budget");
#else
				DisplayMessage("Pas assez de budget");
#endif
#ifdef ENGLISH
				fomen("Press any key");
#else
				fomen("Appuyer sur une touche");
#endif
				get();
#ifdef ENGLISH
				DisplayMessage("Press ESC-F to Terminate");
#else
				DisplayMessage("Appuyer sur ESC-F pour terminer");
#endif
			}
			else if( tr_opt==RS && aps_system==ABSENT ){
			 if( st_mast.st_value-s_rec.s_amount<0.0 ){
#ifdef ENGLISH
			   sprintf(e_mesg,"Value can't exceed %lf",
					st_mast.st_value);
#else
			   sprintf(e_mesg,"Valeur ne peut pas depasser %lf",
					st_mast.st_value);
#endif
			   fomer(e_mesg);
			   s_rec.s_amount = LV_DOUBLE;
			 }
			}
			else
				fomca1( AMT_FLD, 19, 0 );
			break; 
		default:
			break;
	}
	sr.nextfld = sr.curfld;
	return(0);
}
ShowPos(mode)
int	mode;
{
	Po_item	po_item;
	Po_hdr	po_hdr;
	St_tran tmp_tran;
	int	i, j, first;

	for(i=0;i<MAX_PO;i++) {
		s_rec.s_items[i].s_po = 0;
		s_rec.s_items[i].s_ord_qty = 0.00;
		s_rec.s_items[i].s_recv_qty = 0.00;
	}

	i = 0;
	j = -1;
	first = -1;

	strcpy(po_item.pi_st_code,s_rec.s_stcode);
	if(mode == ALL_POS)
		po_item.pi_code = 0;
	else 
		po_item.pi_code = s_rec.s_po_no;
	po_item.pi_item_no = 0;
	flg_reset(POITEM);
	for( ; ; ) {
		retval = get_n_poitem(&po_item,BROWSE,2,FORWARD,e_mesg);
		if(retval < 0) {
			if(retval == EFL) break;
			DispError();
			return(retval);
		}

		if(strcmp(po_item.pi_st_code,s_rec.s_stcode) != 0 ) break;
		if(mode == ONE_PO && po_item.pi_code != s_rec.s_po_no) 
			break;

		po_hdr.ph_code = po_item.pi_code;
		retval = get_pohdr(&po_hdr,BROWSE,0,e_mesg);
		if(retval < 0) {
			DispError();
			return(retval);
		}

		if(strcmp(po_hdr.ph_supp_cd,s_rec.s_supp_cd) != 0 ) continue;

		if(first==-1 && mode == ALL_POS) {
			s_rec.s_items[i].s_po = po_item.pi_code;
			first = 0;
		}	
		if(po_item.pi_code != s_rec.s_items[i].s_po && mode==ALL_POS) {
			if(s_rec.s_items[i].s_ord_qty -
			   s_rec.s_items[i].s_recv_qty != 0.00) {
				j=i;
				i++;
			}
			else {
				s_rec.s_items[i].s_po = 0;
				s_rec.s_items[i].s_ord_qty = 0.00;
				s_rec.s_items[i].s_recv_qty = 0.00;
			}
		}

		/* Fill In Po Items */
		s_rec.s_items[i].s_po = po_item.pi_code;
		s_rec.s_items[i].s_ord_qty += po_item.pi_orig_qty;
		
		tmp_tran.st_po_no = po_hdr.ph_code;
		strcpy(tmp_tran.st_type,RECPT);
		tmp_tran.st_date = 0;
		tmp_tran.st_seq_no = 0;
		flg_reset(STTRAN);
		for( ; ; ) {
			/* If Two Items on same po don't do this again */
			if(j==i) break;
			retval = get_n_sttran(&tmp_tran,BROWSE,2,FORWARD,e_mesg);
			if(retval < 0) {
				if(retval == EFL) break;
				DispError();
				return(retval);
			}
			if(tmp_tran.st_po_no != po_hdr.ph_code ||
			   strcmp(tmp_tran.st_type,RECPT) != 0 ||
			   strcmp(tmp_tran.st_code,po_item.pi_st_code) !=0) 
				break;
			s_rec.s_items[i].s_recv_qty += tmp_tran.st_qty;
		}
	}

	/* Show Po's Found */
	if(s_rec.s_items[i].s_po != 0)
		j=i+1;
	else
		j = 0;

	for(i=0;i<j;i++) {
		s_rec.s_items[i].s_diff = s_rec.s_items[i].s_ord_qty -
			s_rec.s_items[i].s_recv_qty;
	}
	s_rec.s_dummy[0] = ' ' ;
	for(;j<MAX_PO;j++) {
		s_rec.s_items[j].s_po = HV_LONG;
		s_rec.s_items[j].s_ord_qty = HV_DOUBLE;
		s_rec.s_items[j].s_recv_qty = HV_DOUBLE;
		s_rec.s_items[j].s_diff = HV_DOUBLE ;
	}
	return(WriteFields(ITEM_ST,ITEM_END));
}
/*	Set the global "tr_opt" flag depending on the transaction option */
SetTranOption()
{
	if( !strcmp(s_rec.s_trtype,ALLOC) )
		tr_opt = AL;
	else if( !strcmp(s_rec.s_trtype,ORDER) )
		tr_opt = OR;
	else if( !strcmp(s_rec.s_trtype,RECPT) )
		tr_opt = RE;
	else if( !strcmp(s_rec.s_trtype,RETSUP) )
		tr_opt = RS;
	else if( !strcmp(s_rec.s_trtype,ISSUE) )
		tr_opt = IS;
	else if( !strcmp(s_rec.s_trtype,RETURN) )
		tr_opt = RT;
	else if( !strcmp(s_rec.s_trtype,ADJUST) )
		tr_opt = AD;
	else if( !strcmp(s_rec.s_trtype,WRTOFF) )
		tr_opt = WO;
	return(0);
}
/* 	Display the Credit/Debit or both account numbers  or read them,
	depending on the type of transaction
*/
DispAccounts()
{
	int	retval;

	switch( tr_opt ){
	  case AL:	/* Allocations */
		/* display default acct# from stock master; allow any change */
		STRCPY(s_rec.s_dbacc,st_mast.st_accno);
		sr.nextfld = sr.endfld = DBACCT_FLD;
		fomud( (char *)&s_rec );
		ret(err_chk(&sr));
		s_rec.s_dbacc[0] = LV_CHAR;
		break;
	  case RE:	/* Receipts from supplier */
			/* Don't read accounts if APS is present */
		if( aps_system==PRESENT )
			break;

		/* if aps system is absent */
		/* Display Inv.Gl Acct as Debit account; Can't be changed */
		STRCPY(s_rec.s_dbacc,ctl_rec.inv_acnt);
		s_rec.s_cracc[0] = LV_CHAR;
		break;
	  case RS:	/* Returns to supplier */
			/* Don't read accounts if APS is present */
		if( aps_system==PRESENT )
			break;

		/* if aps system is absent */
		/* Display Inv.Gl Acct as Credit account; Can't be changed */
		STRCPY(s_rec.s_cracc,ctl_rec.inv_acnt);
		s_rec.s_dbacc[0] = LV_CHAR;
		break;
	  case IS:	/* Issues to cost centre */
		/* Display Inv.Gl Acct as Credit account; Can't be changed */
		/* display default Db Acct from stock master; allow change */
		ctl_rec.fund = s_rec.s_fund2;
		retval = get_ctl( &ctl_rec, BROWSE, 0, e_mesg );
		if( retval==ERROR ){
			DispError();
			return(-1);
		}
		if(strcmp(st_mast.st_accno,ctl_rec.inv_acnt) != 0)
			STRCPY(s_rec.s_dbacc,st_mast.st_accno);
		else
			s_rec.s_dbacc[0] = '\0';
		STRCPY(s_rec.s_cracc,ctl_rec.inv_acnt);
		sr.nextfld = sr.endfld = DBACCT_FLD;
		fomud( (char *)&s_rec );
		ret(err_chk(&sr));
		s_rec.s_dbacc[0] = LV_CHAR;
		break;
	  case RT:	/* Returns from the cost centre */
		/* Display Inv.Gl Acct as Debit account; Can't be changed */
		/* display default Cr Acct from stock master; allow change */
		ctl_rec.fund = s_rec.s_fund;
		retval = get_ctl( &ctl_rec, BROWSE, 0, e_mesg );
		if( retval==ERROR ){
			DispError();
			return(-1);
		}
		STRCPY(s_rec.s_dbacc,ctl_rec.inv_acnt);
		if(strcmp(st_mast.st_accno,ctl_rec.inv_acnt) != 0)
			STRCPY(s_rec.s_cracc,st_mast.st_accno);
		else
			s_rec.s_cracc[0] = '\0';
		sr.nextfld = sr.endfld = CRACCT_FLD;
		fomud( (char *)&s_rec );
		ret(err_chk(&sr));
		s_rec.s_cracc[0] = LV_CHAR;
		break;
	  case AD:	/* adjustments of stock */
		/* Display db and cr accounts defaulted to inv gen acct */
		/* As amount can be less than zero, user has to decide
		   Debit and Credit account */
		ctl_rec.fund = s_rec.s_fund;
		retval = get_ctl( &ctl_rec, BROWSE, 0, e_mesg );
		if( retval==ERROR ){
			DispError();
			return(-1);
		}
		STRCPY(s_rec.s_dbacc,ctl_rec.inv_acnt);
		ctl_rec.fund = s_rec.s_fund2;
		retval = get_ctl( &ctl_rec, BROWSE, 0, e_mesg );
		if( retval==ERROR ){
			DispError();
			return(-1);
		}
		STRCPY(s_rec.s_cracc,ctl_rec.inv_acnt);
		sr.nextfld = DBACCT_FLD;
		sr.endfld = CRACCT_FLD;
		fomud( (char *)&s_rec );
		ret(err_chk(&sr));
		s_rec.s_dbacc[0] = LV_CHAR;
		s_rec.s_cracc[0] = LV_CHAR;
		break;
	  case WO:	/* Write Offs */
		/* Display Inv.Gl Acct as Credit account; Can't be changed */
		/* read the Debit account from the user */
		ctl_rec.fund = s_rec.s_fund2;
		retval = get_ctl( &ctl_rec, BROWSE, 0, e_mesg );
		if( retval==ERROR ){
			DispError();
			return(-1);
		}
		STRCPY(s_rec.s_cracc,ctl_rec.inv_acnt);
		ctl_rec.fund = s_rec.s_fund;
		retval = get_ctl( &ctl_rec, BROWSE, 0, e_mesg );
		if( retval==ERROR ){
			DispError();
			return(-1);
		}
		STRCPY(s_rec.s_dbacc,ctl_rec.sus_acnt);
		sr.nextfld = sr.endfld = DBACCT_FLD;
		fomud( (char *)&s_rec );
		ret(err_chk(&sr));
		s_rec.s_dbacc[0] = LV_CHAR;
		break;
	  default:
		break;
	}
	return(0);
}
/*	Check if the entered quantity leaves any negative balances in the stock
	master or Allocation File. Allow negative qty for Allocation & Order 
	types only.  Check the priorities in the case of Issues, by scanning 
	the Allocation file, which records the time of entry also. 
*/
CheckQuantity()
{
	int	endfldno;

	switch( tr_opt ){
	   case AL:	/* Allocations */
		if( (retval=CheckAllocQty())<0 ){
			roll_back(e_mesg);
			return(ESCAPE);
		}
		if( retval>0 )	/* improper qty */
			s_rec.s_qty = LV_DOUBLE;
		else{
		/* positive qty: calculate value from stock avg.rate, but 
		   allow user to change it 
		*/
		    if( s_rec.s_qty>0.0 ){
			s_rec.s_amount = s_rec.s_qty*st_mast.st_rate;
			fomca1(AMT_FLD,19,2);
			sr.nextfld = sr.endfld = AMT_FLD;
			fomud( (char *)&s_rec);
			s_rec.s_amount = LV_DOUBLE;
			sr.nextfld = AMT_FLD;
#ifdef ENGLISH
			fomer("Amount shown is calculated from average stock rate");
#else
			fomer("Montant affiche calcule a partir du taux moyen des stocks");
#endif
		    }
		/* negative qty: if all the remaining qty in alloc record is 
		   deallocated, value of Xaction = value remaining in the 
		   alloc record. Let it not be changed by the user.
		*/
		    else if(s_rec.s_qty+alloc_rec.st_alloc<DELTA_DIFF)
			s_rec.s_amount = alloc_rec.st_value;
		    else 
		/* negative qty: if only a part of allocated qty is deallocated,
		   decrement the value of the allocated stock in the alloc rec
		   by a proportionate amount
		*/
			s_rec.s_amount = (-s_rec.s_qty*alloc_rec.st_value)/
					alloc_rec.st_alloc;
		}
		break;
	   case OR:	/* Orders */
		/* if negative orders(order cancellation): Qty can't exceed qty
			on order in the stock master
		*/
		if( s_rec.s_qty + st_mast.st_on_order < 0.0 ){
#ifdef ENGLISH
			sprintf(e_mesg,
				"Qty can't be less than %lf",
				-st_mast.st_on_order );
#else
			sprintf(e_mesg,
				"Quantite ne peut pas etre moins que %lf",
				-st_mast.st_on_order );
#endif
			fomer( e_mesg );
			s_rec.s_qty = LV_DOUBLE;
		}
		break;
	   case RE:	/* Receipts from the supplier */
		if( s_rec.s_qty<0.0 ){
#ifdef ENGLISH
		   fomer("negative qty for receipts not allowed");
#else
		   fomer("Quantite negative pour les recus pas permise");
#endif
		   s_rec.s_qty = LV_DOUBLE;
		}
		else if( s_rec.s_qty>st_mast.st_on_order ){
#ifdef ENGLISH
		  sprintf(e_mesg,"On order %lf: Receipts can't exceed this qty!"
				,st_mast.st_on_order);
#else
		  sprintf(e_mesg,"Sur commande %lf: Recus ne peuvent pas depasser cette quantite!"
				,st_mast.st_on_order);
#endif
		  fomer(e_mesg);
		  s_rec.s_qty = LV_DOUBLE;
		}
		break;
	   case RS:	/* Returns to the supplier */
		if( s_rec.s_qty<0.0 ){
#ifdef ENGLISH
		   fomer("negative qty for returns not allowed");
#else
		   fomer("Quantite negative pour les renvois n'est pas permise");
#endif
		   s_rec.s_qty = LV_DOUBLE;
		}
		else if( st_mast.st_on_hand-s_rec.s_qty<0.0 ){
#ifdef ENGLISH
		   fomer("Total stock on hand becomes negative");
#else
		   fomer("Total du stock en maison devient negatif");
#endif
		   s_rec.s_qty = LV_DOUBLE;
		}
		else if( aps_system==ABSENT ){
		/* show value from the avg.stock rate, allow changes */
			endfldno=sr.endfld;
			s_rec.s_amount = s_rec.s_qty*st_mast.st_rate;
#ifdef ENGLISH
			fomer("Value calculated from avg stock rate");
#else
			fomer("Valeur calculee a partir du taux moyen des stocks");
#endif
			fomca1( AMT_FLD,19,2 );
			sr.nextfld=sr.endfld=AMT_FLD;
			fomud((char *)&s_rec);
			ret(err_chk(&sr));
			s_rec.s_amount = LV_DOUBLE;
			sr.nextfld=AMT_FLD;
			sr.endfld=endfldno;
		}
		break;
	   case IS:	/* Issues to cost centre */
		/* Disallow negative qty or qty exceeding stock on hand */
		if( s_rec.s_qty<0.0 ){
#ifdef ENGLISH
		   fomer("negative qty for issues not allowed");
#else
		   fomer("Quantite negative pour les emissions n'est pas permise");
#endif
		   s_rec.s_qty = LV_DOUBLE;
		}
		else if( st_mast.st_on_hand-s_rec.s_qty <0.0 ){
#ifdef ENGLISH
		   fomer("Total stock on hand becomes negative");
#else
		   fomer("Total du stock en maison devient negatif");
#endif
		   s_rec.s_qty = LV_DOUBLE;
		}
		else if( (retval=CheckIssueQty())<0 || 
					retval==ESCAPE )
			return(retval);
		else if( s_rec.s_qty!=LV_DOUBLE )
			s_rec.s_amount = s_rec.s_qty*st_mast.st_rate;
		break;
	   case RT:	/* Return from the cost centre */
		if( s_rec.s_qty<0.0 ){
#ifdef ENGLISH
		   fomer("negative qty for returns not allowed");
#else
		   fomer("Quantite negative pour les renvois n'est pas permise");
#endif
		   s_rec.s_qty = LV_DOUBLE;
		}
		else
			s_rec.s_amount = s_rec.s_qty*st_mast.st_rate;
		break;
	   case AD:	/* adjustments */
		if( st_mast.st_on_hand+s_rec.s_qty <0.0 ){
#ifdef ENGLISH
		   fomer("Total stock on hand becomes negative");
#else
		   fomer("Total du stock en maison devient negatif");
#endif
		   s_rec.s_qty = LV_DOUBLE;
		}
		break;
	   case WO:	/* WriteOffs */
		if( s_rec.s_qty<0.0 ){
#ifdef ENGLISH
		   fomer("negative qty for writeoff not allowed");
#else
		   fomer("Quantite negative pour radiation n'est pas permise");
#endif
		   s_rec.s_qty = LV_DOUBLE;
		}
		else if( st_mast.st_on_hand-s_rec.s_qty <0.0 ){
#ifdef ENGLISH
		   fomer("Total stock on hand becomes negative");
#else
		   fomer("Total du stock en maison devient negatif");
#endif
		   s_rec.s_qty = LV_DOUBLE;
		}
		else
			s_rec.s_amount = s_rec.s_qty*st_mast.st_rate;
		break;
	}
	return(0);
}
/* 	Check if an allocation record exists for the given data
	If it exists, modify it, otherwise create a record;
	If by virtue of the modification, the total allocated qty
		becomes 0 or negative, delete the allocation record 
*/
CheckAllocQty()
{
	/* Form allocation record key with the given data */
	alloc_rec.st_fund = s_rec.s_fund;
	STRCPY( alloc_rec.st_code,s_rec.s_stcode );
	alloc_rec.st_location = s_rec.s_locno;
	STRCPY( alloc_rec.st_expacc,s_rec.s_dbacc );

	/* Initialize mode to UPDATE assuming a record exists in alloc file */
	mode = UPDATE;
	/* Try to read the record from the file */
	retval = get_alloc( &alloc_rec, mode, 0, e_mesg );
	if( retval==UNDEF ){	/* It means Record is not existing */
#ifdef ENGLISH
		fomen("Allocation record will be created. Press any key");
#else
		fomen("Fiche d'allocation sera creee. Appuyer sur une touche");
#endif
		get();

		alloc_rec.st_fund = s_rec.s_fund;
		STRCPY( alloc_rec.st_code,s_rec.s_stcode );
		alloc_rec.st_location = s_rec.s_locno;
		STRCPY( alloc_rec.st_expacc,s_rec.s_dbacc );
		mode = ADD;
	}
	else if( retval!=NOERROR ){	/* Can't read */
		DispError();
		roll_back(e_mesg);
		return(retval);
	}
	/* 	else, record exists */

	if( s_rec.s_qty<0.0 ){	/* negative allocation */
		if( mode==ADD ){	/* record is being created */
#ifdef ENGLISH
			fomen("negative allocation not allowed during creation");
#else
			fomen("allocation negative n'est pas permise pendant la creation");
#endif
			get();
			return(1);
		}
		else if( alloc_rec.st_alloc + s_rec.s_qty < 0.0 ){
#ifdef ENGLISH
			sprintf(e_mesg, 
				"Qty can't be less than %lf for this location",
					-alloc_rec.st_alloc);
#else
			sprintf(e_mesg, 
				"Quantite ne peut pas etre moins que %lf pour cet emplacement",
					-alloc_rec.st_alloc);
#endif
			fomen( e_mesg );
			get();
			return(1);
		}
		else if( st_mast.st_alloc + s_rec.s_qty < 0.0 ){
#ifdef ENGLISH
			sprintf(e_mesg,
				"Qty can't be less than %lf for this stock",
					-st_mast.st_alloc);
#else
			sprintf(e_mesg,
				"Quantite ne peut pas etre moins que %lf pour ce stock",
					-st_mast.st_alloc);
#endif
			fomen( e_mesg );
			get();
			return(1);
		}
	}
	return(0);
}
ChkMastKey(accno,temp_rec) /* Check if a record exists in the GL master */
char *accno;
Gl_rec *temp_rec;
{
	int retval;

	if(s_rec.s_fund != s_rec.s_fund2){

		if(sr.curfld == DBACCT_FLD){
			temp_rec->funds = s_rec.s_fund;
		}
		else{
			temp_rec->funds = s_rec.s_fund2;
		}
	}
	else{
		temp_rec->funds = s_rec.s_fund;
	}

	STRCPY( temp_rec->accno,accno );
	temp_rec->reccod = 99;
	retval = get_gl( temp_rec,UPDATE,0,e_mesg );
	if(retval!=NOERROR ){
		DispError();
		return(retval);
	}
	return(0);
}
/* 	Read user's (single character) response in s_rec.s_resp field */
GetResponse()
{
	sr.nextfld = RESP_FLD;
	fomrf( (char *)&s_rec );
	ret( err_chk(&sr) );
	return(0);
}
EditFlds()	/* Ask if user wants to edit fields before saving */ 
{
	double diff;

	for( ; ; ){
#ifdef ENGLISH
		if(DisplayMessage( "Y(es), E(dit), C(ancel)")<0 ) 
#else
		if(DisplayMessage( "O(ui), M(odifier), A(nnuler)")<0 ) 
#endif
			return(-1);
		if( GetResponse()<0 )
			return(-1);
		switch( s_rec.s_resp[0] ){
			case EDIT:	/* Edit the fields */
				if( (retval=FldEdit())<0 || retval==ESCAPE ){
					roll_back(e_mesg);
					return(retval);
				}
				break;
			case CANCEL:	/* Cancel the session */
				if( DisplayMessage(
#ifdef ENGLISH
					"Confirm the Cancel (Y/N)?")<0 )
#else
					"Confirmer l'annulation (O/N)?")<0 )
#endif
					return(-1);
				if(GetResponse()<0)
					return(-1);
				if( s_rec.s_resp[0]==YES ){	/* Yes */
					roll_back(e_mesg);
					if( HideMessage()<0 ) return(-1);
					return(ESCAPE);
				}
				else
					continue;
			case YES:	/* A nod to save input */
				if( HideMessage()<0 ) return(-1);
				return(0);
		}
	}
}
DisplayMessage(mesg)	/* Display the given message in the message field */
char *mesg;
{
	STRCPY( s_rec.s_mesg, mesg );
	if( WriteFields(MESG_FLD,MESG_FLD)<0 )	return(-1);
	return(0);
}
HideMessage()	/* Hide the message field */
{
	if( FillMsgRespFlds(HIGH)<0 )	return(-1);
	if( WriteFields(MESG_FLD,RESP_FLD)<0 ) return(-1);
	return(0);
}
/* 	Allow the user to edit values entered earlier */
FldEdit()
{
	int i;

	for( i=FUND_FLD; i<=REMARK_FLD; i+=100 ){
		fomca1( i,19,2);	/* enable dup buffers */
	/*	fomca1(i,10,0);	*/	/* disable user escape */
	}		
	sr.nextfld = FUND_FLD;
	sr.endfld = REMARK_FLD;
	fomud( (char *)&s_rec);		/* Update dup buffers */

	if( FillNonkeyFlds(LOW)<0 )	
		return(-1);
	if(tr_opt == IS || tr_opt == WO) {
		s_rec.s_fund = LV_SHORT;
		s_rec.s_dbacc[0] = LV_CHAR;
	}
	else if(tr_opt == RT) {
		s_rec.s_fund2 = LV_SHORT;
		s_rec.s_cracc[0] = LV_CHAR;
	}
	else {
		s_rec.s_fund = LV_SHORT;
		s_rec.s_fund2 = LV_SHORT;
		s_rec.s_dbacc[0] = LV_CHAR;
		s_rec.s_cracc[0] = LV_CHAR;
	}
	if( MaskByType()<0 )	
		return(-1);
	if(	tr_opt==AL || 
		tr_opt==OR || 
		( aps_system==PRESENT && (tr_opt==RE || tr_opt==RS ))
	  )
		s_rec.s_period = pa_rec.pa_cur_period;

	retval = ReadFields(FUND_FLD,REMARK_FLD);/* Read all non key fields once */
	if( retval<0 || retval==ESCAPE )	
		return(retval);

	for( i=FUND_FLD; i<=REMARK_FLD; i+=100 ){
		fomca1( i,19,0);	/* disable dup buffers */
	/*	fomca1(i,10,1);	*/	/* enable user escape */
	}
	return(0);
}
WriteSession()	/* Write the stock master record */
{
	int	err;

	/* J. Prescott Sept. 29/92 Try to Lock GL Trans file until successful */
	for( ; ; ) {
		if((err = lock_file(GLTRHDR)) < 0) {
			if(err == LOCKED) { 
				continue;
			}
			DispError();
			roll_back(e_mesg);	/* Unlock the locked Records */
			return(err);
		}
		else break;
	}
	/***********************************************/

	if(s_rec.s_amount != HV_DOUBLE) {
		s_rec.s_amount = D_Roundoff(s_rec.s_amount);
	}

	/* stock master already read on UPDATE mode during validation */
	/* But is read again in case record locked error occured in */
	/* gl trans file. */
	/* Try to read a stock master record on this code */
	/* This is in case record locked error is encountered */
	/* which releases the locks on the file. */

	st_mast.st_fund = 1;
	STRCPY( st_mast.st_code, s_rec.s_stcode );
	retval = get_stmast( &st_mast, UPDATE, 0, e_mesg );
	if( retval<0 ){
		DispError();
		roll_back(e_mesg);
		return(retval);
	}

	switch( tr_opt ){
		case AL: 	/* Allocations */
			if( (retval=ProcAllocations()) < 0 )
				return(retval);
			break;
		case OR:	/* Orders */
			if( ( retval=ProcOrders())<0 )
				return(retval);
			break;
		case RE:	/* Receipts */
		case RS:	/* Returns to supplier */
			if( ( retval=ProcReceipts())<0 )
				return(retval);
			break;
		case IS:	/* Issues */
		case RT:	/* Returns from cost centres */
			if( ( retval=ProcIssues())<0 )
				return(retval);
			break;
		case AD:	/* Adjustments */
		case WO:	/* WriteOff */
			if( ( retval= ProcAdjustments())<0 )
				return(retval);
			break;
	}


	/*   Perform Rounding function on items 
		that are defined double		*/

	st_mast.st_alloc 	= D_Roundoff(st_mast.st_alloc);
	st_mast.st_on_hand 	= D_Roundoff(st_mast.st_on_hand);
	st_mast.st_m_rec 	= D_Roundoff(st_mast.st_m_rec);
	st_mast.st_y_rec 	= D_Roundoff(st_mast.st_y_rec);
	st_mast.st_on_order 	= D_Roundoff(st_mast.st_on_order);
	st_mast.st_paidfor 	= D_Roundoff(st_mast.st_paidfor);
	st_mast.st_value 	= D_Roundoff(st_mast.st_value);
	/*******************************************************/
	/* Don't Round st_rate because it is an average        */
	/* st_mast.st_rate 	= D_Roundoff(st_mast.st_rate); */
	/*******************************************************/
	st_mast.st_m_iss 	= D_Roundoff(st_mast.st_m_iss);
	st_mast.st_y_iss 	= D_Roundoff(st_mast.st_y_iss);
	st_mast.st_m_adj 	= D_Roundoff(st_mast.st_m_adj);
	st_mast.st_y_adj 	= D_Roundoff(st_mast.st_y_adj);
	
	/* Write the stock master record */
	retval = put_stmast( &st_mast, UPDATE, e_mesg );
	if( retval!=NOERROR ){
		DispError();
		roll_back(e_mesg);
		return(retval);
	}
	/*   Perform Rounding function on item 
		defined double		*/
	st_tran.st_amount 	= D_Roundoff(st_tran.st_amount);
	st_tran.st_qty		= D_Roundoff(st_tran.st_qty); 


	for ( ; ; ) {
		st_tmp.st_date = st_tran.st_date ;
		STRCPY( st_tmp.st_type, st_tran.st_type);
		st_tmp.st_seq_no = st_tran.st_seq_no;

		retval = get_sttran( &st_tmp, BROWSE,0, e_mesg );

		if(retval<0) {
			if(retval!=UNDEF) {
				DispError();
				roll_back(e_mesg);
				return(retval);
			}
		}
		else
			st_tran.st_seq_no++;

		/* Write the stock transaction record */
		retval = put_sttran( &st_tran, ADD, e_mesg );
		if( retval!=NOERROR ){
			if(retval==DUPE) {
				st_tran.st_seq_no++;
				continue;
			}
			DispError();
			roll_back(e_mesg);
			return(retval);
		}
		if(retval==NOERROR) {
			s_rec.s_trsno = st_tran.st_seq_no;
			if( WriteFields(SNO_FLD,SNO_FLD)<0 )
				return(-1);
 			break;
		}
	}
	/* Commit to the data base */
	if( commit(e_mesg)<0 ){
		fomen(e_mesg);get();
		return(-1);
	}
	return(0);
}
/* 	Check the issue qty: Disallow if the issue leaves any negative balances.

	If issue exceeds allocated qty or if there isn't allocation, consider
	the priorities:
	Don't issue if the stock_on_hand is allocated for anyone else 
*/
CheckIssueQty()
{
	Alloc_rec	a_rec;
	double	prior_alloc = 0.0, diff=0.0; 
	double	extraRequested = 0.0, extraAvailable=0.0;

	alloc_qty = 0.0;	/* Global variable */
	/* Used in decrementing total allocated in stock master while updating
	   it */

	extraAvailable = st_mast.st_on_hand-st_mast.st_alloc;
	if( extraAvailable<DELTA_DIFF )
		extraAvailable=0.0;

	/* Check if any allocation is done for this key combination */
	alloc_rec.st_fund = s_rec.s_fund;
	STRCPY( alloc_rec.st_code, s_rec.s_stcode );
	alloc_rec.st_location = s_rec.s_locno;
	STRCPY( alloc_rec.st_expacc, s_rec.s_dbacc );
	if( get_alloc( &alloc_rec, BROWSE, 0, e_mesg )==NOERROR ){
		/* There is some allocation done earlier for this 
		   combination 
		*/
		AllocationRecord = PRESENT;

		a_rec.st_fund = s_rec.s_fund;
		STRCPY(a_rec.st_code,s_rec.s_stcode);
		a_rec.st_date = 0;
		a_rec.st_time = 0;
		flg_reset( ALLOCATION );

		/* Accumulate all the earlier allocated quantities for this
			stock in the variable prior_alloc, by scanning all the
			allocation records having earlier date/time stamp
		*/
		for( ; ; ){
			retval = get_n_alloc( &a_rec,BROWSE,1,FORWARD,e_mesg );
			if( retval==ERROR ){
				DispError();
				roll_back(e_mesg);
				return(-1);
			}
			else if( retval==EFL )
				break;
			else if( a_rec.st_fund!=s_rec.s_fund ||
				strcmp( a_rec.st_code, s_rec.s_stcode ) )
				break;
			else if( !strcmp(a_rec.st_expacc,s_rec.s_dbacc)
				&& a_rec.st_location==s_rec.s_locno )
				break;

			prior_alloc += a_rec.st_alloc;
		}
		seq_over( ALLOCATION );
		if( s_rec.s_qty>alloc_rec.st_alloc )
			extraRequested = s_rec.s_qty-alloc_rec.st_alloc;
		
		if( prior_alloc<st_mast.st_on_hand ){
		/* Prior allocations do not exceed stock on hand */
		    if( extraRequested<=DELTA_DIFF ){
			if( prior_alloc+s_rec.s_qty <= st_mast.st_on_hand ){
					/* Issue can be made */
				alloc_qty = s_rec.s_qty;
				s_rec.s_amount = s_rec.s_qty*st_mast.st_rate;
				return(0);
			}
			else{
			/*Issue of qty asked leaves negative stock on hand*/
#ifdef ENGLISH
				sprintf(e_mesg, "Only %lf can be issued!",
						st_mast.st_on_hand-prior_alloc);
#else
				sprintf(e_mesg, "Peut seulement emettre %lf!",
						st_mast.st_on_hand-prior_alloc);
#endif
				fomer(e_mesg);
				s_rec.s_qty=LV_DOUBLE;
			}
		    }
		    else if( extraRequested<=extraAvailable ){
			alloc_qty = alloc_rec.st_alloc;
			s_rec.s_amount = s_rec.s_qty*st_mast.st_rate;
			return(0);
		    }
		    else {	/* extra requested > extraAvailable */
			if( extraAvailable>0.0 ){
#ifdef ENGLISH
				sprintf(e_mesg,"Only %lf can be issued!",
					alloc_rec.st_alloc+extraAvailable);
#else
				sprintf(e_mesg,"Peut seulement emettre %lf!",
					alloc_rec.st_alloc+extraAvailable);
#endif
				fomer(e_mesg);
				s_rec.s_qty = LV_DOUBLE;
			}
			else{
				diff = st_mast.st_on_hand - prior_alloc;
#ifdef ENGLISH
				sprintf(e_mesg,"Only %lf can be issued!",
						(diff<alloc_rec.st_alloc)
#else
				sprintf(e_mesg,"Peut seulement emettre %lf!",
						(diff<alloc_rec.st_alloc)
#endif
						?	diff
						:	alloc_rec.st_alloc 
					);
				fomer(e_mesg);
				s_rec.s_qty = LV_DOUBLE;
			}
		    }
		}
		else{
#ifdef ENGLISH
			fomer("Stock reserved by others/not available! Press ESC-F"); 
#else
			fomer("Stock reserve par d'autres/pas disponible! Appuyer sur ESC-F");
#endif
			s_rec.s_qty=LV_DOUBLE;
		}
	}
	else{	/* No prior allocation is made for this request */
		AllocationRecord = ABSENT;
		extraAvailable = st_mast.st_on_hand - st_mast.st_alloc;
		if(extraAvailable>0.0 ){
			/* Qty on hand exceeds total allocated */

			if( s_rec.s_qty <= extraAvailable ){
				s_rec.s_amount = s_rec.s_qty * st_mast.st_rate;
				return(0);
			}
			else{
			/*Issue of requested qty leaves negative balance */
#ifdef ENGLISH
				sprintf(e_mesg, "Only %lf can be issued!",
						extraAvailable );
#else
				sprintf(e_mesg, "Peut seulement emettre %lf!",
						extraAvailable );
#endif
				fomer(e_mesg);
				s_rec.s_qty=LV_DOUBLE;
			}
		}
		else{
#ifdef ENGLISH
			fomer("Stock reserved by others/not available! Press ESC-F");
#else
			fomer("Stock reserve par d'autres/pas disponible! Appuyer sur ESC-F pour continuer");
#endif
			s_rec.s_qty=LV_DOUBLE;
		}
	}
	return(0);
}
/* 	Process for allocation type transaction */
ProcAllocations()
{
	/* If balance qty allocated is <=0  delete the allocation record 
	   else write the updated record
	*/
	if( mode==ADD ){
		alloc_rec.st_alloc = 0.0;
		alloc_rec.st_value = 0.0;
		alloc_rec.st_date = s_rec.s_trdate;
		alloc_rec.st_time = get_time();
	}
	alloc_rec.st_alloc += s_rec.s_qty;
	if( s_rec.s_qty<0.0 )
		alloc_rec.st_value -= s_rec.s_amount;
	else
		alloc_rec.st_value += s_rec.s_amount;
	if( alloc_rec.st_alloc<DELTA_DIFF )
		mode = P_DEL;
	/* Roundoff items that have calculated double values */
	alloc_rec.st_issued 	= D_Roundoff(alloc_rec.st_issued);
	alloc_rec.st_alloc 	= D_Roundoff(alloc_rec.st_alloc);
	alloc_rec.st_value 	= D_Roundoff(alloc_rec.st_value);

	retval = put_alloc( &alloc_rec, mode, e_mesg );
	if( retval!=NOERROR ){
		DispError();
		roll_back(e_mesg);
		return(retval);
	}

	/* Get the GL master record in UPDATE mode (Lock it) */
	if((retval=get_gl(&gl_rec,UPDATE,0,e_mesg))<0 ){
		DispError();
		roll_back(e_mesg);
		return(retval);
	}
	else {	/* Record obtained and locked */
		/* Modify commitments to date in the GL master */
		if( s_rec.s_qty < 0.0 ){
			gl_rec.comdat -= s_rec.s_amount;
			if( gl_rec.comdat<0.0 )
				gl_rec.comdat = 0.0;
		}
		else
			gl_rec.comdat += s_rec.s_amount;
	}

	/*  Round off double items that may have been calculated  */
	gl_rec.comdat	= D_Roundoff(gl_rec.comdat);
	gl_rec.curdb	= D_Roundoff(gl_rec.curdb);
	gl_rec.curcr	= D_Roundoff(gl_rec.curcr);
	gl_rec.ytd	= D_Roundoff(gl_rec.ytd);




	/* Write GL master record */
	if( put_gl(&gl_rec,UPDATE,e_mesg)!=NOERROR ){
		DispError();
		roll_back(e_mesg);
		return(retval);
	}

	/* 	Update the stock master file	*/
	st_mast.st_alloc += s_rec.s_qty;
	if( st_mast.st_alloc<DELTA_DIFF )
		st_mast.st_alloc = 0.0;

	/* Fill the transaction record with the details */
	if( MakeSttran()<0 )
		return(retval);

	return(0);
}
/* 	Process for Receipt & Return to supplier  type transactions */
ProcReceipts()
{
	int	factor;		/* used for sign, negative or positive */

	if( tr_opt==RE )	/* Receipts from supplier */
		factor = 1;	/* to increment stock on hand */
	else			/* return to supplier */
		factor = -1;	/* to decrement stock on hand */
	
	/* Update the stock master record */
	st_mast.st_on_hand += factor * s_rec.s_qty;

	st_mast.st_m_rec += factor * s_rec.s_qty;
	st_mast.st_y_rec += factor * s_rec.s_qty;
	st_mast.st_on_order -= factor * s_rec.s_qty;
	if( aps_system==PRESENT )
		st_mast.st_paidfor -= factor * s_rec.s_qty;
	else if( aps_system==ABSENT ){
		st_mast.st_value += factor * s_rec.s_amount;
		if( st_mast.st_on_hand>DELTA_DIFF )
			st_mast.st_rate = st_mast.st_value/st_mast.st_on_hand;

		if((retval= WriteGlmast())<0 )	return(retval);
		if((retval= WriteTrhdr())<0 )	return(retval);
		if((retval= WriteTritems())<0 )	return(retval);

	/******************************************************************
	   If different funds are being used then we require two more items
	   for the duetofrom_acct
	******************************************************************/

		if(s_rec.s_fund != s_rec.s_fund2){
			if((retval= WriteTrhdr2())<0 )	
				return(retval);
			if((retval= WriteTritems2())<0 )			
				return(retval);
		}

	}
	if( tr_opt == RE ) 	/* date of last receipt from param date */
		st_mast.st_lastdate = get_date() ;

	/* Fill the transaction record with the details */
	if((retval= MakeSttran())<0 )
		return(retval);

	return(0);
}
/*	Write records for Order type transactione */
ProcOrders()
{
	/* Update the stock master */
	st_mast.st_on_order += s_rec.s_qty;
	if( st_mast.st_on_order<DELTA_DIFF )
		st_mast.st_on_order = 0.0;

	/* Fill the transaction record with details */
	if((retval= MakeSttran())<0 )
		return(retval);

	return(0);
}
/* 	Write records for Issue/Return from cost centre type transactions */
ProcIssues()
{
	/* Order of operations should not be changed */
	if((retval= MakeStmast())<0 )	return(retval);
	if((retval= WriteGlmast())<0 )	return(retval);
	if((retval= WriteTrhdr())<0 )	return(retval);
	if((retval= WriteTritems())<0 )	return(retval);

	/******************************************************************
	   If different funds are being used then we require two more items
	   for the duetofrom_acct
	******************************************************************/

	if(s_rec.s_fund != s_rec.s_fund2){
		if((retval= WriteTrhdr2())<0 )	
			return(retval);
		if((retval= WriteTritems2())<0 )		
			return(retval);
	}

	if( tr_opt==IS )
		if((retval= WriteAlloc())<0 )	return(retval);
	if((retval= MakeSttran())<0 )		return(retval);
	return(0);
}
MakeSttran()
{
	if(s_rec.s_fund==HV_SHORT)
		st_tran.st_fund=0;
	else
		st_tran.st_fund = s_rec.s_fund;
	if(s_rec.s_fund2==HV_SHORT)
		st_tran.st_fund2=0;
	else
		st_tran.st_fund2 = s_rec.s_fund2;
	STRCPY( st_tran.st_code , s_rec.s_stcode );
	if(s_rec.s_supp_cd[0]==HV_CHAR)
		st_tran.st_suppl_cd[0]='\0';
	else
		STRCPY( st_tran.st_suppl_cd, s_rec.s_supp_cd );
	if(s_rec.s_ref[0]==HV_CHAR)
		st_tran.st_ref[0]='\0';
	else
		STRCPY( st_tran.st_ref, s_rec.s_ref );

	if(s_rec.s_po_no == HV_LONG) 
		st_tran.st_po_no = 0;
	else
		st_tran.st_po_no = s_rec.s_po_no;

	st_tran.st_location = (s_rec.s_locno==HV_SHORT)
				?	0
				:	s_rec.s_locno;
	st_tran.st_period = (s_rec.s_period==HV_SHORT)
				?	0
				:	s_rec.s_period;
	if(s_rec.s_dbacc[0]==HV_CHAR)
		st_tran.st_db_acc[0]='\0';
	else
		STRCPY( st_tran.st_db_acc, s_rec.s_dbacc );
	if(s_rec.s_cracc[0]==HV_CHAR)
		st_tran.st_cr_acc[0]='\0';
	else
		STRCPY( st_tran.st_cr_acc, s_rec.s_cracc );
	st_tran.st_qty = (s_rec.s_qty==HV_DOUBLE)
				?	0
				:	s_rec.s_qty;
	st_tran.st_amount = (s_rec.s_amount==HV_DOUBLE)
				?	0
				:	s_rec.s_amount;
	STRCPY( st_tran.st_remarks, s_rec.s_remarks );
	return(0);
}
MakeStmast()
{
	int	option;
	double	qty, amt ;

	if( tr_opt==RT || tr_opt==WO )
		option = -1;
	else
		option = 1;
	if( tr_opt==IS || tr_opt==RT ){
		/* Decrement allocated qty in the stock master */
		if( tr_opt==IS )	
			st_mast.st_alloc -= option * alloc_qty;
		st_mast.st_on_hand -= option * s_rec.s_qty;
		st_mast.st_m_iss += option * s_rec.s_qty;
		st_mast.st_y_iss += option * s_rec.s_qty;
		st_mast.st_value -= option * s_rec.s_amount;
	}
	else if( tr_opt==AD ){
		st_mast.st_on_hand += s_rec.s_qty;
		st_mast.st_m_adj += s_rec.s_qty;
		st_mast.st_y_adj += s_rec.s_qty;
		st_mast.st_value += s_rec.s_amount;
	}
	else if( tr_opt==WO ){
		st_mast.st_on_hand += option * s_rec.s_qty;
		st_mast.st_m_adj += option * s_rec.s_qty;
		st_mast.st_y_adj += option * s_rec.s_qty;
		st_mast.st_value += option * s_rec.s_amount;
	}

	if( aps_system==ABSENT ) {
		qty = st_mast.st_on_hand;
		amt = st_mast.st_value ;
	}
	else
		if ( pa_rec.pa_poinv[0] == YES) {
			qty = st_mast.st_on_hand + st_mast.st_paidfor + 
				st_mast.st_po_ordqty;
			amt = st_mast.st_value + st_mast.st_committed ;
		}
		else {
			qty = st_mast.st_on_hand + st_mast.st_paidfor;
			amt = st_mast.st_value ;
		}

	if( qty > DELTA_DIFF )
		st_mast.st_rate = amt / qty;
	return(0);
}
WriteAlloc()
{
	int	write_mode = UPDATE;
	int	factor;
	double	amount, fraction_issued;

	if( tr_opt==IS )	factor = 1;
	/* This routine is called only if above condition is true */

	/* else			factor = -1; */

	alloc_rec.st_fund = s_rec.s_fund;
	STRCPY( alloc_rec.st_code, s_rec.s_stcode );
	alloc_rec.st_location = s_rec.s_locno;
	STRCPY( alloc_rec.st_expacc, s_rec.s_dbacc );
	if( (retval = get_alloc( &alloc_rec, UPDATE, 0, e_mesg ))==NOERROR ){
		fraction_issued = s_rec.s_qty/alloc_rec.st_alloc;
		if( tr_opt==IS && fraction_issued>1.0 )	
				fraction_issued = 1.0;

		alloc_rec.st_issued += factor * s_rec.s_qty;
		if( alloc_rec.st_issued<DELTA_DIFF )
			alloc_rec.st_issued = 0.0;
		alloc_rec.st_alloc -= factor * s_rec.s_qty;
		if( alloc_rec.st_alloc<DELTA_DIFF ){
			alloc_rec.st_alloc = 0.0;
			write_mode = P_DEL;
		}
		/* Value of balance to be changed proportionately */
		amount = factor * fraction_issued * alloc_rec.st_value;
		alloc_rec.st_value -= amount;
		/* Roundoff items that have calculated double values */
		alloc_rec.st_issued 	= D_Roundoff(alloc_rec.st_issued);
		alloc_rec.st_alloc 	= D_Roundoff(alloc_rec.st_alloc);
		alloc_rec.st_value 	= D_Roundoff(alloc_rec.st_value);

		/* Write the allocation record */
		if((retval=put_alloc( &alloc_rec, write_mode, e_mesg ))
				!=NOERROR ){
			DispError();
			roll_back(e_mesg);
			return(retval);
		}
	}
	else if(retval!=UNDEF){
		DispError();
		roll_back(e_mesg);
		return(retval);
	}
		
	return(0);
}

WriteTrhdr()
{
	long	sysdt ;
#ifdef ORACLE
	long	sno, get_maxsno();
#endif
	tr_hdr.th_fund = s_rec.s_fund;
	tr_hdr.th_reccod = 99;
	tr_hdr.th_create[0] = 'G';

#ifndef ORACLE
	tr_hdr.th_seq_no = HV_SHORT;
	retval = get_n_trhdr( &tr_hdr, BROWSE, 0, BACKWARD, e_mesg );
	seq_over( GLTRHDR );
	if( retval==ERROR ){
		DispError();
		roll_back(e_mesg);
		return(-1);
	}
	if( retval==EFL || 
	    tr_hdr.th_fund != s_rec.s_fund ||	
	    tr_hdr.th_reccod != 99 || tr_hdr.th_create[0] != 'G' ){
		tr_hdr.th_fund = s_rec.s_fund;
		tr_hdr.th_reccod = 99;
		tr_hdr.th_create[0] = 'G';
		tr_hdr.th_seq_no = 1;
	}
	else
		tr_hdr.th_seq_no++;
#else
	sno = get_maxsno(GLTRHDR,(char *)&tr_hdr,0,-1,e_mesg);
	if(sno < 0) {
		DispError();
		roll_back(e_mesg);
		return(-1);
	}
	tr_hdr.th_seq_no = sno + 1;
#endif
	
	if(s_rec.s_fund != s_rec.s_fund2){
		fund1_seq_no = tr_hdr.th_seq_no;
	}

	STRCPY( tr_hdr.th_userid, User_Id );
	tr_hdr.th_sys_dt = sysdt = get_date() ;
	tr_hdr.th_period = s_rec.s_period;
	tr_hdr.th_date = s_rec.s_trdate;
	tr_hdr.th_debits = tr_hdr.th_credits = s_rec.s_amount;

	/*  Roundoff double items that have calculated values  */
	tr_hdr.th_debits 	= D_Roundoff(tr_hdr.th_debits);
	tr_hdr.th_credits 	= D_Roundoff(tr_hdr.th_credits);

	switch( tr_opt ){
		case RE:
#ifdef ENGLISH
			STRCPY(tr_hdr.th_descr,"Stock Receipts");
#else
			STRCPY(tr_hdr.th_descr,"Recus de stocks");
#endif
			break;
		case RS:
#ifdef ENGLISH
			STRCPY(tr_hdr.th_descr,"Returns to Supplier");
#else
			STRCPY(tr_hdr.th_descr,"Renvois au fournisseur");
#endif
			break;
		case IS:
#ifdef ENGLISH
			STRCPY(tr_hdr.th_descr,"Stock Issues");
#else
			STRCPY(tr_hdr.th_descr,"Emissions de stocks");
#endif
			break;
		case RT:
#ifdef ENGLISH
			STRCPY(tr_hdr.th_descr,"Stock Returns");
#else
			STRCPY(tr_hdr.th_descr,"Renvois de stocks");
#endif
			break;
		case AD:
#ifdef ENGLISH
			STRCPY(tr_hdr.th_descr,"Stock Adjustments");
#else
			STRCPY(tr_hdr.th_descr,"Ajustements de stocks");
#endif
			break;
		case WO:
#ifdef ENGLISH
			STRCPY(tr_hdr.th_descr,"Stock Written off");
#else
			STRCPY(tr_hdr.th_descr,"Radiations de stocks");
#endif
			break;
	}
	sprintf(tr_hdr.th_reference, "%s-%d", s_rec.s_trtype, s_rec.s_trsno) ;
	tr_hdr.th_supp_cd[0] = '\0';
	tr_hdr.th_type[0] = 'I';

	for( ; ; ) {
		tr_tmp.th_fund = tr_hdr.th_fund ;
		tr_tmp.th_reccod = tr_hdr.th_reccod ;
		tr_tmp.th_create[0] = tr_hdr.th_create[0] ;
		tr_tmp.th_seq_no = tr_hdr.th_seq_no ;

		retval = get_trhdr( &tr_tmp, BROWSE,0,e_mesg );
		if(retval<0) {
			if( retval!=UNDEF ) {
				DispError();
				roll_back(e_mesg);
				return(retval);
			}
		}
		else 
			tr_hdr.th_seq_no++;

		retval = put_trhdr( &tr_hdr, ADD, e_mesg );
		if(retval<0) {
			if(retval==DUPE) {
				tr_hdr.th_seq_no++;
				continue;
			}
			DispError();
			roll_back(e_mesg);
			return(retval);
		}
		if(retval==NOERROR) break;
	}
	return(0);
}

/*************************************************************************
 Write a new header record if Cr Fund not equal to the Db Fund then write
 a new header record with the Cr Fund number but all other keys the same
 as before 
*************************************************************************/


WriteTrhdr2()
{
	long	sysdt ;
#ifdef ORACLE
	long	sno, get_maxsno();
#endif

	tr_hdr.th_fund = s_rec.s_fund2;
	tr_hdr.th_reccod = 99;
	tr_hdr.th_create[0] = 'G';
	
#ifndef ORACLE
	tr_hdr.th_seq_no = HV_SHORT;
	retval = get_n_trhdr( &tr_hdr, BROWSE, 0, BACKWARD, e_mesg );
	seq_over( GLTRHDR );
	if( retval==ERROR ){
		DispError();
		roll_back(e_mesg);
		return(-1);
	}
	if( retval==EFL || 
	    tr_hdr.th_fund != s_rec.s_fund2 ||	
	    tr_hdr.th_reccod != 99 || tr_hdr.th_create[0] != 'G' ){
		tr_hdr.th_fund = s_rec.s_fund2;
		tr_hdr.th_reccod = 99;
		tr_hdr.th_create[0] = 'G';
		tr_hdr.th_seq_no = 1;
	}
	else
		tr_hdr.th_seq_no++;
#else
	sno = get_maxsno(GLTRHDR,(char *)&tr_hdr,0,-1,e_mesg);
	if(sno < 0) {
		DispError();
		roll_back(e_mesg);
		return(-1);
	}
	tr_hdr.th_seq_no = sno + 1;
#endif
	
	STRCPY( tr_hdr.th_userid, User_Id );
	tr_hdr.th_sys_dt = sysdt = get_date() ;
	tr_hdr.th_period = s_rec.s_period;
	tr_hdr.th_date = s_rec.s_trdate;
	tr_hdr.th_debits = tr_hdr.th_credits = s_rec.s_amount;

	/*  Roundoff double items that have calculated values  */
	tr_hdr.th_debits 	= D_Roundoff(tr_hdr.th_debits);
	tr_hdr.th_credits 	= D_Roundoff(tr_hdr.th_credits);

	switch( tr_opt ){
		case RE:
#ifdef ENGLISH
			STRCPY(tr_hdr.th_descr,"Stock Receipts");
#else
			STRCPY(tr_hdr.th_descr,"Recus de stocks");
#endif
			break;
		case RS:
#ifdef ENGLISH
			STRCPY(tr_hdr.th_descr,"Returns to Supplier");
#else
			STRCPY(tr_hdr.th_descr,"Renvois au fournisseur");
#endif
			break;
		case IS:
#ifdef ENGLISH
			STRCPY(tr_hdr.th_descr,"Stock Issues");
#else
			STRCPY(tr_hdr.th_descr,"Emissions de stocks");
#endif
			break;
		case RT:
#ifdef ENGLISH
			STRCPY(tr_hdr.th_descr,"Stock Returns");
#else
			STRCPY(tr_hdr.th_descr,"Renvois de stocks");
#endif
			break;
		case AD:
#ifdef ENGLISH
			STRCPY(tr_hdr.th_descr,"Stock Adjustments");
#else
			STRCPY(tr_hdr.th_descr,"Ajustements de stocks");
#endif
			break;
		case WO:
#ifdef ENGLISH
			STRCPY(tr_hdr.th_descr,"Stock Written off");
#else
			STRCPY(tr_hdr.th_descr,"Radiations de stocks");
#endif
			break;
	}
	sprintf(tr_hdr.th_reference, "%s-%d", s_rec.s_trtype, s_rec.s_trsno) ;
	tr_hdr.th_supp_cd[0] = '\0';
	tr_hdr.th_type[0] = 'I';

	for( ; ; ) {
		tr_tmp.th_fund = tr_hdr.th_fund ;
		tr_tmp.th_reccod = tr_hdr.th_reccod ;
		tr_tmp.th_create[0] = tr_hdr.th_create[0] ;
		tr_tmp.th_seq_no = tr_hdr.th_seq_no ;

		retval = get_trhdr( &tr_tmp, BROWSE,0,e_mesg );
		if(retval<0) {
			if( retval!=UNDEF ) {
				DispError();
				roll_back(e_mesg);
				return(retval);
			}
		}
		else 
			tr_hdr.th_seq_no++;

		retval = put_trhdr( &tr_hdr, ADD, e_mesg );
		if(retval<0) {
			if(retval==DUPE) {
				tr_hdr.th_seq_no++;
				continue;
			}
			DispError();
			roll_back(e_mesg);
			return(retval);
		}
		if(retval==NOERROR) break;
	}

	return(0);
}


WriteTritems()
{
	tr_item.ti_fund = tr_hdr.th_fund;
	tr_item.ti_reccod = tr_hdr.th_reccod;
	tr_item.ti_create[0] = 'G';
	tr_item.ti_seq_no = tr_hdr.th_seq_no;
	tr_item.ti_item_no = 1;
	tr_item.ti_sys_dt = tr_hdr.th_sys_dt;
	tr_item.ti_period = tr_hdr.th_period;
	STRCPY(tr_item.ti_accno,s_rec.s_dbacc);
	tr_item.ti_amount = s_rec.s_amount;
	tr_item.ti_status = 0;

	tr_item.ti_section = Dbacc_sect;

	/* Roundoff ti_amount which is double	*/
	tr_item.ti_amount = D_Roundoff(tr_item.ti_amount);

	if( put_tritem(&tr_item, ADD, e_mesg)<0 ){
		DispError();
		roll_back(e_mesg);
		return(-1);
	}

	tr_item.ti_item_no = 2;
	if(s_rec.s_fund != s_rec.s_fund2)
		STRCPY(tr_item.ti_accno, Crfund_dtf); /* duetofrom acct# for Cr Fund */
	else
		STRCPY(tr_item.ti_accno,s_rec.s_cracc);
	tr_item.ti_amount = -s_rec.s_amount;

	tr_item.ti_section = Crdue_sect;

	/* Roundoff ti_amount which is double	*/
	tr_item.ti_amount = D_Roundoff(tr_item.ti_amount);

	if( put_tritem(&tr_item, ADD, e_mesg)<0 ){
		DispError();
		roll_back(e_mesg);
		return(-1);
	}
	return(0);
}

/********************************************************************
  If the Cr Fund and Db Fund are not equal then there must be two 
  additional records written for both funds duetofrom_acct for the
  current trheader 
********************************************************************/

WriteTritems2()
{
	tr_item.ti_fund = tr_hdr.th_fund;
	tr_item.ti_reccod = tr_hdr.th_reccod;
	tr_item.ti_create[0] = 'G';
	tr_item.ti_seq_no = tr_hdr.th_seq_no;
	tr_item.ti_item_no = 3;
	tr_item.ti_sys_dt = tr_hdr.th_sys_dt;
	tr_item.ti_period = tr_hdr.th_period;
	
	STRCPY(tr_item.ti_accno, Dbfund_dtf); /* duetofrom acct# for Db Fund */
	tr_item.ti_amount = s_rec.s_amount;
	tr_item.ti_status = 0;

	tr_item.ti_section = Dbdue_sect;

	/* Roundoff ti_amount which is double	*/
	tr_item.ti_amount = D_Roundoff(tr_item.ti_amount);

	if( put_tritem(&tr_item, ADD, e_mesg)<0 ){
		DispError();
		roll_back(e_mesg);
		return(-1);
	}

	tr_item.ti_item_no = 4;
	STRCPY(tr_item.ti_accno,s_rec.s_cracc);
	tr_item.ti_amount = -s_rec.s_amount;
	
	tr_item.ti_section = Crdue_sect;

	/* Roundoff ti_amount which is double	*/
	tr_item.ti_amount = D_Roundoff(tr_item.ti_amount);

	if( put_tritem(&tr_item, ADD, e_mesg)<0 ){
		DispError();
		roll_back(e_mesg);
		return(-1);
	}
	return(0);
}

WriteGlmast()
{
	double	tempamount;

	gl_rec.funds = s_rec.s_fund;
	STRCPY( gl_rec.accno, s_rec.s_dbacc );
	gl_rec.reccod = 99;
	retval = get_gl( &gl_rec, UPDATE, 0, e_mesg );
	if( retval!=NOERROR ){
		DispError();
		roll_back(e_mesg);
		return(retval);
	}
	/* Change commitments to date only if stock was allocated */
	/* and if the transaction type is IS */
	if( tr_opt==IS && AllocationRecord==PRESENT ){
		/* if only partly issued, reduce commitments proportionately */
		if( s_rec.s_qty<alloc_rec.st_alloc ){
			tempamount = (s_rec.s_qty*alloc_rec.st_value)/
					alloc_rec.st_alloc;
			gl_rec.comdat -= tempamount;
			alloc_rec.st_value -= tempamount;
		}
		else{ /* reduce commitments by the value of allocation */
			gl_rec.comdat -= alloc_rec.st_value;
			alloc_rec.st_value = 0.0;
		}
		if( gl_rec.comdat<0.0 )
			gl_rec.comdat = 0.0;
	}
	Dbacc_sect = gl_rec.sect;  /* section of db acct : used in GL Xaction */
	gl_rec.curdb += s_rec.s_amount;
	gl_rec.ytd += s_rec.s_amount;
	gl_rec.currel[s_rec.s_period-1] += s_rec.s_amount;
	/*  Round off double items that may have been calculated  */
	gl_rec.comdat	= D_Roundoff(gl_rec.comdat);
	gl_rec.curdb	= D_Roundoff(gl_rec.curdb);
	gl_rec.curcr	= D_Roundoff(gl_rec.curcr);
	gl_rec.ytd	= D_Roundoff(gl_rec.ytd);
	gl_rec.currel[s_rec.s_period-1] =
		D_Roundoff(gl_rec.currel[s_rec.s_period-1]);

	retval = put_gl( &gl_rec, UPDATE, e_mesg );
	if( retval!=NOERROR ){
		DispError();
		roll_back(e_mesg);
		return(retval);
	}

	gl_rec.funds = s_rec.s_fund2;
	STRCPY( gl_rec.accno, s_rec.s_cracc );
	gl_rec.reccod = 99;
	retval = get_gl( &gl_rec, UPDATE, 0, e_mesg );
	if( retval!=NOERROR ){
		DispError();
		roll_back(e_mesg);
		return(retval);
	}
	Cracc_sect = gl_rec.sect;  /* section of cr acct : used in GL Xaction */
	gl_rec.curcr -= s_rec.s_amount;
	gl_rec.ytd -= s_rec.s_amount;
	gl_rec.currel[s_rec.s_period-1] -= s_rec.s_amount;
	/*  Round off double items that may have been calculated  */
	gl_rec.comdat	= D_Roundoff(gl_rec.comdat);
	gl_rec.curdb	= D_Roundoff(gl_rec.curdb);
	gl_rec.curcr	= D_Roundoff(gl_rec.curcr);
	gl_rec.ytd	= D_Roundoff(gl_rec.ytd);
	gl_rec.currel[s_rec.s_period-1] =
		D_Roundoff(gl_rec.currel[s_rec.s_period-1]);

	retval = put_gl( &gl_rec, UPDATE, e_mesg );
	if( retval!=NOERROR ){
		DispError();
		roll_back(e_mesg);
		return(retval);
	}

	if (s_rec.s_fund == s_rec.s_fund2) return(0);

	/**************************************************** 
	 if Cr Fund not equal to Db Fund then we must also 
	 perform the following reverse entries 
	 ****************************************************/

	/* read the ctl record for the duetofrom_acct number for the Db Fund */

	ctl_rec.fund = s_rec.s_fund;
	retval = get_ctl( &ctl_rec, BROWSE, 0, e_mesg );
	if( retval < 0 ){
		DispError();
		return(-1);
	}

	gl_rec.funds = s_rec.s_fund;
	STRCPY( gl_rec.accno, ctl_rec.duetofrom_acct );
	gl_rec.reccod = 99;
	retval = get_gl( &gl_rec, UPDATE, 0, e_mesg );
	if( retval!=NOERROR ){
		DispError();
		roll_back(e_mesg);
		return(retval);
	}

	/* reverse the transaction for the duetofrom acct for the fund */

	STRCPY(Crfund_dtf, ctl_rec.duetofrom_acct);
	Dbdue_sect = gl_rec.sect;  /* section of db due to from acct : 
						used in GL Xaction */
	gl_rec.curdb -= s_rec.s_amount;
	gl_rec.ytd -= s_rec.s_amount;
	gl_rec.currel[s_rec.s_period-1] -= s_rec.s_amount;
	/*  Round off double items that may have been calculated  */
	gl_rec.comdat	= D_Roundoff(gl_rec.comdat);
	gl_rec.curdb	= D_Roundoff(gl_rec.curdb);
	gl_rec.curcr	= D_Roundoff(gl_rec.curcr);
	gl_rec.ytd	= D_Roundoff(gl_rec.ytd);
	gl_rec.currel[s_rec.s_period-1] =
		D_Roundoff(gl_rec.currel[s_rec.s_period-1]);

	retval = put_gl( &gl_rec, UPDATE, e_mesg );
	if( retval!=NOERROR ){
		DispError();
		roll_back(e_mesg);
		return(retval);
	}


	/* read the ctl record for the duetofrom_acct number for the Cr Fund */

	ctl_rec.fund = s_rec.s_fund2;
	retval = get_ctl( &ctl_rec, BROWSE, 0, e_mesg );
	if( retval < 0 ){
		DispError();
		return(-1);
	}

	gl_rec.funds = s_rec.s_fund2;
	STRCPY( gl_rec.accno, ctl_rec.duetofrom_acct );
	gl_rec.reccod = 99;
	retval = get_gl( &gl_rec, UPDATE, 0, e_mesg );
	if( retval!=NOERROR ){
		DispError();
		roll_back(e_mesg);
		return(retval);
	}

	/* reverse the transaction for the duetofrom acct for the fund2 */

	STRCPY(Dbfund_dtf, ctl_rec.duetofrom_acct);
	Crdue_sect = gl_rec.sect;  /* section of cr due to from acct : 
						used in GL Xaction */
	gl_rec.curcr += s_rec.s_amount;
	gl_rec.ytd += s_rec.s_amount;
	gl_rec.currel[s_rec.s_period-1] += s_rec.s_amount;
	/*  Round off double items that may have been calculated  */
	gl_rec.comdat	= D_Roundoff(gl_rec.comdat);
	gl_rec.curdb	= D_Roundoff(gl_rec.curdb);
	gl_rec.curcr	= D_Roundoff(gl_rec.curcr);
	gl_rec.ytd	= D_Roundoff(gl_rec.ytd);
	gl_rec.currel[s_rec.s_period-1] =
		D_Roundoff(gl_rec.currel[s_rec.s_period-1]);

	retval = put_gl( &gl_rec, UPDATE, e_mesg );
	if( retval!=NOERROR ){
		DispError();
		roll_back(e_mesg);
		return(retval);
	}

	return(0);

}
ProcAdjustments()
{
	if((retval = MakeStmast())<0 )		return(retval);
	if((retval = WriteGlmast())<0 )		return(retval);
	if((retval = WriteTrhdr())<0 )		return(retval);
	if((retval = WriteTritems())<0)		return(retval);

	/******************************************************************
	   If different funds are being used then we require two more items
	   for the duetofrom_acct
	******************************************************************/

	if(s_rec.s_fund != s_rec.s_fund2){
		if((retval= WriteTrhdr2())<0 )	
			return(retval);
		if((retval = WriteTritems2())<0)	
			return(retval);
	}

	if((retval = MakeSttran())<0 )	return(retval);
	return(0);
}
	
Inquiry( access, direction )	/* Screen inquiry, random/sequential access */
int access, direction;		/* forward or backward direction */
{
	int retval;

	if( access==RANDOM ){
		retval = GetStKey();	/* Read the key values */
		if(retval==UNDEF || retval==ESCAPE)
			return(0);
	}
	else{
		retval = GetNextRec( direction );	/* Get next rec */
		if(retval==EFL)
			return(0);
	}
	if( retval==ERROR ){
		DispError();
		return(-1);
	}
	retval = DispRec();	/* Display the header & item records */
	if( retval<0 ) return(retval);

	return(0);
}
DispRec()	/* Get and display the header and item records */
{

	if(st_tran.st_fund == 0) 
		s_rec.s_fund = HV_SHORT;
	else
		s_rec.s_fund = st_tran.st_fund;
	if(st_tran.st_fund2 == 0) 
		s_rec.s_fund2 = HV_SHORT;
	else
		s_rec.s_fund2 = st_tran.st_fund2;
	STRCPY( s_rec.s_stcode, st_tran.st_code );
	STRCPY( s_rec.s_supp_cd, st_tran.st_suppl_cd );
	STRCPY( s_rec.s_ref, st_tran.st_ref );
	s_rec.s_po_no = st_tran.st_po_no;
	s_rec.s_locno = st_tran.st_location;
	s_rec.s_period = st_tran.st_period;
	STRCPY( s_rec.s_dbacc, st_tran.st_db_acc );
	STRCPY( s_rec.s_cracc, st_tran.st_cr_acc );
	s_rec.s_qty = st_tran.st_qty;
	s_rec.s_amount = st_tran.st_amount;
	STRCPY( s_rec.s_remarks, st_tran.st_remarks );

	if( SetTranOption()<0 )
		return(-1);
	if( MaskByType()<0 )
		return(-1);
	if( WriteFields(FUND_FLD,REMARK_FLD) < 0 )
		return(-1);
	return(0);
}
GetNextRec(direction)	/* Read the next record in the specified direction */
int	direction;
{
	int retval;
	
	if( flg_start(STTRAN)!=direction ){ 	/* file not in seq read mode */
		st_tran.st_date = s_rec.s_trdate;
		STRCPY( st_tran.st_type, s_rec.s_trtype );
		st_tran.st_seq_no = s_rec.s_trsno;
		if( direction==FORWARD )
			st_tran.st_seq_no++;
		else
			st_tran.st_seq_no--;
		flg_reset( STTRAN );
	}
	/* Read the next record from stmast file */
	retval = get_n_sttran( &st_tran, BROWSE, 0, direction, e_mesg );
#ifndef ORACLE
	seq_over( STTRAN );
#endif
	if( retval==EFL ){
#ifdef ENGLISH
		fomen("No More Records....");
#else
		fomen("Plus de Fiches....");
#endif
		get();
		flg_reset(STTRAN);
		return(EFL);
	}
	if( retval!=NOERROR ){
		fomen(e_mesg);	get();
		return(retval);
	}
	s_rec.s_trdate = st_tran.st_date; 
	STRCPY( s_rec.s_trtype, st_tran.st_type );
	s_rec.s_trsno = st_tran.st_seq_no;
	if( WriteFields(TRDATE_FLD,SNO_FLD)<0 )
		return(-1);
	return(0);
}
GetStKey()	/* Read the header key values, get terminal info ,read rec */
{
	int retval;

	/* Enable dup buffers for key */
	if( SetDupBuffers( TRDATE_FLD, SNO_FLD, 2 )<0 )
		return(-1);
	if( FillKeyFields(LOW)<0 )  return(-1);
	if( (retval=ReadFields(TRDATE_FLD,SNO_FLD))<0 ) return(-1);
	if( retval==ESCAPE )
		return(ESCAPE);

	st_tran.st_date = s_rec.s_trdate;
	STRCPY( st_tran.st_type, s_rec.s_trtype );
	st_tran.st_seq_no = s_rec.s_trsno;

	retval = get_sttran( &st_tran, BROWSE, 0, e_mesg );
	if( retval!=NOERROR ){
		fomer(e_mesg);
		get();
		return(retval);
	}
	return(0);
}
fund_default()
{

	s_rec.s_fund =1;
	s_rec.s_fund2 =1;
	fomca1(FUND_FLD,19,2);
	fomca1(FUND2_FLD,19,2);
	WriteFields(FUND_FLD,FUND2_FLD);
	/* Inventory is automatically run out of the 
		main fund which is always fund 1 */
	if(tr_opt == IS || tr_opt == WO) 
		s_rec.s_fund = LV_SHORT;
	else if(tr_opt == RT) 
		s_rec.s_fund2 = LV_SHORT;
	else if(tr_opt == RE || tr_opt == RS) {
		s_rec.s_fund = HV_SHORT;
		s_rec.s_fund2 = HV_SHORT;
	}
	else if(tr_opt == AL) {
		s_rec.s_fund = LV_SHORT;
		s_rec.s_fund2 = HV_SHORT;
	}
	else {
		s_rec.s_fund = LV_SHORT;
		s_rec.s_fund2 = LV_SHORT;
	}
	return(0);
}
