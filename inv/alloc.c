/******************************************************************************
		Sourcename    : alloc.c
		System        : Budgetary Financial system.
		Module        : Inventory system
		Sub-Module    : Allocations Maintenance
		Created on    : 89-09-06
		Created  By   : K HARISH.
		Cobol sources : 

HISTORY:
 Date           Programmer     Description of modification

1990/12/13      F.Tao          Change screen so that only displaying 2 decimal
			       place.
1990/12/28      F.Tao          Put error message on proper position.          

1991/02/06	P.Ralph		Default fund to 1

About the program:
	This program allows the user to scan the allocation file, which is
	maintained by the system. The allocation records are created and
	deleted by the system only. However, the user is allowed to view
	these transient records any time, for reference.
		An allocation record is created by the system by allocation
	transaction.
		An allocation record is deleted by the system when the 
	total quantity allocated for the cost-centre becomes 0, by virtue
	of stock issues, or -ve allocations.
******************************************************************************/
#include <stdio.h>

#define MAIN
#define MAINFL	ALLOCATION

#include <bfs_defs.h>
#include <bfs_recs.h>
#include <cfomstrc.h>

#define SYSTEM		"INVENTORY"
#define MOD_DATE	"23-JAN-90"
#define SCREEN_NAME	"allocate"
#define ITEMSPERPAGE 	15
#define LOW 		-1
#define HIGH 		 1
#define ESCAPE		12
#define ALLOC_ERROR	13
#define ADD_MODE	16
#define INQ_MODE	17
#define RANDOM  	18
#define SEQUENTIAL	19
#define PATH_FILE_SIZE	50
#define DELTA_AMT	0.0001
#define HL_CHAR(VAL)	(VAL==HIGH) ? HV_CHAR : LV_CHAR
#define ESC_F		(sr.retcode==RET_USER_ESC && \
			(sr.escchar[0]=='F'||sr.escchar[0]=='f'))
#define ESC_H		(sr.retcode==RET_USER_ESC && \
			(sr.escchar[0]=='H'||sr.escchar[0]=='h'))
#define NO_HLP_WIN	(sr.curfld!=600 && sr.curfld!=700 && sr.curfld!=800)

#ifdef ENGLISH
#define NEXT 		'N'
#define PREV 		'P'
#define INQUIRE 	'I'
#define EXITOPT 	'E'
#else
#define NEXT 		'S'
#define PREV 		'P'
#define INQUIRE 	'I'
#define EXITOPT 	'F'
#endif

#define	FUND_FLD	500

/* allocate.sth - header for C structure generated by PROFOM EDITOR */

struct	al_struct	{
	char	s_progname[11];	/* 100 program name */
	long	s_rundt;	/* 300 system date */
	char	s_fn[2];	/* 400 function */
	short	s_fund;		/* 500 fund */
	char	s_stcode[11];	/* 600 stock code */
	short	s_location;	/* 700 location/school */
	char	s_expacc[19];	/* 800 expense account */
	long	s_date;		/* 1100 date of allocation */
	short	s_time;		/* 1200 time of allocation */
	double 	s_issued;	/* 1300 qty issued */
	double	s_alloc;	/* 1400 balance of qty allocated */
	double 	s_value;	/* 1500 value of balance */
	char	s_mesg[78];	/* 1600 message field */
	char	s_resp[2];	/* 1700 response field */
};

struct al_struct	s_rec;		/* screen record */
struct stat_rec 	sr;		/* profom status record */
Alloc_rec	alloc_rec;	/* allocation record */

int retval;	/* Global variable to store function values */
char e_mesg[100]; /* to store error messages */
char disp_e_mesg[80];    /* store first 80 characters of error messages */

/* Initialize profom fields, call entry procedures */
main( argc, argv )
int argc;
char *argv[];
{
	strncpy( SYS_NAME, SYSTEM, 50 ); /* Module name */
	strncpy( CHNG_DATE, MOD_DATE, 10 );/* Last date of change */
	proc_switch( argc,argv,MAINFL ); 	/* process the switches */

	if( Initialize()<0 ) exit(-1);

	retval = Process();

	CleanExit();
}
CleanExit()
{
	/* clear and exit the screen , close files & exit program */
	/* free_audit(); */
	fomcs();
	fomrt();
	close_dbh();
	exit(retval);
}
Initialize()
{
	/* initialize the profom screen variables */
	STRCPY( sr.scrnam, NFM_PATH );
	strcat( sr.scrnam, SCREEN_NAME );
	STRCPY( sr.termnm, terminal );

	/* initialize the fields and the profom screen */
	if( FillScrHdg()<0 ) return(-1);
	if( FillKeyFields( LOW )<0 ) return(-1);
	if( FillNonKeyFlds( HIGH )<0 ) return(-1);
	if( FillMesgRespFlds( HIGH )<0 ) return(-1);
	if( InitProfom()<0 ){
		fomcs();
		fomrt();
		return(-1);
	}
	return(0);
}
/* initialize profom & screen */
InitProfom()
{
	fomin( &sr );		/* initialize profom */
	ret( err_chk(&sr) );	/* if profom error return */
	if( WriteFields(1,0)<0 )	return(-1);
	fomcf(1,1);		/* Enable snap-screen option */
	return(0);
}
/* Fill the screen heading fields, the program name and the date */
FillScrHdg()
{
	STRCPY( s_rec.s_progname, PROG_NAME );
	s_rec.s_rundt = get_date();
	return(0);
}
/* Fill the keyfields with high or low values */
FillKeyFields( value )
short value;
{
	s_rec.s_fund = value * HV_SHORT;
	s_rec.s_stcode[0] = HL_CHAR(value);
	s_rec.s_location = value * HV_SHORT;
	s_rec.s_expacc[0]	= HL_CHAR(value);

	return(0);
}
/* Fill the non key fields with high/low values */
FillNonKeyFlds( value )
short value;
{
	s_rec.s_date 		= value * HV_LONG;
	s_rec.s_time 		= value * HV_SHORT;
	s_rec.s_issued 		= value * HV_DOUBLE;
	s_rec.s_alloc 		= value * HV_DOUBLE;
	s_rec.s_value 		= value * HV_DOUBLE;

	return(0);
}
/* Fill the message and response fields with high or low values */
FillMesgRespFlds( value )
short value;
{
	s_rec.s_mesg[0] = HL_CHAR(value);
	s_rec.s_resp[0] = HL_CHAR(value);
	return(0);
}
/* Accept user's option and call the corresponding routine in a loop */
Process()
{
	int retval;

	s_rec.s_fund = 0;	/* initializing the key fields */
	s_rec.s_stcode[0] = '\0';/* useful if N(ext) option is selected first */
	s_rec.s_location = 0;
	s_rec.s_expacc[0] = '\0';
	for( ; ; ){
		if( ReadFunction()<0 ) return(-1);	/* user's option */
		switch( s_rec.s_fn[0] ){
			case NEXT:	/* show next Xaction list in sequence */
				CHKACC(retval,BROWSE,e_mesg);
				if( Inquiry(SEQUENTIAL,FORWARD)<0 ) 
					return(-1);
				break;
			case PREV:	/* show prev Xaction list in sequence */
				CHKACC(retval,BROWSE,e_mesg);
				if( Inquiry(SEQUENTIAL,BACKWARD)<0 ) 
					return(-1);
				break;
			case INQUIRE:	/* show selected Xaction list */
				CHKACC(retval,BROWSE,e_mesg);
				if( Inquiry(RANDOM,0)<0 ) 
					return(-1);
				break;
			case EXITOPT:	/* exit */
				return(0);
			default:
				break;
		}
		if( retval<0 ){
			strncpy(disp_e_mesg,e_mesg,78);
			fomen(disp_e_mesg);
			get();
		}
		if( retval==DBH_ERR )
			return(retval);
	}
}
ReadFunction()	/* Display options at the bottom and read entry */
{
#ifdef ENGLISH
	fomer("N(ext), P(rev), I(nquire), E(xit)");
#else
	fomer("S(uivant), P(recedent), I(nterroger), F(in)");
#endif
	sr.nextfld = 400;	/* Fn field number */
	fomrf( (char *)&s_rec );
	ret( err_chk(&sr) );
	return(0);
}
ReadFields(start,end)	/* read fields whose numbers range from start to end */
int start, end;		/* start and end fields */
{
	int retval;

	sr.nextfld = start;
	sr.endfld = end;
	for( ; ; ){
		fomrd( (char *)&s_rec );
		ret(err_chk(&sr));
		if( sr.retcode==RET_USER_ESC || sr.retcode==RET_VAL_CHK ){
			if( ESC_F ) return( ESCAPE );
			retval=Validate();
			if(retval<0 || retval==ESCAPE)
				return(retval);
			else
				continue;
		}
		break;
	}
	return(0);
}
WriteFields( start,end )/* write fields whose numbers range from start to end */
int start, end;
{
	sr.nextfld = start;
	sr.endfld = end;
	fomwr( (char *)&s_rec );
	ret( err_chk(&sr) );
	return(0);
}
Validate()	/* Validate the values entered by the user */
{
	short	reccod;

	switch( sr.curfld ){
		case 600:	/* stock code */
			if( ESC_H ){
				retval = stock_hlp( s_rec.s_fund,
							s_rec.s_stcode,6,13 );
				if( retval==DBH_ERR )
					return( retval );
				else if( retval>=0 )
					redraw();
			}
			break;
		case 700:	/* Location number */
			if( ESC_H ){
				retval = sch_hlp( &s_rec.s_location, 6,13 );
				if( retval==DBH_ERR )
					return( retval );
				else if( retval>=0 )
					redraw();
			}
			break;
		case 800:	/* account number of the item */
			if( ESC_H ){
				retval = gl_hlp( s_rec.s_fund,
						 s_rec.s_expacc,
						 &reccod,7,13 );
				if( retval==DBH_ERR )
					return( retval );
				else if( retval>=0 )
					redraw();
			}
			if( acnt_chk(s_rec.s_expacc)==ERROR ){
#ifdef ENGLISH
				fomer("Invalid Account number");
#else
				fomer("Numero de compte invalide");
#endif
				s_rec.s_expacc[0]=LV_CHAR;
				break;
			}
			/* Check if a record exists with given key */
			alloc_rec.st_fund = s_rec.s_fund;
			STRCPY( alloc_rec.st_code, s_rec.s_stcode );
			alloc_rec.st_location = s_rec.s_location;
			STRCPY( alloc_rec.st_expacc, s_rec.s_expacc );
			retval = get_alloc(&alloc_rec,BROWSE,0,e_mesg);
			if( retval!=NOERROR ){
				strncpy(disp_e_mesg,e_mesg,78);
				fomen(disp_e_mesg);
				get();
				return(ESCAPE);
			}
			break; 
		default:
			break;
	}
	sr.nextfld = sr.curfld;
	return(0);
}
DisplayMessage(mesg)	/* Display the given message in the message field */
char *mesg;
{
	STRCPY( s_rec.s_mesg, mesg );
	if( WriteFields(1600,1600)<0 )	return(-1);
	return(0);
}
HideMessage()	/* Hide the message field */
{
	if( FillMesgRespFlds(HIGH)<0 )	return(-1);
	if( WriteFields(1600,1700)<0 ) return(-1);
	return(0);
}
Inquiry( access, direction )	/* Screen inquiry, random/sequential */
int access, direction;		/* RANDOM, SEQUENTIAL accesses */
{
	int retval;

	if( access==RANDOM ){	/* Read key values and get the record */
		retval = GetRecord();
		if( retval==ESCAPE || retval==UNDEF )
			return( ESCAPE );
	}
	else{			/* Read the next record in sequence */
		retval = GetNextRec( direction );
		if(retval==EFL)	/* if end of file, don't do anything */
			return(0);
	}
	if( retval<0 ){
		strncpy(disp_e_mesg,e_mesg,78);
		fomen(disp_e_mesg);
		get();
		return(-1);
	}
	return(DisplayRecord());	/* Display the header & item records */
}
DisplayRecord()	/* Get and display the header and item records */
{
	/* Key fields already copied & displayed */
	/* Copy other fields from the file record to screen record */
	s_rec.s_date = alloc_rec.st_date ; 
	s_rec.s_time = alloc_rec.st_time ; 
	s_rec.s_issued = alloc_rec.st_issued ; 
	s_rec.s_alloc = alloc_rec.st_alloc ; 
	s_rec.s_value = alloc_rec.st_value ; 

	/* Write them on the screen */
	if( WriteFields(1100,1500) < 0 )
		return(-1);
	return(0);
}
GetNextRec(direction)	/* Read the next record in the specified direction */
int	direction;
{
	int retval;
	char *ptr;
	
	if(flg_start(ALLOCATION) != direction ){ /* file not in seq read mode */
		alloc_rec.st_fund = s_rec.s_fund;
		STRCPY( alloc_rec.st_code, s_rec.s_stcode );
		alloc_rec.st_location = s_rec.s_location;
		STRCPY( alloc_rec.st_expacc, s_rec.s_expacc );
		ptr = alloc_rec.st_expacc;
		inc_str( alloc_rec.st_expacc, sizeof(alloc_rec.st_expacc)-1,
					direction );
		flg_reset(ALLOCATION);
	}
	/* Read the next record from stmast file */
	retval = get_n_alloc( &alloc_rec, BROWSE, 0, direction, e_mesg );
#ifndef ORACLE
	seq_over( ALLOCATION );
#endif
	if( retval==EFL ){
#ifdef ENGLISH
		fomen("No More Records....");
#else
		fomen("Plus de fiches....");
#endif
		get();
		flg_reset(ALLOCATION);
		return(EFL);
	}
	if( retval!=NOERROR ){
		strncpy(disp_e_mesg,e_mesg,78);
		fomen(disp_e_mesg);
		get();
		return(retval);
	}

	/* Copy the key fields from the file record to screen record */
	s_rec.s_fund = alloc_rec.st_fund;
	STRCPY( s_rec.s_stcode, alloc_rec.st_code );
	s_rec.s_location = alloc_rec.st_location;
	STRCPY( s_rec.s_expacc, alloc_rec.st_expacc );
	if( WriteFields(500,800)<0 )
		return(-1);
	return(0);
}
GetRecord()	/* Read the header key values, get terminal info ,read rec */
{
	int retval;

	SetDupBuffers( 500, 800, 2 ) ;

	if( FillKeyFields(LOW)<0 )	return(-1);

	/* Record is read in Validate() routine */
	fund_default();
	if( (retval=ReadFields(500,800))<0 || retval==ESCAPE ) 
		return( retval );
	return(0);
}

SetDupBuffers( firstfld, lastfld, value )
int	firstfld, lastfld;	/* field numbers range */
int	value;			/* ENABLE or DISABLE */
{
	int i;

	for( i=firstfld; i<=lastfld; i+=100 )
		fomca1( i, 19, value);
	sr.nextfld = firstfld;
	sr.endfld = lastfld;
	fomud( (char *)&s_rec );
	ret( err_chk(&sr) );

	return( 0 );
}
fund_default()
{
	fomca1(FUND_FLD,19,2);
	s_rec.s_fund = 1;
	WriteFields(FUND_FLD,19,2);
	s_rec.s_fund = LV_SHORT;
}
