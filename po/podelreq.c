/*-----------------------------------------------------------------------
Source Name: podelete.c
System     : Accounts Payables.
Created  On: 10th September 89.
Created  By: CATHY BURNS.

DESCRIPTION:
	Program to cancel Purchase Orders.

MODIFICATIONS:        

Programmer     YY/MM/DD       Description of modification
J.PRESCOTT     90/05/31       Added Remove Item 
J.PRESCOTT     90/12/11       Added Gst & Pst calculations 
F.Tao	       90/12/12	      Clear message field after exit.   
C.Leadbeater   90/12/18	      Added D_Roundoff() for calculated double 
			      values where req'd before writing to files. 
J.Prescott     91/02/12       Changed Screen layout.
------------------------------------------------------------------------*/

#define	MAIN		/* Main program. This is to declare Switches */
#define MAINFL		POHDR			/* main file used */

#define	SYSTEM		"PURCHASE ORDER"	/* Sub System Name */
#define	MOD_DATE	"12-FEB-91"		/* Program Last Modified */

#include <stdio.h>
#include <cfomstrc.h>
#include <bfs_defs.h>
#include <bfs_recs.h>

#define	DELTA_AMT  0.005	/* To Check float and double values for zero */
#define	DELTA_QTY  0.00005	/* To Check float and double values for zero */

/* User Interface define constants */
#ifdef ENGLISH
#define ADDREC		'A'
#define REMOVEITEM	'R'
#define DELETE		'D'
#define INQUIRE		'I'
#define EXITOPT		'E'

#define	YES		'Y'
#define	NEXTPAGE	'N'
#define	PREVPAGE	'P'
#define	CANCEL		'C'
#define DELITEM		'D'
#define REVIVE		'R'

#define TAXABLE		'T'
#define EXEMPT		'E'

#define ACTIVE		"ACT"
#define DELETED		"DEL"
#else

#define ADDREC		'R'
#define DELETE		'E'
#define REMOVEITEM	'R'
#define INQUIRE		'I'
#define EXITOPT		'F'

#define	YES		'O'
#define	NEXTPAGE	'S'
#define	PREVPAGE	'P'
#define	CANCEL		'A'
#define DELITEM		'E'
#define REVIVE		'V'

#define TAXABLE		'T'
#define EXEMPT		'E'

#define ACTIVE		"ACT"
#define DELETED		"ELI"
#endif

/* PROFOM Releted declarations */

#define	SCR_NAME	"poreq"	/* PROFOM screen Name */

#define	PAGESIZE	2		/* No of Items */

/* PROFOM Screen STH file */

/* Field PROFOM numbers */

#define	HDR_ST_FLD	800	/* Header Start Field */
#define	HDR_END_FLD	2300	/* Header End Field */
#define	ITEM_ST_FLD	2400	/* Item 1 Start Field */
#define	END_FLD		9700	/* Last Field of the screen */
#define	STEP		1700	/* NO of fields diff. between 2 items */

/* HDR Fields */
#define	FN_FLD		400	/* Fn: */
#define	KEY_START	500	/* Supplier Cd: */
#define	KEY_END		500	/* Type: */
#define	CHG_FLD		600	/* Field: */
#define	SUPPCD_FLD	800	/* Supplier Cd: */
#define	PAYEE_FLD	900	/* Payee Cd: */
#define	POAMT_FLT	1000	/* Po amt */
#define	ENTRYDT_FLD	1100	/* Entry Dt: */
#define DUEDT_FLD	1200	/* Due Date */
#define	PERIOD_FLD	1400	/* Period: */
#define	FUND_FLD	1500	/* Fund: */
#define SHIPTO_FLD	1700	/* Ship To: */
#define	TYPE_FLD	1800	/* Type: */
#define ATT_FLD		2000	/* Contact Person */
#define	PAGENO_FLD	2200	/* Page#: */
#define COLHDG_FLD	2300
	
/* Item Fields. These numbers are difference between that field
   and the 1st fld within the item */
#define	ACNO_FLD	100
#define	STCKCD_FLD	200
#define UOM_FLD		300
#define	SCHOOL_FLD	400
#define DESC_FLD	500
#define ITM_STAT	600
#define	QTY_FLD		1000
#define	PRICE_FLD	1100
#define	NET_FLD		1200
#define OSQTY_FLD	1500
#define REQNO_FLD	1600

/* po.sth - header for C structure generated by PROFOM EDITOR */

typedef	struct	{	/* Start Fld 2400, Endfld 5700 and Step 1700 */

	short	s_sno;		/* NUMERIC 99 field 2400 */
	char	s_accno[19];	/* STRING XXXXXXXXXXXXXXXXXX Field 2500 */
	char	s_stck_cd[11];	/* STRING XXXXXXXXXX Field 2600 */
	char	s_uom[7];	/* STRING XXXXXX Field 2700 */
	short	s_school;	/* NUMERIC 99 Field 2800 */
	char	s_desc[61];	/* STRING X(60) Field 2900 */
	char	s_act_del[4];	/* STRING XXX Field 3000 */
	char	s_subhdg[2];	/* STRING X(60) Field 3100 */
	char	s_gst[2];	/* STRING XX Field 3200 */
	char	s_pst[2];	/* STRING XX Field 3300 */
	double	s_ord_qty;	/* NUMERIC 99999.9999 Field 3400 */
	double	s_unit_cost;	/* NUMERIC 99999.99 Field 3500 */
	double	s_net_amt;	/* NUMERIC 9999999.99 Field 3600 */
	double	s_value;	/* NUMERIC 9999999.99 Field 3700 */
	double	s_pd_amount;	/* NUMERIC 9999999.99 Field 3800 */
	double	s_os_qty;	/* NUMERIC 99999.9999 Field 3900 */
	long	s_reqno;	/* NUMERIC 999999999 Field 4000 */
}	S_item ;

typedef struct	{

	char	s_pgm[11];	/* STRING XXXXXXXXXX Field 100 */
	char	s_scrname[15]; 	/* STRING X(14) Field 200 */
	long	s_rundate;	/* DATE YYYYFMMFDD Field 300 */
	char	s_fn[2];	/* STRING X Field 400 */
	long	s_po_no;	/* NUMERIC 99999999 Field 500 */
	short	s_field;	/* NUMERIC 999 Field 600 */

	char	s_supp_cd[11];	/* STRING XXXXXXXXXX Field 700 */
	char	s_payee_cd[11];	/* STRING XXXXXXXXXX Field 800 */
	double  s_po_amt;	/* NUMERIC 99999999.99 Field 900 */
	long	s_entry_dt;	/* STRING XXXXXXXX Field 1000 */
	long	s_due_dt;	/* STRING XXXXXXXX Field 1100 */
	double  s_liq_amt;	/* NUMERIC 99999999.99 Field 1200 */
	short	s_period;	/* NUMERIC 99 Field 1300 */
	short	s_fund;		/* NUMERIC 999 Field 1400 */
	long	s_liq_dt;	/* STRING XXXXXXXX Field 1500 */
	short	s_shipto;	/* NUMERIC 99 Field 1600 */
	char	s_type[2];	/* STRING X Field 1700 */
	short	s_billto;	/* NUMERIC 99 Field 1800 */
	char	s_attention[16];/* STRING X(15) Field 1900 */
	char	s_status[2];	/* STRING X Field 2000 */
	short	s_page_no;	/* NUMERIC 99 Field 2100 */
	char	s_dummy1[2];	/* STRING X Field 2200 */

	S_item	s_items[PAGESIZE] ;	/* Start Fld 2400, End Fld 5700 and
					   Step 1700 */

	double	s_total_po;	/* NUMERIC  Field 5800 */
	double	s_total_itm;	/* NUMERIC  Field 5900 */
	double	s_total_diff;	/* NUMERIC  Field 6000 */

	char	s_mesg[78];	/* STRING X[77] Field 9600 */
	char	s_resp[2];	/* STRING X Field 9700 */
} s_struct;

static	short	gst_tax;
static	short	pst_tax;
static	short	rebate;
static	Tax_cal	tax_cal;

static	s_struct  s_sth;	/* PROFOM Screen Structure */
static	struct  stat_rec  sr;		/* PROFOM status rec */

static	Po_hdr		po_hdr ;	/* Purchase Order Header */
static  Po_item 	po_item ;	/* Purchase Order Item Record */
static	Po_hdr		pre_po ;	/* Purchase Order Header */
static  Po_item 	pre_item ;	/* Purchase Order Item Record */
static	Supplier	supplier ;	/* Supplier */
static	Pa_rec		pa_rec ;	/* Parameters Record */
static	Ctl_rec		ctl_rec ;	/* Fund/Control Record */
static	Gl_rec		gl_rec ;	/* Gl Master rec, for general purpose */
static	St_mast		stck_rec ;	/* Stock Master Rec */
static	Alloc_rec	aloc_rec ;	/* Stock Allocation Record */

static	char 	e_mesg[100];  		/* dbh will return err msg in this */
double	D_Roundoff();

/*
*	Doubly linked list to maintain invoice items. Each node in this list
*	conatins one page full of invoice items. This list is freed only at the
*	time of exiting program. 
*/

typedef	struct Page {

	S_item	Items[PAGESIZE] ;	/* Items information */
	short	PoItemNo[PAGESIZE] ;	/* Corresponding PO Item# */
	char	PoStatus[PAGESIZE] ;	/* Status Add, Change */
	struct	Page	*PrevPage ;	/* Ptr to Previous Page */
	struct	Page	*NextPage ;	/* Ptr to Next Page */
	short	NoItems ;		/* No of Items in this page */
	short	Pageno ;		/* Page Number */

}	Page ;

static	Page	*FirstPage,		/* Address of the First Page */
		*CurPage,		/* Address of the Active Page */
		*PoLast,		/* Address of Cur. PO Last page */
		*LastPage ;		/* Address of the Last page Memory
					   allocated */
static long	TotalItems ;		/* Total Items on PO */

void	free() ;
char	*malloc() ;
double	Commit_Calculation();
double	comdat; 

main(argc,argv)
int argc;
char *argv[];
{
	int 	retval;

	retval = Initialize(argc,argv);	/* Initialization routine */

	if (retval == NOERROR) retval = Process();

	CloseRtn();			/* return to menu */
	if (retval != NOERROR) exit(1);
	exit(0);
}

/*-------------------------------------------------------------------*/
/* Initialize PROFOM */

Initialize(argc, argv)
int	argc ;
char	*argv[] ;
{
	int	err ;

	/*
	*	Initialize DBH Environment
	*/
	strncpy(SYS_NAME,SYSTEM,50);	/* Sub system name */
	strncpy(CHNG_DATE,MOD_DATE,10);	/* Modification Date */

	proc_switch(argc, argv, MAINFL) ; 	/* Process Switches */

	/*
	*	Initialize PROFOM & Screen
	*/
	STRCPY(sr.termnm,terminal);	/* Copy Terminal Name */
	fomin(&sr);
	ret(err_chk(&sr)) ;		/* Check for PROFOM Error */
	fomcf(1,1);			/* Enable Snap screen option */

	err = InitScreen() ;		/* Initialize Screen */
	if(NOERROR != err) return(err) ;

	/*
	*	Get The Parameter Record
	*/
	err = get_param(&pa_rec, BROWSE, 1, e_mesg) ;
	if(err == ERROR) {
		DispError(e_mesg);
		return(ERROR) ;
	}
	else if(err == UNDEF) {
#ifdef ENGLISH
                DispError("Parameters are not setup..");
#else
                DispError("Parametres ne sont pas etablis..");
#endif
		return(ERROR) ;
	}

	/*
	*	Initialize Variables
	*/

	FirstPage = NULL ;
	LastPage  = NULL ;

	return(NOERROR) ;
}	/* Initialize() */

/*--------------------------------------------------------------------------*/
/* Close nessary files and environment before exiting program               */

CloseRtn() 
{
	/* Free the linked list from the end */

	/* Free all the pages except the first page */
	for( ; LastPage != FirstPage ; ) {
		LastPage = LastPage->PrevPage ;
		free((char*)LastPage->NextPage) ;
		LastPage->NextPage = NULL ;
	}
	if(FirstPage != NULL)
		free((char*)FirstPage) ;
		
	FirstPage = LastPage = NULL ;

	/* Set terminal back to normal mode from PROFOM */
	fomcs();
	fomrt();

	close_dbh();	/* Close files */

	return(NOERROR);
}	/* CloseRtn() */
/*----------------------------------------------------------------*/
/* Initialize screen before going to process options */

InitScreen()
{
	int	err ;

	/* move screen name to Profom status structure */
	STRCPY(sr.scrnam,NFM_PATH);
	strcat(sr.scrnam,SCR_NAME) ;

	STRCPY(s_sth.s_pgm,PROG_NAME);
#ifdef ENGLISH
	STRCPY(s_sth.s_scrname, " PO  DELETION ");
#else
	STRCPY(s_sth.s_scrname, "ELIMINATION BC");
#endif
	s_sth.s_rundate = get_date();	/* get Today's Date in YYYYMMDD format*/
	s_sth.s_field = HV_SHORT ;
	s_sth.s_mesg[0] = HV_CHAR ;
	s_sth.s_resp[0] = HV_CHAR ;

	/* Initialize Key Fields. So that, if user selectes 'N' option
	   immediately after invoking program, then he gets the first
	   record in the file */

	s_sth.s_po_no = 0 ;

	/* Move High Values to data fields and Display the screen */
	err = ClearScreen() ;
	if(NOERROR != err) return(err) ;

	return(NOERROR) ;
}	/* InitScreen() */

/*-------------------------------------------------------------------*/
/* Get Option from user and call corresponding function */

Process()
{
	int err;

	for( ; ; ){

		/* Get the Fn: option from the user */
		if((err = ReadFunction()) != NOERROR) return(err) ;

		err = ProcFunction() ;	/* Process Function */

		if(QUIT == err)		return(NOERROR) ;    /* Exit */
		if(PROFOM_ERR == err)	return(PROFOM_ERR);  /* PROFOM ERROR */
		if(DBH_ERR == err) {
			DispError(e_mesg);
#ifdef ENGLISH
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"System Error... Iserror:",
				iserror, dberror, errno);
#else
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"Erreur du systeme... Iserror:",
				iserror, dberror, errno);
#endif
			DispError(e_mesg);
			return(DBH_ERR); /* DBH ERROR */
		}
		/* Clear message field.    XXXX */
		s_sth.s_mesg[0] = HV_CHAR ;
		ShowMesg();
	}      /*   end of the for( ; ; )       */
}	/* Process() */
/*----------------------------------------------------------------*/
/* Display the Function (Fn:) options and get the option from the user */

ReadFunction()
{
	/* Display Fn: options */
#ifdef ENGLISH
	fomer("D(elete), R(emove Item), I(nquire), N(ext), P(rev), E(xit)");
#else
	fomer("E(liminer), R(etirer article), I(nterroger), S(uivant), P(recedent), F(in)");
#endif
	/* Read Fn: field to get the option */
	sr.nextfld = FN_FLD ;
	fomrf( (char *)&s_sth );
	ret(err_chk(&sr));	/* Check for PROFOM error */

	return(NOERROR) ;
}	/* ReadFunction() */
/*----------------------------------------------------------------*/
/* Process the user selected Fn: option */

ProcFunction()
{
	int retval;

	switch (s_sth.s_fn[0]) {
	case DELETE  :			/* Delete */
		CHKACC(retval,P_DEL,e_mesg);
		return( DeletePo() ) ;
	case REMOVEITEM  :
		CHKACC(retval,UPDATE,e_mesg);
		return( RemoveItem() ) ;
	case INQUIRE  :			/* Inquire Po */
		CHKACC(retval,BROWSE,e_mesg);
		return( InquirePo() ) ;
	case NEXTPAGE  :			/* Next Po */
		CHKACC(retval,BROWSE,e_mesg);
		return( NextPo(FORWARD) ) ;
	case PREVPAGE  :			/* Previous Po */
		CHKACC(retval,BROWSE,e_mesg);
		return( NextPo(BACKWARD) ) ;
	case EXITOPT  :			/* Exit */
		return( QUIT ) ;
	}  /*   end of the switch statement */

	return(retval);
}	/* ProcFunction() */
/*-----------------------------------------------------------------------*/
/* Show the user given keys Po */

DeletePo()
{
	int	err ;

	err = SelectPo(UPDATE) ;
	if(NOERROR != err) return(err) ;

	if( po_hdr.ph_status[0] == COMPLETE) {
#ifdef ENGLISH
	    fomen("Status is complete. This will be purged automatically at Period Close");
#else
	    fomen("Etat complete. Sera efface automatiquement a la fermeture de la periode");
#endif
	    get() ;
	    return(NOERROR) ;
	}

	for( ; ; ) {
		err = CheckFund(s_sth.s_fund) ;
		if(err < 0) return(err) ;

		err = ConfirmItems() ;
		if(err != YES) {
			roll_back(e_mesg);
			return(err) ;
		}
		err = WriteRecords() ;
		if( err == NOERROR ) break; 
		if( err == LOCKED) {
			roll_back(e_mesg) ;
			continue ;
		}
		if (err < 0) return(err) ;
		/* Move High Values to data fields and Display the screen */
	}
	err = ClearScreen() ;
	
	WriteFields(KEY_START,KEY_END);
	return(NOERROR) ;
}	/* DeletePo() */
/*-----------------------------------------------------------------------*/
/* Show the user given keys Po */

RemoveItem()
{
	int	err ;

	err = SelectPo(UPDATE) ;
	if(NOERROR != err) return(err) ;

	if( po_hdr.ph_status[0] == COMPLETE) {
#ifdef ENGLISH
	    fomen("Status is complete. No Items can be removed");
#else
	    fomen("Etat complete. Articles ne peuvent pas etre enleves");
#endif
	    get() ;
	    return(NOERROR) ;
	}

	if( TotalItems == 1) {
#ifdef ENGLISH
	    fomen("Cannot Remove the Only Item on PO");
#else
	    fomen("Ne peut pas retirer le seul article du BC");
#endif
	    get();
	    return(NOERROR);
	}

	for( ; ; ) {
		err = CheckFund(s_sth.s_fund) ;
		if(err < 0) return(err) ;

		err = ConfirmItems() ;
		if(err != YES) {
			roll_back(e_mesg);
			return(err) ;
		}

		err = WriteRecords() ;
		if( err == NOERROR ) break; 
		if( err == LOCKED) {
			roll_back(e_mesg) ;
			continue ;
		}
		if (err < 0) return(err) ;
	}

	err = ClearScreen() ;
	return(NOERROR) ;
}	/* RemoveItem() */
/*-----------------------------------------------------------------------*/
/* Show the user given keys Po */

InquirePo()
{
	int	err ;

	err = SelectPo(BROWSE) ;
	if(NOERROR != err) return(err) ;

	err = ConfirmItems() ;
	if(err < 0) return(err) ;

	return(NOERROR) ;
}	/* InquirePo() */
/*----------------------------------------------------------*/
/* Show the next or previous Po */

NextPo(direction)
int	direction ;
{
	int err;

	/* Check whether file is in seq. read mode */
	if(flg_start(POHDR) != direction) {
		po_hdr.ph_code = s_sth.s_po_no;
		if (direction == FORWARD)
			po_hdr.ph_code++ ;
		else	po_hdr.ph_code-- ;
		flg_reset(POHDR);
	}

	err = get_n_pohdr(&po_hdr, BROWSE, 0, direction, e_mesg);
#ifndef ORACLE
	seq_over(POHDR);
#endif
	if(ERROR == err)return(DBH_ERR) ;
	if(EFL == err) {
#ifdef	ENGLISH
		fomen("No More Records....");
#else
		fomen("Plus de fiches....");
#endif
		get();
		flg_reset(POHDR);
		return(NOERROR) ;
	}

	return( ShowPo() ) ;
}	/* NextPo() */
/*----------------------------------------------------------*/
/* Get the Po key and show the invoice */

SelectPo(md)
int	md ;	/* UPDATE or BROWSE. UPDATE locks the invoice */
{
	int	err ;

	for(; ;){
		err = ReadKey();
		if(err != NOERROR) return(err) ;

		/* Get the record from database */
		err = GetPoHdr(md);
		if(ERROR == err) return(DBH_ERR) ;
		if(err < 0) {		/* UNDEF or LOCKED */
			fomer(e_mesg) ;
			get() ;
			continue ;
		}

		return( ShowPo() ) ;
	}
}	/* SelectPo() */
/*----------------------------------------------------------------------*/
/* Get the Item to delete from the user.				*/ 
SelectItem(item_status)
char	*item_status;
{

	if(TotalItems == 1 && strcmp(item_status,DELETED)==0) {
#ifdef ENGLISH
		fomer("Cannot Remove All Items From PO");
#else
		fomer("Ne peut pas enlever tous les articles du BC");
#endif
		get();
	}
	for( ; ; ) {
		/* Cannot remove all items */
		if(TotalItems == 1 && strcmp(item_status,DELETED)==0) {
			 break;
		}
#ifdef ENGLISH
		STRCPY(s_sth.s_mesg,"Enter RETURN to terminate Edit");
#else
		STRCPY(s_sth.s_mesg,"Appuyer sur RETURN pour terminer l'ajustement");
#endif
		ShowMesg() ;
		sr.nextfld = CHG_FLD ;
		fomrf( (char *)&s_sth );
		ret(err_chk(&sr));

		if(s_sth.s_field == 0) break ;
		if( s_sth.s_field < 1 || CurPage == NULL ||
				s_sth.s_field > CurPage->NoItems)
			continue ;

		if(strcmp(CurPage->Items[s_sth.s_field-1].s_act_del,
		  					 item_status)==0) {
			continue;
		}

		if(CurPage->Items[s_sth.s_field-1].s_pd_amount > DELTA_AMT) {
#ifdef ENGLISH
			fomer("Cannot Remove Item because amount already paid");
#else
			fomer("Ne peut pas enlever l'article parce que le montant est deja paye");
#endif
			get();
			break;
		}

		STRCPY(s_sth.s_items[s_sth.s_field-1].s_act_del,item_status);	
		STRCPY(CurPage->Items[s_sth.s_field-1].s_act_del,item_status);	
		sr.nextfld = ITEM_ST_FLD + (STEP * (s_sth.s_field-1))+ITM_STAT;
		fomwf( (char *)&s_sth );
		ret(err_chk(&sr));
		
		if(strcmp(item_status,ACTIVE) == 0) {
			TotalItems++;
			CurPage->PoStatus[s_sth.s_field-1] = ' ';
		}
		else {
			TotalItems--;
			CurPage->PoStatus[s_sth.s_field-1] = 'R';
		}
	}

	sr.nextfld = CHG_FLD ;
	s_sth.s_field = HV_SHORT ;
	fomwf( (char *)&s_sth );
	ret(err_chk(&sr));

	s_sth.s_mesg[0] = HV_CHAR;
	ShowMesg();

	return(NOERROR);
}	/* SelectItem() */
/*----------------------------------------------------------------------*/
/* Get the invoice key from user. In ADD mode disable dup buffers, other
   modes enable dup buffers and show the current key as a default key */

ReadKey()
{
	int	i;
	long	po_no;

	for(i = KEY_START ; i <= KEY_END ; i += 100)
		fomca1(i,19,1) ;

	sr.nextfld = KEY_START;
	sr.endfld = KEY_END;
	fomud((char*)&s_sth);	/* Update Dup Buffers */

	/* Store fields to copy back when user gives ESC-F */
	po_no = s_sth.s_po_no ;

	s_sth.s_po_no = LV_LONG ;

#ifdef ENGLISH
	STRCPY(s_sth.s_mesg,"Press ESC-F to Go Back to Fn:");
#else
	STRCPY(s_sth.s_mesg,"Appuyer sur ESC-F pour retourner a Fn:");
#endif
	ShowMesg();

	i = ReadFields(KEY_START, KEY_END) ;
	if(PROFOM_ERR == i || DBH_ERR == i) return(i) ;
	if(RET_USER_ESC == i){
		/* copy back key fields */
		s_sth.s_po_no = po_no ;

		ret( WriteFields(KEY_START, KEY_END) ) ;

		s_sth.s_mesg[0] = HV_CHAR;
		ShowMesg();

		return(RET_USER_ESC) ;
	}

	return(NOERROR);
}	/*  ReadKey() */
/*------------------------------------------------------------*/
/* Read the PROFOM Screen for a given Range of fields */

static
ReadFields(st_fld, end_fld)
int	st_fld ;
int	end_fld ;
{
	sr.nextfld = st_fld ;
	sr.endfld  = end_fld ;

	for( ; ;){
		fomrd( (char *)&s_sth );
		ret(err_chk(&sr));
		if(sr.retcode == RET_VAL_CHK){
			continue;
		}
		if(sr.retcode == RET_USER_ESC){
			if(sr.escchar[0] == 'f' || sr.escchar[0] == 'F')
				return(RET_USER_ESC) ;
			continue;
		}
		/* else RET_NO_ERROR */
		break;
	}

	return(NOERROR) ;
}	/* ReadFields() */
/*-----------------------------------------------------------------------*/ 
/* Update the records and write to files */

WriteRecords()
{
	int	err;
	int	i ;
	int	mode ;
	Page	*temppage ;

	/* Get Inventory General GL account, if not a direct disbursement */
	if(s_sth.s_type[0] == BULK) {
		err = CheckGlAcnt(ctl_rec.inv_acnt) ;
		if(err < 0) return(err) ;
	}
	STRCPY(supplier.s_supp_cd, s_sth.s_supp_cd);
	err = get_supplier(&supplier, UPDATE, 0, e_mesg);
	if(err < 0) {
		DispError(e_mesg);
		return(DBH_ERR) ;
	}

	po_hdr.ph_code = s_sth.s_po_no;
	err = get_pohdr(&po_hdr, UPDATE, 0, e_mesg);
	if(err < 0) {
		DispError(e_mesg) ;
		return(DBH_ERR) ;
	}

	supplier.s_ytd_ord -= (po_hdr.ph_comm - po_hdr.ph_lqamt);

	/* Copy Items and write to the file */
	if(PoLast != NULL)
	    for(temppage = FirstPage ; temppage != NULL ;
						temppage = temppage->NextPage) {
		for(i = 0; i < temppage->NoItems ; i++) {
			if(s_sth.s_fn[0] == REMOVEITEM && 
			   strcmp(temppage->Items[i].s_act_del,ACTIVE)==0) {
					continue;
			}
			err = ProcItemUpdates(temppage, i, P_DEL) ;
			if(err == LOCKED) return(LOCKED) ;
			if(err != NOERROR) break ;
		}
		/* IF the process is done upto Current Po Last Page,
		   then break */
		if(temppage == PoLast) break ;
	    }

	if(s_sth.s_fn[0] != DELETE) 
		supplier.s_ytd_ord += (po_hdr.ph_comm - po_hdr.ph_lqamt);

	if( s_sth.s_type[0] == BULK) {
/*** CHANGE XXXXXX ***/
		if (po_item.pi_tax1[0] == TAXABLE){ 
			gst_tax = ctl_rec.gst_tax;  
			rebate = ctl_rec.rebate;
		}
		else{
			gst_tax = 0.0;    
			rebate = 0.0 ;
		}    
		if (po_item.pi_tax2[0] == TAXABLE)
			pst_tax = ctl_rec.pst_tax;
		else
			pst_tax = 0.0;    

		/* call commi_cal and store comm_amt in pi_value */
		comdat = Commit_Calculation(gst_tax,pst_tax,rebate,
			po_hdr.ph_comm-po_hdr.ph_lqamt,&tax_cal);

		gl_rec.comdat -= comdat;

	}
			/* round ph_comm before writing */
	po_hdr.ph_comm = D_Roundoff(po_hdr.ph_comm); 

	if(s_sth.s_fn[0] == REMOVEITEM) {
		mode = UPDATE;
	}
	else {
		mode = P_DEL;
	}

	err = put_pohdr(&po_hdr, mode,e_mesg) ;
	if(err < 0) {
		DispError(e_mesg) ;
		return(DBH_ERR) ;
	}
     	scpy((char*)&pre_po,(char*)&po_hdr,sizeof(po_hdr));

	err = rite_audit((char*)&s_sth, POHDR,mode,(char*)&po_hdr,
				(char*)&pre_po,e_mesg);
	if(err == LOCKED) {
		DispError(e_mesg);
		roll_back(e_mesg);
		return(LOCKED);
	}
	if(err != NOERROR){
#ifdef	ENGLISH
		DispError("ERROR in Saving Records"); 
#else
		DispError("ERREUR en conservant les fiches");
#endif
		DispError(e_mesg);
		roll_back(e_mesg);
		return(DBH_ERR);
	}
	
	if( s_sth.s_type[0] == BULK) { 
			/* round value before writing */
		gl_rec.comdat = D_Roundoff(gl_rec.comdat); 
		err = put_gl(&gl_rec,UPDATE,e_mesg);
		if (err < 0) return(err);
	}

		/* round calculated double value before writing */
	supplier.s_ytd_ord = D_Roundoff(supplier.s_ytd_ord); 

	err = put_supplier(&supplier, UPDATE, e_mesg) ;
	if (err < 0) return(err) ;

	if(err == NOERROR)
		err = commit(e_mesg) ;
	if(err < 0) {
#ifdef ENGLISH
		DispError("ERROR in Saving Records"); 
#else
		DispError("ERREUR en conservant les fiches");
#endif
		DispError(e_mesg);
		ClearScreen() ;
		return(DBH_ERR);
	}

	return(NOERROR);
}	/* WriteRecords() */
/*-----------------------------------------------------------------------*/ 
/* Process given item and Update the files */

ProcItemUpdates(temppage, item_no, mode)
Page	*temppage ;
int	item_no ;
int	mode ;
{
	int err;
	double 	os_amt,	os_qty;
	double  alloc_amt;

	if (s_sth.s_type[0] == DIRECT || s_sth.s_type[0] == NON_BULK ) {
		/* get the GL acnt to increase the commitments */
		err = CheckGlAcnt(temppage->Items[item_no].s_accno) ;
		if(err < 0) return(err) ;
	}

	po_item.pi_code = po_hdr.ph_code ;
	po_item.pi_item_no = temppage->PoItemNo[item_no] ;
	err = get_poitem(&po_item,UPDATE, 0, e_mesg);
	if(err < 0) {
		DispError(e_mesg) ;
		return(DBH_ERR) ;
	}
     	scpy((char*)&pre_item,(char*)&po_item,sizeof(po_item));
	
	if(mode == P_DEL) {
		os_qty = po_item.pi_orig_qty - po_item.pi_pd_qty ;
		os_amt = po_item.pi_value - po_item.pi_paid ;
	}
	else {
		os_qty = po_item.pi_orig_qty;
		os_amt = po_item.pi_value;
	}
	err = UpdateWithPoItem() ;
	if (err < 0) return(err) ;

	/* If not Direct Disbursement */
	if(s_sth.s_type[0] == NON_BULK) {
	   if (os_amt < -(DELTA_AMT) || os_amt > DELTA_AMT || 
  	      os_qty < -(DELTA_QTY) || os_qty > DELTA_QTY) {
		/* calculate alloc_amt with tax for pi_value */
		Tax_Calculation(gst_tax,pst_tax,po_item.pi_value,&tax_cal);
		alloc_amt = tax_cal.gros_amt;	

		/* Create/Increase the Allocation */
		err = CheckAllocation(&(temppage->Items[item_no]));
		if(err < 0 && err != UNDEF) return(err) ; 
		if(err == UNDEF)  
			os_qty = os_amt = 0.00 ;
		else {
			if (os_amt > aloc_rec.st_value) 
				os_amt = aloc_rec.st_value;
			if (os_qty > aloc_rec.st_alloc)
				os_qty = aloc_rec.st_alloc;

			aloc_rec.st_alloc -= os_qty ;
			aloc_rec.st_value -= os_amt ;
			if(mode == P_DEL) {
				/* Add Paid amount back because all */
				/* pi_value deleted above */
				Tax_Calculation(gst_tax,pst_tax,
						po_item.pi_paid,&tax_cal);
				aloc_rec.st_value += tax_cal.gros_amt;
			}
		

			if (aloc_rec.st_value < DELTA_AMT)
				aloc_rec.st_value = 0.00;
			
			aloc_rec.st_alloc = D_Roundoff(aloc_rec.st_alloc);   
			aloc_rec.st_value = D_Roundoff(aloc_rec.st_value);

			if (aloc_rec.st_alloc < DELTA_QTY)
				err = put_alloc(&aloc_rec, P_DEL, e_mesg) ;
			else	
				err = put_alloc(&aloc_rec, UPDATE, e_mesg) ;
		
			if (err < 0) return(err) ;
	   	}
	  }
	}

	/* Decrease the Commitments */
	if (os_amt < -(DELTA_AMT) || os_amt > DELTA_AMT) {
		if (s_sth.s_type[0] != BULK) {
/*** CHANGE XXXXXX ***/
			if (po_item.pi_tax1[0] == TAXABLE){ 
				gst_tax = ctl_rec.gst_tax;  
				rebate = ctl_rec.rebate;
			}
			else{
				gst_tax = 0;    
				rebate = 0 ;
			}    
			if (po_item.pi_tax2[0] == TAXABLE)
				pst_tax = ctl_rec.pst_tax;
			else
				pst_tax = 0;    

			/* Calculate Commitments for item  */
			comdat = Commit_Calculation(gst_tax,
				pst_tax,rebate,os_amt,&tax_cal);

			gl_rec.comdat -= comdat;
/*
			gl_rec.comdat -= os_amt ;
*/
	
				/* round value before writing */
			gl_rec.comdat = D_Roundoff(gl_rec.comdat); 

			err = put_gl(&gl_rec, UPDATE, e_mesg) ;
			if (err < 0) return(err);
		}
	}

	/* Increase On Order in stock */
	if (s_sth.s_type[0] == BULK || s_sth.s_type[0] == NON_BULK) {
		if ((os_qty < -(DELTA_QTY) || os_qty > DELTA_QTY) ||
		    (os_amt < -(DELTA_AMT) || os_amt > DELTA_AMT)) { 
		gst_tax = ( (temppage->Items[item_no].s_gst[0] == TAXABLE)
			? ctl_rec.gst_tax : 0.0 );
		pst_tax = ( (temppage->Items[item_no].s_pst[0] == TAXABLE)
			? ctl_rec.pst_tax : 0.0 );
		os_amt = Commit_Calculation(gst_tax,
				pst_tax,rebate,os_amt,&tax_cal);
			err = UpdateStock(temppage->Items[item_no].s_stck_cd,os_qty, os_amt);
			if (err < 0) return(err) ;
		}
	}
	return(NOERROR) ;
}	/* ProcItemUpdates() */
/*-----------------------------------------------------------------------*/ 
/* Updating files when PoIsGiven. Get the PO item, increase the QTY and
  paid value and update */

UpdateWithPoItem()
{
	int err;
	
	po_item.pi_value = D_Roundoff(po_item.pi_value);	
	err = put_poitem(&po_item, P_DEL ,e_mesg) ;
	if(err < 0) {
		DispError(e_mesg) ;
		return(DBH_ERR) ;
	}

	err = rite_audit((char*)&s_sth, POITEM,P_DEL,(char*)&po_item,
				(char*)&pre_item,e_mesg);
	if(err == LOCKED) {
		DispError(e_mesg);
		roll_back(e_mesg);
		return(LOCKED);
	}
	if(err != NOERROR){
#ifdef	ENGLISH
		DispError("ERROR in Saving Records"); 
#else
		DispError("ERREUR en conservant les fiches");
#endif
		DispError(e_mesg);
		roll_back(e_mesg);
		return(DBH_ERR);
	}
	
	if (po_item.pi_tax1[0] == TAXABLE){ 
		gst_tax = ctl_rec.gst_tax;  
		rebate = 0.0;     /* ctl_rec.rebate; */
	}
	else{
		gst_tax = 0.0;    
		rebate = 0.0 ;
	}    
	if (po_item.pi_tax2[0] == TAXABLE)
		pst_tax = ctl_rec.pst_tax;
	else
		pst_tax = 0.0;    

	/* call commi_cal and store comm_amt in pi_value */
	po_hdr.ph_comm -= Commit_Calculation(gst_tax,pst_tax,rebate,
		po_item.pi_value,&tax_cal);
/*  CB June 26,1991 - The taxes were not being decreased, making the po
	              unbalanced by the amount of the tax 	
	po_hdr.ph_comm -= po_item.pi_original;
*/


	return(NOERROR) ;
}	/* UpdateWithPoItem() */
/*----------------------------------------------------------------*/
/* get the allocation for given keys in UPDATE mode. If record not exists
   and mode = ADD then make the new record and return UNDEF */

CheckAllocation(s_item)
S_item	*s_item ;
{
	int	err ;

	aloc_rec.st_fund = s_sth.s_fund ;
	STRCPY(aloc_rec.st_code, s_item->s_stck_cd) ;
	aloc_rec.st_location = s_item->s_school ;
	STRCPY(aloc_rec.st_expacc, s_item->s_accno) ;

	err = get_alloc(&aloc_rec, UPDATE, 0, e_mesg) ;
	if(ERROR == err) return(DBH_ERR) ;
	if(err != UNDEF && err < 0) {
		fomer(e_mesg) ;
		get() ;
		return(ERROR) ;
	}
	return(err) ;
}	/* CheckAllocation() */
/*----------------------------------------------------------------*/
/* Read the given stock code record in UPDATE mode */

CheckStock(stcode)
char	*stcode ;
{
	int	err ;

	stck_rec.st_fund = s_sth.s_fund ;
	STRCPY(stck_rec.st_code, stcode) ;

	err = get_stmast(&stck_rec, UPDATE, 0, e_mesg) ;
	if(ERROR == err) return(DBH_ERR);
	if(err < 0) {
		fomer(e_mesg) ;
		return(ERROR) ;
	}
	return(NOERROR) ;
}	/* CheckStock() */
/*-----------------------------------------------------------------------*/
/* Update the stock allocation and on-order quantities.  If site wants   */
/* to have po/inventory interface which is set in the parameters then    */
/* the committed value and average price in inventory will be updated.   */

UpdateStock(stock_code, quantity, amount)
char	*stock_code;
double	quantity;
double	amount;
{
	int	err;
	double	qty;

	err = CheckStock(stock_code) ;
	if (err < 0) return(err) ;
/* Cathy Burns June 20,1991 - Update Stock with committed quantities and values 			     when the parameter is set for po to inventory 
			     interface  				    */
	if(pa_rec.pa_poinv[0] == YES) {
		stck_rec.st_po_ordqty -= quantity ;
		if (stck_rec.st_po_ordqty < DELTA_QTY) 
			stck_rec.st_po_ordqty = 0.00;
		stck_rec.st_committed -= amount ;
		if (stck_rec.st_committed < DELTA_QTY) 
			stck_rec.st_committed = 0.00;
	}
	stck_rec.st_on_order -= quantity ;
	if (stck_rec.st_on_order < DELTA_QTY) 
		stck_rec.st_on_order = 0.00;
	if (s_sth.s_type[0] == NON_BULK) {
		stck_rec.st_alloc -= quantity ;
		if (stck_rec.st_alloc < DELTA_QTY) 
			stck_rec.st_alloc = 0.00;
	}

		 /* round stmast double variables calculated */
	stck_rec.st_on_order= D_Roundoff(stck_rec.st_on_order); 
	stck_rec.st_po_ordqty= D_Roundoff(stck_rec.st_po_ordqty); 
	stck_rec.st_committed= D_Roundoff(stck_rec.st_committed); 
	stck_rec.st_alloc = D_Roundoff(stck_rec.st_alloc); 

	/*******************************************************/
	/* DO NOT Round stock rate because it is four decimals */
	if (pa_rec.pa_poinv[0] == YES) {
		qty = (stck_rec.st_on_hand + stck_rec.st_paidfor + stck_rec.st_po_ordqty);
		if(qty > DELTA_QTY) {
			stck_rec.st_rate = 
			(stck_rec.st_value + stck_rec.st_committed) / qty;
		}
	}
	else {
		qty = (stck_rec.st_on_hand + stck_rec.st_paidfor);
		if(qty > DELTA_QTY) {
			stck_rec.st_rate = stck_rec.st_value / qty;
		}
	}
	err = put_stmast(&stck_rec, UPDATE, e_mesg) ;
	if (err < 0) return(err) ;

	return(NOERROR);
}	/* UpdateStock() */
/*-----------------------------------------------------------------------*/ 
/* Copy the key fields from screen to invoice header record and get the
   record from data base */

GetPoHdr(md)
int	md; /* BROWSE or UPDATE */
{
	po_hdr.ph_code = s_sth.s_po_no ;

	return(get_pohdr(&po_hdr, md, 0, e_mesg));
}
/*------------------------------------------------------------*/
/*
*	Get the next node in linked list to add po items. If the
*	(Cur. Po last page) = (Last Page in linked List) or no
*	nodes in list, allocate node and add to linked list
*/

MakeFreshPage()
{
	Page	*tempptr ;

	/* If, no node is allocated yet or Current po used all the nodes,
	   then allocate new node */

	if( LastPage == NULL || PoLast == LastPage ){
		tempptr= (Page *)malloc((unsigned)sizeof(Page)) ;

		if( tempptr == NULL ){
#ifdef ENGLISH
			DispError("MEMORY ALLOCATION ERROR...");
#else
			DispError("ERREUR D'ALLOCATION A LA MEMOIRE...");
#endif
			return(ERROR);
		}
		tempptr->NextPage = NULL ;

		if( LastPage == NULL ){	/* No node is allocated Yet */
			tempptr->PrevPage = NULL ;
			tempptr->Pageno = 1 ;
			FirstPage = tempptr ;
		}
		else {				/* Not a first node in list */
			tempptr->Pageno = LastPage->Pageno + 1 ;
			LastPage->NextPage = tempptr ;
			tempptr->PrevPage = LastPage ;
		}
		LastPage = tempptr ;
	}

	if(PoLast == NULL)
		PoLast = FirstPage ;
	else
		PoLast = PoLast->NextPage ;

	PoLast->NoItems = 0 ;
	CurPage = PoLast ;

	return(NOERROR);
}	/* MakeFreshPage() */
/*------------------------------------------------------------*/
/* Write fields on Screen for a given Range */

static
WriteFields(st_fld, end_fld)
int	st_fld ;
int	end_fld ;
{
	sr.nextfld = st_fld ;
	sr.endfld  = end_fld ;

	fomwr( (char *)&s_sth );
	ret(err_chk(&sr));

	return(NOERROR) ;
}	/* WriteFields() */
/*----------------------------------------------------------------*/
/* Copy the items form given node to screen and display */

ShowItems(pageptr)
Page	*pageptr ;
{
	int	i ;

	if(pageptr != NULL) {
		/* Copy the items to screen */
		scpy((char*)s_sth.s_items, (char*)pageptr->Items,
			(pageptr->NoItems * sizeof(S_item)) );

		s_sth.s_page_no    = pageptr->Pageno ;
	
		if(pageptr->NoItems==2) {
			s_sth.s_items[0].s_subhdg[0] = ' ';
			s_sth.s_items[1].s_subhdg[0] = ' ';
		}
		if(pageptr->NoItems==1) 
			s_sth.s_items[0].s_subhdg[0] = ' ';
		
		s_sth.s_dummy1[0] = ' ' ;
		i = pageptr->NoItems ;
	}
	else {
		s_sth.s_page_no    = HV_SHORT ;
		s_sth.s_dummy1[0] = HV_CHAR ;
		i = 0 ;
	}

	/* Move High Values to remaining Items */
	for( ; i < PAGESIZE ; i++ )
		InitItem(i, HV_CHAR, HV_SHORT, HV_DOUBLE, UPDATE) ;

	ret( WriteFields( PAGENO_FLD, (END_FLD - 200)) );

	return(NOERROR) ;
}	/* ShowItems() */
/*----------------------------------------------------------------*/
/* Check the given funds availability in file */

CheckFund(fund)
short	fund ;
{
	int	err ;

	ctl_rec.fund = fund ;
	err = get_ctl(&ctl_rec, BROWSE, 0, e_mesg) ;
	if(ERROR == err) return(err);
	if(err < 0) {
		fomer(e_mesg) ;
		return(ERROR) ;
	}
	return(NOERROR) ;
}	/* CheckFund() */
/*----------------------------------------------------------------*/
/* Check the given GL account availability in file */

CheckGlAcnt(accno)
char	*accno ;
{
	int	err ;

	gl_rec.funds = s_sth.s_fund ;
	STRCPY( gl_rec.accno, accno);
	gl_rec.reccod = 99;
	err = get_gl(&gl_rec, UPDATE, 0, e_mesg) ;
	if(ERROR == err) return(err);
	if(err < 0) {
		fomer(e_mesg) ;
		return(ERROR) ;
	}
	return(NOERROR) ;
}	/* CheckGlAcnt() */
/*-----------------------------------------------------------------------*/
/* Take the confirmation from user for the header part */

ConfirmItems()
{
	int	err ;
	char	itm_stat[4];

	/* Options:
	   Cancel   - YNPC
	   Inquiry  - YNP
	   RemoveItem - YNPCR
	*/

	for( ; ; ) {
	    switch(s_sth.s_fn[0]) {
	    case  DELETE :		/* Delete Po */
#ifdef ENGLISH
		err = GetOption(
		"Y(es), N(ext Pg), P(rev Pg), C(ancel)"
		,"YNPC");
#else
		err = GetOption(
		"O(ui), S(uivant), P(recedent), A(nnuler)"
		,"OSPA");
#endif
		break ;
	    case  REMOVEITEM :		/* Remove Item */
#ifdef ENGLISH
		err = GetOption(
		"Y(es), N(ext Pg), P(rev Pg), D(elete Item), R(eactivate Item), C(ancel)"
		,"YNPDRC");
#else
		err = GetOption(
		"O(ui), S(uiv), P(rec), E(liminer article), V(ivifier article), A(nnuler)"
		,"OSPERA");
#endif
		break ;
	    case  INQUIRE :		/* Inquire Po */
#ifdef ENGLISH
		err = GetOption("Y(es), N(ext Pg), P(rev Pg)","YNP");
#else
		err = GetOption("O(ui), S(uivant), P(recedent)","OSP");
#endif
		break ;
	    }
	    if(err == PROFOM_ERR) return(err) ;

	    switch(err) {
	    case  YES  :
		return(YES);
	    case  NEXTPAGE :
		if(CurPage == PoLast || PoLast == NULL) {
#ifdef ENGLISH
			fomer("No More Pages....") ;
#else
			fomer("Plus de pages....") ;
#endif
			continue ;
		}
		CurPage = CurPage->NextPage ;
		err = ShowItems(CurPage) ;
		break ;
	    case  PREVPAGE :
		if(PoLast == NULL || CurPage == FirstPage ) {
#ifdef ENGLISH
			fomer("No More Pages....") ;
#else
			fomer("Plus de pages....") ;
#endif
			continue ;
		}
		CurPage = CurPage->PrevPage ;
		err = ShowItems(CurPage) ;
		break ;
	    case  DELITEM:
	    case  REVIVE:
		if(err == REVIVE) {
			STRCPY(itm_stat,ACTIVE);
		}
		else {
			STRCPY(itm_stat,DELETED);
		}
		err = SelectItem(itm_stat);
		break;
	    case  CANCEL :
#ifdef ENGLISH
		err = GetOption("Confirm the Cancel (Y/N)?", "YN") ;
#else
		err = GetOption("Confirmer l'annulation (O/N)?", "ON") ;
#endif
		if(err == YES) return(CANCEL) ;
		break ;
	    }	/* switch err */

	    if(err == PROFOM_ERR) return(err) ;
	    if(err == DBH_ERR) return(err) ;
	}	/* for(; ; ) */
}	/* ConfirmItems() */
/*-----------------------------------------------------------------------*/
/* Display message and get the option */

GetOption(msg,options)
char	*msg ;
char	*options ;
{
	int	i, j ;

	STRCPY(s_sth.s_mesg,msg);
	ShowMesg() ;

	sr.nextfld = END_FLD ;
	for( ; ; ) {
		fomrf( (char *)&s_sth ) ;
		ret(err_chk(&sr)) ;

		j = strlen(options) ;
		for( i = 0 ; i < j ; i++)
			if(s_sth.s_resp[0] == options[i]) break ;
		if(i != j) break ;	/* Valid Option Selected */
#ifdef ENGLISH
		fomer("Invalid Option..");
#else
		fomer("Option invalide..");
#endif
	}

	s_sth.s_mesg[0] = HV_CHAR ;
	s_sth.s_resp[0] = HV_CHAR ;
	
	ret( WriteFields(END_FLD -100, END_FLD) );

	return((int)(options[i])) ;
}	/* GetOption() */
/*-----------------------------------------------------------------------*/
/* Move invoice header details to Screen Header part and read invoice items
   into linked list and show the Po first page on screen */

ShowPo()
{
	int	err ;

	err = CheckFund(1) ;
	if(err < 0) return(err) ;

	/* Initialize totals to zero */
	s_sth.s_total_po   = 0.00;
	s_sth.s_total_itm  = 0.00;
	s_sth.s_total_diff = 0.00;

	/* Make Items Linked List form invoice */
	if((err = MakePoItemsList()) < 0) return(err) ;

	if((err = InvcHdrtoScrHdr()) < 0) return(err) ;	/* Move Header Fields */
	/* Get Po total and calculate difference. Item totals are calculated
	   in MakePoItemsList() */
	s_sth.s_total_po = s_sth.s_po_amt;
	s_sth.s_total_diff = s_sth.s_total_po - s_sth.s_total_itm;

	if((err = ShowItems(CurPage)) < 0) return(err) ;	/* Show Items */

	return(NOERROR) ;
}	/* ShowPo() */
/*-----------------------------------------------------------*/
/* Move Po Header to Screen Hdr Fields */

InvcHdrtoScrHdr()
{
	/* Copy Key */
	s_sth.s_po_no = po_hdr.ph_code;

	/* Copy Header Fields */
	STRCPY( s_sth.s_supp_cd, po_hdr.ph_supp_cd);
	STRCPY( s_sth.s_payee_cd, po_hdr.ph_payee);
	s_sth.s_entry_dt = po_hdr.ph_date ;
	s_sth.s_fund = po_hdr.ph_funds ;
	s_sth.s_po_amt = po_hdr.ph_comm ;
	s_sth.s_billto = po_hdr.ph_billto ;
	s_sth.s_shipto = po_hdr.ph_shipto ;
	STRCPY(s_sth.s_attention,po_hdr.ph_attention);
	s_sth.s_due_dt = po_hdr.ph_due_date ;
	s_sth.s_period = po_hdr.ph_period ;
	s_sth.s_liq_amt = po_hdr.ph_lqamt ;
	s_sth.s_type[0] = po_hdr.ph_type[0] ;
	s_sth.s_type[1] = '\0';
	s_sth.s_liq_dt = po_hdr.ph_lqdate ;
	s_sth.s_status[0] = po_hdr.ph_status[0] ;
	s_sth.s_status[1] = '\0' ;

	ret( WriteFields( KEY_START, HDR_END_FLD) ) ;
	return(NOERROR) ;
}	/* InvcHdrtoScrHdr() */
/*-----------------------------------------------------------*/
/* Read PO Items and make Linked list */

MakePoItemsList()	/* Make the linked list from PO Items */
{
	int	err, i ;

	po_item.pi_code = po_hdr.ph_code ;
	po_item.pi_item_no = 0;
	flg_reset(POITEM);	/* Initialize to get first rec under givenkey */

	PoLast = CurPage = NULL ;
	TotalItems=0 ;
	i = 0 ;

	for( ; ; ){
#ifndef ORACLE
		err = get_n_poitem( &po_item, BROWSE, 0, FORWARD, e_mesg);
#else
		err = get_n_poitem( &po_item, BROWSE, 0, EQUAL, e_mesg);
#endif
		if(ERROR == err) return(DBH_ERR) ;
		if(EFL == err) break ;

#ifndef ORACLE
		/* If PO changes break */
		if( po_item.pi_code != po_hdr.ph_code)  break ;
#endif

		if(PAGESIZE == i) i = 0 ;
		if(0 == i)		/* 1st Item in the Page */
			if((err = MakeFreshPage()) < 0) return(err) ;

		CurPage->Items[i].s_sno = i + 1 ;
		CurPage->Items[i].s_school = po_item.pi_school ;
		STRCPY(CurPage->Items[i].s_accno, po_item.pi_acct) ;
		CurPage->Items[i].s_ord_qty = po_item.pi_orig_qty ;
		CurPage->Items[i].s_unit_cost = po_item.pi_unitprice ;

		if( po_item.pi_tax1[0] == TAXABLE) 
			gst_tax = ctl_rec.gst_tax;
		else {
			po_item.pi_tax1[0] = EXEMPT;
			gst_tax = 0.00;
		}
		if( po_item.pi_tax2[0] == TAXABLE) 
			pst_tax = ctl_rec.pst_tax;
		else {
			po_item.pi_tax2[0] = EXEMPT;
			pst_tax = 0.00;
		}

		Tax_Calculation(gst_tax,pst_tax,po_item.pi_value,&tax_cal);

		CurPage->Items[i].s_net_amt = po_item.pi_value ;
		CurPage->Items[i].s_value = tax_cal.gros_amt ;
		STRCPY(CurPage->Items[i].s_stck_cd, po_item.pi_st_code);
		STRCPY(CurPage->Items[i].s_desc, po_item.pi_desc);
		STRCPY(CurPage->Items[i].s_act_del, ACTIVE);
		STRCPY(CurPage->Items[i].s_gst, po_item.pi_tax1);
		STRCPY(CurPage->Items[i].s_pst, po_item.pi_tax2);
		STRCPY(CurPage->Items[i].s_uom, po_item.pi_unit);
		CurPage->Items[i].s_os_qty = po_item.pi_orig_qty -
						po_item.pi_pd_qty ;
	
		Tax_Calculation(gst_tax,pst_tax,po_item.pi_paid,&tax_cal);
		CurPage->Items[i].s_pd_amount = tax_cal.gros_amt ;
		CurPage->Items[i].s_reqno = po_item.pi_req_no;
		CurPage->PoItemNo[i] = po_item.pi_item_no ;
		CurPage->PoStatus[i] = ' ';

		/* Calculate Items Total */
		s_sth.s_total_itm += CurPage->Items[i].s_value;

		CurPage->NoItems++ ;
		TotalItems++ ;
		i++ ;
	} 
	seq_over(POITEM) ;

	if(PoLast != NULL)
		CurPage = FirstPage ;

	return(NOERROR) ;
}	/* MakePoItemsList() */
/*------------------------------------------------------------------------*/
/* Move High values to all data fields and clear the screen */

ClearScreen()
{
	int	i;

	/* Move High Values to Hedaer part */
	InitHdr(HV_CHAR, HV_SHORT, HV_LONG, HV_DOUBLE) ;

	s_sth.s_page_no    = HV_SHORT ;
	s_sth.s_dummy1[0] = HV_CHAR ;

	/* Move High Values to All items */
	for(i = 0 ; i < PAGESIZE ; i++)
		InitItem(i, HV_CHAR, HV_SHORT, HV_DOUBLE, UPDATE) ;

	InitTotals(HV_DOUBLE);

	ret( WriteFields(HDR_ST_FLD, (END_FLD - 200)) );

	return(NOERROR);
}	/* ClearScreen() */
/*-------------------------------------------------------------------------*/
/* Initialize Screen Header with either Low or High Values */

InitHdr( t_char, t_short, t_long, t_double )
char	t_char ;
short	t_short ;
long	t_long ;
double	t_double ;
{
	s_sth.s_supp_cd[0] = t_char ;
	s_sth.s_payee_cd[0] = t_char ;
	s_sth.s_po_amt = t_double ;
	s_sth.s_entry_dt = t_long ;
	s_sth.s_due_dt = t_long ;
	s_sth.s_liq_amt = t_double ;
	s_sth.s_period = t_short ;
	s_sth.s_fund = t_short ;
	s_sth.s_liq_dt = t_long ;
	s_sth.s_shipto = t_short ;
	if(t_short == LV_SHORT) {
		/* If Inventory system not present, always Direct
		   Disbursement */
		if(pa_rec.pa_stores[0] == YES)
			s_sth.s_type[0] = t_char ;
		else
			s_sth.s_type[0] = DIRECT ;
	}
	else
		s_sth.s_type[0] = t_char ;

	s_sth.s_billto = t_short ;

	s_sth.s_attention[0] = t_char;

	if (s_sth.s_fn[0] == ADDREC && t_char == LV_CHAR) 
		s_sth.s_status[0] = OPEN ;
	else
		s_sth.s_status[0] = t_char ;

	return(NOERROR) ;
}	/* InitHdr() */
/*-------------------------------------------------------------------------*/
/* Initialize Given screen item with either Low values or High values */

InitItem(item_no, t_char, t_short, t_double, mode)
int	item_no ;
char	t_char ;
short	t_short ;
double	t_double ;
int	mode ;
{

	if (mode == ADD || s_sth.s_fn[0] == ADDREC ) {
		s_sth.s_items[item_no].s_accno[0] = t_char ;
		s_sth.s_items[item_no].s_stck_cd[0] = t_char ;

		s_sth.s_items[item_no].s_school = t_short ;
		s_sth.s_items[item_no].s_desc[0] = t_char ;
	}
	else if (t_short == HV_SHORT) {
		s_sth.s_items[item_no].s_accno[0] = t_char ;
		s_sth.s_items[item_no].s_stck_cd[0] = t_char ;

		s_sth.s_items[item_no].s_school = t_short ;
		s_sth.s_items[item_no].s_desc[0] = t_char ;
	}

	if(t_char != LV_CHAR) 
		s_sth.s_items[item_no].s_act_del[0] = t_char ;
		
	s_sth.s_items[item_no].s_uom[0] = t_char ;

	if(t_short == LV_SHORT) 
		s_sth.s_items[item_no].s_subhdg[0] = ' ' ;
	else
		s_sth.s_items[item_no].s_subhdg[0] = t_char ;


	s_sth.s_items[item_no].s_gst[0] = t_char;
	s_sth.s_items[item_no].s_pst[0] = t_char;
	s_sth.s_items[item_no].s_ord_qty = t_double ;
	s_sth.s_items[item_no].s_unit_cost = t_double ;
	s_sth.s_items[item_no].s_net_amt = t_double ;
	s_sth.s_items[item_no].s_value = t_double ;

	if (t_short == HV_SHORT) {
		s_sth.s_items[item_no].s_sno = t_short ;
		s_sth.s_items[item_no].s_os_qty = t_double ;
		s_sth.s_items[item_no].s_pd_amount = t_double ;
		s_sth.s_items[item_no].s_reqno = HV_LONG;
	}
	else 
		if (mode == ADD) {
			s_sth.s_items[item_no].s_os_qty = 0.0 ;
			s_sth.s_items[item_no].s_pd_amount = 0.0 ;
		}

	return(NOERROR) ;
}	/* Inititem() */

/*-------------------------------------------------------------------------*/
InitTotals(t_double)
double	t_double;
{

	s_sth.s_total_po   = t_double;
	s_sth.s_total_itm  = t_double;
	s_sth.s_total_diff = t_double;
}	/* InitTotals() */

/*-------------------------------------------------------------------------*/
static
DispError(s)    /* show ERROR and wait */
char	*s;
{
	STRCPY(s_sth.s_mesg,s);
	ShowMesg();
#ifdef ENGLISH
	fomen("Press any key to continue");
#else
	fomen("Appuyer sur une touche pour continuer");
#endif
	get();
	s_sth.s_mesg[0] = HV_CHAR;
	ShowMesg();
	return(NOERROR);
}
/*-------------------------------------------------------------------------*/

ShowMesg()  /* shows or clears message field */
{
	sr.nextfld = END_FLD - 100;
	fomwf( (char *)&s_sth ) ;
}
/*-------------------- E n d   O f   P r o g r a m ---------------------*/

