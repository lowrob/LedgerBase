/*-----------------------------------------------------------------------
Source Name: reqmaint.c
System     : Accounts Payables.
Created  On: 11th March 91.
Created  By: Jonathan Prescott.

DESCRIPTION:
	Program to enter Requisitions.

MODIFICATIONS:        

Programmer     YY/MM/DD       Description of modification
----------     ---------      ---------------------------
L. Robichaud   92/12/08		Allow interfunding. Added a field to the
				reqhdr and reqitem file to store the second 
				fund called stock_fund and also to the 
				screen.
L. Robichaud	93/08/02	Make the warehouse cost center number a 
				valid entry for schools ship to and make it
				the default as well.
L. Robichaud	93/08/02	Fix ESC-F on the HeaderEdit to return the 
				fields to original value when pressed.
				Item edit will probably need same thing.
L. Robichaud	96/02/19	The procedure to calculate the amount of a
		requ was actually doubling the amounts.  Found an extra 
		tax calculation in the CalcOverBudget routine that was flaging
		things over budget when they shouldn't be.
------------------------------------------------------------------------*/
#define	MAIN		/* Main program. This is to declare Switches */
#define MAINFL		REQHDR			/* main file used */

#define	SYSTEM		"REQUISITIONING"	/* Sub System Name */
#define	MOD_DATE	"11-MAR-91"		/* Progran Last Modified */

#include <stdio.h>
#include <cfomstrc.h>
#include <bfs_defs.h>
#include <bfs_recs.h>
#include <requ.h>

#define	DELTA_AMT  0.005	/* To Check double values for zero */
#define	DELTA_QTY  0.00005	/* To Check double values for zero */

#define TAXABLE		'T'
#define EXEMPT		'E'

/* User Interface define constants */
#ifdef ENGLISH
#define ADDREC		'A'
#define CHANGE		'C'
#define DELETE		'D'
#define INQUIRE		'I'
#define EXITOPT		'E'
#define	NEXT		'N'
#define	PREV		'P'

#define	YES		'Y'
#define NO		'N'
#define	ADDITEMS	'A'
#define	DELITEM		'D'
#define	REVIVEITEM	'R'
#define	EDIT		'E'
#define HEADEREDIT	'H'
#define	NEXTPAGE	'N'
#define	PREVPAGE	'P'
#define	CANCEL		'C'

#define ACTIVE		"ACT"
#define DELETED		"DEL"

#define STOCK_STAT	"S"
#define OPEN_STAT	"O"

#define APPROVED	'A'
#else
#define ADDREC		'R'
#define CHANGE		'C'
#define DELETE		'E'
#define INQUIRE		'I'
#define EXITOPT		'F'
#define	NEXT		'S'
#define	PREV		'P'

#define	YES		'O'
#define NO		'N'
#define	ADDITEMS	'R'
#define	DELITEM		'E'
#define	REVIVEITEM	'V'
#define	EDIT		'M'
#define HEADEREDIT	'C'
#define	NEXTPAGE	'S'
#define	PREVPAGE	'P'
#define	CANCEL		'A'

#define ACTIVE		"ACT"
#define DELETED		"ELI"

#define STOCK_STAT	"S"
#define OPEN_STAT	"O"

#define APPROVED	'A'
#endif

/* PROFOM Releted declarations */

#define	SCR_NAME	"reqmaint"	/* PROFOM screen Name */

#define	PAGESIZE	2		/* No of Items */

/* PROFOM Screen STH file */

/* Field PROFOM numbers */

#define	HDR_ST_FLD	800	/* Header Start Field */
#define	HDR_END_FLD	2300	/* Header End Field */
#define	ITEM_ST_FLD	2400	/* Item 1 Start Field */
#define	END_FLD		9700	/* Last Field of the screen */
#define	STEP		1700	/* NO of fields diff. between 2 items */

#define TOTAL_ST_FLD	5900	/* Totals Start Field */
#define TOTAL_END_FLD	6100	/* Totals End Field */

/* HDR Fields */
#define	FN_FLD		400	/* Fn: */
#define	KEY_START	500	/* PO Number */
#define	KEY_END		500	/* PO Number */
#define	CHG_FLD		600	/* Field: */

#define	SUPPCD_FLD	800	/* Supplier Cd: */
#define	CCNO_FLD	900	/* Cost Center: */
#define REQAMT_FLD	1000 	/* Req Amt: */
#define	ENTRYDT_FLD	1100	/* Entry Dt: */
#define DUEDT_FLD	1200	/* Due Date */
#define	FUND_FLD	1500	/* Fund: */
#define	STCKFUND_FLD	1600	/* Stck Fund: */
#define SHIPTO_FLD	1800	/* Ship To: */
#define	PERIOD_FLD	1900	/* Period: */
#define ATT_FLD		2100    /* Attention: */

#define	PAGENO_FLD	2200	/* Page#: */
#define COLHDG_FLD	2300
	
/* Item Fields. These numbers are difference between that field
   and the 1st fld within the item */
#define	ACNO_FLD	100
#define	STCKCD_FLD	300
#define ITM_STAT_FLD	400
#define	SCHOOL_FLD	500
#define DESC_FLD	600

#define GST_FLD		800
#define	PST_FLD		900
#define	QTY_FLD		1000
#define UOM_FLD		1100
#define	PRICE_FLD	1200
#define	NET_FLD		1300
#define GROSS_FLD	1400
#define PONBR_FLD	1500
#define ACTDEL_FLD	1600

/* reqmaint.sth - header for C structure generated by PROFOM EDITOR */

typedef	struct	{	/* Start Fld 2400, Endfld 5700 and Step 1600 */

	short	s_sno;		/* NUMERIC 999 field 2400 */
	char	s_accno[19];	/* STRING XXXXXXXXXXXXXXXXXX Field 2500 */
	char	s_overbud[2];	/* Over Budget Flag Field 2600*/
	char	s_stck_cd[11];	/* STRING XXXXXXXXXX Field 2700 */
	char	s_itm_stat[2];	/* STRING XXX Field 2800 */
	short	s_school;	/* NUMERIC 99 Field 2900 */
	char	s_desc[61];	/* STRING X(60) Field 3000 */
	char	s_subhdg[2];	/* STRING X Field 3100 */
	char	s_gst[2];	/* STRING XX Field 3200 */
	char	s_pst[2];	/* STRING XX Field 3300 */
	double	s_ord_qty;	/* NUMERIC 99999.9999 Field 3400 */
	char	s_uom[7];	/* STRING XXXXXX Field 3500 */
	double	s_unit_cost;	/* NUMERIC 99999.999 Field 3600 */
	double	s_net_amt;	/* NUMERIC 9999999.99 Field 3700 */
	double	s_value;	/* NUMERIC 9999999.99 Field 3800 */
	long	s_po_nbr;	/* NUMERIC 99999999 Field 3900 */
	char	s_act_del[4];	/* STRING XXX Field 4000 */
}	S_item ;

typedef struct	{

	char	s_pgm[11];	/* STRING XXXXXXXXXX Field 100 */
	char	s_scrname[27]; 	/* STRING X(14) Field 200 */
	long	s_rundate;	/* DATE YYYYFMMFDD Field 300 */
	char	s_fn[2];	/* STRING X Field 400 */
	long	s_req_no;	/* NUMERIC 99999999 Field 500 */
	short	s_field;	/* NUMERIC 999 Field 600 */

	char	s_supp_cd[11];	/* STRING XXXXXXXXXX Field 800 */
	short	s_costcenter;	/* NUMERIC 99 Field 900 */
	double  s_req_amt;	/* NUMERIC 99999999.99 Field 1000 */
	long	s_entry_dt;	/* DATE YYYYFMMFDD Field 1200 */
	long	s_due_dt;	/* DATE YYYYFMMFDD Field 1200 */
	double  s_approve_amt;	/* NUMERIC 9999999.99 Field 1300 */
	short	s_billto;	/* NUMERIC 99 Field 1400 */
	short	s_fund;		/* NUMERIC 999 Field 1500 */
	short	s_stckfund;	/* NUMERIC 999 Field 1600 */
	long	s_approve_dt;	/* DATE YYYYFMMFDD Field 1700 */
	short	s_shipto;	/* NUMERIC 99 Field 1800 */
	short	s_period;	/* STRING X Field 1900 */
	char	s_status[2];	/* STRING X Field 2000 */
	char	s_attention[16];/* STRING X(15) Field 2100 */
	short	s_page_no;	/* NUMERIC 99 Field 2200 */
	char	s_dummy1[4];	/* STRING X Field 2300 */

	S_item	s_items[PAGESIZE] ;	/* Start Fld 2400, End Fld 5700 and
					   Step 1600 */
	char	s_reason[71];	/* CHAR X(70) Field 5800 */
	double	s_total_req;	/* NUMERIC 9999999.99 Field 5900 */
	double	s_total_itm;	/* NUMERIC 9999999.99 Field 6000 */
	double	s_total_diff;	/* NUMERIC 99999999.99 Field 6100 */

	char	s_mesg[78];	/* STRING X[77] Field 9600 */
	char	s_resp[2];	/* STRING X Field 9700 */
} s_struct;


static  short gst_tax;
static  short pst_tax;
static  Tax_cal tax_cal;
static  double  net_amt;
double	D_Roundoff();
double	Commit_Calculation();

static	s_struct  s_sth, image;	/* PROFOM Screen Structure */
static	struct  stat_rec  sr;		/* PROFOM status rec */

static	Req_hdr		req_hdr, tmp_reqhdr ;	/* Purchase Order Header */
static  Req_item 	req_item, tmp_reqitm ;	/* Purchase Order Item Record */
static	Supplier	supplier;	/* Supplier */
static	Pa_rec		pa_rec ;	/* Parameters Record */
static	Ctl_rec		ctl_rec ;	/* Fund/Control Record */
static	Last_req	lastreq_rec ;	/* Last Requisition Number Record */
static	Gl_rec		gl_rec ;	/* Gl Master rec, for general purpose */
static	St_mast		stck_rec ;	/* Stock Master Rec */
static	Alloc_rec	aloc_rec ;	/* Allocation Rec */
static	Sch_rec		schl_rec ;	/* School Record */

static	char 	e_mesg[100];  		/* dbh will return err msg in this */

/*
*	Doubly linked list to maintain req items. Each node in this list
*	conatins one page full of req items. This list is freed only at the
*	time of exiting program. 
*/

typedef	struct Page {

	S_item	Items[PAGESIZE] ;	/* Items information */
	short	ReqItemNo[PAGESIZE] ;	/* Corresponding Req Item# */
	char	ReqStatus[PAGESIZE] ;	/* Status Add, Change */
	struct	Page	*PrevPage ;	/* Ptr to Previous Page */
	struct	Page	*NextPage ;	/* Ptr to Next Page */
	short	NoItems ;		/* No of Items in this page */
	short	Pageno ;		/* Page Number */

}	Page ;

static	Page	*FirstPage,		/* Address of the First Page */
		*CurPage,		/* Address of the Active Page */
		*ReqLast,		/* Address of Cur. PO Last page */
		*LastPage ;		/* Address of the Last page Memory
					   allocated */
long	Entry_date;			/* Last Entry date used */
char	Prev_acct[19];
int	items_committed;		/* number of items commited to file */
char	bdgt_flag[2];

int	KeyAndHdrValidation(), ItemsValidation() ;
int	HdrAndKeyWindowHelp(), ItemsWindowHelp() ;
int	Argc;
char	**Argv;

void	free() ;
char	*malloc() ;

main(argc,argv)
int argc;
char *argv[];
{
	int 	retval;

	/* These two are passed to execute() when it is called */
	Argc = argc;
	Argv = argv;

	retval = Initialize(argc,argv);	/* Initialization routine */

	if (retval == NOERROR) retval = ReqProcess();

	CloseRtn();			/* return to menu */
	if (retval != NOERROR) exit(-1);

	exit(0);
}

/*-------------------------------------------------------------------*/
/* Initialize PROFOM */

Initialize(argc, argv)
int	argc ;
char	*argv[] ;
{
	int	err ;

	/*
	*	Initialize DBH Environment
	*/
	strncpy(SYS_NAME,SYSTEM,50);	/* Sub system name */
	strncpy(CHNG_DATE,MOD_DATE,10);	/* Modification Date */

	proc_switch(argc, argv, MAINFL) ; 	/* Process Switches */

	/*
	*	Initialize PROFOM & Screen
	*/
	STRCPY(sr.termnm,terminal);	/* Copy Terminal Name */
	fomin(&sr);
	ret(err_chk(&sr)) ;		/* Check for PROFOM Error */
	fomcf(1,1);			/* Enable Snap screen option */

	err = InitScreen() ;		/* Initialize Screen */
	if(NOERROR != err) return(err) ;

	err = settax(e_mesg);	/* Set up the global tax variables.	*/
	if (err != NOERROR)
	{
		fomer(e_mesg);
		get();
		return(ERROR);
	}
	/*
	*	Get The Parameter Record
	*/
	err = get_param(&pa_rec, BROWSE, 1, e_mesg) ;
	if(err == ERROR) {
		DispError(e_mesg);
		return(ERROR) ;
	}
	else if(err == UNDEF) {
#ifdef ENGLISH
		DispError("Parameters Are Not Set Up ...");
#else
		DispError("Parametres ne sont pas etablis... ");
#endif
		return(ERROR) ;
	}

	/* Initialize first Entry date to system date */
	Entry_date = get_date();

	/*
	*	Initialize Variables
	*/

	FirstPage = NULL ;
	LastPage  = NULL ;

	return(NOERROR) ;
}	/* Initialize() */

/*--------------------------------------------------------------------------*/
/* Close nessary files and environment before exiting program               */

CloseRtn() 
{
	/* Free the linked list from the end */

	/* Free all the pages except the first page */
	for( ; LastPage != FirstPage ; ) {
		LastPage = LastPage->PrevPage ;
		free((char*)LastPage->NextPage) ;
		LastPage->NextPage = NULL ;
	}
	if(FirstPage != NULL)
		free((char*)FirstPage) ;
		
	FirstPage = LastPage = NULL ;

	/* Set terminal back to normal mode from PROFOM */
	fomcs();
	fomrt();

	close_dbh();	/* Close files */

	return(NOERROR);
}	/* CloseRtn() */
/*----------------------------------------------------------------*/
/* Initialize screen before going to process options */

InitScreen()
{
	int	err ;

	/* move screen name to Profom status structure */
	STRCPY(sr.scrnam,NFM_PATH);
	strcat(sr.scrnam,SCR_NAME) ;

	STRCPY(s_sth.s_pgm,PROG_NAME);
#ifdef ENGLISH
	STRCPY(s_sth.s_scrname, " REQUISITION  MAINTENANCE ");
#else
	STRCPY(s_sth.s_scrname, " ENTRETIEN DE REQUISITION " );
#endif
	s_sth.s_rundate = get_date();	/* get Today's Date in YYYYMMDD format*/
	s_sth.s_field = HV_SHORT ;
	s_sth.s_mesg[0] = HV_CHAR ;
	s_sth.s_resp[0] = HV_CHAR ;

	/* Initialize Key Fields. So that, if user selectes 'N' option
	   immediately after invoking program, then he gets the first
	   record in the file */

	s_sth.s_req_no = 0 ;

	/* Move High Values to data fields and Display the screen */
	err = ClearScreen() ;
	if(NOERROR != err) return(err) ;

	return(NOERROR) ;
}	/* InitScreen() */

/*-------------------------------------------------------------------*/
/* Get Option from user and call corresponding function */

ReqProcess()
{
	int err;

	for( ; ; ){

		/* Get the Fn: option from the user */
		if((err = ReadFunction()) != NOERROR) return(err) ;

		err = ProcFunction() ;	/* Process Function */

		if(QUIT == err)		return(NOERROR) ;    /* Exit */
		if(NOACCESS == err)	fomen(e_mesg);	     /* security */
		if(PROFOM_ERR == err)	return(PROFOM_ERR);  /* PROFOM ERROR */
		if(DBH_ERR == err) {
			DispError(e_mesg);
#ifdef ENGLISH
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"System Error... Iserror:",
				iserror, dberror, errno);
#else
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"Erreur du systeme... Iserror:",
				iserror, dberror, errno);
#endif
			DispError(e_mesg);
			return(DBH_ERR); /* DBH ERROR */
		}
	}      /*   end of the for( ; ; )       */
}	/* ReqProcess() */
/*----------------------------------------------------------------*/
/* Display the Function (Fn:) options and get the option from the user */

ReadFunction()
{
	/* Display Fn: options */
#ifdef ENGLISH
	fomer("A(dd), C(hange), D(elete), I(nquire), N(ext), P(rev), E(xit)");
#else
	fomer("R(ajouter), C(hanger), E(liminer), I(nterroger), S(uivant), P(recedent), F(in)");
#endif
	/* Read Fn: field to get the option */
	sr.nextfld = FN_FLD ;
	fomrf( (char *)&s_sth );
	ret(err_chk(&sr));	/* Check for PROFOM error */

	return(NOERROR) ;
}	/* ReadFunction() */
/*----------------------------------------------------------------*/
/* Process the user selected Fn: option */

ProcFunction()
{
	int retval;

	switch (s_sth.s_fn[0]) {
	case ADDREC :			/* Add Requisition */ 
		CHKACC(retval,ADD,e_mesg);
		return( AddReq() ) ;
	case CHANGE  :			/* CHANGE */
		CHKACC(retval,UPDATE,e_mesg);
		return( ChangeReq() ) ;
	case DELETE :
		CHKACC(retval,UPDATE,e_mesg);
		return( DeleteReq() ) ;
	case INQUIRE  :			/* Inquire Req */
		CHKACC(retval,BROWSE,e_mesg);
		return( InquireReq() ) ;
	case NEXT  :			/* Next Req */
		CHKACC(retval,BROWSE,e_mesg);
		return( NextReq(FORWARD) ) ;
	case PREV  :			/* Previous Req */
		CHKACC(retval,BROWSE,e_mesg);
		return( NextReq(BACKWARD) ) ;
	case EXITOPT  :			/* Exit */
		return( QUIT ) ;
	}  /*   end of the switch statement */

	return(retval);
}	/* ProcFunction() */
/*----------------------------------------------------------------------*/
/* Adding Req. Get the unique Key, accept details and update the files */

AddReq()
{
	int	err ;

	err = GetUniqueKey();
	if(err != NOERROR) return(err) ;

	CurPage = NULL ;
	ReqLast  = NULL ;

	/* Clear The Screen */
	err = ClearScreen();
	if(err != NOERROR) return(err) ;

	err = GetDetails() ;
	if(PROFOM_ERR == err || DBH_ERR == err) return(err) ;
	if(err < 0 || CANCEL == err) {
		roll_back(e_mesg) ;	/* Unlock the locked Records */
		return(ClearScreen()) ;	/* Clear the Screen */
	}

	return(NOERROR);
}	/* AddReq() */
/*-----------------------------------------------------------------------*/
/* Change the Req */

ChangeReq()
{
	int	err ;

	err = SelectReq(UPDATE) ;
	if(NOERROR != err) return(err) ;

	if(req_hdr.print_form[0] == YES) {
#ifdef ENGLISH
		DispError("Requisition has already been Printed.. Changes are not allowed");
#else
		DispError("Requisition a deja ete imprimee.. Changements ne sont pas permis");
#endif
		roll_back(e_mesg);
		return(NOERROR) ;
	}

	if(req_hdr.status[0] != OPEN) {
#ifdef ENGLISH
		DispError("Requisition does not have Open Status.. Changes are not allowed");
#else
		DispError("Requisition n'a pas l'etat Ouvert.. Changements ne sont pas permis");
#endif
		roll_back(e_mesg);
		return(NOERROR) ;
	}
	for( ; ; ) {
		err = ConfirmItems() ;
		if(err != YES) {
			roll_back(e_mesg);
			return(err) ;
		}

		err = WriteRecords(UPDATE) ;
		if(err==NOERROR) break;
		if(err==LOCKED) {
			roll_back(e_mesg) ;
			continue;
		}
		if (err < 0) {
			roll_back(e_mesg);
			return(err) ;
		}
	}

	return(NOERROR) ;
}	/* ChangeReq() */
/*-----------------------------------------------------------------------*/
/* Delete the Req */

DeleteReq()
{
	int	err ;

	err = SelectReq(UPDATE) ;
	if(NOERROR != err) return(err) ;

	if(req_hdr.print_form[0] == YES) {
#ifdef ENGLISH
		DispError("Requisition has already been Printed.. Deletion is not allowed");
#else
		DispError("Requisition a deja ete imprimee.. Elimination n'est pas permis");
#endif
		roll_back(e_mesg);
		return(NOERROR) ;
	}

	if(req_hdr.status[0] != OPEN) {
#ifdef ENGLISH
		DispError("Requisition does not have Open Status.. Changes are not allowed");
#else
		DispError("Requisition n'a pas l'etat Ouvert.. Changements ne sont pas permis");
#endif
		roll_back(e_mesg);
		return(NOERROR) ;
	}
	for( ; ; ) {
		err = ConfirmItems() ;
		if(err != YES) {
			roll_back(e_mesg);
			return(err) ;
		}

		err = WriteRecords(P_DEL) ;
		if(err==NOERROR) break;
		if(err==LOCKED) {
			roll_back(e_mesg) ;
			continue;
		}
		if (err < 0) {
			roll_back(e_mesg);
			return(err) ;
		}
	}

	return(NOERROR) ;
}	/* DeleteReq() */
/*-----------------------------------------------------------------------*/
/* Show the user given keys Req */

InquireReq()
{
	int	err ;

	err = SelectReq(BROWSE) ;
	if(NOERROR != err) return(err) ;

	err = ConfirmItems() ;
	if(err < 0) return(err) ;

	return(NOERROR) ;
}	/* InquireReq() */
/*----------------------------------------------------------*/
/* Show the next or previous Req */

NextReq(direction)
int	direction ;
{
	int err;

	/* Check whether file is in seq. read mode */
	if(flg_start(REQHDR) != direction) {
		req_hdr.code = s_sth.s_req_no ;
		if (direction == FORWARD)
			req_hdr.code++;
		else	req_hdr.code--;
		flg_reset(REQHDR);
	}

	for( ; ; ) {
		err = get_n_reqhdr(&req_hdr, BROWSE, 0, direction, e_mesg);
#ifndef ORACLE
		seq_over(REQHDR);
#endif
		if(ERROR == err)return(DBH_ERR) ;
		if(EFL == err) {
#ifdef	ENGLISH
			fomen("No More Records....");
#else
			fomen("Plus de fiches....");
#endif
			get();
			flg_reset(REQHDR);
			return(NOERROR) ;
		}
		/* only show requisitions for current cost center unless
		   district office */
		if(req_hdr.costcenter != CC_no &&
			CC_no != pa_rec.pa_distccno) {
			continue;
		}

		return( ShowReq() ) ;
	}
}	/* NextReq() */
/*----------------------------------------------------------------------*/
/* Read the Req Key. Check whether the Req exists with this key */

GetUniqueKey()
{
	int retval,i;

	retval = CheckFund((short)1) ;
	if(retval < 0) return(retval) ;
	req_hdr.code = lastreq_rec.last_req + 1 ;
	s_sth.s_req_no = req_hdr.code;	

	SetDupBuffers(KEY_START,KEY_END,2);	/* set dup buffer on */
	s_sth.s_req_no = LV_LONG;

	i = ReadFields(KEY_START, KEY_END,
		KeyAndHdrValidation, HdrAndKeyWindowHelp,0) ;
	if(PROFOM_ERR == i || DBH_ERR == i) return(i) ;
	if(RET_USER_ESC == i){
		/* copy back key fields */
		s_sth.s_req_no = req_hdr.code ;

		ret(WriteFields(KEY_START, KEY_END));

		s_sth.s_mesg[0] = HV_CHAR;
		ShowMesg();

		return(RET_USER_ESC) ;
	}

	if(WriteFields(KEY_START,KEY_END)<0) return(-1);

	return(NOERROR) ;
}	/* GetUniqueKey() */
/*------------------------------------------------------------*/
/* Read the Req Details from the User */

GetDetails()
{
	int	i ;
	int	retry;

	i = ReadHdr() ;
	if(NOERROR != i) return(i) ;

	i = ConfirmHdr() ;
	if(i != YES) return(i);

	/* Initialize totals to zero */
	s_sth.s_total_req = 0.00;
	s_sth.s_total_itm = 0.00;
	s_sth.s_total_diff = 0.00;

	i = AddItems();
	if(NOERROR != i) return(i) ;

	i = ConfirmItems() ;
	if(i != YES) return(NOERROR);

	retry=0;
	for( ; ; ) {
		i = WriteRecords(ADD) ;
		if(i < 0) {
			if(i == LOCKED) continue;
			if(i == DUPE) {
				s_sth.s_req_no = req_hdr.code++;
				/* redisplay new Req no */
				if((i = ReqHdrtoScrHdr()) < 0) 
					return(i) ;	
				retry=1;
				continue;
			}
			break;
		}
		break;
	}
	if(i == NOERROR && retry != 0) {
		sprintf(e_mesg,"Requisition Number Used: %ld",s_sth.s_req_no);
		DispError(e_mesg);
	}
	if(i != NOERROR) return(i);
	return(NOERROR) ;
}	/* GetDetails() */
/*----------------------------------------------------------*/
/* Get the Req key and show the Req */

SelectReq(md)
int	md ;	/* UPDATE or BROWSE. UPDATE locks the Req */
{
	int	err ;

	for(; ;){
		err = ReadKey();
		if(err != NOERROR) return(err) ;

		/* Get the record from database */
		err = GetReqHdr(md);
		if(ERROR == err) return(DBH_ERR) ;
		if(err < 0) {		/* UNDEF or LOCKED */
			fomer(e_mesg) ;
			get() ;
			continue ;
		}

		if(req_hdr.costcenter != CC_no &&
			CC_no != pa_rec.pa_distccno) {
#ifdef ENGLISH
			fomer("Requistion does not belong to this cost center");
#else
			fomer("Requisition n'appartient pas a ce centre de couts");
#endif
			continue;
		}
		return( ShowReq() ) ;
	}
}	/* SelectReq() */
/*----------------------------------------------------------------------*/
/* Get the Req key from user. In ADD mode disable dup buffers, other
   modes enable dup buffers and show the current key as a default key */

ReadKey()
{
	int	i;
	long	req_no;

	/* In Add mode turn off dup control for key fields.
	   Other modes reverse it */
	if(s_sth.s_fn[0] == ADDREC){	/* ADD */
		SetDupBuffers(KEY_START,KEY_END,0); /* Off Dup Control */
	}
	else {
		SetDupBuffers(KEY_START,KEY_END,2);
	}

	/* Store fields to copy back when user gives ESC-F */
	req_no = s_sth.s_req_no ;

	s_sth.s_req_no = LV_LONG ;

#ifdef ENGLISH
	STRCPY(s_sth.s_mesg,"Press ESC-F to Go Back to Fn:");
#else
	STRCPY(s_sth.s_mesg,"Appuyer sur ESC-F pour retourner a Fn:");
#endif
	ShowMesg();

	i = ReadFields(KEY_START, KEY_END,
		KeyAndHdrValidation, HdrAndKeyWindowHelp,0) ;
	if(PROFOM_ERR == i || DBH_ERR == i) return(i) ;
	if(RET_USER_ESC == i){
		/* copy back key fields */
		s_sth.s_req_no = req_no ;

		ret( WriteFields(KEY_START, KEY_END) ) ;

		s_sth.s_mesg[0] = HV_CHAR;
		ShowMesg();

		return(RET_USER_ESC) ;
	}

	return(NOERROR);
}	/*  ReadKey() */
/*-----------------------------------------------------------------------*/ 
/* Update the records and write to files */

WriteRecords(mode)
int mode;
{
	int	err;
	int	i ;
	Page	*temppage ;

	items_committed = 0;	/* no items written */

	if(mode == ADD && s_sth.s_req_no < 89999999) {  /* automatic no. po */
		ctl_rec.fund = 1 ;
		err = get_ctl(&ctl_rec,BROWSE, 0, e_mesg) ;
		if(err < 0) {
			DispError(e_mesg);
			return(err) ;
		}
		err = get_lastreq(&lastreq_rec,UPDATE, 1, e_mesg) ;
		if(err < 0) {
			DispError(e_mesg);
			return(err) ;
		}
	}
	else {
		ctl_rec.fund = 1 ;
		err = get_ctl(&ctl_rec,BROWSE, 0, e_mesg) ;
		if(err < 0) {
			DispError(e_mesg);
			return(err) ;
		}
	}
	if(mode == UPDATE || mode == P_DEL) {
		req_hdr.code = s_sth.s_req_no ;
		err = get_reqhdr(&req_hdr, mode, 0, e_mesg);
		if(err < 0) {
			DispError(e_mesg) ;
			return(err) ;
		}
     		scpy((char*)&tmp_reqhdr,(char*)&req_hdr,sizeof(req_hdr));
	}

	ScrHdrtoReqHdr(mode) ;		/* Copy Req Header */

	err = put_reqhdr(&req_hdr, mode,e_mesg) ;
	if(err < 0) {
		DispError(e_mesg) ;
		return(err) ;
	}

	if(mode != ADD) {
		err = rite_audit((char*)&s_sth, REQHDR,mode,(char*)&req_hdr,
						(char*)&tmp_reqhdr,e_mesg);
		if(err==LOCKED) {
			DispError(e_mesg);
			roll_back(e_mesg) ;
			return(LOCKED) ;
		}
		if(err != NOERROR ){
#ifdef	ENGLISH
			DispError("ERROR in Saving Records"); 
#else
			DispError("ERREUR en conservant les fiches");
#endif
			DispError(e_mesg);
			roll_back(e_mesg);
			return(err);
		}
	}

	
	/* Copy Items and write to the file */
	if(ReqLast != NULL)
	    for(temppage=FirstPage;temppage!=NULL;temppage=temppage->NextPage) {
		for(i = 0; i < temppage->NoItems ; i++) {
			if (temppage->ReqStatus[i] == ' ' &&
			    (strcmp(temppage->Items[i].s_act_del,ACTIVE)==0) &&
			    s_sth.s_fn[0] != DELETE) 
				continue;
			err = ProcItemUpdates(temppage, i) ;
			if(err==LOCKED) {
				DispError(e_mesg);
				roll_back(e_mesg) ;
				return(LOCKED) ;
			}
			if(err != NOERROR) break ;
		}
		/* IF the process is done upto Current Req Last Page,
		   then break */
		if(temppage == ReqLast) break ;
	    }

	/* if no items commited to file do not write requisition header */
	if(mode == ADD) {
		if(items_committed == 0) {
			roll_back(e_mesg);
			return(NOERROR);
		}
	}

	if(mode == ADD && s_sth.s_req_no < 89999999) {
		lastreq_rec.last_req = s_sth.s_req_no ;
		err = put_lastreq(&lastreq_rec, UPDATE, 1, e_mesg) ;
		if(err >= 0) {
			err = NOERROR;
		}
	}

	if(err == NOERROR)
		err = commit(e_mesg) ;
	if(err < 0) {
		if(err != DUPE) {
#ifdef ENGLISH
			DispError("ERROR in Saving Records"); 
#else
			DispError("ERREUR en conservant les fiches");
#endif
			DispError(e_mesg);
		}
		return(err);
	}

	return(NOERROR);
}	/* WriteRecords() */
/*-----------------------------------------------------------------------*/ 
/* Check whether total of items amount is equal to Req total */

CheckTotal()
{
	double	total, diff ;
	Page	*temppage ;
	int	i, items ;

	/* Total up all items amount */
	total = 0.0 ;
	items = 0 ;

	if(ReqLast != NULL)
	    for(temppage = FirstPage ; temppage != NULL ;
						temppage = temppage->NextPage) {
		/* Take Each Req Item and Update the files */
		for(i = 0 ; i < temppage->NoItems ; i++) {
			if(strcmp(temppage->Items[i].s_act_del,DELETED)!=0) {
				total += temppage->Items[i].s_value ;
				items++ ;
			}
		}

		/* IF the process is done upto Current Req Last Page,
		   then break */
		if(temppage == ReqLast) break ;
	    }

	if(items == 0) {
#ifdef ENGLISH
		DispError("No Items On Requisition..  Cancel to Quit..");
#else
		DispError("Pas d'articles dans Requisition.. Annuler pour retourner..");
#endif
		return(ERROR);
	}

	diff = s_sth.s_req_amt - total ;	/* Differnce */

	if(diff < -(DELTA_AMT) || diff > DELTA_AMT) {
#ifdef ENGLISH
		sprintf(e_mesg,
			"Req Total: %12.2lf  Items Total: %12.2lf Diff: %12.2lf",
			s_sth.s_req_amt, total, diff) ;
#else
		sprintf(e_mesg,
			"Total Req: %.2lf  Total Articles: %.2lf  Diff: %.2lf",
			s_sth.s_req_amt, total, diff) ;
#endif
		DispError(e_mesg) ;
		return(ERROR) ;
	}

	return(NOERROR) ;
}	/* CheckTotal() */
/*-----------------------------------------------------------------------*/ 
/* Process given item and Update the files */

ProcItemUpdates(temppage, item_no)
Page	*temppage ;
int	item_no ;
{
	int 	mode, err;
	int	stock_cd_chg = 0;
	double	os_amt, os_qty;
	double	alloc_amt;
	int	factor;

	if (s_sth.s_fn[0] == CHANGE && temppage->ReqStatus[item_no] == 'C' &&
	    temppage->Items[item_no].s_stck_cd[0] != '\0' &&
	    temppage->Items[item_no].s_stck_cd[0] != HV_CHAR &&
	    s_sth.s_costcenter != pa_rec.pa_wareccno)  {
		err = AdjustPrevVals(temppage, item_no);
		if (err < 0) return (err);
	}

	err = CheckOverBudget(mode, temppage,item_no);

	req_item.code = req_hdr.code ;
	req_item.item_no = temppage->ReqItemNo[item_no] ;
	err = get_reqitem(&req_item,UPDATE, 0, e_mesg);
	if(err == UNDEF) 
		mode = ADD ;
	else if(err < 0) {
		DispError(e_mesg) ;
		return(DBH_ERR) ;
	}
	else mode = UPDATE;

	factor = 1;
     	scpy((char*)&tmp_reqitm,(char*)&req_item,sizeof(req_item));

	if(strcmp(temppage->Items[item_no].s_act_del,DELETED)==0) {
		if(temppage->ReqStatus[item_no] == 'A')
			return(NOERROR);
		else {
			mode = P_DEL;
			factor = -1;
		}
	}

	if(s_sth.s_fn[0] == DELETE) {
		mode = P_DEL;
		factor = -1;
	}
	os_amt = temppage->Items[item_no].s_net_amt;
	os_qty = temppage->Items[item_no].s_ord_qty;

	err = UpdateWithReqItem(mode,temppage->ReqItemNo[item_no],
		temppage->Items[item_no]);
	if (err < 0) return(err) ;

	/* Update Allocation */
	/* If not Direct Disbursement */
	if(temppage->Items[item_no].s_stck_cd[0] != '\0' &&
	   temppage->Items[item_no].s_stck_cd[0] != HV_CHAR &&
	   s_sth.s_costcenter != pa_rec.pa_wareccno) {
	   if(os_amt < -(DELTA_AMT) || os_amt > DELTA_AMT || 
  	      os_qty < -(DELTA_QTY) || os_qty > DELTA_QTY) {
		gst_tax = ( (req_item.tax1[0] == TAXABLE)
			? ctl_rec.gst_tax : 0.0 );
		pst_tax = ( (req_item.tax2[0] == TAXABLE)
			? ctl_rec.pst_tax : 0.0 );
		/* calculate alloc_amt with tax for pi_value */
		alloc_amt = Commit_Calculation(gst_tax,pst_tax,ctl_rec.rebate,
			req_item.value,&tax_cal);

		/* Create/Increase the Allocation */
		err = CheckAllocation(&(temppage->Items[item_no]),mode);
		if(err < 0 && err != UNDEF) return(err) ; 
		if(err != UNDEF) {
			if (os_amt > aloc_rec.st_value) 
				os_amt = aloc_rec.st_value;
			if (os_qty > aloc_rec.st_alloc)
				os_qty = aloc_rec.st_alloc;
		}
		aloc_rec.st_alloc += os_qty * factor;
		aloc_rec.st_value += alloc_amt * factor;
		if(mode == P_DEL) {
			/* Add Paid amount back because all */
			/* value deleted above */
			gst_tax = ( (req_item.tax1[0] == TAXABLE)
				? ctl_rec.gst_tax : 0.0 );
			pst_tax = ( (req_item.tax2[0] == TAXABLE)
				? ctl_rec.pst_tax : 0.0 );
			aloc_rec.st_value += 
				Commit_Calculation(gst_tax,pst_tax,
				ctl_rec.rebate,req_item.value,&tax_cal);
		}

		if (aloc_rec.st_value < DELTA_AMT)
			aloc_rec.st_value = 0.00;
			
		aloc_rec.st_alloc = D_Roundoff(aloc_rec.st_alloc);   
		aloc_rec.st_value = D_Roundoff(aloc_rec.st_value);

		if(err == UNDEF) 
			err = put_alloc(&aloc_rec, ADD, e_mesg) ;
		else if (aloc_rec.st_alloc < DELTA_QTY)
			err = put_alloc(&aloc_rec, P_DEL, e_mesg) ;
		else	
			err = put_alloc(&aloc_rec, UPDATE, e_mesg) ;
		
		if (err < 0) return(err) ;

		err = UpdateStock(temppage->Items[item_no].s_stck_cd,
			os_qty,os_amt);
		if (err < 0) return(err) ;
	  }

	}
	items_committed++;	/* add one to items commited */
	return(NOERROR) ;
}	/* ProcItemUpdates() */
/*-----------------------------------------------------------------------*/
/*  If editing req item in change mode, update both previous stock 
    allocation and stock master files if required.			 */

AdjustPrevVals(temppage, item_no)
Page	*temppage ;
int	item_no ;
{
	int	err;
	double	old_quant = 0.0;
	double	old_value = 0.0;

	req_item.code = req_hdr.code ;
	req_item.item_no = temppage->ReqItemNo[item_no] ;
	err = get_reqitem(&req_item, UPDATE, 0, e_mesg);
	
	if(err < 0) {
		DispError(e_mesg) ;
		return(DBH_ERR) ;
	}

	old_quant = req_item.orig_qty;
	old_value = req_item.value;

	/* Calculate tax on old_value */

	gst_tax = ( (req_item.tax1[0] == TAXABLE) ? ctl_rec.gst_tax : 0.0 );
	pst_tax = ( (req_item.tax2[0] == TAXABLE) ? ctl_rec.pst_tax : 0.0 );
	old_value = Commit_Calculation(gst_tax,pst_tax,ctl_rec.rebate,
		old_value, &tax_cal);

		/*  Read stock master record for old poitem */

	stck_rec.st_fund = req_item.fund ;
	STRCPY(stck_rec.st_code,req_item.st_code) ;

	err = get_stmast(&stck_rec, UPDATE, 0, e_mesg) ;

	if(err == UNDEF) return (NOERROR); /* not found */
	if(ERROR == err) return(DBH_ERR);
	if(err < 0) {
		fomer(e_mesg) ;
		return(ERROR) ;
	}

	/* Adjust stock master st_alloc */

	stck_rec.st_alloc -= old_quant ;
	if (stck_rec.st_alloc < DELTA_QTY) 
		stck_rec.st_alloc = 0.00;

	/* round stock master double variables calculated */
	stck_rec.st_alloc	= D_Roundoff(stck_rec.st_alloc); 

	/* Update old stock master record */
	stck_rec.st_fund = req_item.fund ;
	STRCPY(stck_rec.st_code,req_item.st_code) ;

	err = put_stmast(&stck_rec, UPDATE, e_mesg) ;
	if (err < 0) return(err) ;

	/* Read allocation record */

	/* aloc_rec.st_fund = req_item.fund; LR. */
	aloc_rec.st_fund = req_item.stock_fund; 
	STRCPY(aloc_rec.st_code, req_item.st_code);
	aloc_rec.st_location = req_item.school;
	STRCPY(aloc_rec.st_expacc, req_item.acct);

	err = get_alloc(&aloc_rec, UPDATE, 0, e_mesg) ;
		
	if(ERROR == err) return(DBH_ERR) ;
	if(err != UNDEF && err < 0) {
		fomer(e_mesg) ;
		get() ;
		return(ERROR) ;
	}

	aloc_rec.st_alloc -= old_quant;
	if (aloc_rec.st_alloc < DELTA_QTY) 
		aloc_rec.st_alloc = 0.00;

	aloc_rec.st_value -= old_value;
	if(aloc_rec.st_value < DELTA_AMT)
		aloc_rec.st_value = 0.00;

		/* round allocation values after mathmatical 
				calculations */

	aloc_rec.st_alloc = D_Roundoff(aloc_rec.st_alloc);
	aloc_rec.st_value = D_Roundoff(aloc_rec.st_value); 

	/* aloc_rec.st_fund = req_item.fund;  LR. */
	aloc_rec.st_fund = req_item.stock_fund; 
	STRCPY(aloc_rec.st_code, req_item.st_code);
	aloc_rec.st_location = req_item.school;
	STRCPY(aloc_rec.st_expacc, req_item.acct);
	
	if (aloc_rec.st_alloc < DELTA_QTY)
		err = put_alloc(&aloc_rec, P_DEL, e_mesg) ;
	else	
		err = put_alloc(&aloc_rec, UPDATE, e_mesg) ;

	if (err < 0) return(err) ;

	return(NOERROR);
}  /* AdjustPrevVals */

/*----------------------------------------------------------------*/
/* get the allocation for given keys in UPDATE mode. If record not exists
   and mode = ADD then make the new record and return UNDEF */

CheckAllocation(s_item, mode)
S_item	*s_item ;
int	mode ;
{
	int	err ;

/*	aloc_rec.st_fund = s_sth.s_fund ; lr*/
	aloc_rec.st_fund = s_sth.s_stckfund ;
	STRCPY(aloc_rec.st_code, s_item->s_stck_cd) ;
	aloc_rec.st_location = s_item->s_school ;
	STRCPY(aloc_rec.st_expacc, s_item->s_accno) ;

	err = get_alloc(&aloc_rec, UPDATE, 0, e_mesg) ;
	if(ERROR == err) return(DBH_ERR) ;
	if(err != UNDEF && err < 0) {
		fomer(e_mesg) ;
		get() ;
		return(ERROR) ;
	}
	if(err == UNDEF && mode == UPDATE) { /* Used if gl account changed */
		mode = ADD;
	}
	if(err == UNDEF && mode == ADD) {	/* Make the Rec */
		aloc_rec.st_date = s_sth.s_entry_dt ;
		aloc_rec.st_time = get_time() ;
		aloc_rec.st_issued = 0.0 ;
		aloc_rec.st_alloc = 0.0 ;
		aloc_rec.st_value = 0.0 ;
	}
	return(err) ;
}	/* CheckAllocation() */
/*-----------------------------------------------------------------------*/
/* Update the stock allocation and on-order quantities.  If site wants   */
/* to have po/inventory interface which is set in the parameters then    */
/* the committed value and average price in inventory will be updated.   */

UpdateStock(stock_code, quantity, amount)
char	*stock_code;
double	quantity;
double	amount;
{
	int	err;
	double	qty;

	err = CheckStock(stock_code,UPDATE) ;
	if (err < 0) return(err) ;

	stck_rec.st_alloc += quantity ;
	if (stck_rec.st_alloc < DELTA_QTY) 
		stck_rec.st_alloc = 0.00;

	stck_rec.st_alloc = D_Roundoff(stck_rec.st_alloc); 

	err = put_stmast(&stck_rec, UPDATE, e_mesg) ;
	if (err < 0) return(err) ;

	return(NOERROR);
}	/* UpdateStock() */
/*-----------------------------------------------------------------------*/ 
/* Updating files when ReqIsGiven. Get the PO item, increase the QTY and
  paid value and update */

UpdateWithReqItem(mode,req_item_no,s_item)
int	mode ;
short	req_item_no ;
S_item 	s_item ;
{
	int 	err ;
	short	i;

	if (mode == ADD) {
		req_item.code = req_hdr.code ;
		req_item.item_no = req_item_no ;
		err = get_reqitem(&req_item,BROWSE, 0, e_mesg);
		/* get new item no if exists in the file */
		for (i = req_item_no; err == 0; i++){
			req_item.code = req_hdr.code ;
			req_item.item_no = i ;
			err = get_reqitem(&req_item,BROWSE, 0, e_mesg);
		}
  		req_item.fund = req_hdr.funds ;
		req_item.stock_fund = req_hdr.stock_fund ;
		req_item.school = s_item.s_school ;
		req_item.value = s_item.s_value ;
		req_item.pocode = s_item.s_po_nbr;
	}
		/* for UPDATE mode, the original value remains the amount
		   originally entered not the current value. */
	if(mode != P_DEL) {
		STRCPY(req_item.acct, s_item.s_accno);
		STRCPY(req_item.appstat, s_item.s_itm_stat);
		STRCPY(req_item.st_code, s_item.s_stck_cd);
		STRCPY(req_item.desc, s_item.s_desc);
		STRCPY(req_item.unit, s_item.s_uom);
		STRCPY(req_item.tax1, s_item.s_gst);
		STRCPY(req_item.tax2, s_item.s_pst);
		req_item.unitprice = s_item.s_unit_cost ;
		req_item.orig_qty = s_item.s_ord_qty ;
		req_item.value = s_item.s_net_amt ;
  		req_item.fund = req_hdr.funds ;
		req_item.stock_fund = req_hdr.stock_fund ;
	
		/* round any calculated reqitem double values */
		req_item.value = D_Roundoff(req_item.value); 
		req_item.value = D_Roundoff(req_item.value); 
		strcpy(req_item.bdgt_flag, bdgt_flag);

	}
	err = put_reqitem(&req_item, mode,e_mesg) ;
	if(err < 0) {
		DispError(e_mesg) ;
		return(DBH_ERR) ;
	}

	if(s_sth.s_fn[0] == CHANGE && mode != ADD) {
		err = rite_audit((char*)&s_sth, REQITEM,mode,(char*)&req_item,
						(char*)&tmp_reqitm,e_mesg);
		if(err==LOCKED) {
			DispError(e_mesg);
			roll_back(e_mesg) ;
			return(LOCKED) ;
		}
		if(err != NOERROR){
#ifdef	ENGLISH
			DispError("ERROR in Saving Records"); 
#else
			DispError("ERREUR en conservant les fiches");
#endif
			DispError(e_mesg);
			roll_back(e_mesg);
			return(DBH_ERR);
		}
	}

	return(NOERROR) ;
}	/* UpdateWithReqItem() */
/*-----------------------------------------------------------------------*/ 
/* Copy the key fields from screen to req header record and get the
   record from data base */

GetReqHdr(md)
int	md; /* BROWSE or UPDATE */
{
	req_hdr.code = s_sth.s_req_no ;

	return(get_reqhdr(&req_hdr, md, 0, e_mesg));
}
/*------------------------------------------------------------*/
/* Get the Header details from user */

ReadHdr()
{
	int	i ;
	
	/* Change PROFOM logical attributes */
	for(i = HDR_ST_FLD ; i <= HDR_END_FLD ; i += 100) {
		fomca1(i,19,0); /* Disable Dup control */
		fomca1(i,10,1); /* Enable User Escape */
	}

#ifdef ENGLISH
	STRCPY(s_sth.s_mesg,"Press ESC-F to Go Back to Fn:");
#else
	STRCPY(s_sth.s_mesg,"Appuyer sur ESC-F pour retourner a Fn:");
#endif
	ShowMesg();

	/* Show last entered entry date as a default entry date */
	s_sth.s_entry_dt = Entry_date ;
	SetDupBuffers(ENTRYDT_FLD,ENTRYDT_FLD,2);

	/* Initialize Header fields with Low values */
	InitHdr(LV_CHAR, LV_SHORT, LV_LONG, LV_DOUBLE) ;
	s_sth.s_approve_dt = 0 ;
	s_sth.s_approve_amt = 0 ;
	s_sth.s_billto = pa_rec.pa_distccno ;

	/* set fund to 1 and period to current period */
	s_sth.s_period = pa_rec.pa_cur_period ;

	i = ReadFields(HDR_ST_FLD, HDR_END_FLD,
		KeyAndHdrValidation, HdrAndKeyWindowHelp, 0) ;
	if(PROFOM_ERR == i || DBH_ERR == i) return(i) ;
	if(RET_USER_ESC == i) {	/* ESC-F */
		InitHdr(HV_CHAR,HV_SHORT,HV_LONG,HV_DOUBLE) ;

		ret( WriteFields(HDR_ST_FLD, HDR_END_FLD) ) ;

		s_sth.s_mesg[0] = HV_CHAR ;
		ShowMesg() ;

		return(ERROR) ;
	}

	/** set Entry date to the entry date shown on the screen **/
	Entry_date = s_sth.s_entry_dt;

	return(NOERROR) ;
}	/* ReadHdr() */
/*------------------------------------------------------------*/
/* Read Item Details from the User */

AddItems()
{
	int	err ;
	short	i;

	/* If the last node of req is Partial filled then Show Page */
	if(ReqLast != NULL && ReqLast->NoItems < PAGESIZE ) {
		ret( ShowItems(ReqLast) ) ;
		i = ReqLast->NoItems ;
		CurPage = ReqLast ;
	}
	else {
		/* Calculate the page# */
		if(ReqLast != NULL) {
			i = PAGESIZE ;
			CurPage = ReqLast ;
		}
		else {
			s_sth.s_page_no = 1 ;
			STRCPY(s_sth.s_dummy1,"---");
			ret( WriteFields(PAGENO_FLD, COLHDG_FLD) ) ;
			i = 0 ;
		}
	}


	for( ; ; ) {
		if( PAGESIZE == i) {	/* Page Full */

			/* Move High Values to All items except first */
			for(i-- ; i > 0 ; i--)
			     InitItem(i,HV_CHAR,HV_SHORT,HV_LONG,HV_DOUBLE);

			/* Calculate the page# */
			s_sth.s_page_no = ReqLast->Pageno + 1 ;

			ret( WriteFields(PAGENO_FLD, (END_FLD - 200)) ) ;

			i = 0 ;
		}

		err = ReadItem(i,ADD) ;		/* Read Each Item Line */
		if(PROFOM_ERR == err || DBH_ERR == err) return(err) ;
		if(NOERROR != err) break ;	/* ESC-F */

		if(0 == i)	/* First Item in the Page */
			if((err = MakeFreshPage()) < 0) return(err) ;
		
		/* Copy the Item to List */
		scpy((char*)&(CurPage->Items[i]), (char*)&(s_sth.s_items[i]),
			sizeof(S_item)) ;

		CurPage->ReqItemNo[i] = ((ReqLast->Pageno - 1) * 
					PAGESIZE) + (i + 1) ;
		CurPage->ReqStatus[i] = 'A' ;
		i++ ;

		CurPage->NoItems = i;
	}
	if(i == 0) 
		if((err=ShowItems(CurPage))<0) return(err) ;

	return(NOERROR) ;
}	/* AddItems() */
/*------------------------------------------------------------*/
/*
*	Get the next node in linked list to add req items. If the
*	(Cur. Req last page) = (Last Page in linked List) or no
*	nodes in list, allocate node and add to linked list
*/

MakeFreshPage()
{
	Page	*tempptr ;

	/* If, no node is allocated yet or Current req used all the nodes,
	   then allocate new node */

	if( LastPage == NULL || ReqLast == LastPage ){
		tempptr= (Page *)malloc((unsigned)sizeof(Page)) ;

		if( tempptr == NULL ){
#ifdef ENGLISH
			DispError("MEMORY ALLOCATION ERROR...");
#else
			DispError("ERREUR D'ALLOCATION A LA MEMOIRE...");
#endif
			return(ERROR);
		}
		tempptr->NextPage = NULL ;

		if( LastPage == NULL ){	/* No node is allocated Yet */
			tempptr->PrevPage = NULL ;
			tempptr->Pageno = 1 ;
			FirstPage = tempptr ;
		}
		else {				/* Not a first node in list */
			tempptr->Pageno = LastPage->Pageno + 1 ;
			LastPage->NextPage = tempptr ;
			tempptr->PrevPage = LastPage ;
		}
		LastPage = tempptr ;
	}

	if(ReqLast == NULL)
		ReqLast = FirstPage ;
	else
		ReqLast = ReqLast->NextPage ;

	ReqLast->NoItems = 0 ;
	CurPage = ReqLast ;

	return(NOERROR);
}	/* MakeFreshPage() */
/*------------------------------------------------------------*/
/* Read details of given item# */

ReadItem(item_no,mode)
int	item_no ;
int	mode ;
{
	int	i, j, k ;
	int	st_fld ;
	int	end_fld ;

#ifdef ENGLISH
	STRCPY(s_sth.s_mesg,"Press ESC-F to Terminate");
#else
	STRCPY(s_sth.s_mesg,"Appuyer sur ESC-F pour terminer");
#endif
	ShowMesg();

	st_fld  = ITEM_ST_FLD + (STEP * item_no) ;
	end_fld = st_fld + STEP - 100 ;

	/* if Update mode subtract value of item entered then later
	   add value of new item */

	if(UPDATE == mode) 
		s_sth.s_total_itm -= s_sth.s_items[item_no].s_value;

	/* If mode == UPDATE turn ON dup control, else OFF */
	SetDupBuffers(st_fld,end_fld,(mode == UPDATE) ? 2 : 0); 

	if(ADD == mode) {
		/* Set the account number default to the last account number */
		/* entered if not the first item of the first page */

		if(item_no!=0 || s_sth.s_page_no != 1) {
		      STRCPY(s_sth.s_items[item_no].s_accno,Prev_acct);
		      SetDupBuffers(st_fld+ACNO_FLD,st_fld+ACNO_FLD,2);
		}
		s_sth.s_items[item_no].s_ord_qty = 1.0 ;
		SetDupBuffers(st_fld+QTY_FLD,st_fld+QTY_FLD,2);
	}

	/* Initialize Reading Item with Low values */
	InitItem(item_no,LV_CHAR,LV_SHORT,LV_LONG,LV_DOUBLE) ;

	if(ADD == mode) {
		s_sth.s_items[item_no].s_sno = item_no + 1;
	}
	if(ADD == mode || UPDATE == mode) {
		s_sth.s_items[item_no].s_po_nbr = 0;
	}
	STRCPY(s_sth.s_items[item_no].s_itm_stat," ");
	if(pa_rec.pa_stores[0] != YES) {
		s_sth.s_items[item_no].s_stck_cd[0] = HV_CHAR;
		s_sth.s_items[item_no].s_school = HV_SHORT;
	}
	STRCPY(s_sth.s_items[item_no].s_act_del,ACTIVE);

	i = ReadFields(st_fld,end_fld,ItemsValidation,ItemsWindowHelp,mode) ;
	if(PROFOM_ERR == i || DBH_ERR == i) return(i) ;
	if(RET_USER_ESC == i) {
		if(ADD == mode) {	/* Terminating the ADD */
		      InitItem(item_no,HV_CHAR,HV_SHORT,HV_LONG,HV_DOUBLE);
			ret( WriteFields(st_fld, end_fld) );
			return(RET_USER_ESC) ;
		}
		/*
		* When user gives ESC-F while changing fields, assumption is
		* he completed his changes, and remaining fields are same as
		* old. But, at this point STH will be having low values in the 
		* remaining fields. So move the old values form the linked list.
		*/

		/* Get Offset of the begining field of the Item in 'k' */
		fomfp(st_fld,&k,&j) ;
		/* Offset to the field where ESC-F Pressed in 'j' */
		fomfp(sr.curfld,&j,&i);
		i =  j - k ;	/* Offset within item */

		j = sizeof(S_item) - i ;  /* Length to copy */
/*
       		scpy((char *)(&s_sth.s_items[item_no])+i,
			(char*)(&CurPage->Items[item_no])+i, j);
*/
       		scpy((char *)&(s_sth.s_items[item_no]),
			 (char*)&(CurPage->Items[item_no]), sizeof(S_item));
		ret( WriteFields(st_fld, end_fld) );
		s_sth.s_total_itm += s_sth.s_items[item_no].s_value;
		return(RET_USER_ESC) ;
	}

	/** Set previous account number to last account number entered **/
	STRCPY(Prev_acct,s_sth.s_items[item_no].s_accno);

	/* Calculate and Display totals at Bottom of Screen */
	s_sth.s_total_req = s_sth.s_req_amt;
	s_sth.s_total_itm += s_sth.s_items[item_no].s_value;
	s_sth.s_total_diff = s_sth.s_total_req - s_sth.s_total_itm;

	ret(WriteFields(TOTAL_ST_FLD,TOTAL_END_FLD));

	return(NOERROR) ;
}	/* ReadItem() */
/*------------------------------------------------------------*/
/* Read the PROFOM Screen for a given Range of fields */

static
ReadFields(st_fld, end_fld, Validate, WindowHelp, mode)
int	st_fld ;
int	end_fld;
int	(*Validate)() ;
int	(*WindowHelp)() ;
int	mode ;	/* ADD or UPDATE. This is required only when reading item */
{
	int	err ;

	sr.nextfld = st_fld ;
	sr.endfld  = end_fld;
	for( ; ;){
		fomrd( (char *)&s_sth );
		ret(err_chk(&sr));

		if(sr.retcode == RET_VAL_CHK){
			err = (*Validate)(mode) ;
			if(DBH_ERR == err || PROFOM_ERR == err) return(err);
			sr.nextfld = sr.curfld ;
			continue;
		}
		if(sr.retcode == RET_USER_ESC){
			if(sr.escchar[0] == 'f' || sr.escchar[0] == 'F')
				return(RET_USER_ESC) ;
			if(sr.escchar[0] == 'h' || sr.escchar[0] == 'H'){
				err = (*WindowHelp)() ;
				if(DBH_ERR == err || PROFOM_ERR == err)
					return(err) ;
				sr.nextfld = sr.curfld ;
				continue;
			}
			continue;
		}
		/* else RET_NO_ERROR */
		break;
	}

	return(NOERROR) ;
}	/* ReadFields() */
/*------------------------------------------------------------*/
/* Write fields on Screen for a given Range */

static
WriteFields(st_fld, end_fld)
int	st_fld ;
int	end_fld ;
{
	sr.nextfld = st_fld ;
	sr.endfld  = end_fld ;

	fomwr( (char *)&s_sth );
	ret(err_chk(&sr));

	return(NOERROR) ;
}	/* WriteFields() */
/*----------------------------------------------------------------*/
/* Set Duplication buffers for fields 				  */
SetDupBuffers( firstfld, lastfld, value )
int	firstfld, lastfld;	/* field numbers range */
int	value;			/* ENABLE or DISABLE */
{
	int i ;

	for( i=firstfld; i<=lastfld; i+=100 )
		fomca1( i, 19, value);
	if( value==0 )
		return(0);
	sr.nextfld = firstfld;
	sr.endfld = lastfld;
	fomud( (char *)&s_sth );
	ret( err_chk(&sr) );

	return( 0 );
}
/*----------------------------------------------------------------*/
/* Copy the items form given node to screen and display */

ShowItems(pageptr)
Page	*pageptr ;
{
	int	i ;

	if(pageptr != NULL) {
		/* Copy the items to screen */
		scpy((char*)s_sth.s_items, (char*)pageptr->Items,
			(pageptr->NoItems * sizeof(S_item)) );

		s_sth.s_page_no   = pageptr->Pageno ;

		if(pageptr->NoItems==2) {
			s_sth.s_items[0].s_subhdg[0] = ' ';
			s_sth.s_items[1].s_subhdg[0] = ' ';
		}
		if(pageptr->NoItems==1) 
			s_sth.s_items[0].s_subhdg[0] = ' ';
		
		STRCPY(s_sth.s_dummy1,"---");
		i = pageptr->NoItems ;
	}
	else {
		s_sth.s_page_no   = HV_SHORT ;
		s_sth.s_dummy1[0] = HV_CHAR ;
		i = 0 ;
	}

	/* Move High Values to remaining Items */
	for( ; i < PAGESIZE ; i++ )
		InitItem(i,HV_CHAR,HV_SHORT,HV_LONG,HV_DOUBLE) ;

	ret( WriteFields( PAGENO_FLD, (END_FLD - 200)) );

	return(NOERROR) ;
}	/* ShowItems() */
/*----------------------------------------------------------------*/
/* Validation function() for Key and Header fields when PROFOM returns
  RET_VAL_CHK */

KeyAndHdrValidation(mode)
int	mode;
{
	int	err, save_nextfld, save_endfld ;

	switch(sr.curfld){
	case	KEY_START	:	/* req number */
		if(s_sth.s_fn[0] == ADDREC) {
			if(s_sth.s_req_no != req_hdr.code &&
				s_sth.s_req_no >= 10000000) {
#ifdef ENGLISH
			fomer("Requisition number cannot be greater than 9999999");
#else
			fomer("Numero de requisition ne peut pas etre plus grand que 9999999");
#endif
				s_sth.s_req_no = LV_LONG;
				break;
			}
			if(s_sth.s_req_no != req_hdr.code) 
				s_sth.s_req_no += 90000000;
				
			req_hdr.code = s_sth.s_req_no ;
			err = get_reqhdr(&req_hdr, BROWSE, 0, e_mesg);
			if(err == UNDEF) break;
			if(err < 0) {
				DispError(e_mesg) ;
				return(DBH_ERR) ;
			}
			else {
#ifdef ENGLISH
				fomer("Requisition already exists");
#else
				fomer("Requisition existe deja");
#endif
				s_sth.s_req_no = LV_LONG;
				break;
			}
		}
		break;
	case	SUPPCD_FLD	:	/* Supplier Cd: */
  		Right_Justify_Numeric(s_sth.s_supp_cd,
					sizeof(s_sth.s_supp_cd)-1);
		STRCPY(supplier.s_supp_cd,s_sth.s_supp_cd);
		err = get_supplier(&supplier,BROWSE,0,e_mesg); 
		if(err != NOERROR) {
			fomer(e_mesg);
			s_sth.s_supp_cd[0] = LV_CHAR;
		}
		fomer(supplier.s_name);
		if(CC_no == pa_rec.pa_distccno && mode != UPDATE) {
			/* save field numbers because SetDupBuffers clears */
			/* them out. Then restore numbers after SetDupBuffers */
			/* is called. */
			save_nextfld = sr.nextfld; 
			save_endfld = sr.endfld; 

			s_sth.s_costcenter = CC_no;
			SetDupBuffers(CCNO_FLD,CCNO_FLD,2);	
			s_sth.s_costcenter = LV_SHORT;	

			sr.nextfld = save_nextfld;
			sr.endfld = save_endfld;
		}
		else if(mode != UPDATE){
			s_sth.s_costcenter = CC_no;
		}
		break;
	case	CCNO_FLD:
		schl_rec.sc_numb = s_sth.s_costcenter ;
		err = get_sch(&schl_rec, BROWSE, 0, e_mesg) ;
		if(ERROR == err) return(DBH_ERR) ;
		if(err < 0) {
			fomer(e_mesg) ;
			s_sth.s_costcenter = LV_SHORT ;
			return(ERROR) ;
		}
		fomer(schl_rec.sc_name);
		break;
	case	ENTRYDT_FLD	:	/* Entry Dt: */
		/* Entry Date shouldn't be future date */
		if(s_sth.s_entry_dt > get_date()) {
#ifdef ENGLISH
			fomer("Date Can't be Future Date");
#else
			fomer("Date ne peut pas etre ulterieure");
#endif
			s_sth.s_entry_dt = LV_LONG ;
			return(ERROR) ;
		}
		/* If the entry date is, show default due date as 90 days after
		   entry date */
		if((s_sth.s_fn[0] == ADDREC || s_sth.s_fn[0] == CHANGE) &&
							mode != UPDATE) {
			s_sth.s_due_dt = date_plus(s_sth.s_entry_dt,
							pa_rec.pa_due_days_po);
			save_nextfld = sr.nextfld;
			save_endfld = sr.endfld;
			SetDupBuffers(DUEDT_FLD,DUEDT_FLD,2);
			s_sth.s_due_dt = LV_LONG ;
			sr.nextfld = save_nextfld;
			sr.endfld = save_endfld;
		}
		/** set Entry date to entry date shown on screen **/
		Entry_date = s_sth.s_entry_dt;
		break ;
	case	DUEDT_FLD	:	/* Due Date: */
		if(s_sth.s_due_dt < s_sth.s_entry_dt) {
#ifdef ENGLISH
			fomer("Due date can't be before Req Date");
#else
			fomer("Echeance ne peut pas etre avant la date de requisition");
#endif
			s_sth.s_due_dt = LV_LONG;
			return(ERROR) ;
		}
		if (s_sth.s_fn[0] == ADDREC) {
			s_sth.s_shipto = pa_rec.pa_wareccno;
			SetDupBuffers(SHIPTO_FLD,SHIPTO_FLD,2);	
			s_sth.s_shipto = LV_SHORT;	
	
			s_sth.s_fund = 1; 
			s_sth.s_stckfund = 1; 
			SetDupBuffers(FUND_FLD,STCKFUND_FLD,2);	
			s_sth.s_fund = LV_SHORT;	
			s_sth.s_stckfund = LV_SHORT;	
		}

		break ;
	case	PERIOD_FLD	:	/* Period: */
		/* Period should belong to Current Year, should be <= Current
		   period, and in case of previous period is should not < 
		   allowed open periods */
		if(s_sth.s_period < 1 || s_sth.s_period > pa_rec.pa_cur_period
			|| s_sth.s_period <
				(pa_rec.pa_cur_period - pa_rec.pa_open_per) ) {
#ifdef ENGLISH
			fomer("Invalid Period");
#else
			fomer("Periode invalide");
#endif
			s_sth.s_period = LV_SHORT ;
			return(ERROR) ;
		}
		break ;
	case	FUND_FLD	:	/* Fund: */
		err = CheckFund(s_sth.s_fund) ;
		if(DBH_ERR == err) return(err) ;
		if(ERROR == err) {
			s_sth.s_fund = LV_SHORT ;
			return(ERROR) ;
		}
		fomer(ctl_rec.desc);
		break ;
	case	STCKFUND_FLD	:	/* Stock Fund: */
		err = CheckFund(s_sth.s_stckfund) ;
		if(DBH_ERR == err) return(err) ;
		if(ERROR == err) {
			s_sth.s_stckfund = LV_SHORT ;
			return(ERROR) ;
		}
		fomer(ctl_rec.desc);
		if(s_sth.s_fund != s_sth.s_stckfund &&
		   s_sth.s_stckfund != 1){
#ifdef ENGLISH
			fomer("If this is an interfund requisition the Stck Fund must be 1");
#else
			fomer("");
#endif
			s_sth.s_stckfund = LV_SHORT;
			return(ERROR);
		}
		break ;
	case SHIPTO_FLD :	/* Ship to Fields */
		if(CC_no == pa_rec.pa_distccno) {
			schl_rec.sc_numb = s_sth.s_shipto ;
			err = get_sch(&schl_rec, BROWSE, 0, e_mesg) ;
			if(ERROR == err) return(DBH_ERR) ;
			if(err < 0) {
				fomer(e_mesg) ;
				s_sth.s_shipto = LV_SHORT ;
				return(ERROR) ;
			}
			fomer(schl_rec.sc_name);
		}
		else {
			if(s_sth.s_shipto != CC_no && 
			   s_sth.s_shipto != pa_rec.pa_distccno &&
			   s_sth.s_shipto != pa_rec.pa_wareccno) {
#ifdef ENGLISH
				sprintf(e_mesg,"Valid cost centers to ship to are %d and %d and %d",
				 	CC_no,pa_rec.pa_distccno,pa_rec.pa_wareccno);
#else
				sprintf(e_mesg,"Centres de couts valables a expedier a sont %d et %d et %d",
				 	CC_no,pa_rec.pa_distccno,pa_rec.pa_wareccno);
#endif
				fomer(e_mesg);
				s_sth.s_shipto = LV_SHORT ;
			}
		}
		break ;
	default :
#ifdef ENGLISH
		sprintf(e_mesg,"No Validity Check For Field#  %d",sr.curfld);
#else
		sprintf(e_mesg,"Pas de controle de validite pour le Champ#  %d",sr.curfld);
#endif
		fomen(e_mesg);
		get();
		return(ERROR) ;
	}	/* Switch sr.curfld */

	return(NOERROR) ;
}	/* KeyAndHdrValidation() */
/*----------------------------------------------------------------*/
/* Validation function() for Item fields when PROFOM returns RET_VAL_CHK */

ItemsValidation(mode)
int	mode ;
{
	double	temp, diff ;
	int	err, cur_fld, end_fld ;
	int	fld_no, item_no ;

	diff = 0.00;

	/* Calculate item# and Fld# within item */
	item_no = (sr.curfld - ITEM_ST_FLD) / STEP ;
	fld_no  = (sr.curfld - ITEM_ST_FLD) % STEP;

	switch(fld_no){
	case ACNO_FLD :		/* GL Account# Fields */
		if (acnt_chk(s_sth.s_items[item_no].s_accno) < 0)  {
			s_sth.s_items[item_no].s_accno[0] = LV_CHAR ;
#ifdef ENGLISH
			fomer("Invalid GL Account Number");
#else
			fomer("Numero de compte G/L invalide");
#endif
			return(ERROR) ;
		}
		err = CheckGlAcnt(s_sth.s_items[item_no].s_accno) ;
		if(DBH_ERR == err) return(err) ;
		if(err < 0) {
			s_sth.s_items[item_no].s_accno[0] = LV_CHAR ;
			return(ERROR) ;
		}
		if(gl_rec.keys[pa_rec.pa_cc_key-1] != CC_no &&
		   CC_no != pa_rec.pa_distccno) {
#ifdef ENGLISH
			fomer("G/L account not for this cost center");
#else
			fomer("Compte du G/L n'est pas pour ce centre de couts");
#endif
			s_sth.s_items[item_no].s_accno[0] = LV_CHAR ;
			return(ERROR) ;
		}
		fomer(gl_rec.desc);
		break ;
	case STCKCD_FLD :	/* Stock Code Field */
		if(strcmp(s_sth.s_items[item_no].s_stck_cd,"\0") == 0) {
			s_sth.s_items[item_no].s_school = 0;
			sr.curfld += 100;
			break;
		}
		err = CheckStock(s_sth.s_items[item_no].s_stck_cd,BROWSE);
		if(err == DBH_ERR) return(err);
		if(err < 0) {
			/* Set status to Stock Type */
			s_sth.s_items[item_no].s_stck_cd[0] = LV_CHAR ;
			return(ERROR) ;
		}

		/** added for description ****/
		cur_fld = ITEM_ST_FLD + (STEP * item_no) ;
		cur_fld += DESC_FLD ;
		STRCPY( s_sth.s_items[item_no].s_desc, stck_rec.st_desc);
		SetDupBuffers(cur_fld,cur_fld,2);

		s_sth.s_items[item_no].s_desc[0] = LV_CHAR ;
		sr.curfld = (ITEM_ST_FLD + (STEP * item_no) ) + STCKCD_FLD ;
		sr.endfld = (ITEM_ST_FLD + (STEP * item_no) ) + (STEP - 100) ;

		/** added for unit/cost ****/
		cur_fld = ITEM_ST_FLD + (STEP * item_no) ;
		cur_fld += PRICE_FLD ;
		s_sth.s_items[item_no].s_unit_cost = stck_rec.st_rate;
		SetDupBuffers(cur_fld,cur_fld,2);

		s_sth.s_items[item_no].s_unit_cost = LV_DOUBLE ;
		sr.curfld = (ITEM_ST_FLD + (STEP * item_no) ) + STCKCD_FLD ;
		sr.endfld = (ITEM_ST_FLD + (STEP * item_no) ) + (STEP - 100) ;

		/* Show the Stock UOM as a default UOM on requisition */
		cur_fld = ITEM_ST_FLD + (STEP * item_no) ;
		cur_fld += UOM_FLD ;
		STRCPY( s_sth.s_items[item_no].s_uom, stck_rec.st_unit);
		SetDupBuffers(cur_fld,cur_fld,2);

		s_sth.s_items[item_no].s_uom[0] = LV_CHAR ;
		sr.curfld = (ITEM_ST_FLD + (STEP * item_no) ) + STCKCD_FLD ;
		sr.endfld = (ITEM_ST_FLD + (STEP * item_no) ) + (STEP - 100) ;

		/* set cc# to cost center entering requistion */
		s_sth.s_items[item_no].s_school = s_sth.s_costcenter;
		break;
	case SCHOOL_FLD :	/* School Fields */
		schl_rec.sc_numb = s_sth.s_items[item_no].s_school ;
		err = get_sch(&schl_rec, BROWSE, 0, e_mesg) ;
		if(ERROR == err) return(DBH_ERR) ;
		if(err < 0) {
			fomer(e_mesg) ;
			s_sth.s_items[item_no].s_school = LV_SHORT ;
			return(ERROR) ;
		}
		fomer(schl_rec.sc_name);
		break ;
	case DESC_FLD :		/* Description */
		/* Show the PO TAX type as TAXABLE */
		cur_fld = ITEM_ST_FLD + (STEP * item_no) ;
		cur_fld += GST_FLD ;

		/* default gst & pst flags to defaults set in parameter file
  		   if add ftn & not update mode or change ftn & add mode.  */

		if( (s_sth.s_fn[0] == ADDREC) && (mode != UPDATE) ||
		    (s_sth.s_fn[0] == CHANGE) && (mode == ADD) ) {
			s_sth.s_items[item_no].s_gst[0] = pa_rec.pa_gst_tax[0];
			s_sth.s_items[item_no].s_pst[0] = pa_rec.pa_pst_tax[0];
  			SetDupBuffers(cur_fld,cur_fld+100,2);
		}

		s_sth.s_items[item_no].s_gst[0] = LV_CHAR ;
		s_sth.s_items[item_no].s_pst[0] = LV_CHAR ;

		sr.endfld = (ITEM_ST_FLD + (STEP * item_no) ) + (STEP - 100) ;
		break ;
	case GST_FLD:		/* GST Fields */
		if( s_sth.s_items[item_no].s_gst[0] != TAXABLE &&
			s_sth.s_items[item_no].s_gst[0] != EXEMPT )  {
#ifdef	ENGLISH
			fomer("Valid Tax codes are T(axable) or E(xempt)");
#else
			fomer("Codes valides de taxe sont T(axable) ou E(xempte)");
#endif
			s_sth.s_items[item_no].s_gst[0] = LV_CHAR;
		}
		break;
	case PST_FLD:		/* PST Fields */
		if( s_sth.s_items[item_no].s_pst[0] != TAXABLE &&
			s_sth.s_items[item_no].s_pst[0] != EXEMPT )  {
#ifdef	ENGLISH
			fomer("Valid Tax codes are T(axable) or E(xempt)");
#else
			fomer("Codes valides de taxe sont T(axable) ou E(xempte)");
#endif
			s_sth.s_items[item_no].s_pst[0] = LV_CHAR;
		}
		break;
	case QTY_FLD :		/* QTY Fields */
		if ( s_sth.s_items[item_no].s_ord_qty < DELTA_QTY) {
#ifdef ENGLISH
			fomer("Can't be zero");
#else
			fomer("Ne peut pas etre zero");
#endif
			s_sth.s_items[item_no].s_ord_qty = LV_DOUBLE ;
			return(ERROR) ;
		}
		break;
	case PRICE_FLD :	/* Cost/Unit Fields */
		/* Show the PO Value as a default amount */
		cur_fld = ITEM_ST_FLD + (STEP * item_no) ;
		cur_fld += NET_FLD ;
		end_fld = sr.endfld;
		s_sth.s_items[item_no].s_net_amt = 
			s_sth.s_items[item_no].s_ord_qty *
				s_sth.s_items[item_no].s_unit_cost ;
		SetDupBuffers(cur_fld,cur_fld,2);

		s_sth.s_items[item_no].s_net_amt = LV_DOUBLE ;
		sr.curfld  = cur_fld ;
		sr.endfld  = end_fld ;
		break;
	case NET_FLD :		/* Net Amount Fields */
		net_amt = s_sth.s_items[item_no].s_net_amt;
		
		calctax(s_sth.s_items[item_no].s_gst,
			s_sth.s_items[item_no].s_pst,net_amt,&tax_cal);
		
		s_sth.s_items[item_no].s_value = tax_cal.gros_amt;

		if(mode == ADD) 
			diff += s_sth.s_items[item_no].s_net_amt;
		else
			diff += (s_sth.s_items[item_no].s_net_amt - 
				 CurPage->Items[item_no].s_net_amt);

		temp = gl_rec.budcur - gl_rec.comdat - gl_rec.ytd ;
		if(s_sth.s_items[item_no].s_value > DELTA_AMT && temp < diff){
/****
printf("\n current budget: %lf", gl_rec.budcur);
printf("\n commit to date: %lf", gl_rec.comdat);
printf("\n commit yr to dt: %lf", gl_rec.ytd);
printf("\nsetting bdgt_flag to YES remaining budget %lf is less than %lf",
temp,diff);
printf("\n press any key to continue");
get();
***/
#ifdef ENGLISH
			DispError("Not Enough Budget");
#else
			DispError("Pas assez de budget");
#endif
#ifdef ENGLISH
			STRCPY(s_sth.s_mesg,"Press ESC-F to Terminate");
#else
			STRCPY(s_sth.s_mesg,"Appuyer sur ESC-F pour terminer");
#endif
			ShowMesg();
		}
		sr.nextfld = sr.endfld;
		break ;
	default :
#ifdef ENGLISH
		sprintf(e_mesg,"No Validity Check For Field#  %d",sr.curfld);
#else
		sprintf(e_mesg,"Pas de controle de validite pour le Champ#  %d",sr.curfld);
#endif
		fomen(e_mesg);
		get();
		return(ERROR) ;
	}	/* Switch sr.curfld */
	sr.nextfld = sr.curfld;
	return(NOERROR) ;
}	/* ItemsValidation() */
/*----------------------------------------------------------------*/
/* Check the given funds availability in file */

CheckFund(fund)
short	fund;
{
	int	err ;

	ctl_rec.fund = fund ;
	err = get_ctl(&ctl_rec, BROWSE, 0, e_mesg) ;
	if(ERROR == err) return(err);
	if(err < 0) {
		fomer(e_mesg) ; get();
		return(ERROR) ;
	}

	err = get_lastreq(&lastreq_rec, BROWSE, 1, e_mesg) ;
	if(ERROR == err) return(err);
	if(err < 0) {
		fomer(e_mesg) ; get();
		return(ERROR) ;
	}

	return(NOERROR) ;
}	/* CheckFund() */
/*----------------------------------------------------------------*/
/* Check the given GL account availability in file */

CheckGlAcnt(accno)
char	*accno ;
{
	int	err ;

	gl_rec.funds = s_sth.s_fund ;
	STRCPY( gl_rec.accno, accno);
	gl_rec.reccod = 99;
	err = get_gl(&gl_rec, UPDATE, 0, e_mesg) ;
	if(ERROR == err) return(err);
	if(err < 0) {
		fomer(e_mesg) ;
		return(ERROR) ;
	}
	return(NOERROR) ;
}	/* CheckGlAcnt() */
/*----------------------------------------------------------------*/
/* Read the given stock code record in BROWSE mode */

CheckStock(stcode,mode)
char	*stcode ;
int	mode;
{
	int	err ;

  	stck_rec.st_fund = s_sth.s_stckfund ;
	STRCPY(stck_rec.st_code, stcode) ;

	err = get_stmast(&stck_rec, mode, 0, e_mesg) ;
	if(ERROR == err) return(DBH_ERR);
	if(err < 0) {
		fomer(e_mesg) ;
		return(ERROR) ;
	}
	return(NOERROR) ;
}	/* CheckStock() */
/*----------------------------------------------------------------*/
/* Show Help Windows, if applicable, when user gives ESC-H in key
   and header fields */

HdrAndKeyWindowHelp()
{
	int	err ;

	switch(sr.curfld){
	case	SUPPCD_FLD	:	/* Supplier Cd: */
		err = supp_hlp(s_sth.s_supp_cd, 7, 13 );
		if(err == DBH_ERR) return(err) ;
		if(err >=0 ) redraw();
		if(err < 1) return(ERROR) ;

		STRCPY(supplier.s_supp_cd, s_sth.s_supp_cd) ;
		err = get_supplier(&supplier, UPDATE, 0, e_mesg) ;
		if(ERROR == err) return(DBH_ERR) ;
		if(err < 0) {
			fomer(e_mesg) ;
			s_sth.s_supp_cd[0] = LV_CHAR ;
			return(ERROR) ;
		}
		fomer(supplier.s_name);
		if(CC_no == pa_rec.pa_distccno) {
			s_sth.s_costcenter = CC_no;
			SetDupBuffers(CCNO_FLD,CCNO_FLD,2);	
			s_sth.s_costcenter = LV_SHORT;	
		}
		else {
			s_sth.s_costcenter = CC_no;
		}
		break ;
	case CCNO_FLD :			/* Cost Center Field */
		err = sch_hlp(&s_sth.s_costcenter, 7, 13 );
		if(err == DBH_ERR) return(err) ;
		if(err >=0 ) redraw();
		if(err < 1) return(ERROR) ;	/* Not Selected */
		break ;
	case SHIPTO_FLD :		/* Ship To Fields */
		if(CC_no == pa_rec.pa_distccno) {
			err = sch_hlp(&s_sth.s_shipto, 7, 13 );
			if(err == DBH_ERR) return(err) ;
			if(err >=0 ) redraw();
			if(err < 1) return(ERROR) ;	/* Not Selected */
			break ;
		}
		else {
#ifdef ENGLISH
			sprintf(e_mesg,"Valid cost centers to ship to are %d and %d",
			 	CC_no,pa_rec.pa_distccno);
#else
			sprintf(e_mesg,"Centres de couts valables a expedier a sont %d et %d",
				CC_no,pa_rec.pa_distccno);
#endif
			fomer(e_mesg);
		}
	default :
#ifdef ENGLISH
		fomer("No Help Window For This Field");
#else
		fomer("Pas de fenetre d'assistance pour ce champ");
#endif
	}	/* Switch sr.curfld */

	return(NOERROR) ;
}	/* HdrAndKeyWindowHelp() */
/*----------------------------------------------------------------*/
/* Show Help Windows, if applicable, when user gives ESC-H in Item fields */

ItemsWindowHelp()
{
	int	err ;
	int	fld_no, item_no ;
	int	cur_fld;
	short	reccod ;

	/* Calculate item# and Fld# within item */
	item_no = (sr.curfld - ITEM_ST_FLD) / STEP ;
	fld_no  = (sr.curfld - ITEM_ST_FLD) % STEP;

	/* Calculate item# ans Fld# within item 
	item_no = (sr.curfld - ITEM_ST_FLD) / STEP ;
	fld_no  = (sr.curfld - ITEM_ST_FLD); */

	switch(fld_no){
	case STCKCD_FLD :		/* Stock Code Fields */
		err = stock_hlp(s_sth.s_stckfund, s_sth.s_items[item_no].s_stck_cd, 
			7, 13 );
		if(err == DBH_ERR) return(err) ;
		if(err >=0 ) redraw();
		if(err < 1) return(ERROR) ;	/* Not Selected */
		
		err = CheckStock(s_sth.s_items[item_no].s_stck_cd,BROWSE);
		if(err == DBH_ERR) return(err);
		if(err < 0) {
			s_sth.s_items[item_no].s_stck_cd[0] = LV_CHAR ;
			return(ERROR) ;
		}
		/** added for description ****/
		cur_fld = ITEM_ST_FLD + (STEP * item_no) ;
		cur_fld += DESC_FLD ;
		STRCPY( s_sth.s_items[item_no].s_desc, stck_rec.st_desc);
		SetDupBuffers(cur_fld,cur_fld,2);

		s_sth.s_items[item_no].s_desc[0] = LV_CHAR ;
		sr.curfld = (ITEM_ST_FLD + (STEP * item_no) ) + STCKCD_FLD ;
		sr.endfld = (ITEM_ST_FLD + (STEP * item_no) ) + (STEP - 100) ;

		/** added for unit/cost ****/
		cur_fld = ITEM_ST_FLD + (STEP * item_no) ;
		cur_fld += PRICE_FLD ;
		s_sth.s_items[item_no].s_unit_cost = stck_rec.st_rate;
		SetDupBuffers(cur_fld,cur_fld,2);

		s_sth.s_items[item_no].s_unit_cost = LV_DOUBLE ;
		sr.curfld = (ITEM_ST_FLD + (STEP * item_no) ) + STCKCD_FLD ;
		sr.endfld = (ITEM_ST_FLD + (STEP * item_no) ) + (STEP - 100) ;

		/* Show the PO UOM as a default UOM on stock master */
		cur_fld = ITEM_ST_FLD + (STEP * item_no) ;
		cur_fld += UOM_FLD ;
		STRCPY( s_sth.s_items[item_no].s_uom, stck_rec.st_unit);
		SetDupBuffers(cur_fld,cur_fld,2);

		s_sth.s_items[item_no].s_uom[0] = LV_CHAR ;
		sr.curfld = (ITEM_ST_FLD + (STEP * item_no) ) + STCKCD_FLD ;
		sr.endfld = (ITEM_ST_FLD + (STEP * item_no) ) + (STEP - 100) ;

		/* set cc# to cost center entering requistion */

		/* set cc# to cost center entering requistion */
		s_sth.s_items[item_no].s_school = s_sth.s_costcenter;
		fomer(stck_rec.st_desc);
		break ;
	case SCHOOL_FLD :		/* School Fields */
		err = sch_hlp(&s_sth.s_items[item_no].s_school, 7, 13 );
		if(err == DBH_ERR) return(err) ;
		if(err >=0 ) redraw();
		if(err < 1) return(ERROR) ;	/* Not Selected */
		break ;
	case ACNO_FLD :		/* GL Account# Fields */
		err = reqacnt_hlp(s_sth.s_fund,s_sth.s_items[item_no].s_accno,
			&reccod,CC_no,pa_rec.pa_cc_key, 7, 13 );
		if(err == DBH_ERR) return(err) ;
		if(err >=0 ) redraw();
		if(err < 1) return(ERROR) ;	/* Not Selected */
		if(reccod != 99) {
#ifdef ENGLISH
			fomer("Select records with 99 as Record Code only");
#else
			fomer("Choisir les fiches avec 99 seulement comme code de fiche");
#endif
			s_sth.s_items[item_no].s_accno[0] = LV_CHAR ;
			return(ERROR) ;
		}
		err = CheckGlAcnt(s_sth.s_items[item_no].s_accno) ;
		if(DBH_ERR == err) return(err) ;
		if(err < 0) {
			s_sth.s_items[item_no].s_accno[0] = LV_CHAR ;
			return(ERROR) ;
		}
		break ;
	default :
#ifdef ENGLISH
		fomer("No Help Window For This Field");
#else
		fomer("Pas de fenetre d'assistance pour ce champ");
#endif
	}	/* Switch sr.curfld */

	return(NOERROR) ;
}	/* ItemsWindowHelp() */
/*-----------------------------------------------------------------------*/
/* Take the confirmation from user for the header part */

ConfirmHdr()
{
	int	err ;

	/* Options:
	   Add      - AEC
	*/

	for( ; ; ) {
#ifdef ENGLISH
		err = GetOption("A(dd Items), E(dit), C(ancel)", "AEC");
#else
		err = GetOption("R(ajouter articles), M(odifier), A(nnuler)", "RMA");
#endif
		if(err == PROFOM_ERR) return(err) ;

		switch(err) {
		case  ADDITEMS :
			return(YES) ;
		case  EDIT  :
			err = HeaderEdit();
			break ;
		case  CANCEL :
#ifdef ENGLISH
			err = GetOption("Confirm the Cancel (Y/N)?", "YN") ;
#else
			err = GetOption("Confirmer l'annulation (O/N)?", "ON") ;
#endif
			if(err == YES) return(CANCEL) ;
			break ;
		}	/* switch err */

		if(err == PROFOM_ERR) return(err) ;
		if(err == DBH_ERR) return(err) ;
	}	/* for(; ; ) */
}	/* ConfirmHdr() */
/*-----------------------------------------------------------------------*/
/* Take the confirmation from user for the header part */

ConfirmItems()
{
	int	err ;
	char	act_del_stat[4];

	/* Options:
	   Add      - YAENPC
	   Change   - YAEHSTNPC
	   Inquiry  - YNPH
	*/

	for( ; ; ) {
	    switch(s_sth.s_fn[0]) {
	    case  ADDREC :		/* Add Req */
	    case  CHANGE :		/* Change Req */
#ifdef ENGLISH
		err = GetOption(
		"Y(es),A(dd items),E(dit),D(el),R(eactivate),H(dr edit),N(ext),P(rev),C(ancel)"
		,"YAEDRHNPC");
#else
		err = GetOption(
		"O(ui),R(aj art),M(od),E(lim),V(ivi),C(hange en-tete),S(uiv),P(rec),A(nnuler)"
		,"ORMEVCSPA");
#endif
		break ;
	    case  DELETE :
#ifdef ENGLISH
		err = GetOption("Y(es), C(ancel)","YC");
#else
		err = GetOption("O(ui), A(nnuler)","OA");
#endif
		break;
	    case  INQUIRE :		/* Inquire Req */
#ifdef ENGLISH
		err = GetOption("Y(es), N(ext Page), P(rev Page)","YNP");
#else
		err = GetOption("O(ui), S(uivant), P(recedent)","OSP");
#endif
		break ;
	    }
	    if(err == PROFOM_ERR) return(err) ;

	    switch(err) {
	    case  YES  :
		if(s_sth.s_fn[0] == ADDREC || s_sth.s_fn[0] == CHANGE) {
			err = CheckTotal();
			if (err == ERROR) break;  
			err = ValFundAcnt();
			if (err == ERROR) break;
		}
		return(YES);
	    case  ADDITEMS :
		err = AddItems() ;
		break ;
	    case  EDIT  :
		err = ChangeItems(EDIT);
		break ;
	    case  DELITEM:
	    case  REVIVEITEM:
		if(err == DELITEM) 
			STRCPY(act_del_stat,DELETED);
		else
			STRCPY(act_del_stat,ACTIVE);
		err = ChangeActDel(act_del_stat);
		break;
	    case  HEADEREDIT:  
		err = HeaderEdit();
		break;	  
	    case  NEXTPAGE :
		if(CurPage == ReqLast || ReqLast == NULL) {
#ifdef ENGLISH
			fomer("No More Pages....") ;
#else
			fomer("Plus de pages....") ;
#endif
			continue ;
		}
		CurPage = CurPage->NextPage ;
		err = ShowItems(CurPage) ;
		break ;
	    case  PREVPAGE :
		if(ReqLast == NULL || CurPage == FirstPage ) {
#ifdef ENGLISH
			fomer("No More Pages....") ;
#else
			fomer("Plus de pages....") ;
#endif
			continue ;
		}
		CurPage = CurPage->PrevPage ;
		err = ShowItems(CurPage) ;
		break ;
	    case  CANCEL :
#ifdef ENGLISH
		err = GetOption("Confirm the Cancel (Y/N)?", "YN") ;
#else
		err = GetOption("Confirmer l'annulation (O/N)?", "ON") ;
#endif
		if(err == YES) return(CANCEL) ;
		break ;
	    }	/* switch err */

	    if(err == PROFOM_ERR) return(err) ;
	    if(err == DBH_ERR) return(err) ;
	}	/* for(; ; ) */
}	/* ConfirmItems() */
/*----------------------------------------------------------------------*/
/* Changing Items. Accept Item to be changed, deleted or revived.
   For change option read the item and others mark the Item */

ChangeItems(option)
int	option ;
{
	int	i ;

	/* Get The Item to Be Modified */

	for( ; ; ) {
#ifdef ENGLISH
		STRCPY(s_sth.s_mesg,"Enter RETURN to terminate Edit");
#else
		STRCPY(s_sth.s_mesg,"Appuyer sur RETURN pour terminer l'ajustement");
#endif
		ShowMesg() ;
		sr.nextfld = CHG_FLD ;
		fomrf( (char *)&s_sth );
		ret(err_chk(&sr));

		if(s_sth.s_field == 0) break ;
		if( s_sth.s_field < 1 || CurPage == NULL ||
				s_sth.s_field > CurPage->NoItems)
			continue ;

		if(CurPage->Items[s_sth.s_field-1].s_itm_stat[0] == COMPLETE) {
#ifdef ENGLISH
			fomer("Item is Complete and Cannot be Edited");
#else
			fomer("TRANSLATE");
#endif
			continue;
		}
		if(CurPage->ReqStatus[s_sth.s_field-1] == ' ' ||
				CurPage->ReqStatus[s_sth.s_field-1]==COMPLETE) {
			req_item.code = req_hdr.code ;
			req_item.item_no = CurPage->ReqItemNo[s_sth.s_field-1];
			i = get_reqitem(&req_item,UPDATE, 0, e_mesg);
			if(i < 0) {
				DispError(e_mesg);
				if(i == ERROR) return(DBH_ERR);
				return(ERROR) ;
			}
		}

		switch(option) {
		case	EDIT :
			i = ReadItem((int)(s_sth.s_field-1), UPDATE) ;
			if(i == PROFOM_ERR) return(i) ;
			if(i == DBH_ERR) return(i) ;
			/* Copy the Item to List */

			scpy((char*)&(CurPage->Items[s_sth.s_field-1]),
				(char*)&(s_sth.s_items[s_sth.s_field-1]),
				sizeof(S_item)) ;
			if(CurPage->ReqStatus[s_sth.s_field-1] == ' ') 
				CurPage->ReqStatus[s_sth.s_field-1] = COMPLETE;
			break;
		/*	continue ;*/
		}	/* Switch */
	}	/* for( ; ; ) */

	s_sth.s_field = HV_SHORT ;
	fomwf( (char *)&s_sth );
	ret(err_chk(&sr));

	s_sth.s_mesg[0] = HV_CHAR;
	ShowMesg();

	return(NOERROR);
}	/* ChangeItems() */
/*-----------------------------------------------------------------------*/
/* Display message and get the option */
ChangeActDel(status)
char	*status;
{
	int	flag;

	for( ; ; ) {
#ifdef ENGLISH
		STRCPY(s_sth.s_mesg,"Enter RETURN to terminate Edit");
#else
		STRCPY(s_sth.s_mesg,"Appuyer sur RETURN pour terminer l'ajustement");
#endif
		ShowMesg() ;
		sr.nextfld = CHG_FLD ;
		fomrf( (char *)&s_sth );
		ret(err_chk(&sr));

		if(s_sth.s_field == 0) break ;
		if( s_sth.s_field < 1 || CurPage == NULL ||
				s_sth.s_field > CurPage->NoItems)
			continue ;

		if(strcmp(s_sth.s_items[s_sth.s_field-1].s_act_del,ACTIVE)==0 
		   && strcmp(status,ACTIVE) == 0 ||
		   strcmp(s_sth.s_items[s_sth.s_field-1].s_act_del,DELETED)==0 
		   && strcmp(status,DELETED) == 0) {
			continue;
		}
		/* Change status on screen and in linked list */
		STRCPY(s_sth.s_items[s_sth.s_field-1].s_act_del,status);
		STRCPY(CurPage->Items[s_sth.s_field-1].s_act_del,status);
		sr.nextfld = ((s_sth.s_field-1)*STEP) + 
					ITEM_ST_FLD + ACTDEL_FLD;
		fomwf( (char *)&s_sth );
		ret(err_chk(&sr));

		/* Calculate Totals and Display */
		if(strcmp(status,ACTIVE) == 0) 
			flag = 1;
		else
			flag = -1;

		s_sth.s_total_itm += 
				s_sth.s_items[s_sth.s_field-1].s_value * flag;

		s_sth.s_total_diff = s_sth.s_total_req - s_sth.s_total_itm;

		ret(WriteFields(TOTAL_ST_FLD,TOTAL_END_FLD));
			
	}
	/* Hide Field Number */
	s_sth.s_field = HV_SHORT;
	ret(WriteFields(CHG_FLD,CHG_FLD));

	return(ERROR);
}
/*-----------------------------------------------------------------------*/
/* Display message and get the option */
static
GetOption(msg,options)
char	*msg ;
char	*options ;
{
	int	i, j ;

	STRCPY(s_sth.s_mesg,msg);
	ShowMesg() ;

	sr.nextfld = END_FLD ;
	for( ; ; ) {
		fomrf( (char *)&s_sth ) ;
		ret(err_chk(&sr)) ;

		j = strlen(options) ;
		for( i = 0 ; i < j ; i++)
			if(s_sth.s_resp[0] == options[i]) break ;
		if(i != j) break ;	/* Valid Option Selected */
#ifdef ENGLISH
		fomer("Invalid Option..");
#else
		fomer("Option invalide..");
#endif
	}

	s_sth.s_mesg[0] = HV_CHAR ;
	s_sth.s_resp[0] = HV_CHAR ;
	
	ret( WriteFields(END_FLD -100, END_FLD) );

	return((int)(options[i])) ;
}	/* GetOption() */
/*-----------------------------------------------------------------------*/
/* Move req header details to Screen Header part and read req items
   into linked list and show the Req first page on screen */

ShowReq()
{
	int	err ;
	
	if( CheckFund((short)1) <0 ) 	return(-1);

	/* Initialize totals to zero */
	s_sth.s_total_req = 0.00;
	s_sth.s_total_itm = 0.00;
	s_sth.s_total_diff = 0.00;

	/* Make Items Linked List from req */
	if((err = MakeReqItemsList()) < 0) return(err) ;

	if((err = ReqHdrtoScrHdr()) < 0) return(err) ;	/* Move Header Fields */
	/* Get Req total and calculate Difference Items total calculated in
	   MakeReqItemsList() */
	s_sth.s_total_req = s_sth.s_req_amt;
	s_sth.s_total_diff = s_sth.s_total_req - s_sth.s_total_itm;	

	if((err = ShowItems(CurPage)) < 0) return(err) ;	/* Show Items */

	return(NOERROR) ;
}	/* ShowReq() */
/*-----------------------------------------------------------*/
/* Move Req Header to Screen Hdr Fields */

ReqHdrtoScrHdr()
{
	/* Copy Key */
	s_sth.s_req_no = req_hdr.code ;

	/* Copy Header Fields */
	STRCPY(s_sth.s_supp_cd,req_hdr.supp_cd);
	s_sth.s_costcenter = req_hdr.costcenter;
	s_sth.s_req_amt = req_hdr.amount ;
	s_sth.s_entry_dt = req_hdr.date ;
	s_sth.s_due_dt = req_hdr.due_date ;
	s_sth.s_approve_amt = req_hdr.appamt ;
	s_sth.s_billto = req_hdr.billto ;
	s_sth.s_fund = req_hdr.funds ;
	s_sth.s_stckfund = req_hdr.stock_fund;
	s_sth.s_approve_dt = req_hdr.appdate ;
	s_sth.s_shipto = req_hdr.shipto ;
	s_sth.s_period = req_hdr.period ;
	STRCPY(s_sth.s_attention,req_hdr.attention);
	STRCPY(s_sth.s_status,req_hdr.status) ;

	ret( WriteFields( KEY_START, HDR_END_FLD) ) ;
	return(NOERROR) ;
}	/* ReqHdrtoScrHdr() */
/*-----------------------------------------------------------*/
/* Read PO Items and make Linked list */

MakeReqItemsList()	/* Make the linked list from PO Items */
{
	int	err, i ;

	req_item.code = req_hdr.code ;
	req_item.item_no = 0;
	flg_reset(REQITEM);	/* Initialize to get first rec under givenkey */

	ReqLast = CurPage = NULL ;
	i = 0 ;

	for( ; ; ){
#ifndef ORACLE
		err = get_n_reqitem( &req_item, BROWSE, 0, FORWARD, e_mesg);
#else
		err = get_n_reqitem( &req_item, BROWSE, 0, EQUAL, e_mesg);
#endif
		if(ERROR == err) return(DBH_ERR) ;
		if(EFL == err) break ;

#ifndef ORACLE
		/* If PO changes break */
		if( req_item.code != req_hdr.code) break ;
#endif

		if(PAGESIZE == i) i = 0 ;
		if(0 == i)		/* 1st Item in the Page */
			if((err = MakeFreshPage()) < 0) return(err) ;

		CurPage->Items[i].s_sno = i + 1 ;
		STRCPY(CurPage->Items[i].s_accno, req_item.acct) ;
		STRCPY(CurPage->Items[i].s_overbud, " ") ;
		STRCPY(CurPage->Items[i].s_stck_cd, req_item.st_code);
		STRCPY(CurPage->Items[i].s_itm_stat, req_item.appstat);
		CurPage->Items[i].s_school = req_item.school ;
		STRCPY(CurPage->Items[i].s_desc, req_item.desc);

		STRCPY(CurPage->Items[i].s_gst, req_item.tax1);
		STRCPY(CurPage->Items[i].s_pst, req_item.tax2);
						
		calctax(CurPage->Items[i].s_gst,CurPage->Items[i].s_pst,
			req_item.value,&tax_cal);

		CurPage->Items[i].s_ord_qty = req_item.orig_qty ;
		if (req_item.unit[0] == LV_CHAR) 
			STRCPY(CurPage->Items[i].s_uom, "    ");
		else
			STRCPY(CurPage->Items[i].s_uom, req_item.unit);
		CurPage->Items[i].s_unit_cost = req_item.unitprice ;
		CurPage->Items[i].s_net_amt = req_item.value;
		CurPage->Items[i].s_value = tax_cal.gros_amt; 

		CurPage->Items[i].s_po_nbr = req_item.pocode;
		STRCPY(CurPage->Items[i].s_act_del,ACTIVE);

		CurPage->ReqItemNo[i] = req_item.item_no ;
		CurPage->ReqStatus[i] = ' ';

		/* Calculate Items Total */
		s_sth.s_total_itm += CurPage->Items[i].s_value;

		CurPage->NoItems++ ;
		i++ ;
	} 
	seq_over(REQITEM) ;

	if(ReqLast != NULL)
		CurPage = FirstPage ;

	return(NOERROR) ;
}	/* MakeReqItemsList() */
/*-----------------------------------------------------------*/
/* Move Screen Hdr Fields to Req Header */

ScrHdrtoReqHdr(mode)
int	mode ;
{

	req_hdr.code = s_sth.s_req_no ;

	STRCPY(req_hdr.supp_cd, s_sth.s_supp_cd) ;
	req_hdr.billto = s_sth.s_billto ;
	req_hdr.shipto = s_sth.s_shipto ;
	req_hdr.costcenter = s_sth.s_costcenter;
	req_hdr.date = s_sth.s_entry_dt ;
	req_hdr.funds = s_sth.s_fund ;
	req_hdr.stock_fund = s_sth.s_stckfund ;
	req_hdr.amount = s_sth.s_req_amt ;
	req_hdr.due_date = s_sth.s_due_dt ;
	req_hdr.period = s_sth.s_period ;
	req_hdr.appdate = s_sth.s_approve_dt ;
	req_hdr.code = s_sth.s_req_no;
	STRCPY(req_hdr.attention, s_sth.s_attention) ;
	if (mode == ADD) {
		req_hdr.print_form[0] = NO ;
		req_hdr.print_stock[0] = NO ;
		req_hdr.print_rpt[0] = NO ;
	}
	req_hdr.appamt = s_sth.s_approve_amt ;
	STRCPY(req_hdr.status,s_sth.s_status) ;
	
		/* round all calculated double variables before writing CL*/

	req_hdr.amount = D_Roundoff(req_hdr.amount); 
	req_hdr.appamt = D_Roundoff(req_hdr.appamt);  

	return(NOERROR) ;
}	/* ScrHdrtoReqHdr() */
/*------------------------------------------------------------------------*/
/* Move High values to all data fields and clear the screen */

ClearScreen()
{
	int	i;

	/* Move High Values to Hedaer part */
	InitHdr(HV_CHAR, HV_SHORT, HV_LONG, HV_DOUBLE) ;

	s_sth.s_page_no    = HV_SHORT ;
	s_sth.s_dummy1[0] = HV_CHAR ;

	/* Move High Values to All items */
	for(i = 0 ; i < PAGESIZE ; i++)
		InitItem(i,HV_CHAR,HV_SHORT,HV_LONG,HV_DOUBLE) ;

	/* Only used for requisition approval */
	s_sth.s_reason[0] = HV_CHAR;

	InitTotals(HV_DOUBLE);

	ret( WriteFields(HDR_ST_FLD, (END_FLD - 200)) );

	return(NOERROR);
}	/* ClearScreen() */
/*-------------------------------------------------------------------------*/
/* Initialize Screen Header with either Low or High Values */

InitHdr( t_char, t_short, t_long, t_double )
char	t_char ;
short	t_short ;
long	t_long ;
double	t_double ;
{
	s_sth.s_supp_cd[0] = t_char ;
	s_sth.s_costcenter = t_short ;
	s_sth.s_req_amt = t_double ;
	s_sth.s_entry_dt = t_long ;
	s_sth.s_due_dt = t_long ;
	s_sth.s_approve_amt = t_double ;
	s_sth.s_billto = t_short ;
	s_sth.s_fund = t_short ;
	s_sth.s_stckfund = t_short ;
	s_sth.s_approve_dt = t_long ;
	s_sth.s_shipto = t_short ;
	s_sth.s_period = t_short ;
	s_sth.s_attention[0] = t_char ;

	if (s_sth.s_fn[0] == ADDREC && t_char == LV_CHAR) 
		s_sth.s_status[0] = OPEN ;
	else
		s_sth.s_status[0] = t_char ;


	return(NOERROR) ;
}	/* InitHdr() */
/*-------------------------------------------------------------------------*/
/* Initialize Given screen item with either Low values or High values */

InitItem(item_no, t_char, t_short, t_long, t_double)
int	item_no ;
char	t_char ;
short	t_short ;
long	t_long ;
double	t_double ;
{

	if(t_short == HV_SHORT) 
		s_sth.s_items[item_no].s_sno = t_short ;

	s_sth.s_items[item_no].s_accno[0] = t_char ;
	s_sth.s_items[item_no].s_overbud[0] = ' ';
	s_sth.s_items[item_no].s_stck_cd[0] = t_char ;
	s_sth.s_items[item_no].s_itm_stat[0] = t_char ;
	s_sth.s_items[item_no].s_school = t_short ;
	s_sth.s_items[item_no].s_desc[0] = t_char ;

	if(t_short == LV_SHORT) 
		s_sth.s_items[item_no].s_subhdg[0] = ' ';
	else
		s_sth.s_items[item_no].s_subhdg[0] = t_char;

	s_sth.s_items[item_no].s_gst[0] = t_char;
	s_sth.s_items[item_no].s_pst[0] = t_char;
	s_sth.s_items[item_no].s_ord_qty = t_double ;
	s_sth.s_items[item_no].s_uom[0] = t_char ;
	s_sth.s_items[item_no].s_unit_cost = t_double ;
	s_sth.s_items[item_no].s_net_amt = t_double ;
	s_sth.s_items[item_no].s_value = t_double ;
	s_sth.s_items[item_no].s_po_nbr = t_long;	
	s_sth.s_items[item_no].s_act_del[0] = t_char;	

	return(NOERROR) ;
}	/* Inititem() */
/*-------------------------------------------------------------------------*/
/* Initialize Given screen item with either Low values or High values */
InitTotals(t_double)
double t_double;
{
	
	s_sth.s_total_req = t_double;
	s_sth.s_total_itm = t_double;
	s_sth.s_total_diff = t_double;

	return(NOERROR);
}	/* InitTotals() */
/*-------------------------------------------------------------------------*/

static
DispError(s)    /* show ERROR and wait */
char	*s;
{
	strncpy(s_sth.s_mesg,s, (sizeof(s_sth.s_mesg) - 1));
	ShowMesg();
#ifdef ENGLISH
	fomen("Press any key to continue");
#else
	fomen("Appuyer sur une touche pour continuer");
#endif
	get();
	s_sth.s_mesg[0] = HV_CHAR;
	ShowMesg();
	return(NOERROR);
}
/*-------------------------------------------------------------------------*/

ShowMesg()  /* shows or clears message field */
{
	sr.nextfld = END_FLD - 100;
	fomwf( (char *)&s_sth ) ;
	return(0);
}

/*-------------------------------------------------------------------------*/
HeaderEdit()
{

	int retval;
	int firstfld,lastfld;

	/* Make copy of the screen in case of ESC-F */
	scpy((char*)&image, (char*)&s_sth, sizeof(s_sth));

#ifdef ENGLISH
	STRCPY(s_sth.s_mesg,"Enter RETURN to terminate Edit");
#else
	STRCPY(s_sth.s_mesg,"Appuyer sur RETURN pour terminer l'ajustement");
#endif
	ShowMesg();


	for( ; ; ){
		/* Read number of field to be changed */
		s_sth.s_field = LV_SHORT;
		retval = ReadFields(CHG_FLD, CHG_FLD,
			KeyAndHdrValidation, HdrAndKeyWindowHelp, 0) ;
		if( retval < 0) return(retval);
		if( retval==RET_USER_ESC ){
			s_sth.s_field = HV_SHORT;
			ret(WriteFields(CHG_FLD,CHG_FLD));
			break;
		}
		if(s_sth.s_field == 0) {
			s_sth.s_field = HV_SHORT;
			ret(WriteFields(CHG_FLD,CHG_FLD));
			break;
		}
		switch(s_sth.s_field){
			case 1: 	/* Supplier code */
				firstfld = lastfld = SUPPCD_FLD;
				break;
			case 2: 	/* Requisition amount */
				firstfld = lastfld = REQAMT_FLD;
				break;
			case 3: 	/* Entry date */
				firstfld = lastfld = ENTRYDT_FLD;
				break;
			case 4: 	/* Due date */
				if (s_sth.s_fn[0] == ADDREC) {
					firstfld =  DUEDT_FLD;
					lastfld = SHIPTO_FLD;
				}
				else  firstfld = lastfld = DUEDT_FLD; 
				break;
			case 7: 	/* Ship To date */
				firstfld = lastfld = SHIPTO_FLD;
				break;
			case 9: 	/* Attention */
				firstfld = lastfld = ATT_FLD;
				break;
#ifdef ENGLISH
			default: fomer("Can't change specified field");
#else
			default: fomer("Ne peut pas changer le champ specifie");
#endif
				continue;
		}
		retval = ModifyField(firstfld, lastfld);
		if( retval<0 )	return(retval);
		if( retval==RET_USER_ESC ){
			s_sth.s_field = HV_SHORT;
			ret(WriteFields(CHG_FLD,CHG_FLD));
			CopyBack((char*)&s_sth,(char*)&image,firstfld,lastfld);
			break;
		}
	}
	return(0);
}
ModifyField( firstfld, lastfld )	/* Read & change the specified fields */
int firstfld,lastfld;
{
	int i, retval;

	for( i=firstfld; i<=lastfld; i+=100 ){
		fomca1( i,19,2);	/* enable dup buffers */
	}
	sr.nextfld = firstfld;
	sr.endfld = lastfld;
	fomud( (char *)&s_sth);		/* Update dup buffers */
	/* Reset fields because fomud initializes endfld to 0 */
	sr.nextfld = firstfld;
	sr.endfld = lastfld;
	switch(firstfld){
		case SUPPCD_FLD:	/* Supplier code */
			s_sth.s_supp_cd[0] = LV_CHAR;
			break;
		case REQAMT_FLD:	/* Requisition amount */
			s_sth.s_req_amt = LV_DOUBLE;
			break;
		case ENTRYDT_FLD:	/* Entry date */
			s_sth.s_entry_dt = LV_LONG;
			break;
		case DUEDT_FLD:	/* Due date */
			s_sth.s_due_dt = LV_LONG;
			break;
		case SHIPTO_FLD:	/* Ship to */
			s_sth.s_shipto = LV_SHORT;
			break;
		case ATT_FLD:	/* Attention field */
			s_sth.s_attention[0] = LV_CHAR;
			break;
		default:
			break;
	}
	retval = ReadFields(firstfld, lastfld,
		KeyAndHdrValidation, HdrAndKeyWindowHelp, UPDATE) ;
	if( retval<0 || retval==RET_USER_ESC )	return(retval);
	for( i=firstfld; i<=lastfld; i+=100 ){
		fomca1( i,19,0);	/* disable dup buffers */
		fomca1( i,10,1);	/* enable escape flag */
	}

	/* if changing amount field update totals on botton of screen */
	/* only if the totals are showing on bottom of screen */
	if(firstfld == REQAMT_FLD && s_sth.s_total_itm != HV_DOUBLE) {
		/* Calculate and Display totals at Bottom of Screen */
		s_sth.s_total_req = s_sth.s_req_amt;
		s_sth.s_total_diff = s_sth.s_total_req - s_sth.s_total_itm;

		ret(WriteFields(TOTAL_ST_FLD,TOTAL_END_FLD));
	}
	return(0);
}
/******************************************************************/
/* Check to see if budget exceeded.                               */
CheckOverBudget(mode,temppage,item_no)
int	mode;
Page	*temppage;
int 	item_no ;
{
	int 	i, retval;
	double	diff;
	double	temp;
	double	commit_req;
	Page	*current_pg;

	diff = 0.00;
	commit_req = 0.00;

	gst_tax = ( (temppage->Items[item_no].s_gst[0] == TAXABLE)
		? ctl_rec.gst_tax : 0.0 );
	pst_tax = ( (temppage->Items[item_no].s_pst[0] == TAXABLE)
		? ctl_rec.pst_tax : 0.0 );
	/* calculate alloc_amt with tax for pi_value */
	diff = Commit_Calculation(gst_tax,pst_tax,ctl_rec.rebate,
		temppage->Items[item_no].s_value,&tax_cal);
	diff = D_Roundoff(diff);

	retval = CheckGlAcnt(temppage->Items[item_no].s_accno) ;
	if(retval < 0) return(retval);
	/* Form the search key for the requisition item file.  This	*/
	/* will allow access to all requisition line items that have	*/
	/* the same fund and account as those passed.			*/
	req_item.fund = req_hdr.funds;
	STRCPY(req_item.acct,temppage->Items[item_no].s_accno);
	req_item.code = 0;
	req_item.item_no = 0;

	flg_reset(REQITEM);

	/* For each requisition line item.				*/
	for ( ; ;) {
		retval=get_n_reqitem((char*)&req_item,BROWSE,1,FORWARD,e_mesg); 
		if(retval == EFL) break;
		if(retval < 0) {
			DispError(e_mesg);
			return(retval) ;
		}
		/* If the fund or account number do not match the	*/
		/* desired one, then set the retcode to EFL to indicate	*/
		/* an exceptable return code and leave the loop.	*/
		if (req_item.fund != req_hdr.funds || 
		    strcmp(req_item.acct,temppage->Items[item_no].s_accno)) {
			break;
		}

		/* If the status is Unapproved then it is not a 	*/
		/* commitment so continue to the next record.		*/
		if (req_item.appstat[0] != ' ' && req_item.appstat[0] != 'A')
		{
			continue;
		}

		gst_tax = ( (req_item.tax1[0] == TAXABLE)
			? ctl_rec.gst_tax : 0.0 );
		pst_tax = ( (req_item.tax2[0] == TAXABLE)
			? ctl_rec.pst_tax : 0.0 );
		/* calculate alloc_amt with tax for pi_value */
		commit_req += Commit_Calculation(gst_tax,pst_tax,ctl_rec.rebate,
			req_item.value,&tax_cal);
		commit_req = D_Roundoff(commit_req);
	}

	temp = gl_rec.budcur - gl_rec.comdat - gl_rec.ytd - commit_req;
/*****
printf("\nadding in amount %lf from requ %ld item %ld",req_item.value,
	req_item.code, req_item.item_no);get(); 
printf("\nat this point the other requs total %lf",commit_req);get();
louis = commit_req;

printf("\nthe total of this requ is %lf",commit_req - louis);get();
printf("\n current budget: %lf", gl_rec.budcur);
printf("\n commit to date: %lf", gl_rec.comdat);
printf("\n commit yr to dt: %lf", gl_rec.ytd);
printf(" \n requ ammount : %lf", commit_req);
printf("\n press any key to continue");
get();
******/

	if(current_pg->Items[item_no].s_value > DELTA_AMT && temp < diff)
		strcpy(bdgt_flag,"Y");
	else
		strcpy(bdgt_flag,"N");

	return(NOERROR);
}	/* CheckOverBudget() */
/*-----------------------------------------------------------------------*/
/* Procedure written to make sure GL Account and Stock Codes are for the */
/* correct funds.							 */
/*-----------------------------------------------------------------------*/
ValFundAcnt()
{
	double	total, diff ;
	Page	*temppage ;
	int	i, err ;

	if(ReqLast != NULL)
	    for(temppage=FirstPage;temppage!=NULL;temppage=temppage->NextPage) {
		/* Take Each Req Item and Update the files */
		for(i = 0 ; i < temppage->NoItems ; i++) {
			err=CheckGlAcnt(temppage->Items[i].s_accno) ;
			if(err == ERROR){
				DispError("Please Check the Account Number and Make sure it is for the Appropriate Fund");
				return(ERROR);
			}
			if(strcmp(temppage->Items[i].s_stck_cd,"\0")==0) 
				continue;
			err=CheckStock(temppage->Items[i].s_stck_cd,BROWSE);
			if(err == ERROR){
				DispError("Please Check the Stock Code and Make sure it is for the Appropriate Fund");
				return(ERROR);
			}
		}

		/* IF the process is done upto Current Req Last Page,
		   then break */
		if(temppage == ReqLast) break ;
	    }

	return(NOERROR) ;
}	/* ValFundAcnt() */
/*-------------------- E n d   O f   P r o g r a m ---------------------*/
