/*------------------------------------------------------------------------
Found a problem in this program with large data files.  Theread in UPDATE
mode in the procmerge is opening too many files and creating a lock problem.

Source Name: reqmerge.c
System     : Accounts Payables.
Created  On: 1st April 91.
Created  By: J PRESCOTT.

DESCRIPTION:
	Program to merge requisitions into Purchase Orders.

MODIFICATIONS:        

Programmer     YY/MM/DD       Description of modification
~~~~~~~~~~     ~~~~~~~~       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
------------------------------------------------------------------------*/

#define	MAIN		/* Main program. This is to declare Switches */
#define MAINFL		POHDR

#define	SYSTEM		"REQUISITIONING"	/* Sub System Name */
#define	MOD_DATE	"1-APR-91"		/* Program Last Modified */

#include <stdio.h>
#include <cfomstrc.h>
#include <bfs_defs.h>
#include <bfs_recs.h>
#include <requ.h>

#define	DELTA_AMT	0.005	/* To Check float and double values for zero */
#define	DELTA_QTY	0.00005	/* To Check float and double values for zero */
#define EXIT	   	12

/* User Interface define constants */
#ifdef ENGLISH
#define MERGE		'M'
#define PROCESS		'P'
#define EXITOPT		'E'

#define	YES		'Y'
#define NO		'N'
#define	EDIT		'E'
#define	CANCEL		'C'
#else
#define MERGE		'I'
#define PROCESS		'T'
#define EXITOPT		'F'

#define	YES		'O'
#define NO		'N'
#define	EDIT		'M'
#define	CANCEL		'A'
#endif

/* PROFOM Releted declarations */

#define	SCR_NAME	"reqmerge"	/* PROFOM screen Name */

/* Field PROFOM numbers */
#define START_FLD 	400	/* Start Field in range */
#define	END_FLD		1500	/* Last Field of the screen */

#define DUEDATE		400	/* due on or before date field number */
#define SUPPCD1		500	/* starting supplier code field number */
#define SUPPCD2		600	/* ending supplier code field number */
#define REQNO1		700	/* starting requisition no. field number */
#define REQNO2		800	/* ending requisition no. field number */
#define FUND1		900	/* starting fund no. field number */
#define FUND2		1000	/* ending fund no. field number */
#define CCNO1		1100	/* starting cost center no. field number */
#define CCNO2		1200	/* ending cost center no. field number */
#define OPTION		1300	/* option choice field number */
#define MESSAGE		1400	/* message field number */
#define RESPONSE	1500	/* response field number */

/* pselect.sth - header for C structure generated by PROFOM EDITOR */

typedef struct	{

	char	s_pgm[11];	/* 100 program name */
	long	s_rundate;	/* 300 run date */
	long	s_duedate;	/* 400 due date */
	char 	s_suppcd1[11];	/* 500 starting supplier code */
	char	s_suppcd2[11];	/* 600 ending supllier code */
	long	s_reqno1;	/* 700 starting trans ref. no. */
	long	s_reqno2;	/* 800 ending trans ref. no. */
	short	s_fund1;	/* 900 starting fund # */
	short 	s_fund2;	/* 1000 ending fund # */
	short	s_ccno1;	/* 1100 starting cc# */
	short 	s_ccno2;	/* 1200 ending cc# */
	char	s_option[2];	/* 1300 option choice */
	char	s_mesg[78];	/* 1400 message field */
	char	s_resp[2];	/* 1500 response field */
	} S_STRUCT;


S_STRUCT	s_sth;	/* PROFOM Screen Structure */
static	struct  stat_rec  sr;		/* PROFOM status rec */

/* File structures */
Pa_rec	pa_rec;
Req_hdr	req_hdr;

static	char 	e_mesg[100];  		/* dbh will return err msg in this */

double 	D_Roundoff();

main(argc,argv)
int argc;
char *argv[];
{
	int 	retval;

	retval = Initialize(argc,argv);	/* Initialization routine */

	if(CC_no != pa_rec.pa_distccno) {
#ifdef ENGLISH
		fomer("Can only be run from district office");
#else
		fomer("Ne peut pas fonctionner a partir du conseil scolaire");
#endif
		retval=-1;
	}

	if (retval == NOERROR) retval = Process();

	CloseRtn();			/* return to menu */
	if (retval != NOERROR) exit(1);
	exit(0);
}

/*-------------------------------------------------------------------*/
/* Initialize PROFOM */

Initialize(argc, argv)
int	argc ;
char	*argv[] ;
{
	int	err ;

	/*
	*	Initialize DBH Environment
	*/
	strncpy(SYS_NAME,SYSTEM,50);	/* Sub system name */
	strncpy(CHNG_DATE,MOD_DATE,10);	/* Modification Date */

	proc_switch(argc, argv, MAINFL) ; 	/* Process Switches */

	/*
	*	Initialize PROFOM & Screen
	*/
	STRCPY(sr.termnm,terminal);	/* Copy Terminal Name */
	fomin(&sr);
	ret(err_chk(&sr)) ;		/* Check for PROFOM Error */
	fomcf(1,1);			/* Enable Snap screen option */

	err = InitScreen() ;		/* Initialize Screen */
	if(NOERROR != err) return(err) ;

	err = settax();
	if(err != NOERROR) {
		fomer(e_mesg);
		get();
		return(ERROR);
	}
	/*
	*	Get The Parameter Record
	*/
	err = get_param(&pa_rec, BROWSE, 1, e_mesg) ;
	if(err == ERROR) {
		DispError(e_mesg);
		return(ERROR) ;
	}
	else if(err == UNDEF) {
#ifdef ENGLISH
		DispError("Parameters Are Not Setup..");
#else
		DispError("Parametres ne sont pas etablis..");
#endif
		return(ERROR) ;
	}

	return(NOERROR) ;
}	/* Initialize() */

/*--------------------------------------------------------------------------*/
/* Close nessary files and environment before exiting program               */

CloseRtn() 
{
	/* Set terminal back to normal mode from PROFOM */
	fomcs();
	fomrt();

	close_dbh();	/* Close files */

	return(NOERROR);
}	/* CloseRtn() */
/*----------------------------------------------------------------*/
/* Initialize screen before going to process options */

InitScreen()
{
	/* move screen name to Profom status structure */
	STRCPY(sr.scrnam,NFM_PATH);
	strcat(sr.scrnam,SCR_NAME) ;

	STRCPY(s_sth.s_pgm,PROG_NAME);
	s_sth.s_rundate = get_date();	/* get Today's Date in YYYYMMDD format*/
	s_sth.s_option[0] = HV_CHAR;
	s_sth.s_mesg[0] = HV_CHAR ;
	s_sth.s_resp[0] = HV_CHAR ;

	/* Move Low Values to data fields */
	InitFields() ;

	return(NOERROR) ;
}	/* InitScreen() */

/*-------------------------------------------------------------------*/
/* Get Option from user and call corresponding function */

Process()
{
	int	err;

	for( ; ; ){

		if((err = ReadOption())<0) 
			return(err);

		switch(s_sth.s_option[0]) {
		case  EXITOPT :
			return(NOERROR);
		case  MERGE :
		case  PROCESS :
			if(pa_rec.pa_cur_period == 0) {
#ifdef ENGLISH
				fomer("Not Allowed Before Yearly Closing...");
#else
				fomer("Pas permis avant la fermeture annuelle...");
#endif
				get();
				break;
			}
			CHKACC(err,ADD,e_mesg);
			err = ProcRequisitions(s_sth.s_option) ;
			break ;
		default :
			continue;
		}

		if(NOACCESS == err)	fomen(e_mesg);
		if(PROFOM_ERR == err)	return(PROFOM_ERR);  /* PROFOM ERROR */
		if(DBH_ERR == err) {
			DispError(e_mesg);
#ifdef ENGLISH
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"System Error... Iserror:",
				iserror, dberror, errno);
#else
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"Erreur du systeme... Iserror:",
				iserror, dberror, errno);
#endif
			DispError(e_mesg);
			return(DBH_ERR); /* DBH ERROR */
		
		}
	}      /*   end of the for( ; ; )       */
}	/* Process() */
/*------------------------------------------------------------*/
ReadOption()
{

	s_sth.s_mesg[0] = HV_CHAR;
	ShowMesg();	
	s_sth.s_resp[0] = HV_CHAR;
	ret(WriteFields(RESPONSE,RESPONSE));	

#ifdef ENGLISH
	fomer("M(erge), P(rocess individual), E(xit)");
#else
	fomer("I(nterclasser), T(raiter individuellement), F(in)");
#endif
	sr.nextfld = OPTION;
	fomrf((char *)&s_sth);
	ret(err_chk(&sr));

}	/* ReadOption */
/*------------------------------------------------------------*/
ProcRequisitions(option)
char	*option;
{
	int	i, err ;

	for(i = START_FLD ; i <= END_FLD - 300 ; i += 100)
		fomca1(i, 19, 0) ;    /* disable dup control */

	err = ReadRange(ADD) ;
	if(err != NOERROR) {
		return(err) ;
	}

	for( ; ; ) {
		err = ProcOptions() ;
		if(err != YES){
			 break ;
		}
	
		if(option[0] == MERGE) {
			err = ProcMerge();
		}
		else {
			err = ProcIndividual();
		}	
		if(err == LOCKED) {
			continue;
		}
		break;
	}

	return(err);
}	/* ProcRequisitions() */
/*------------------------------------------------------------*/
/* Get the Header details from user */

ReadRange(mode)
int	mode ;
{
	int	 i, err ;

	if(mode == ADD) {
#ifdef ENGLISH
		STRCPY(s_sth.s_mesg,"Press ESC-F to Go to Option:");
#else
		STRCPY(s_sth.s_mesg,"Appuyer sur ESC-F pour retourner a option:");
#endif
		ShowMesg();

		fomca1(DUEDATE, 19, 2) ;
		fomca1(SUPPCD1, 19, 2);
		fomca1(SUPPCD2, 19, 2) ;
		fomca1(REQNO1, 19, 2) ;
		fomca1(REQNO2, 19, 2) ;
		fomca1(FUND1, 19, 2) ;
		fomca1(FUND2, 19, 2) ;
		fomca1(CCNO1, 19, 2) ;
		fomca1(CCNO2, 19, 2) ;
		s_sth.s_duedate = 99991231 ;
		STRCPY(s_sth.s_suppcd1, "0");
		STRCPY(s_sth.s_suppcd2, "ZZZZZZZZZZ");
		s_sth.s_reqno1 = 0;
		s_sth.s_reqno2 = 99999999;
		s_sth.s_fund1 = 1 ;
		s_sth.s_fund2 = 999 ;
		s_sth.s_ccno1 = 1 ;
		s_sth.s_ccno2 = 99 ;
		sr.nextfld = DUEDATE ;
		sr.endfld = END_FLD - 300 ;
		fomud((char*)&s_sth);
		ret(err_chk(&sr));
	}
	InitFields() ;

	i = ReadFields(START_FLD, END_FLD - 300, mode) ;
	if(PROFOM_ERR == i || DBH_ERR == i) return(i) ;
	if(RET_USER_ESC == i) {	/* ESC-F */
		return(RET_USER_ESC) ;
	}

	return(NOERROR) ;
}	/* ReadRange() */
/*------------------------------------------------------------*/
/* Read the PROFOM Screen for a given Range of fields */

ReadFields(st_fld, end_fld, mode)
int	st_fld ;
int	end_fld ;
int	mode ;
{
	int	err ;

	sr.nextfld = st_fld ;
	sr.endfld  = end_fld ;

	for( ; ;){
		fomrd( (char *)&s_sth );
		ret(err_chk(&sr));
		if(sr.retcode == RET_VAL_CHK){
			err = Validation() ;
			if(DBH_ERR == err || PROFOM_ERR == err) return(err);
			sr.nextfld = sr.curfld ;
			continue;
		}
		if(sr.retcode == RET_USER_ESC){
			if(mode == ADD &&
				(sr.escchar[0] == 'f' || sr.escchar[0] == 'F'))
					return(RET_USER_ESC) ;
			continue;
		}
		/* else RET_NO_ERROR */
		break;
	}

	return(NOERROR) ;
}	/* ReadFields() */
/*------------------------------------------------------------*/
/* Write fields on Screen for a given Range */

WriteFields(st_fld, end_fld)
int	st_fld ;
int	end_fld ;
{
	sr.nextfld = st_fld ;
	sr.endfld  = end_fld ;

	fomwr( (char *)&s_sth );
	ret(err_chk(&sr));

	return(NOERROR) ;
}	/* WriteFields() */
/*----------------------------------------------------------------*/
/* Validation function() for Key and Header fields when PROFOM returns
  RET_VAL_CHK */

Validation()
{
	switch(sr.curfld){
	case SUPPCD1:  /* ending supplier code */
		Right_Justify_Numeric(s_sth.s_suppcd1
					,(sizeof(s_sth.s_suppcd1)-1));
		break;
	case SUPPCD2:  /* ending supplier code */
		Right_Justify_Numeric(s_sth.s_suppcd2
					,(sizeof(s_sth.s_suppcd2)-1));
		if(strcmp(s_sth.s_suppcd2,s_sth.s_suppcd1) <0) {
#ifdef ENGLISH
			fomer("Ending code cannot precede starting code");
#else
			fomer("Code finissant ne peut pas preceder le code debutant");
#endif
			s_sth.s_suppcd2[0] = LV_CHAR;
		}
		break;
	case REQNO2:  /* ending requisition no. */
		if(s_sth.s_reqno2 < s_sth.s_reqno1) {
#ifdef ENGLISH
			fomer("Ending number cannot precede starting number");
#else
			fomer("Numero finissant ne peut pas preceder le numero debutant");
#endif
			s_sth.s_reqno2 = LV_LONG;
		}
		break;
	case FUND2:  /* ending fund number */
		if(s_sth.s_fund2 == 0) {
#ifdef ENGLISH
			fomer("Ending fund must be greater than Zero");
#else
			fomer("Fond finissant doit etre plus grand que zero");
#endif
			s_sth.s_fund2 = LV_SHORT;
		}
		if(s_sth.s_fund2 < s_sth.s_fund1) {
#ifdef ENGLISH
			fomer("Ending fund cannot precede starting fund");
#else
			fomer("Fond finissant ne peut pas preceder le fond debutant");
#endif
			s_sth.s_fund2 = LV_SHORT;
		}
		break;
	case CCNO2:  /* ending cost center number */
		if(s_sth.s_ccno2 < s_sth.s_ccno1) {
#ifdef ENGLISH
			fomer("Ending cost center cannot precede starting cost center");
#else
			fomer("Centre de cout finissant ne peut pas preceder le centre de cout commencant");
#endif
			s_sth.s_ccno2 = LV_SHORT;
		}
		break;
	default :
#ifdef ENGLISH
		sprintf(e_mesg,"No Validity Check For Field#  %d",sr.curfld);
#else
		sprintf(e_mesg,"Pas de controle de validite pour le Champ#  %d",sr.curfld);
#endif
		fomen(e_mesg);
		get();
		return(ERROR) ;
	}	/* Switch sr.curfld */

	return(NOERROR) ;
}	/* Validation() */
/*-----------------------------------------------------------------------*/
/* Take the confirmation from user for the header part */

ProcOptions()
{
	int	err ;

	for( ; ; ) {
#ifdef ENGLISH
		err = GetOption("Y(es), E(dit), C(ancel)", "YEC");
#else
		err = GetOption("O(ui), M(odifier), A(nnuler)", "OMA");
#endif
		if(err == PROFOM_ERR) return(err) ;

		switch(err) {
		case  YES :
			return(YES) ;
		case  EDIT  :
			err = ReadRange(UPDATE);
			if(err != NOERROR) return(err) ;
			break ;
		case  CANCEL :
#ifdef ENGLISH
			err = GetOption("Confirm the Cancel (Y/N)?", "YN") ;
#else
			err = GetOption("Confirmer l'annulation (O/N)?", "ON") ;
#endif
			if(err == YES) { 
				roll_back(e_mesg) ;	/* Unlock  Records */
				return(CANCEL) ;
			}
			break ;
		}	/* switch err */

		if(err == PROFOM_ERR) return(err) ;
		if(err == DBH_ERR) return(err) ;
	}	/* for(; ; ) */
}	/* ProcOptions() */
/*-----------------------------------------------------------------------*/
/* Display message and get the option */

GetOption(msg,options)
char	*msg ;
char	*options ;
{
	int	i, j ;

	STRCPY(s_sth.s_mesg,msg);
	ShowMesg() ;

	sr.nextfld = RESPONSE ;
	for( ; ; ) {
		fomrf( (char *)&s_sth ) ;
		ret(err_chk(&sr)) ;

		j = strlen(options) ;
		for( i = 0 ; i < j ; i++)
			if(s_sth.s_resp[0] == options[i]) break ;
		if(i != j) break ;	/* Valid Option Selected */
#ifdef ENGLISH
		fomer("Invalid Option..");
#else
		fomer("Option invalide..");
#endif
	}

	s_sth.s_mesg[0] = HV_CHAR ;
	s_sth.s_resp[0] = HV_CHAR ;
	
	ret( WriteFields(MESSAGE,RESPONSE) );

	return((int)(options[i])) ;
}	/* GetOption() */
/*-------------------------------------------------------------------------*/
/* Initialize Screen Header with either Low Values */

InitFields()
{
	s_sth.s_duedate = LV_LONG ;
	s_sth.s_suppcd1[0] = LV_CHAR ;
	s_sth.s_suppcd2[0] = LV_CHAR ;
	s_sth.s_reqno1 = LV_LONG ;
	s_sth.s_reqno2 = LV_LONG ;
	s_sth.s_fund1 = LV_SHORT ;
	s_sth.s_fund2 = LV_SHORT ;
	s_sth.s_ccno1 = LV_SHORT ;
	s_sth.s_ccno2 = LV_SHORT ;
	
	return(NOERROR) ;
}	/* InitFields() */
/*-------------------------------------------------------------------------*/
ProcMerge()
{
	int 	err;
	char	current_supp[11];
	long	po_nos[MAX_PO];

	current_supp[0] = '\0';

	req_hdr.funds = s_sth.s_fund1;
	STRCPY(req_hdr.supp_cd,s_sth.s_suppcd1);
	req_hdr.code = s_sth.s_reqno1;
	flg_reset(REQHDR);
	for( ; ; ) {
		err = get_n_reqhdr(&req_hdr,UPDATE,3,FORWARD,e_mesg);
		if(err == EFL) {
			break;
		}
		if(err < 0) {
			DispError(e_mesg);
			return(err);
		}	

printf("\nrecord read is sup %s, code %ld",req_hdr.supp_cd, req_hdr.code);
get();
		/* Check Ranges */
		if(req_hdr.funds > s_sth.s_fund2) {
			break;
		}

		if(req_hdr.due_date > s_sth.s_duedate) {
			continue;
		}

		if((strcmp(req_hdr.supp_cd,s_sth.s_suppcd1) < 0) ||
		   (strcmp(req_hdr.supp_cd,s_sth.s_suppcd2) > 0)) {
			break;
		}
		
		if(req_hdr.code < s_sth.s_reqno1 || 
		   req_hdr.code > s_sth.s_reqno2) {
			continue;
		}

		if(req_hdr.costcenter < s_sth.s_ccno1 || 
		   req_hdr.costcenter > s_sth.s_ccno2) {
			continue;
		}

printf("\nstatus is %s",req_hdr.status);
get();
		if(req_hdr.status[0] != APPROVED) {
			continue;
		}
printf("\nrecord passed checks sup %s, code %ld",req_hdr.supp_cd, req_hdr.code);
get();

		if(strcmp(req_hdr.supp_cd,current_supp) != 0) {
printf("\nrecord put to po sup %s, code %ld",req_hdr.supp_cd, req_hdr.code);
printf("\ncurrent supplier code is %ld",current_supp);
get();
			if(current_supp[0] != '\0') {

/*** added for testing ***/
				req_hdr.funds = 1;
				STRCPY(req_hdr.supp_cd,current_supp);
				req_hdr.code = 99;
				err = get_reqhdr(&req_hdr,UPDATE,3,e_mesg);
				if(err < 0) {
					DispError(e_mesg);
					break;
				}
				
/*** Done addition ***/
				if((err=complete_po(po_nos,e_mesg))!=NOERROR){
					DispError(e_mesg);
					break;
				}
				/* Lock Current Record again. Because 
			           complete_po() does a commit() and releases
				   locks. */
				err = get_reqhdr(&req_hdr,UPDATE,3,e_mesg);
				if(err < 0) {
					DispError(e_mesg);
					break;
				}
			}	
			if((err = init_po()) != NOERROR) {
				break;
			}
			STRCPY(current_supp,req_hdr.supp_cd);
		}

		if((err = req_process(&req_hdr,e_mesg)) != NOERROR) {
			DispError(e_mesg);
			break;
		}
		/* req_process: does a put_reqhdr so the code must be */
		/* incremented to get the next record */
		req_hdr.code++;
	}
	if(err != NOERROR && err != EFL) {
		return(err);
	}

	if(current_supp[0] != '\0') {
printf("\nrecord put to po sup %s, code %ld",req_hdr.supp_cd, req_hdr.code);
get();
		if((err = complete_po(po_nos,e_mesg)) != NOERROR) {
			DispError(e_mesg);
		}
	}
	
	return(NOERROR);
}	/* ProcMerge() */
/*-------------------------------------------------------------------------*/
ProcIndividual()
{
	int 	err;
	long	po_nos[MAX_PO];

	req_hdr.funds = s_sth.s_fund1;
	STRCPY(req_hdr.supp_cd,s_sth.s_suppcd1);
	req_hdr.code = s_sth.s_reqno1;
	flg_reset(REQHDR);
	for( ; ; ) {
		err = get_n_reqhdr(&req_hdr,UPDATE,3,FORWARD,e_mesg);
		if(err == EFL) {
			break;
		}
		if(err < 0) {
			DispError(e_mesg);
			return(err);
		}	

		/* Check Ranges */
		if(req_hdr.funds > s_sth.s_fund2) {
			break;
		}

		if(req_hdr.due_date > s_sth.s_duedate) {
			continue;
		}

		if((strcmp(req_hdr.supp_cd,s_sth.s_suppcd1) < 0) ||
		   (strcmp(req_hdr.supp_cd,s_sth.s_suppcd2) > 0)) {
			continue;
		}
		
		if(req_hdr.code < s_sth.s_reqno1 || 
		   req_hdr.code > s_sth.s_reqno2) {
			continue;
		}
		if(req_hdr.costcenter < s_sth.s_ccno1 || 
		   req_hdr.costcenter > s_sth.s_ccno2) {
			continue;
		}

		if(req_hdr.status[0] != APPROVED) {
			continue;
		}

		if((err = init_po()) != NOERROR) {
			break;
		}

		if((err = req_process(&req_hdr,e_mesg)) != NOERROR) {
			DispError(e_mesg);
			break;
		}

		if((err = complete_po(po_nos,e_mesg)) != NOERROR) {
			DispError(e_mesg);
			break;
		}

		/* req_process: does a put_reqhdr so the code must be */
		/* incremented to get the next record */
		req_hdr.code++;
	}
	
	if(err != NOERROR && err != EFL) {
		return(err);
	}
	return(NOERROR);
}	/* ProcIndividual() */
/*-------------------------------------------------------------------------*/
DispError(s)    /* show ERROR and wait */
char	*s;
{
	strncpy(s_sth.s_mesg,s, (sizeof(s_sth.s_mesg) - 1));
	ShowMesg();
#ifdef ENGLISH
	fomen("Press any key to continue");
#else
	fomen("Appuyer sur une touche pour continuer");
#endif
	get();
	roll_back(e_mesg);
	s_sth.s_mesg[0] = HV_CHAR;
	ShowMesg();
	return(NOERROR);
}
/*-------------------------------------------------------------------------*/
ShowMesg()  /* shows or clears message field */
{
	sr.nextfld = MESSAGE;
	fomwf( (char *)&s_sth ) ;
}
/*-----------------------------------------------------------*/
char	/* Display message and retrieve response. */
confirm(s)

char	*s;	/* Prompt message.	*/

{
	/* Display message.	*/
	STRCPY(s_sth.s_mesg,s);
	sr.nextfld = END_FLD - 100;
	fomwf((char*)&s_sth);

	/* Get user response.	*/
	sr.nextfld = END_FLD;
	sr.endfld = END_FLD;
	fomrf((char*)&s_sth);
	if (err_chk(&sr) == PROFOM_ERR)
	{
		return('\0');
	}

	return(s_sth.s_resp[0]);
}	/* confirm() */
/*-------------------- E n d   O f   P r o g r a m ---------------------*/

