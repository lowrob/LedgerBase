/*-----------------------------------------------------------------------
Source Name: massappr.c
System     : Requisitioning
Created  On: 08th Nov. 95.
Created  By: Louis Robichaud.

DESCRIPTION:
	Program to mass Approve Requisitions to avoid having to go into each
individual item.

	This program was taken from the reqappr.c

MODIFICATIONS:        

Programmer     YY/MM/DD       Description of modification
------------------------------------------------------------------------*/
#define	MAIN		/* Main program. This is to declare Switches */
#define MAINFL		REQHDR			/* main file used */

#define	SYSTEM		"REQUISITIONING"	/* Sub System Name */
#define	MOD_DATE	"08-NOV-95"		/* Progran Last Modified */

#include <stdio.h>
#include <cfomstrc.h>
#include <bfs_defs.h>
#include <bfs_recs.h>
#include <requ.h>

#define	DELTA_AMT  0.005	/* To Check double values for zero */
#define	DELTA_QTY  0.00005	/* To Check double values for zero */

#define HEADER		0
#define ITEMS		1

/* User Interface define constants */
#ifdef ENGLISH
#define APPROVE		'A'
#define CHANGE		'C'
#define INQUIRE		'I'
#define EXITOPT		'E'
#define	NEXT		'N'
#define	PREV		'P'

#define	YES		'Y'
#define NO		'N'
#define	ADDITEMS	'A'
#define	DELITEM		'D'
#define	REVIVEITEM	'R'
#define	EDIT		'E'
#define	STATUSEDIT	'S'
#define HEADEREDIT	'H'
#define	NEXTPAGE	'N'
#define	PREVPAGE	'P'
#define	CANCEL		'C'

#define ACTIVE		"ACT"

#else
#define APPROVE		'A'
#define CHANGE		'C'
#define INQUIRE		'I'
#define EXITOPT		'F'
#define	NEXT		'S'
#define	PREV		'P'

#define	YES		'O'
#define NO		'N'
#define	ADDITEMS	'R'
#define	DELITEM		'E'
#define	REVIVEITEM	'V'
#define	EDIT		'M'
#define	STATUSEDIT	'C'
#define HEADEREDIT	'E'
#define	NEXTPAGE	'S'
#define	PREVPAGE	'P'
#define	CANCEL		'A'

#define ACTIVE		"ACT"

#endif

/* PROFOM Releted declarations */

#define	SCR_NAME	"reqmaint"	/* PROFOM screen Name */
#define	SCR_NAME1	"massappr"	/* PROFOM screen Name */

#define	PAGESIZE	2		/* No of Items */

/* PROFOM Screen STH file */

/* Field PROFOM numbers */
#define INITSTREQU	400	/* Start field for init screen */
#define INITENDREQU	500	/* End field for init screen */
#define	INITEND_FLD	700	/* Last Field of the init screen */

#define	HDR_ST_FLD	800	/* Header Start Field */
#define	HDR_END_FLD	2300	/* Header End Field */
#define	ITEM_ST_FLD	2400	/* Item 1 Start Field */
#define	END_FLD		9700	/* Last Field of the screen */
#define	STEP		1700	/* NO of fields diff. between 2 items */

#define REASON_FLD	5800	/* Reason Field */

#define TOTAL_ST_FLD	5900	/* Totals Start Field */
#define TOTAL_END_FLD	6100	/* Totals End Field */

/* HDR Fields */
#define	FN_FLD		400	/* Fn: */
#define	KEY_START	500	/* Req Number */
#define	KEY_END		500	/* Req Number */
#define	CHG_FLD		600	/* Field: */

#define	SUPPCD_FLD	800	/* Supplier Cd: */
#define REQAMT_FLD	1000 	/* Req Amt: */
#define	ENTRYDT_FLD	1100	/* Entry Dt: */
#define DUEDT_FLD	1200	/* Due Date */
#define APPAMT_FLD	1300	/* Due Date */
#define	FUND_FLD	1500	/* Fund: */
#define	STCKFUND_FLD	1600	/* Stock Fund: */
#define APPDT_FLD	1700	/* Due Date */
#define SHIPTO_FLD	1800	/* Ship To: */
#define	PERIOD_FLD	1900	/* Period: */
#define STATUS_FLD	2000    /* Status: */
#define ATT_FLD		2100    /* Attention: */

#define	PAGENO_FLD	2200	/* Page#: */
#define COLHDG_FLD	2300
	
/* Item Fields. These numbers are difference between that field
   and the 1st fld within the item */
#define	ACNO_FLD	100
#define	STCKCD_FLD	300
#define ITM_STAT_FLD	400
#define	SCHOOL_FLD	500
#define DESC_FLD	600

#define GST_FLD		800
#define	PST_FLD		900
#define	QTY_FLD		1000
#define UOM_FLD		1100
#define	PRICE_FLD	1200
#define	NET_FLD		1300
#define GROSS_FLD	1400
#define REQNBR_FLD	1500
#define ACTDEL_FLD	1600

#define OVERBUDGET	1

/* massappr.sth - header for C structure generated by PROFOM EDITOR */
/* This is the initial screen that is used for setup */

typedef	struct	{

	char	s_pgm[11];	/* Program name Field 100 */
	char	s_scrname[27]; 	/* Screen Name Field 200 */
	long	s_rundate;	/* DATE YYYYFMMFDD Field 300 */
	long	s_strequ;	/* Requ starting number Field 400*/
	long	s_endrequ;	/* Requ ending number Field 500*/
	char	s_mesg[78];	/* Message Field 600 */
	char	s_resp[2];	/* Response Field 700 */
	} S_init;

/* reqmaint.sth - header for C structure generated by PROFOM EDITOR */
/* This is the main screen */

typedef	struct	{	/* Start Fld 2400, Endfld 5700 and Step 1600 */

	short	s_sno;		/* NUMERIC 999 field 2400 */
	char	s_accno[19];	/* STRING XXXXXXXXXXXXXXXXXX Field 2500 */
	char	s_overbud[2];	/* STRING X field 2600 */
	char	s_stck_cd[11];	/* STRING XXXXXXXXXX Field 2700 */
	char	s_itm_stat[2];	/* STRING XXX Field 2800 */
	short	s_school;	/* NUMERIC 99 Field 2900 */
	char	s_desc[61];	/* STRING X(60) Field 3000 */
	char	s_subhdg[2];	/* STRING X Field 3100 */
	char	s_gst[2];	/* STRING XX Field 3200 */
	char	s_pst[2];	/* STRING XX Field 3300 */
	double	s_ord_qty;	/* NUMERIC 99999.9999 Field 3400 */
	char	s_uom[7];	/* STRING XXXXXX Field 3500 */
	double	s_unit_cost;	/* NUMERIC 99999.999 Field 3600 */
	double	s_net_amt;	/* NUMERIC 9999999.99 Field 3700 */
	double	s_value;	/* NUMERIC 9999999.99 Field 3800 */
	long	s_po_nbr;	/* NUMERIC 99999999 Field 3900 */
	char	s_act_del[4];	/* STRING XXX Field 4000 */
}	S_item ;

typedef struct	{

	char	s_pgm[11];	/* STRING XXXXXXXXXX Field 100 */
	char	s_scrname[27]; 	/* STRING X(14) Field 200 */
	long	s_rundate;	/* DATE YYYYFMMFDD Field 300 */
	char	s_fn[2];	/* STRING X Field 400 */
	long	s_req_no;	/* NUMERIC 99999999 Field 500 */
	short	s_field;	/* NUMERIC 999 Field 600 */

	char	s_supp_cd[11];	/* STRING XXXXXXXXXX Field 800 */
	short	s_costcenter;	/* NUMERIC 99 Field 900 */
	double  s_req_amt;	/* NUMERIC 99999999.99 Field 1000 */
	long	s_entry_dt;	/* DATE YYYYFMMFDD Field 1100 */
	long	s_due_dt;	/* DATE YYYYFMMFDD Field 1200 */
	double  s_approve_amt;	/* NUMERIC 9999999.99 Field 1300 */
	short	s_billto;	/* NUMERIC 99 Field 1400 */
	short	s_fund;		/* NUMERIC 999 Field 1500 */
	short	s_stckfund;	/* NUMERIC 999 Field 1600 */
	long	s_approve_dt;	/* DATE YYYYFMMFDD Field 1700 */
	short	s_shipto;	/* NUMERIC 99 Field 1800 */
	short	s_period;	/* STRING X Field 1900 */
	char	s_status[2];	/* STRING X Field 2000 */
	char	s_attention[16];/* STRING X(15) Field 2100 */
	short	s_page_no;	/* NUMERIC 99 Field 2200 */
	char	s_dummy1[4];	/* STRING X Field 2300 */

	S_item	s_items[PAGESIZE] ;	/* Start Fld 2400, End Fld 5700 and
					   Step 1600 */

	char	s_reason[71];	/* STRING X(70) Field 5800 */

	double	s_total_req;	/* NUMERIC 9999999.99 Field 5900 */
	double	s_total_itm;	/* NUMERIC 9999999.99 Field 6000 */
	double	s_total_diff;	/* NUMERIC 99999999.99 Field 6100 */

	char	s_mesg[78];	/* STRING X[77] Field 9600 */
	char	s_resp[2];	/* STRING X Field 9700 */
} s_struct;


static	short	pst_tax;
static	short	gst_tax;
static  Tax_cal tax_cal;
static  double  net_amt;
double	D_Roundoff();
double	Commit_Calculation();

static	S_init	s_init;		/* The profom first screen with the ranges */
static	s_struct  s_sth,image;	/* PROFOM Screen Structure */
static	struct  stat_rec  sr;		/* PROFOM status rec */

static	Req_hdr		req_hdr, tmp_reqhdr ;	/* Requistion Header */
static  Req_item 	req_item, tmp_reqitm ;	/* Requisiton Item Record */
static  Req_reason 	req_reason;	/* Requisition Reason Record */
static	Supplier	supplier;	/* Supplier */
static	Pa_rec		pa_rec ;	/* Parameters Record */
static	Ctl_rec		ctl_rec ;	/* Fund/Control Record */
static	Gl_rec		gl_rec ;	/* Gl Master rec, for general purpose */
static	St_mast		stck_rec ;	/* Stock Master Rec */
static	Alloc_rec	aloc_rec ;	/* Allocation Rec */
static	Sch_rec		schl_rec ;	/* School Record */

static	char 	e_mesg[100];  		/* dbh will return err msg in this */

/*
*	Doubly linked list to maintain req items. Each node in this list
*	conatins one page full of req items. This list is freed only at the
*	time of exiting program. 
*/

typedef	struct Page {

	S_item	Items[PAGESIZE] ;	/* Items information */
	short	ReqItemNo[PAGESIZE] ;	/* Corresponding Req Item# */
	char	ReqStatus[PAGESIZE] ;	/* Status Add, Change */
	char	ReqReason[PAGESIZE][71];/* Reason For each Item Disapproved */
	struct	Page	*PrevPage ;	/* Ptr to Previous Page */
	struct	Page	*NextPage ;	/* Ptr to Next Page */
	short	NoItems ;		/* No of Items in this page */
	short	Pageno ;		/* Page Number */

}	Page ;

static	char	HdrReason[71];		/* Reason for whole req. Disapproval */

static	Page	*FirstPage,		/* Address of the First Page */
		*CurPage,		/* Address of the Active Page */
		*ReqLast,		/* Address of Cur. REQ Last page */
		*LastPage ;		/* Address of the Last page Memory
					   allocated */
long	Entry_date;			/* Last Entry date used */
char	Prev_acct[19];
int	items_committed;		/* number of items commited to file */

int	KeyAndHdrValidation(), ItemsValidation() ;
int	HdrAndKeyWindowHelp(), ItemsWindowHelp() ;
int	Argc;
char	**Argv;

void	free() ;
char	*malloc() ;
static	double alloc_qty;
static	double stck_req_qty;
static	int edit_field;
double	amnt_available = 0;
main(argc,argv)
int argc;
char *argv[];
{
	int 	retval;

	/* These two are passed to execute() when it is called */
	Argc = argc;
	Argv = argv;


	retval = Initialize(argc,argv);	/* Initialization routine */

	if(CC_no != pa_rec.pa_distccno) {
#ifdef ENGLISH
		fomer("Can only be run from district office");
#else
		fomer("Ne peut pas fonctionner a partir du conseil scolaire");
#endif
		retval=-1;
	}

	if (retval == NOERROR) retval = ReqProcess();

	CloseRtn();			/* return to menu */
	if (retval != NOERROR) exit(-1);

	exit(0);
}

/*-------------------------------------------------------------------*/
/* Initialize PROFOM */

Initialize(argc, argv)
int	argc ;
char	*argv[] ;
{
	int	err ;

	/* Initialize DBH Environment */
	strncpy(SYS_NAME,SYSTEM,50);	/* Sub system name */
	strncpy(CHNG_DATE,MOD_DATE,10);	/* Modification Date */

	proc_switch(argc, argv, MAINFL) ; 	/* Process Switches */

	/* Initialize PROFOM & Screen */
	STRCPY(sr.termnm,terminal);	/* Copy Terminal Name */
	fomin(&sr);
	ret(err_chk(&sr)) ;		/* Check for PROFOM Error */
	fomcf(1,1);			/* Enable Snap screen option */

	/* Initilize the first screen */
	err = InitScreen1();
	if(NOERROR != err) return(err) ;

	/* Get The Parameter Record */
	err = get_param(&pa_rec, BROWSE, 1, e_mesg) ;
	if(err == ERROR) {
		DispError(e_mesg);
		return(ERROR) ;
	}
	else if(err == UNDEF) {
#ifdef ENGLISH
		DispError("Parameters Are Not Set Up ...");
#else
		DispError("Parametres ne sont pas etablis... ");
#endif
		return(ERROR) ;
	}

	err = GetRanges();
	if(NOERROR != err) return(err) ;

	err = ConfirmInitScr();
	if(err == CANCEL) return(ERROR);

	err = InitScreen() ;		/* Initialize Screen */
	if(NOERROR != err) return(err) ;

	err = settax(e_mesg);	/* Set up the global tax variables.	*/
	if (err != NOERROR)
	{
		fomer(e_mesg);
		get();
		return(ERROR);
	}

	/* Initialize first Entry date to system date */
	Entry_date = get_date();

	/* Initialize Variables */

	FirstPage = NULL ;
	LastPage  = NULL ;

	return(NOERROR) ;
}	/* Initialize() */

/*--------------------------------------------------------------------------*/
GetRanges()
{

	int err, value, i;

	value = 2;

	/* Set the dup buffer */
	for( i=INITSTREQU; i<=INITENDREQU; i+=100 )
		fomca1( i, 19, value);
	if( value==0 )
		return(0);
	sr.nextfld = INITSTREQU;
	sr.endfld = INITENDREQU;
	fomud( (char *)&s_init );
	ret( err_chk(&sr) );

	s_init.s_strequ = LV_LONG;
	s_init.s_endrequ = LV_LONG;

	sr.nextfld = INITSTREQU ;
	sr.endfld  = INITENDREQU;
	for( ; ;){
		fomrd( (char *)&s_init );
		ret(err_chk(&sr));

/********* This routine is for validation
		if(sr.retcode == RET_VAL_CHK){
			err = (*Validate)(mode) ;
			if(DBH_ERR == err || PROFOM_ERR == err) return(err);
			sr.nextfld = sr.curfld ;
			sr.endfld =  INITENDREQU;
			continue;
		}
**********************/
		if(sr.retcode == RET_USER_ESC){
			if(sr.escchar[0] == 'f' || sr.escchar[0] == 'F')
				return(RET_USER_ESC) ;
/******* Window Help
			if(sr.escchar[0] == 'h' || sr.escchar[0] == 'H'){
				err = (*WindowHelp)() ;
				if(DBH_ERR == err || PROFOM_ERR == err)
					return(err) ;
				sr.nextfld = sr.curfld ;
				sr.endfld =  end_fld;
				continue;
			}
**************/
			continue;
		}
		/* else RET_NO_ERROR */
		break;
	}

	return(NOERROR);

}
/*-----------------------------------------------------------------------*/
/* Take the confirmation from user for the initial screen */

ConfirmInitScr()
{
	int	err ;

	for( ; ; ) {
#ifdef ENGLISH
		err = GetInitOption("Y(es), E(dit), C(ancel)", "YEC");
#else
		err = GetInitOption("O(ui), M(odifier), A(nnuler)", "RMA");
#endif
		if(err == PROFOM_ERR) return(err) ;

		switch(err) {
		case  YES :
			return(YES) ;
		case  EDIT  :
			err = GetRanges();
			break ;
		case  CANCEL :
#ifdef ENGLISH
			err = GetInitOption("Confirm the Cancel (Y/N)?", "YN") ;
#else
			err = GetInitOption("Confirmer l'annulation (O/N)?", "ON") ;
#endif
			if(err == YES) return(CANCEL) ;
			break ;
		}	/* switch err */

		if(err == PROFOM_ERR) return(err) ;
		if(err == DBH_ERR) return(err) ;
	}	/* for(; ; ) */
}	/* ConfirmInitScr() */
/*-----------------------------------------------------------------------*/
/* Display message and get the option for the initial screen */

static
GetInitOption(msg,options)
char	*msg ;
char	*options ;
{
	int	i, j ;

	STRCPY(s_init.s_mesg,msg);

	/* Show the message */
	sr.nextfld = INITEND_FLD - 100;
	fomwf( (char *)&s_init ) ;

	sr.nextfld = INITEND_FLD ;
	for( ; ; ) {
		fomrf( (char *)&s_init ) ;
		ret(err_chk(&sr)) ;

		j = strlen(options) ;
		for( i = 0 ; i < j ; i++)
			if(s_init.s_resp[0] == options[i]) break ;
		if(i != j) break ;	/* Valid Option Selected */
#ifdef ENGLISH
		fomer("Invalid Option..");
#else
		fomer("Option invalide..");
#endif
	}

	s_sth.s_mesg[0] = HV_CHAR ;
	s_sth.s_resp[0] = HV_CHAR ;
	
	ret( WriteFields(INITEND_FLD -100, INITEND_FLD) );

	return((int)(options[i])) ;
}	/* GetOption() */
/*--------------------------------------------------------------------------*/
/* Close nessary files and environment before exiting program               */

CloseRtn() 
{
	/* Free the linked list from the end */

	/* Free all the pages except the first page */
	for( ; LastPage != FirstPage ; ) {
		LastPage = LastPage->PrevPage ;
		free((char*)LastPage->NextPage) ;
		LastPage->NextPage = NULL ;
	}
	if(FirstPage != NULL)
		free((char*)FirstPage) ;
		
	FirstPage = LastPage = NULL ;

	/* Set terminal back to normal mode from PROFOM */
	fomcs();
	fomrt();

	close_dbh();	/* Close files */

	return(NOERROR);
}	/* CloseRtn() */
/*----------------------------------------------------------------*/
/* Initialize first info screen before going to process options */

InitScreen1()
{
	int	err ;

	/* move screen name to Profom status structure */
	STRCPY(sr.scrnam,NFM_PATH);
	strcat(sr.scrnam,SCR_NAME1) ;

	STRCPY(s_init.s_pgm,PROG_NAME);
#ifdef ENGLISH
	STRCPY(s_init.s_scrname, "MASS REQUISITION APPROVAL ");
#else
	STRCPY(s_init.s_scrname, "APPROBATION DE REQUISITION");
#endif
	s_init.s_rundate = get_date();	/* get Today's Date in YYYYMMDD format*/
	s_init.s_mesg[0] = HV_CHAR ;
	s_init.s_resp[0] = HV_CHAR ;

	return(NOERROR) ;
}	/* InitScreen1() */
/*----------------------------------------------------------------*/
/* Initialize screen before going to process options */

InitScreen()
{
	int	err ;

	/* move screen name to Profom status structure */
	STRCPY(sr.scrnam,NFM_PATH);
	strcat(sr.scrnam,SCR_NAME) ;

	STRCPY(s_sth.s_pgm,PROG_NAME);
#ifdef ENGLISH
	STRCPY(s_sth.s_scrname, "MASS REQUISITION APPROVAL ");
#else
	STRCPY(s_sth.s_scrname, "APPROBATION DE REQUISITION");
#endif
	s_sth.s_rundate = get_date();	/* get Today's Date in YYYYMMDD format*/
	s_sth.s_field = HV_SHORT ;
	s_sth.s_mesg[0] = HV_CHAR ;
	s_sth.s_resp[0] = HV_CHAR ;

	/* Initialize Key Fields. So that, if user selectes 'N' option
	   immediately after invoking program, then he gets the first
	   record in the file */

	s_sth.s_req_no = 0 ;

	/* Move High Values to data fields and Display the screen */
	err = ClearScreen() ;
	if(NOERROR != err) return(err) ;

	return(NOERROR) ;
}	/* InitScreen() */

/*-------------------------------------------------------------------*/
/* Get Option from user and call corresponding function */

ReqProcess()
{
	int err;

	for( ; ; ){

		/* Make the function approve automaticly */
		s_sth.s_fn[0] = APPROVE;
		err = NextReq();
		if(err == EFL) return(NOERROR);
		if(err < 0) return(err);

		/* Check For greater than the range set by user */
		if(req_hdr.code > s_init.s_endrequ)
			return(NOERROR);

		err = ApproveReq();

		if(QUIT == err)		return(NOERROR) ;    /* Exit */
		if(NOACCESS == err)	fomen(e_mesg);	     /* security */
		if(PROFOM_ERR == err)	return(PROFOM_ERR);  /* PROFOM ERROR */
		if(DBH_ERR == err) {
			DispError(e_mesg);
#ifdef ENGLISH
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"System Error... Iserror:",
				iserror, dberror, errno);
#else
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"Erreur du systeme... Iserror:",
				iserror, dberror, errno);
#endif
			DispError(e_mesg);
			return(DBH_ERR); /* DBH ERROR */
		}
	}      /*   end of the for( ; ; )       */
}	/* ReqProcess() */
/*----------------------------------------------------------------------*/
/* Adding Req. Get the unique Key, accept details and update the files */

ApproveReq()
{
	int	err ;

	err = SelectReq(UPDATE) ;
	if(NOERROR != err) return(err) ;

	if(req_hdr.status[0] != OPEN) {
#ifdef ENGLISH
		DispError("Can only Approve an outstanding Requistion");
#else
		DispError("Peut seulement approuver une requisition non-reglee");
#endif
		roll_back(e_mesg);
		return(NOERROR) ;
	}

	err = GetApproval() ;
	if(PROFOM_ERR == err || DBH_ERR == err) return(err) ;
	if(err < 0 || CANCEL == err) {
		roll_back(e_mesg) ;	/* Unlock the locked Records */
		return(ClearScreen()) ;	/* Clear the Screen */
	}

	return(NOERROR);
}	/* ApproveReq() */
/*-----------------------------------------------------------------------*/
/* Change the Req */

ChangeReq()
{
	int	err ;

	err = SelectReq(UPDATE) ;
	if(NOERROR != err) return(err) ;

	if(req_hdr.status[0] == PROCESSED) {
#ifdef ENGLISH
		DispError("Requisition has already been Processed.. Changes are not allowed");
#else
		DispError("Requisition a deja ete traitee.. Changements ne sont pas permis");
#endif
		roll_back(e_mesg);
		return(NOERROR) ;
	}
	for( ; ; ) {
		err = ConfirmItems() ;
		if(err != YES) {
			roll_back(e_mesg);
			return(err) ;
		}

		/* put in 'for(;;)' for lock, louis */
		err = WriteRecords(UPDATE) ;
		if(err==NOERROR) break;
		if(err==LOCKED) {
			roll_back(e_mesg) ;
			continue;
		}
		if (err < 0) {
			roll_back(e_mesg);
			return(err) ;
		}
	}

	return(NOERROR) ;
}	/* ChangeReq() */
/*----------------------------------------------------------*/
/* Show the next or previous Req */

NextReq()
{
	int err;

	/* Check whether file is in seq. read mode */
/*****
	if(flg_start(REQHDR) != direction) {
		req_hdr.code = s_init.s_strequ ;
		if (direction == FORWARD)
			req_hdr.code++;
		else	req_hdr.code--;
		flg_reset(REQHDR);
	}
****/
printf("\nInit requ code is %ld",s_init.s_strequ);get();

	req_hdr.code = s_init.s_strequ ;

	for( ; ; ) {
		fomer("Processing Please Wait . . . . .");
		err = get_n_reqhdr(&req_hdr, BROWSE, 0, FORWARD, e_mesg);
#ifndef ORACLE
		seq_over(REQHDR);
#endif
		if(ERROR == err)return(DBH_ERR) ;
		if(EFL == err) {
#ifdef	ENGLISH
			fomen("End of file.... Press Any Key To Continue");
#else
			fomen("Plus de fiches....");
#endif
			get();
			flg_reset(REQHDR);
			return(EFL) ;
		}
		/* If requ is not open then get next one */
		if(req_hdr.status[0] != OPEN)
			continue;

		/* Check For greater than the range set by user */
		if(req_hdr.code > s_init.s_endrequ)
			return(NOERROR);

		/* only show requisitions for current cost center unless
		   district office */
		if(req_hdr.costcenter != CC_no &&
			CC_no != pa_rec.pa_distccno) {
			continue;
		}

		return( ShowReq() ) ;
	}
}	/* NextReq() */
/*----------------------------------------------------------------------*/
/* Read the Req Approval Details from the User */

GetApproval()
{
	int	err ;

	err = ApproveHdr() ;
	if(NOERROR != err) return(err) ;

	err = ApproveItems();
	if(NOERROR != err) return(err) ;

	for( ; ; ) {
		err = AdjustTotals();
		if(NOERROR != err) return(err) ;

/**********
		err = ConfirmItems() ;
		if(err != YES) break;
*/

		err = WriteRecords(UPDATE) ;
		if(err < 0) {
			if(err == LOCKED) continue;
			if(err == DUPE) {
				s_sth.s_req_no = req_hdr.code++;
				/* redisplay new Req no */
				if((err = ReqHdrtoScrHdr()) < 0) 
					return(err) ;	
				continue;
			}
			break;
		}
		break;
	}
	if(err != NOERROR) return(err);
	return(NOERROR) ;
}	/* GetApproval() */
/*----------------------------------------------------------*/
/* Get the Req key and show the Req */

SelectReq(md)
int	md ;	/* UPDATE or BROWSE. UPDATE locks the Req */
{
	int	err ;

	for(; ;){
		/* Get the record from database */
		err = GetReqHdr(md);
		if(ERROR == err) return(DBH_ERR) ;
		if(err < 0) {		/* UNDEF or LOCKED */
			fomer(e_mesg) ;
			get() ;
/* Louis */
			return(ERROR) ;
		}

		if(req_hdr.costcenter != CC_no &&
			CC_no != pa_rec.pa_distccno) {
#ifdef ENGLISH
			fomer("Requistion does not belong to this cost center");
#else
			fomer("Requisition n'appartient pas a ce centre de couts");
#endif
			continue;
		}
		return( ShowReq() ) ;
	}
}	/* SelectReq() */
/*----------------------------------------------------------------------*/
/* Update the records and write to files */

WriteRecords(mode)
int mode;
{
	int	err;
	int	i ;
	Page	*temppage ;

	items_committed = 0;	/* no items written */

	if(mode == UPDATE || mode == P_DEL) {
		req_hdr.code = s_sth.s_req_no ;
		err = get_reqhdr(&req_hdr, mode, 0, e_mesg);
		if(err < 0) {
			DispError(e_mesg) ;
			return(err) ;
		}
     		scpy((char*)&tmp_reqhdr,(char*)&req_hdr,sizeof(req_hdr));
	}

	ScrHdrtoReqHdr(mode) ;		/* Copy Req Header */

	err = put_reqhdr(&req_hdr, mode,e_mesg) ;
	if(err < 0) {
		DispError(e_mesg) ;
		return(err) ;
	}

	err = PutReason(HEADER,0,NULL);
	if(err != NOERROR) {
		DispError(e_mesg);
		return(err);
	}

	if(mode != ADD) {
		err = rite_audit((char*)&s_sth, REQHDR,mode,(char*)&req_hdr,
						(char*)&tmp_reqhdr,e_mesg);
		if(err==LOCKED) {
			DispError(e_mesg);
			roll_back(e_mesg) ;
			return(LOCKED) ;
		}
		if(err != NOERROR ){
#ifdef	ENGLISH
			DispError("ERROR in Saving Records"); 
#else
			DispError("ERREUR en conservant les fiches");
#endif
			DispError(e_mesg);
			roll_back(e_mesg);
			return(err);
		}
	}

	
	/* Copy Items and write to the file */
	if(ReqLast != NULL)
	    for(temppage = FirstPage ; temppage != NULL ;
						temppage = temppage->NextPage) {
		for(i = 0; i < temppage->NoItems ; i++) {
			err = ProcItemUpdates(temppage, i) ;
			if(err==LOCKED) {
				DispError(e_mesg);
				roll_back(e_mesg) ;
				return(LOCKED) ;
			}
			if(err != NOERROR) {
				DispError(e_mesg);
				break ;
			}
			err = PutReason(ITEMS,i,temppage);
			if(err != NOERROR) {
				DispError(e_mesg);
				return(err);
			}

		}
		/* IF the process is done upto Current Req Last Page,
		   then break */
		if(temppage == ReqLast) break ;
	    }

	/* if no items commited to file do not write requisition header */
	if(items_committed == 0) {
		roll_back(e_mesg);
		return(NOERROR);
	}

	if(err == NOERROR) {
		err = commit(e_mesg) ;
		if(err < 0) {
#ifdef ENGLISH
			DispError("ERROR in Saving Records"); 
#else
			DispError("ERREUR en conservant les fiches");
#endif
			DispError(e_mesg);
			return(err);
		}
	}
	return(err);
}	/* WriteRecords() */
/*-----------------------------------------------------------------------*/
/* If this is an Interfund account validate that it is approved through  */
/* stock								 */

CheckInterfund()
{
	Page	*temppage ;
	int	j, items, stock ;

	/* Verfiy Interfund Requisition */
	items = 0;
	stock = 0;

	if(ReqLast != NULL)
	    for(temppage=FirstPage;temppage!=NULL;temppage=temppage->NextPage){
			/* Take Each Req Item and Update the files */
		for(j = 0 ; j < temppage->NoItems ; j++) {
			if(temppage->Items[j].s_itm_stat[0] != STOCK && 
		   	temppage->Items[j].s_itm_stat[0] != '\0' &&
			temppage->Items[j].s_itm_stat[0] != ' ' &&
			temppage->Items[j].s_itm_stat[0] != COMPLETE &&
			temppage->Items[j].s_itm_stat[0] != DISAPPROVED) 
				items++;/*Number not appr. thro stock or blank*/
			if(temppage->Items[j].s_itm_stat[0] == STOCK ||  
			   temppage->Items[j].s_itm_stat[0] == DISAPPROVED) 
				stock++; /*Number appr. through stock */
		}
		if(temppage == ReqLast) break ;
	    }
	if(items>0){
#ifdef ENGLISH
			fomer("This is an Interfund Requisition - Please Approve through Stock");
#else
			fomer("This is an Interfund Requisition - Please Approve through Stock");
#endif
		return(ERROR);
	}
	if(stock < 1){
#ifdef ENGLISH
			fomer("Atleast one Item must be approved through stock");
#else
			fomer("Translate the above ");
#endif
		return(ERROR);
	}
	return(NOERROR);
}
/*-----------------------------------------------------------------------*/ 
/* Check whether total of items amount is equal to Req total */

CheckTotal()
{
	double	total, diff ;
	Page	*temppage ;
	int	j, items ;

	/* Total up all items amount */
	total = 0.0 ;
	items = 0 ;

	if(ReqLast != NULL)
	    for(temppage = FirstPage ; temppage != NULL ;
						temppage = temppage->NextPage) {
		/* Take Each Req Item and Update the files */
		for(j = 0 ; j < temppage->NoItems ; j++) {
			total += temppage->Items[j].s_value ;
			items++ ;
		}

		/* IF the process is done upto Current Req Last Page,
		   then break */
		if(temppage == ReqLast) break ;
	    }

	if(items == 0) {
#ifdef ENGLISH
		DispError("No Items On Requisition..  Cancel to Quit..");
#else
		DispError("Pas d'articles dans Requisition.. Annuler pour retourner..");
#endif
		return(ERROR);
	}

	diff = s_sth.s_req_amt - total ;	/* Differnce */

	if(diff < -(DELTA_AMT) || diff > DELTA_AMT) {
#ifdef ENGLISH
		sprintf(e_mesg,
			"Req Total: %12.2lf  Items Total: %12.2lf Diff: %12.2lf",
			s_sth.s_req_amt, total, diff) ;
#else
		sprintf(e_mesg,
			"Total Req: %.2lf  Total Articles: %.2lf  Diff: %.2lf",
			s_sth.s_req_amt, total, diff) ;
#endif
		DispError(e_mesg) ;
		return(ERROR) ;
	}

	return(NOERROR) ;
}	/* CheckTotal() */
/*-----------------------------------------------------------------------*/ 
/* This function is used to automatically adjust requisition totals.     */
AdjustTotals()
{
	double	total, diff ;
	Page	*temppage ;
	int	i, items ;

	/* Total up all items amount */
	total = 0.0 ;
	items = 0 ;

	if(ReqLast != NULL)
	    for(temppage = FirstPage ; temppage != NULL ;
						temppage = temppage->NextPage) {
		/* Take Each Req Item and Update the files */
		for(i = 0 ; i < temppage->NoItems ; i++) {
			total += temppage->Items[i].s_value ;
			items++ ;
		}

		/* IF the process is done upto Current Req Last Page,
		   then break */
		if(temppage == ReqLast) break ;
	    }

	diff = s_sth.s_req_amt - total ;	/* Differnce */

	s_sth.s_req_amt = total;
	s_sth.s_total_req = total;
	s_sth.s_total_itm = total;
	s_sth.s_total_diff = s_sth.s_total_req - s_sth.s_total_itm;

	if(diff < -(DELTA_AMT) || diff > DELTA_AMT) { 
	   	if(s_sth.s_fn[0] != APPROVE) {
#ifdef ENGLISH
			sprintf(e_mesg,
			"Req amount differs by %6.2lf due to tax calculations"
			 ,diff) ;
#else
			sprintf(e_mesg,
			"Le monant de la req est different de %6.2lf a cause du calcul de la taxe"
			,diff) ;
#endif
			fomer(e_mesg) ;
		}
		/* update requistion amount in header */
		ret(WriteFields(REQAMT_FLD,REQAMT_FLD));

		/* Write totals at bottom of screen */
		ret(WriteFields(TOTAL_ST_FLD,TOTAL_END_FLD));
	}

	return(NOERROR) ;
}	/* AdjustTotals() */

/*-----------------------------------------------------------------------*/ 
/* Process given item and Update the files */

ProcItemUpdates(temppage, item_no)
Page	*temppage ;
int	item_no ;
{
	int 	mode, err;
	int	stock_cd_chg = 0;
	double	os_amt, os_qty;
	double	alloc_amt;
	int	factor;

	if (temppage->Items[item_no].s_itm_stat[0] == 'C') {
		return(NOERROR);
	} 
	if (temppage->Items[item_no].s_stck_cd[0] != '\0' &&
	    temppage->Items[item_no].s_stck_cd[0] != HV_CHAR &&
	    s_sth.s_costcenter != pa_rec.pa_wareccno)  {
		err = AdjustPrevVals(temppage, item_no);
		if (err < 0) return (err);
	}

	req_item.code = req_hdr.code ;
	req_item.item_no = temppage->ReqItemNo[item_no] ;
	err = get_reqitem(&req_item,UPDATE, 0, e_mesg);
	if(err == UNDEF) 
		mode = ADD ;
	else if(err < 0) {
		DispError(e_mesg) ;
		return(DBH_ERR) ;
	}
	else mode = UPDATE;

     	scpy((char*)&tmp_reqitm,(char*)&req_item,sizeof(req_item));

	if(temppage->Items[item_no].s_itm_stat[0] == DISAPPROVED ||
	   s_sth.s_status[0] == DISAPPROVED) {
		os_amt = temppage->Items[item_no].s_net_amt * -1;
		os_qty = temppage->Items[item_no].s_ord_qty * -1;
	}
	else {
		os_amt = temppage->Items[item_no].s_net_amt;
		os_qty = temppage->Items[item_no].s_ord_qty;
	}

	err = UpdateWithReqItem(mode,temppage->ReqItemNo[item_no],
		temppage->Items[item_no]);
	if (err < 0) return(err) ;

	/* Update Allocation */
	/* If not Direct Disbursement */
	if(temppage->Items[item_no].s_stck_cd[0] != '\0' &&
	   temppage->Items[item_no].s_stck_cd[0] != HV_CHAR &&
	   s_sth.s_costcenter != pa_rec.pa_wareccno) {
	   if(os_amt < -(DELTA_AMT) || os_amt > DELTA_AMT || 
  	      os_qty < -(DELTA_QTY) || os_qty > DELTA_QTY) {
		gst_tax = ( (req_item.tax1[0] == TAXABLE)
			? ctl_rec.gst_tax : 0.0 );
		pst_tax = ( (req_item.tax2[0] == TAXABLE)
			? ctl_rec.pst_tax : 0.0 );
		/* calculate alloc_amt with tax for pi_value */
		alloc_amt = Commit_Calculation(gst_tax,pst_tax,ctl_rec.rebate,
			req_item.value,&tax_cal);

		/* Create/Increase the Allocation */
		err = CheckAllocation(&(temppage->Items[item_no]),mode);
		if(err < 0 && err != UNDEF) return(err) ; 

		aloc_rec.st_alloc += os_qty;
		aloc_rec.st_value += alloc_amt;
		if(mode == P_DEL) {
			/* Add Paid amount back because all */
			/* value deleted above */
			gst_tax = ( (req_item.tax1[0] == TAXABLE)
				? ctl_rec.gst_tax : 0.0 );
			pst_tax = ( (req_item.tax2[0] == TAXABLE)
				? ctl_rec.pst_tax : 0.0 );
			aloc_rec.st_value += 
				Commit_Calculation(gst_tax,pst_tax,
				ctl_rec.rebate,req_item.value,&tax_cal);
		}

		if (aloc_rec.st_alloc < DELTA_AMT)
			aloc_rec.st_alloc = 0.00;
		if (aloc_rec.st_value < DELTA_AMT)
			aloc_rec.st_value = 0.00;
			
		aloc_rec.st_alloc = D_Roundoff(aloc_rec.st_alloc);   
		aloc_rec.st_value = D_Roundoff(aloc_rec.st_value);

		if(temppage->Items[item_no].s_itm_stat[0]==DISAPPROVED && 
		  err == UNDEF) {
			/* Do Nothing Allocation and Stock already affected*/
		}
		else {
			if(err == UNDEF) 
				err = put_alloc(&aloc_rec, ADD, e_mesg) ;
			else if (aloc_rec.st_alloc < DELTA_QTY)
				err = put_alloc(&aloc_rec, P_DEL, e_mesg) ;
			else	
				err = put_alloc(&aloc_rec, UPDATE, e_mesg) ;
		
			if (err < 0) return(err) ;

			err = UpdateStock(temppage->Items[item_no].s_stck_cd,
				os_qty,os_amt);
			if (err < 0) return(err) ;
		}
	  }

	}
	items_committed++;	/* add one to items commited */
	return(NOERROR) ;
}	/* ProcItemUpdates() */
/*-----------------------------------------------------------------------*/
/*  If editing req item in change mode, update both previous stock 
    allocation and stock master files if required.			 */

AdjustPrevVals(temppage, item_no)
Page	*temppage ;
int	item_no ;
{
	int	err;
	double	old_quant = 0.0;
	double	old_value = 0.0;

	req_item.code = req_hdr.code ;
	req_item.item_no = temppage->ReqItemNo[item_no] ;
	err = get_reqitem(&req_item, UPDATE, 0, e_mesg);
	
	if(err < 0 && err != UNDEF) {
		return(err) ;
	}
	if(err == UNDEF) return(NOERROR); /* new item added */
	if(req_item.appstat[0] == DISAPPROVED) return(NOERROR);

	old_quant = req_item.orig_qty;
	old_value = req_item.value;

	/* Calculate tax on old_value */

	gst_tax = ( (req_item.tax1[0] == TAXABLE) ? ctl_rec.gst_tax : 0.0 );
	pst_tax = ( (req_item.tax2[0] == TAXABLE) ? ctl_rec.pst_tax : 0.0 );
	old_value = Commit_Calculation(gst_tax,pst_tax,ctl_rec.rebate,
		old_value, &tax_cal);

		/*  Read stock master record for old poitem */

/*	stck_rec.st_fund = req_item.fund ; SHERRY */
	stck_rec.st_fund = req_item.stock_fund ; 
/***	STRCPY(stck_rec.st_code,req_item.st_code) ; ***/
	STRCPY(stck_rec.st_code, temppage->Items[item_no].s_stck_cd);
	err = get_stmast(&stck_rec, UPDATE, 0, e_mesg) ;
	if(err < 0) {
		return(err) ;
	}

	/* Adjust stock master st_alloc */

	stck_rec.st_alloc -= old_quant ;
	if (stck_rec.st_alloc < DELTA_QTY) 
		stck_rec.st_alloc = 0.00;

	/* round stock master double variables calculated */
	stck_rec.st_alloc	= D_Roundoff(stck_rec.st_alloc); 

	/* Update old stock master record */
	/* stck_rec.st_fund = req_item.fund ; SHERRY */
	stck_rec.st_fund = req_item.stock_fund ; 
/*** 	STRCPY(stck_rec.st_code,req_item.st_code) ; ***/
	STRCPY(stck_rec.st_code, temppage->Items[item_no].s_stck_cd);

	err = put_stmast(&stck_rec, UPDATE, e_mesg) ;
	if (err < 0) return(err) ;

	/* Read allocation record */

	/* aloc_rec.st_fund = req_item.fund; lr*/
	aloc_rec.st_fund = req_item.stock_fund; 
	STRCPY(aloc_rec.st_code, req_item.st_code);
	aloc_rec.st_location = req_item.school;
	STRCPY(aloc_rec.st_expacc, req_item.acct);

	err = get_alloc(&aloc_rec, UPDATE, 0, e_mesg) ;
		
/*******LOUIS
	if(err < 0) {
		return(err) ;
	}
********/
	if(err == ERROR) return(DBH_ERR);
	if(err != UNDEF && err < 0) {
		fomer(e_mesg);
		get();
		return(ERROR);
	}
	if(err == UNDEF)
		return(NOERROR);

	aloc_rec.st_alloc -= old_quant;
	if (aloc_rec.st_alloc < DELTA_QTY) 
		aloc_rec.st_alloc = 0.00;

	aloc_rec.st_value -= old_value;
	if(aloc_rec.st_value < DELTA_AMT)
		aloc_rec.st_value = 0.00;

		/* round allocation values after mathmatical 
				calculations */

	aloc_rec.st_alloc = D_Roundoff(aloc_rec.st_alloc);
	aloc_rec.st_value = D_Roundoff(aloc_rec.st_value); 

	/* aloc_rec.st_fund = req_item.fund; lr*/ 
	aloc_rec.st_fund = req_item.stock_fund; 
	STRCPY(aloc_rec.st_code, req_item.st_code);
	aloc_rec.st_location = req_item.school;
	STRCPY(aloc_rec.st_expacc, req_item.acct);
	
	if (aloc_rec.st_alloc < DELTA_QTY)
		err = put_alloc(&aloc_rec, P_DEL, e_mesg) ;
	else	
		err = put_alloc(&aloc_rec, UPDATE, e_mesg) ;

	if (err < 0) return(err) ;

	return(NOERROR);
}  /* AdjustPrevVals */

/*----------------------------------------------------------------*/
/* get the allocation for given keys in UPDATE mode. If record not exists
   and mode = ADD then make the new record and return UNDEF */

CheckAllocation(s_item, mode)
S_item	*s_item ;
int	mode ;
{
	int	err ;

	/* aloc_rec.st_fund = s_sth.s_fund ; lr*/
	aloc_rec.st_fund = s_sth.s_stckfund ;
	STRCPY(aloc_rec.st_code, s_item->s_stck_cd) ;
	aloc_rec.st_location = s_item->s_school ;
	STRCPY(aloc_rec.st_expacc, s_item->s_accno) ;

	err = get_alloc(&aloc_rec, UPDATE, 0, e_mesg) ;
	if(ERROR == err) return(DBH_ERR) ;
	if(err != UNDEF && err < 0) {
		fomer(e_mesg) ;
		get() ;
		return(ERROR) ;
	}
	if(err == UNDEF && mode == UPDATE) { /* Used if gl account changed */
		mode = ADD;
	}
	if(err == UNDEF && mode == ADD) {	/* Make the Rec */
		aloc_rec.st_date = s_sth.s_entry_dt ;
		aloc_rec.st_time = get_time() ;
		aloc_rec.st_issued = 0.0 ;
		aloc_rec.st_alloc = 0.0 ;
		aloc_rec.st_value = 0.0 ;
	}
	return(err) ;
}	/* CheckAllocation() */
/*-----------------------------------------------------------------------*/
/* Update the stock allocation and on-order quantities.  If site wants   */
/* to have po/inventory interface which is set in the parameters then    */
/* the committed value and average price in inventory will be updated.   */

UpdateStock(stock_code, quantity, amount)
char	*stock_code;
double	quantity;
double	amount;
{
	int	err;
	double	qty;

	err = CheckStock(stock_code,UPDATE) ;
	if (err < 0) return(err) ;

	stck_rec.st_alloc += quantity ;
	if (stck_rec.st_alloc < DELTA_QTY) 
		stck_rec.st_alloc = 0.00;

	stck_rec.st_alloc = D_Roundoff(stck_rec.st_alloc); 

	err = put_stmast(&stck_rec, UPDATE, e_mesg) ;
	if (err < 0) return(err) ;

	return(NOERROR);
}	/* UpdateStock() */

/*-----------------------------------------------------------------------*/ 
/* Updating files when ReqIsGiven. Get the REQ item, increase the QTY and
  paid value and update */

UpdateWithReqItem(mode,req_item_no,s_item)
int	mode ;
short	req_item_no ;
S_item 	s_item ;
{
	int 	err ;
	short	i;

	if (mode == ADD) {
		req_item.code = req_hdr.code ;
		req_item.item_no = req_item_no ;
		err = get_reqitem(&req_item,BROWSE, 0, e_mesg);
		/* get new item no if exists in the file */
		for (i = req_item_no; err == 0; i++){
			req_item.code = req_hdr.code ;
			req_item.item_no = i ;
			err = get_reqitem(&req_item,BROWSE, 0, e_mesg);
		}
  		req_item.fund = req_hdr.funds ;
		req_item.stock_fund = req_hdr.stock_fund ;
		req_item.value = s_item.s_value ;
		req_item.pocode = s_item.s_po_nbr;
	}
		/* for UPDATE mode, the original value remains the amount
		   originally entered not the current value. */
	if(mode != P_DEL) {
		STRCPY(req_item.acct, s_item.s_accno);
		STRCPY(req_item.st_code, s_item.s_stck_cd);
		STRCPY(req_item.appstat, s_item.s_itm_stat);
		req_item.school = s_item.s_school ;
		STRCPY(req_item.desc, s_item.s_desc);
		STRCPY(req_item.unit, s_item.s_uom);
		STRCPY(req_item.tax1, s_item.s_gst);
		STRCPY(req_item.tax2, s_item.s_pst);
		req_item.unitprice = s_item.s_unit_cost ;
		req_item.orig_qty = s_item.s_ord_qty ;
		req_item.value = s_item.s_net_amt ;
  		req_item.fund = req_hdr.funds ;
		req_item.stock_fund = req_hdr.stock_fund ;
	
			/* round any calculated reqitem double values */
		req_item.value = D_Roundoff(req_item.value); 
		req_item.value = D_Roundoff(req_item.value); 
		if(s_item.s_overbud[0] == '*')
			req_item.bdgt_flag[0] = YES;
		else
			req_item.bdgt_flag[0] = NO;
	}
	err = put_reqitem(&req_item, mode,e_mesg) ;
	if(err < 0) {
		DispError(e_mesg) ;
		return(DBH_ERR) ;
	}

	if(s_sth.s_fn[0] == CHANGE && mode != ADD) {
		err = rite_audit((char*)&s_sth, REQITEM,mode,(char*)&req_item,
						(char*)&tmp_reqitm,e_mesg);
		if(err==LOCKED) {
			DispError(e_mesg);
			roll_back(e_mesg) ;
			return(LOCKED) ;
		}
		if(err != NOERROR){
#ifdef	ENGLISH
			DispError("ERROR in Saving Records"); 
#else
			DispError("ERREUR en conservant les fiches");
#endif
			DispError(e_mesg);
			roll_back(e_mesg);
			return(DBH_ERR);
		}
	}

	return(NOERROR) ;
}	/* UpdateWithReqItem() */
/*-----------------------------------------------------------*/
PutReason(position,item_no,temppage)
int	position;	/* 0 - header    1 - items */
int	item_no;	/* item number */
Page	*temppage;
{
	int err;
	int mode;

	req_reason.reqr_code = req_hdr.code;
	if(position == HEADER) {
		req_reason.reqr_item_no = item_no;
	}
	else {
		req_reason.reqr_item_no = temppage->ReqItemNo[item_no];
	}
	err=get_reqreason((char *)&req_reason,UPDATE,0,e_mesg);
	if(err != NOERROR) {
		if(err == UNDEF) {
			mode = ADD;
		}
		else {
			return(err);
		}
	}
	else {
		mode = UPDATE;
	}
	switch(position) {
	case	0:
		if(s_sth.s_status[0] == APPROVED ||
		   s_sth.s_status[0] == STOCK) {
			if(mode != ADD) {
				mode = P_DEL;
			}
			else {
				break;
			}
		} 
		if(s_sth.s_status[0] == DISAPPROVED) {
			STRCPY(req_reason.reqr_reason,HdrReason);
		}
		err=put_reqreason((char *)&req_reason,mode,e_mesg);
		if(err != NOERROR) {
			return(err);
		}
		break;
	case	1:
		if(s_sth.s_status[0] == DISAPPROVED) {
			break;
		}
		if(temppage->Items[item_no].s_itm_stat[0] == APPROVED || 
		   temppage->Items[item_no].s_itm_stat[0] == STOCK) {
			if(mode != ADD) {
				mode = P_DEL;
			}
			else {
				break;
			}
		}
		if(temppage->Items[item_no].s_itm_stat[0] == DISAPPROVED) {
			STRCPY(req_reason.reqr_reason,
				temppage->ReqReason[item_no]);
		}
		err=put_reqreason((char *)&req_reason,mode,e_mesg);
		if(err != NOERROR) {
			return(err);
		}
		break;
	default:
		return(ERROR);
	}
	return(NOERROR);
}	/* PutReason() */
/*-----------------------------------------------------------------------*/ 
/* Copy the key fields from screen to req header record and get the
   record from data base */

GetReqHdr(md)
int	md; /* BROWSE or UPDATE */
{
	req_hdr.code = s_sth.s_req_no ;

	return(get_reqhdr(&req_hdr, md, 0, e_mesg));
}
/*------------------------------------------------------------*/
/* Get the Header details from user */

ApproveHdr()
{
	int	i,j,k ;
	
	/* Change PROFOM logical attributes */
	for(i = HDR_ST_FLD ; i <= HDR_END_FLD ; i += 100) {
		fomca1(i,19,2); /* Enable Dup control */
		fomca1(i,10,1); /* Enable User Escape */
	}

	/* save image of screen for ESC-F during approval */
	scpy((char *)&image,(char *)&s_sth,sizeof(s_struct));

#ifdef ENGLISH
	STRCPY(s_sth.s_mesg,"Press ESC-F to Go Back to Fn:");
#else
	STRCPY(s_sth.s_mesg,"Appuyer sur ESC-F pour retourner a Fn:");
#endif
	ShowMesg();

	SetDupBuffers(STATUS_FLD,STATUS_FLD,2);
	s_sth.s_status[0] = APPROVED;
		
	/** set Entry date to the entry date shown on the screen **/
	Entry_date = s_sth.s_entry_dt;

	return(NOERROR) ;
}	/* ApproveHdr() */
/*------------------------------------------------------------*/
/* Read Item Details from the User */

ApproveItems()
{
	int	err ;
	int	i;
	Page	*tempptr;
	int	setdup_start;
	int	setdup_end;

	edit_field = 0; /* Approving hole item */

	/* save image of screen for ESC-F during approval */
	scpy((char *)&image,(char *)&s_sth,sizeof(s_struct));

	i = 0; /* start at first item */
	for( ; ; ) {
		if(i == CurPage->NoItems) {
			if(i==PAGESIZE) {
				if(CurPage == ReqLast || ReqLast == NULL) 
					break; 
				CurPage = CurPage->NextPage ;
				err = ShowItems(CurPage) ;
				i = 0; /* set item number back to zero */
			}
			else {
				break;
			}
		}

		setdup_start  = ITEM_ST_FLD + (STEP * i) + ITM_STAT_FLD; 
		setdup_end = ITEM_ST_FLD + (STEP * i) + QTY_FLD ;
		SetDupBuffers(setdup_start,setdup_end,2);

		if(s_sth.s_status[0] == APPROVED) {
		       err=CheckStockOrderStatus(CurPage->Items[i].s_stck_cd,i);
		       if(err != NOERROR) {
				return(err);
		       }

		}
		else {
			/* Initialize all item status fields to Disapprove */
			/* And do not allow to change */
			s_sth.s_items[i].s_itm_stat[0] = DISAPPROVED;
		}	

		/* Copy the Item to List */
		scpy((char*)&(CurPage->Items[i]), (char*)&(s_sth.s_items[i]),
			sizeof(S_item)) ;

		/* do not show budgets and purchase limits if disappoving */
		/* the whole requisition */
		if(s_sth.s_status[0] == APPROVED && 
		   s_sth.s_items[i].s_itm_stat[0] != DISAPPROVED &&
		   s_sth.s_items[i].s_itm_stat[0] != COMPLETE) {
			err = CheckBudgetPurLimit(i,UPDATE);
		}
		if(CurPage->Items[i].s_itm_stat[0] == APPROVED || 
		   CurPage->Items[i].s_itm_stat[0] == STOCK) {
			CurPage->ReqReason[i][0] = '\0';
		}

		i++;
	}
	
	if(calcapproveamt()<0) return(ERROR);

	return(NOERROR) ;
}	/* ApproveItems() */
/*------------------------------------------------------------*/
/* if a different qty is approved the initially requested add */
/* a new item to the list containing the difference than what */
/* was approved.					      */
/*------------------------------------------------------------*/
AddNewItem(item_no,qty_diff)
int	item_no;	/* current Items Item no */
double	qty_diff;	/* difference in quantity requisitioned */
/*char	flag[2]; This was passed for BACKORDERS */
{
	int err;
	int i;
	double	unit_cost;

	/* ADD new item to Linked List */

	i = ReqLast->NoItems;

	if(PAGESIZE == i) i = 0;

	if(0 == i) {		/* 1st Item in the Page */
		if((err = MakeFreshPage(1)) < 0) return(err) ;
	}

	ReqLast->Items[i].s_sno = i + 1 ;
	STRCPY(ReqLast->Items[i].s_accno, CurPage->Items[item_no].s_accno );
	STRCPY(ReqLast->Items[i].s_stck_cd,CurPage->Items[item_no].s_stck_cd );
	ReqLast->Items[i].s_itm_stat[0] = ' '; 
/**************
	if(flag[0] == APPROVE) {
		ReqLast->Items[i].s_itm_stat[0] = ' '; 
	}
	else {
		ReqLast->Items[i].s_itm_stat[0] = BACKORDER; 
	}
**************/
	ReqLast->Items[i].s_school = CurPage->Items[item_no].s_school ;
	STRCPY(ReqLast->Items[i].s_desc,CurPage->Items[item_no].s_desc );

	STRCPY(ReqLast->Items[i].s_gst,CurPage->Items[item_no].s_gst );
	STRCPY(ReqLast->Items[i].s_pst,CurPage->Items[item_no].s_pst );
						
	ReqLast->Items[i].s_ord_qty = qty_diff ;

	if ( CurPage->Items[item_no].s_uom == LV_CHAR) 
		STRCPY(ReqLast->Items[i].s_uom, "    ");
	else
		STRCPY(ReqLast->Items[i].s_uom, CurPage->Items[item_no].s_uom );

	ReqLast->Items[i].s_unit_cost =  CurPage->Items[item_no].s_unit_cost;

	/* how to calculate net_amt */
	unit_cost = CurPage->Items[item_no].s_net_amt / 
		    CurPage->Items[item_no].s_ord_qty;	
	ReqLast->Items[i].s_net_amt =  unit_cost * qty_diff;

	calctax(ReqLast->Items[i].s_gst,ReqLast->Items[i].s_pst,
		ReqLast->Items[i].s_net_amt ,&tax_cal);

	ReqLast->Items[i].s_value = tax_cal.gros_amt; 

	ReqLast->Items[i].s_po_nbr =  CurPage->Items[item_no].s_po_nbr;
	STRCPY(ReqLast->Items[i].s_act_del,ACTIVE);

	ReqLast->ReqItemNo[i] = ((ReqLast->Pageno - 1) * 
				PAGESIZE) + (i + 1) ;
	ReqLast->ReqStatus[i] = ' ';

	s_sth.s_total_itm += ReqLast->Items[i].s_value;
	err = CheckOverBudget(ReqLast,i);
	if(err < 0) return(ERROR);
	if(err == OVERBUDGET) 
		STRCPY(ReqLast->Items[i].s_overbud,"*");
	else
		ReqLast->Items[i].s_overbud[0] = HV_CHAR;

	ReqLast->NoItems++ ;

	/* Change Current Item */
	/* change qty in list, change net amount and value with tax */
	STRCPY(CurPage->Items[item_no].s_itm_stat,
				s_sth.s_items[item_no].s_itm_stat);

	/* if(flag[0] == BACKORDER) {
		s_sth.s_items[item_no].s_ord_qty -= qty_diff;
	} */
	CurPage->Items[item_no].s_ord_qty = s_sth.s_items[item_no].s_ord_qty;
	CurPage->Items[item_no].s_net_amt = unit_cost * 
				          s_sth.s_items[item_no].s_ord_qty;

	calctax(CurPage->Items[item_no].s_gst,CurPage->Items[item_no].s_pst,
		CurPage->Items[item_no].s_net_amt,&tax_cal);

	CurPage->Items[item_no].s_value = tax_cal.gros_amt; 
	err = CheckOverBudget(CurPage,item_no);
	if(err < 0) return(ERROR);
	if(err == OVERBUDGET) 
		STRCPY(CurPage->Items[item_no].s_overbud,"*");
	else
		CurPage->Items[item_no].s_overbud[0] = HV_CHAR;
	
	if((err = ShowItems(CurPage)) < 0) return(err) ;
	
	return(NOERROR);
}	/* AddNewItem() */
/*------------------------------------------------------------*/
/*
*	Get the next node in linked list to add req items. If the
*	(Cur. Req last page) = (Last Page in linked List) or no
*	nodes in list, allocate node and add to linked list
*/

MakeFreshPage(mode)
int	mode;		/* 0 - allocate new page and set CurPage to new page */
			/* 1 - allocate new page and keep CurPage position */
{
	Page	*tempptr ;

	/* If, no node is allocated yet or Current req used all the nodes,
	   then allocate new node */

	if( LastPage == NULL || ReqLast == LastPage ){
		tempptr= (Page *)malloc((unsigned)sizeof(Page)) ;

		if( tempptr == NULL ){
#ifdef ENGLISH
			DispError("MEMORY ALLOCATION ERROR...");
#else
			DispError("ERREUR D'ALLOCATION A LA MEMOIRE...");
#endif
			return(ERROR);
		}
		tempptr->NextPage = NULL ;

		if( LastPage == NULL ){	/* No node is allocated Yet */
			tempptr->PrevPage = NULL ;
			tempptr->Pageno = 1 ;
			FirstPage = tempptr ;
		}
		else {				/* Not a first node in list */
			tempptr->Pageno = LastPage->Pageno + 1 ;
			LastPage->NextPage = tempptr ;
			tempptr->PrevPage = LastPage ;
		}
		LastPage = tempptr ;
	}

	if(ReqLast == NULL)
		ReqLast = FirstPage ;
	else
		ReqLast = ReqLast->NextPage ;

	ReqLast->NoItems = 0 ;
	if(mode == 0) {
		CurPage = ReqLast ;
	}
	return(NOERROR);
}	/* MakeFreshPage() */
/*------------------------------------------------------------*/
/* Read details of given item# */

ReadItem(item_no,starting_fld,ending_fld,mode)
int	item_no ;
int	starting_fld;
int	ending_fld;
int	mode ;
{
	int	i, j, k ;
	int	st_fld ;
	int	end_fld ;

#ifdef ENGLISH
	STRCPY(s_sth.s_mesg,"Press ESC-F to Terminate");
#else
	STRCPY(s_sth.s_mesg,"Appuyer sur ESC-F pour terminer");
#endif
	ShowMesg();

	st_fld  = ITEM_ST_FLD + (STEP * item_no) + starting_fld; 
	end_fld = ITEM_ST_FLD + (STEP * item_no) + ending_fld ;
	
	i = ReadFields(st_fld,end_fld,ItemsValidation,ItemsWindowHelp,mode) ;
	if(PROFOM_ERR == i || DBH_ERR == i) return(i) ;
	if(RET_USER_ESC == i) {
		/*
		* When user gives ESC-F while changing fields, assumption is
		* he completed his changes, and remaining fields are same as
		* old. But, at this point STH will be having low values in the 
		* remaining fields. So move the old values form the linked list.
		*/

		/* Get Offset of the begining field of the Item in 'k' */
		fomfp(st_fld,&k,&j) ;
		/* Offset to the field where ESC-F Pressed in 'j' */
		fomfp(sr.curfld,&j,&i);
		i =  j - k ;	/* Offset within item */

		j = sizeof(S_item) - i ;  /* Length to copy */
       		scpy((char *)(&s_sth.s_items[item_no])+i,
			(char*)(&CurPage->Items[item_no])+i, j);

		ret(WriteFields(st_fld, end_fld));
		return(RET_USER_ESC) ;
	}
	ret(WriteFields(TOTAL_ST_FLD,TOTAL_END_FLD));

	return(NOERROR) ;
}	/* ReadItem() */
/*------------------------------------------------------------*/
ReadReason(location,item_no)
int	location;	/* 0 - header  1 - items */
int	item_no;
{
	int	retval;

	if(location == HEADER) {
		STRCPY(s_sth.s_reason,HdrReason);
	}
	else {
		STRCPY(s_sth.s_reason,CurPage->ReqReason[item_no]);
	}
	SetDupBuffers(REASON_FLD,REASON_FLD,2);

	s_sth.s_reason[0] = LV_CHAR;
	retval = ReadFields(REASON_FLD, REASON_FLD,
		KeyAndHdrValidation, HdrAndKeyWindowHelp, 0) ;
	if( retval < 0) return(retval);

	if(location == HEADER) {
		STRCPY(HdrReason,s_sth.s_reason);
	}
	else {
		STRCPY(CurPage->ReqReason[item_no],s_sth.s_reason);
	}

	s_sth.s_reason[0] = HV_CHAR;
	ret(WriteFields(REASON_FLD,REASON_FLD));

	return(NOERROR);
}	/* ReadReason() */
/*------------------------------------------------------------*/
/* Read the PROFOM Screen for a given Range of fields */

static
ReadFields(st_fld, end_fld, Validate, WindowHelp, mode)
int	st_fld ;
int	end_fld;
int	(*Validate)() ;
int	(*WindowHelp)() ;
int	mode ;	/* ADD or UPDATE. This is required only when reading item */
{
	int	err ;

	sr.nextfld = st_fld ;
	sr.endfld  = end_fld;
	for( ; ;){
		fomrd( (char *)&s_sth );
		ret(err_chk(&sr));

		if(sr.retcode == RET_VAL_CHK){
			err = (*Validate)(mode) ;
			if(DBH_ERR == err || PROFOM_ERR == err) return(err);
			sr.nextfld = sr.curfld ;
			sr.endfld =  end_fld;
			continue;
		}
		if(sr.retcode == RET_USER_ESC){
			if(sr.escchar[0] == 'f' || sr.escchar[0] == 'F')
				return(RET_USER_ESC) ;
			if(sr.escchar[0] == 'h' || sr.escchar[0] == 'H'){
				err = (*WindowHelp)() ;
				if(DBH_ERR == err || PROFOM_ERR == err)
					return(err) ;
				sr.nextfld = sr.curfld ;
				sr.endfld =  end_fld;
				continue;
			}
			continue;
		}
		/* else RET_NO_ERROR */
		break;
	}

	return(NOERROR) ;
}	/* ReadFields() */
/*------------------------------------------------------------*/
/* Write fields on Screen for a given Range */

static
WriteFields(st_fld, end_fld)
int	st_fld ;
int	end_fld ;
{
	sr.nextfld = st_fld ;
	sr.endfld  = end_fld ;

	fomwr( (char *)&s_sth );
	ret(err_chk(&sr));

	return(NOERROR) ;
}	/* WriteFields() */
/*----------------------------------------------------------------*/
/* Set Duplication buffers for fields 				  */
SetDupBuffers( firstfld, lastfld, value )
int	firstfld, lastfld;	/* field numbers range */
int	value;			/* ENABLE or DISABLE */
{
	int i ;

	for( i=firstfld; i<=lastfld; i+=100 )
		fomca1( i, 19, value);
	if( value==0 )
		return(0);
	sr.nextfld = firstfld;
	sr.endfld = lastfld;
	fomud( (char *)&s_sth );
	ret( err_chk(&sr) );

	return( 0 );
}
/*----------------------------------------------------------------*/
/* Copy the items form given node to screen and display */

ShowItems(pageptr)
Page	*pageptr ;
{
	int	i ;

	if(pageptr != NULL) {
		/* Copy the items to screen */
		scpy((char*)s_sth.s_items, (char*)pageptr->Items,
			(pageptr->NoItems * sizeof(S_item)) );

		s_sth.s_page_no   = pageptr->Pageno ;

		if(pageptr->NoItems==2) {
			s_sth.s_items[0].s_subhdg[0] = ' ';
			s_sth.s_items[1].s_subhdg[0] = ' ';
		}
		if(pageptr->NoItems==1) 
			s_sth.s_items[0].s_subhdg[0] = ' ';
		
		STRCPY(s_sth.s_dummy1,"---");
		i = pageptr->NoItems ;
	}
	else {
		s_sth.s_page_no   = HV_SHORT ;
		s_sth.s_dummy1[0] = HV_CHAR ;
		i = 0 ;
	}

	/* Move High Values to remaining Items */
	for( ; i < PAGESIZE ; i++ )
		InitItem(i,HV_CHAR,HV_SHORT,HV_LONG,HV_DOUBLE) ;

	ret( WriteFields( PAGENO_FLD, (END_FLD - 200)) );

	return(NOERROR) ;
}	/* ShowItems() */
/*----------------------------------------------------------------*/
/* Validation function() for Key and Header fields when PROFOM returns
  RET_VAL_CHK */

KeyAndHdrValidation(mode)
int	mode;
{
	int	err, save_nextfld, save_endfld ;

	switch(sr.curfld){
	case	KEY_START	:	/* req number */
		break;
	case	SUPPCD_FLD	:	/* Supplier Cd: */
  		Right_Justify_Numeric(s_sth.s_supp_cd,
					sizeof(s_sth.s_supp_cd)-1);
		STRCPY(supplier.s_supp_cd,s_sth.s_supp_cd);
		err = get_supplier(&supplier,BROWSE,0,e_mesg); 
		if(err != NOERROR) {
			fomer(e_mesg);
			s_sth.s_supp_cd[0] = LV_CHAR;
		}
		fomer(supplier.s_name);
		break;
	case	ENTRYDT_FLD	:	/* Entry Dt: */
		/* Entry Date shouldn't be future date */
		if(s_sth.s_entry_dt > get_date()) {
#ifdef ENGLISH
			fomer("Date Can't be Future Date");
#else
			fomer("Date ne peut pas etre ulterieure");
#endif
			s_sth.s_entry_dt = LV_LONG ;
			return(ERROR) ;
		}
		if(s_sth.s_fn[0] == CHANGE) {
			s_sth.s_due_dt = date_plus(s_sth.s_entry_dt,
							pa_rec.pa_due_days_po);
			save_nextfld = sr.nextfld;
			save_endfld = sr.endfld;
			SetDupBuffers(DUEDT_FLD,DUEDT_FLD,1);
/**
			s_sth.s_due_dt = LV_LONG ;
**/
			sr.nextfld = save_nextfld;
			sr.endfld = save_endfld;
		}
		/** set Entry date to entry date shown on screen **/
		Entry_date = s_sth.s_entry_dt;
		break ;
	case	DUEDT_FLD	:	/* Due Date: */
		if(s_sth.s_due_dt < s_sth.s_entry_dt) {
#ifdef ENGLISH
			fomer("Due date can't be before Req Date");
#else
			fomer("Echeance ne peut pas etre avant la date de requisition");
#endif
			s_sth.s_due_dt = LV_LONG;
			return(ERROR) ;
		}
		break ;
	case	PERIOD_FLD	:	/* Period: */
		/* Period should belong to Current Year, should be <= Current
		   period, and in case of previous period is should not < 
		   allowed open periods */
		if(s_sth.s_period < 1 || s_sth.s_period > pa_rec.pa_cur_period
			|| s_sth.s_period <
				(pa_rec.pa_cur_period - pa_rec.pa_open_per) ) {
#ifdef ENGLISH
			fomer("Invalid Period");
#else
			fomer("Periode invalide");
#endif
			s_sth.s_period = LV_SHORT ;
			return(ERROR) ;
		}
		break ;
	case	FUND_FLD	:	/* Fund: */
		err = CheckFund(s_sth.s_fund) ;
		if(DBH_ERR == err) return(err) ;
		if(ERROR == err) {
			s_sth.s_fund = LV_SHORT ;
			return(ERROR) ;
		}
		fomer(ctl_rec.desc);
		if(CC_no != pa_rec.pa_distccno) 
			s_sth.s_shipto = CC_no;
		break ;
	case	STCKFUND_FLD	:	/* stock Fund: */
		err = CheckFund(s_sth.s_stckfund) ;
		if(DBH_ERR == err) return(err) ;
		if(ERROR == err) {
			s_sth.s_stckfund = LV_SHORT ;
			return(ERROR) ;
		}
		fomer(ctl_rec.desc);
		if(CC_no != pa_rec.pa_distccno) 
			s_sth.s_shipto = CC_no;
		break ;
	case SHIPTO_FLD :	/* Ship to Fields */
		schl_rec.sc_numb = s_sth.s_shipto ;
		err = get_sch(&schl_rec, BROWSE, 0, e_mesg) ;
		if(ERROR == err) return(DBH_ERR) ;
		if(err < 0) {
			fomer(e_mesg) ;
			s_sth.s_shipto = LV_SHORT ;
			return(ERROR) ;
		}
		fomer(schl_rec.sc_name);
		break ;
	case STATUS_FLD :
		if(s_sth.s_status[0] != APPROVED && 
				s_sth.s_status[0] != DISAPPROVED) {
#ifdef ENGLISH
			fomer("The Status may only be A(pprove) or D(isapprove)");
#else
			fomer("Etat peut seulement etre A(pprouve) ou N(on-approuve)");
#endif
			s_sth.s_status[0] = LV_CHAR;
			return(ERROR);
		}
		s_sth.s_approve_dt = s_sth.s_rundate;
		ret( WriteFields(APPDT_FLD, APPDT_FLD) );
		if(s_sth.s_status[0] == DISAPPROVED) {
			if((err=ReadReason(HEADER,0)) < 0) return(err);
		}
		else {
			HdrReason[0] = '\0';
		}
		break;
	default :
#ifdef ENGLISH
		sprintf(e_mesg,"No Validity Check For Field#  %d",sr.curfld);
#else
		sprintf(e_mesg,"Pas de controle de validite pour le Champ#  %d",sr.curfld);
#endif
		fomen(e_mesg);
		get();
		return(ERROR) ;
	}	/* Switch sr.curfld */

	return(NOERROR) ;
}	/* KeyAndHdrValidation() */
/*----------------------------------------------------------------*/
/* Validation function() for Item fields when PROFOM returns RET_VAL_CHK */

ItemsValidation(mode)
int	mode ;
{
	double	temp, disp_amnt;
	int	err, cur_fld, end_fld ;
	int	fld_no, item_no ;

	/* Calculate item# and Fld# within item */
	item_no = (sr.curfld - ITEM_ST_FLD) / STEP ;
	fld_no  = (sr.curfld - ITEM_ST_FLD) % STEP ;

	switch(fld_no){
	case ACNO_FLD :		/* GL Account# Fields */
		if (acnt_chk(s_sth.s_items[item_no].s_accno) < 0)  {
			s_sth.s_items[item_no].s_accno[0] = LV_CHAR ;
#ifdef ENGLISH
			fomer("Invalid GL Account Number");
#else
			fomer("Numero de compte G/L invalide");
#endif
			return(ERROR) ;
		}
		err = CheckGlAcnt(s_sth.s_items[item_no].s_accno) ;
		if(DBH_ERR == err) return(err) ;
		if(err < 0) {
			s_sth.s_items[item_no].s_accno[0] = LV_CHAR ;
			return(ERROR) ;
		}
		if(gl_rec.keys[pa_rec.pa_cc_key-1] != CC_no &&
		   CC_no != pa_rec.pa_distccno) {
#ifdef ENGLISH
			fomer("G/L account not for this cost center");
#else
			fomer("Compte du G/L n'est pas pour ce centre de couts");
#endif
			s_sth.s_items[item_no].s_accno[0] = LV_CHAR ;
			return(ERROR) ;
		}
		fomer(gl_rec.desc);
		break ;
	case STCKCD_FLD :	/* Stock Code Field */
		if(strcmp(s_sth.s_items[item_no].s_stck_cd,"\0") == 0) {
			s_sth.s_items[item_no].s_school = 0;
			sr.curfld += 100;
			break;
		}
		err = CheckStock(s_sth.s_items[item_no].s_stck_cd,BROWSE);
		if(err == DBH_ERR) return(err);
		if(err < 0) {
			/* Set status to Stock Type */
			s_sth.s_items[item_no].s_stck_cd[0] = LV_CHAR ;
			return(ERROR) ;
		}

		/** added for description ****/
		cur_fld = ITEM_ST_FLD + (STEP * item_no) ;
		cur_fld += DESC_FLD ;
		STRCPY( s_sth.s_items[item_no].s_desc, stck_rec.st_desc);
		SetDupBuffers(cur_fld,cur_fld,2);

		s_sth.s_items[item_no].s_desc[0] = LV_CHAR ;
		sr.curfld = (ITEM_ST_FLD + (STEP * item_no) ) + STCKCD_FLD ;
		sr.endfld = (ITEM_ST_FLD + (STEP * item_no) ) + (STEP - 100) ;

		/** added for unit/cost ****/
		cur_fld = ITEM_ST_FLD + (STEP * item_no) ;
		cur_fld += PRICE_FLD ;
		s_sth.s_items[item_no].s_unit_cost = stck_rec.st_rate;
		SetDupBuffers(cur_fld,cur_fld,2);

		s_sth.s_items[item_no].s_unit_cost = LV_DOUBLE ;
		sr.curfld = (ITEM_ST_FLD + (STEP * item_no) ) + STCKCD_FLD ;
		sr.endfld = (ITEM_ST_FLD + (STEP * item_no) ) + (STEP - 100) ;

		/* Show the Stock UOM as a default UOM on requisition */
		cur_fld = ITEM_ST_FLD + (STEP * item_no) ;
		cur_fld += UOM_FLD ;
		STRCPY( s_sth.s_items[item_no].s_uom, stck_rec.st_unit);
		SetDupBuffers(cur_fld,cur_fld,2);

		s_sth.s_items[item_no].s_uom[0] = LV_CHAR ;
		sr.curfld = (ITEM_ST_FLD + (STEP * item_no) ) + STCKCD_FLD ;
		sr.endfld = (ITEM_ST_FLD + (STEP * item_no) ) + (STEP - 100) ;

		/* Set status to Stock Type 
		s_sth.s_items[item_no].s_itm_stat[0] = STOCK;
		*/

		/* If not distict set cc# to cost center entering requistion */
		if(CC_no != pa_rec.pa_distccno) 
			s_sth.s_items[item_no].s_school = CC_no;
		break;
	case ITM_STAT_FLD:	/* Item status field */
		if(s_sth.s_items[item_no].s_itm_stat[0] == '\0') {
			sr.curfld+=100;
			break;
		}
		if(s_sth.s_items[item_no].s_itm_stat[0] == COMPLETE) {
			sr.curfld+=100;
			break;
		}
		
		if(s_sth.s_items[item_no].s_stck_cd[0] != '\0') {
		  if(s_sth.s_items[item_no].s_school == pa_rec.pa_wareccno) {
			if(s_sth.s_items[item_no].s_itm_stat[0] != APPROVED && 
			   s_sth.s_items[item_no].s_itm_stat[0] != DISAPPROVED){
#ifdef ENGLISH
				fomer("Status must be A(pprove), D(isapprove), or Blank");
#else
				fomer("Etat doit etre A(pprouve), N(on-approuve)");
#endif
				s_sth.s_items[item_no].s_itm_stat[0] = LV_CHAR;
				return(ERROR);
			}
		  }
		  else {
			if(s_sth.s_items[item_no].s_itm_stat[0] != APPROVED && 
		  	   s_sth.s_items[item_no].s_itm_stat[0] != STOCK &&
			   s_sth.s_items[item_no].s_itm_stat[0] !=DISAPPROVED)
	 /* 		&& s_sth.s_items[item_no].s_itm_stat[0] != BACKORDER)*/{
#ifdef ENGLISH
				fomer("Status must be A(pprove), S(tock), D(isapprove), or Blank");
#else
				fomer("Etat doit etre A(pprouve), S(tock) ou N(on-approuve)");
#endif
				s_sth.s_items[item_no].s_itm_stat[0] = LV_CHAR;
				return(ERROR);
			}
		  }
		}
		else {
			if(s_sth.s_items[item_no].s_itm_stat[0] != APPROVED && 
		   	   s_sth.s_items[item_no].s_itm_stat[0] != DISAPPROVED){
#ifdef ENGLISH
				fomer("Status must be A(pprove), D(isapprove) or Blank");
#else
				fomer("Etat doit etre A(pprouve) ou N(on_approuve)");
#endif
				s_sth.s_items[item_no].s_itm_stat[0] = LV_CHAR;
				return(ERROR);
			}
		}
		if(s_sth.s_items[item_no].s_itm_stat[0] == DISAPPROVED) {
			if((err=ReadReason(ITEMS,item_no)) < 0) return(err);
		}
		if(s_sth.s_items[item_no].s_itm_stat[0] == APPROVED &&
			s_sth.s_fund != s_sth.s_stckfund){
#ifdef ENGLISH
			fomer("This is an Interfund Requisition - Please Approve through Stock");
#else
			fomer("This is an Interfund Requisition - Please Approve through Stock");
#endif
			s_sth.s_items[item_no].s_itm_stat[0] = LV_CHAR;
			return(ERROR);
		}

/*L.R.*/if(s_sth.s_items[item_no].s_stck_cd[0] != '\0' &&
	    s_sth.s_items[item_no].s_stck_cd[0] != HV_CHAR) {
		err = ReadAlloc(item_no);
		if(err < 0) return ERROR;
			   
		amnt_available = stck_rec.st_on_hand - alloc_qty - stck_req_qty;
		/* So that a negative amount available is not displayed. */
		if(amnt_available < 0)
			disp_amnt = 0;
		else
			disp_amnt = amnt_available;
#ifdef ENGLISH
		sprintf(e_mesg,
		"On Hand: %.4lf  Alloc: %.4lf  Requisitioned: %.4lf  Avail: %.4lf",
			stck_rec.st_on_hand,alloc_qty,stck_req_qty,disp_amnt);
#else
		sprintf(e_mesg,
		"En maison: %.4lf  Alloue: %.4lf  Requisitionnne: %.4lf  Disponible: %.4lf",
			stck_rec.st_on_hand,alloc_qty,stck_req_qty,disp_amnt);
#endif
				fomer(e_mesg);
	} /* end if for stock_code L.R.*/
		if(edit_field == 1) {
			if(CurPage->Items[item_no].s_ord_qty > amnt_available &&
			   s_sth.s_items[item_no].s_itm_stat[0] == STOCK) {
				s_sth.s_items[item_no].s_itm_stat[0] = LV_CHAR;
				return(ERROR);
		 	}
		}
		if((s_sth.s_items[item_no].s_itm_stat[0] == STOCK ||
		    s_sth.s_items[item_no].s_itm_stat[0] == APPROVED) &&
		    s_sth.s_fn[0] == APPROVE) {
			    s_sth.s_items[item_no].s_ord_qty = LV_DOUBLE;
		    }
		break;
	case SCHOOL_FLD :	/* School Fields */
		schl_rec.sc_numb = s_sth.s_items[item_no].s_school ;
		err = get_sch(&schl_rec, BROWSE, 0, e_mesg) ;
		if(ERROR == err) return(DBH_ERR) ;
		if(err < 0) {
			fomer(e_mesg) ;
			s_sth.s_items[item_no].s_school = LV_SHORT ;
			return(ERROR) ;
		}
		fomer(schl_rec.sc_name);
		break ;
	case DESC_FLD :		/* Description */
		break ;
	case GST_FLD:		/* GST Fields */
		if( s_sth.s_items[item_no].s_gst[0] != TAXABLE &&
			s_sth.s_items[item_no].s_gst[0] != EXEMPT )  {
#ifdef	ENGLISH
			fomer("Valid Tax codes are T(axable) or E(xempt)");
#else
			fomer("Codes valides de taxe sont T(axable) ou E(xempte)");
#endif
			s_sth.s_items[item_no].s_gst[0] = LV_CHAR;
		}
		break;
	case PST_FLD:		/* PST Fields */
		if( s_sth.s_items[item_no].s_pst[0] != TAXABLE &&
			s_sth.s_items[item_no].s_pst[0] != EXEMPT )  {
#ifdef	ENGLISH
			fomer("Valid Tax codes are T(axable) or E(xempt)");
#else
			fomer("Codes valides de taxe sont T(axable) ou E(xempte)");
#endif
			s_sth.s_items[item_no].s_pst[0] = LV_CHAR;
		}
		break;
	case QTY_FLD :		/* QTY Fields */
		if(s_sth.s_items[item_no].s_ord_qty < DELTA_QTY) {
#ifdef ENGLISH
			fomer("Can't be zero");
#else
			fomer("Ne peut pas etre zero");
#endif
			s_sth.s_items[item_no].s_ord_qty = LV_DOUBLE ;
			return(ERROR) ;
		}
		if(ReadAlloc(item_no) < 0) return ERROR;

		if(s_sth.s_items[item_no].s_ord_qty > 
		   (amnt_available = 
			stck_rec.st_on_hand - alloc_qty - stck_req_qty) &&
		    s_sth.s_items[item_no].s_itm_stat[0] == STOCK) {
		     /* So that a negative amount available is not displayed. */
			if(amnt_available < 0)
				disp_amnt = 0;
			else
				disp_amnt = amnt_available;

#ifdef ENGLISH
			sprintf(e_mesg,
			"On Hand: %.4lf  Alloc: %.4lf  Requisitioned: %.4lf  Avail: %.4lf",
			stck_rec.st_on_hand,alloc_qty,stck_req_qty,disp_amnt);
#else
			sprintf(e_mesg,
			"En maison: %.4lf  Alloue: %.4lf  Requisitionnne: %.4lf  Disponible %.4lf",
			stck_rec.st_on_hand,alloc_qty,stck_req_qty,disp_amnt);
#endif
			fomer(e_mesg); 
			s_sth.s_items[item_no].s_ord_qty = LV_DOUBLE;
			return(ERROR);
	}

		temp = CurPage->Items[item_no].s_ord_qty -
		       s_sth.s_items[item_no].s_ord_qty ; 

		if(temp < 0.00 && s_sth.s_fn[0] == APPROVE) {
			CurPage->Items[item_no].s_net_amt =  

				s_sth.s_items[item_no].s_unit_cost *
				          s_sth.s_items[item_no].s_ord_qty;

			CurPage->Items[item_no].s_ord_qty = 
				s_sth.s_items[item_no].s_ord_qty;
			calctax(CurPage->Items[item_no].s_gst,
				CurPage->Items[item_no].s_pst,
				CurPage->Items[item_no].s_net_amt,&tax_cal);

			CurPage->Items[item_no].s_value = tax_cal.gros_amt; 
	
			/* Show items with new info */
			if((err = ShowItems(CurPage)) < 0) return(err) ;
		}
/***
		if(temp < 0.00) { 
#ifdef ENGLISH
			fomer("Approved Quantity cannot be more than Requisitioned Quantity");
#else
			fomer("Quantite approuve ne peut etre plus que la quantite requisitionnee");
#endif
			s_sth.s_items[item_no].s_ord_qty = LV_DOUBLE;
			return(ERROR);
		}
		else 
***/
		if(temp > 0.00) {
			if(AddNewItem(item_no,temp)<0) return(ERROR);
		}
		break;
	case PRICE_FLD :	/* Cost/Unit Fields */
		/* Show the REQ Value as a default amount */
		cur_fld = ITEM_ST_FLD + (STEP * item_no) ;
		cur_fld += NET_FLD ;
		end_fld = sr.endfld;
		s_sth.s_items[item_no].s_net_amt = 
			s_sth.s_items[item_no].s_ord_qty *
				s_sth.s_items[item_no].s_unit_cost ;
		SetDupBuffers(cur_fld,cur_fld,1);

		s_sth.s_items[item_no].s_net_amt = LV_DOUBLE ;
		sr.curfld  = cur_fld ;
		sr.endfld  = end_fld ;
		break;
	case NET_FLD :		/* Net Amount Fields */
		err = CheckBudgetPurLimit(item_no,mode);
		sr.nextfld = sr.endfld;
		break ;
	default :
#ifdef ENGLISH
		sprintf(e_mesg,"No Validity Check For Field#  %d",sr.curfld);
#else
		sprintf(e_mesg,"Pas de controle de validite pour le Champ#  %d",sr.curfld);
#endif
		fomen(e_mesg);
		get();
		return(ERROR) ;
	}	/* Switch sr.curfld */
	sr.nextfld = sr.curfld;
	return(NOERROR) ;
}	/* ItemsValidation() */
/*----------------------------------------------------------------*/
/* Read the allocation file to get the amount of stock available to
   this transaction. (alloc_qty) Accumulate all allocated stock. LR*/

ReadAlloc(item_no)
int 	item_no;
{
	int   retval;

	/* Initialize everything */
	alloc_qty = 0;
	/* aloc_rec.st_fund = s_sth.s_fund; lr*/
	aloc_rec.st_fund = s_sth.s_stckfund;
	strcpy(aloc_rec.st_code, s_sth.s_items[item_no].s_stck_cd);
	aloc_rec.st_date = 0;
	aloc_rec.st_time = 0;

	flg_reset(ALLOCATION);

	for(;;){
		retval = get_n_alloc(&aloc_rec, BROWSE, 1, FORWARD, e_mesg);
  		if(retval < 0){
			if(retval==EFL) break;
			DispError(e_mesg);
			roll_back(e_mesg);
			return(-1);
		}

		if(strcmp(aloc_rec.st_code, s_sth.s_items[item_no].s_stck_cd) ||
           	/* aloc_rec.st_fund != s_sth.s_fund) lr*/
           	aloc_rec.st_fund != s_sth.s_stckfund)
			break;

		if(aloc_rec.st_location == s_sth.s_costcenter && 
 	   	!strcmp(aloc_rec.st_expacc, s_sth.s_items[item_no].s_accno)){
			break;
      		}

		alloc_qty += aloc_rec.st_alloc;
	} /* end of 'for' loop */
	seq_over(ALLOCATION);
	return(NOERROR);
}
/*---------------------------------------------------------------*/
/* Check the given funds availability in file */

CheckFund(fund)
short	fund;
{
	int	err ;

	ctl_rec.fund = fund ;
	err = get_ctl(&ctl_rec, BROWSE, 0, e_mesg) ;
	if(ERROR == err) return(err);
	if(err < 0) {
		fomer(e_mesg) ; get();
		return(ERROR) ;
	}
	return(NOERROR) ;
}	/* CheckFund() */
/*----------------------------------------------------------------*/
/* Check the given GL account availability in file */

CheckGlAcnt(accno)
char	*accno ;
{
	int	err ;

	gl_rec.funds = s_sth.s_fund ;
	STRCPY( gl_rec.accno, accno);
	gl_rec.reccod = 99;
	err = get_gl(&gl_rec, BROWSE, 0, e_mesg) ;
	if(err < 0) {
		fomer(e_mesg) ;
		return(ERROR) ;
	}
	return(NOERROR) ;
}	/* CheckGlAcnt() */
/*----------------------------------------------------------------*/
/* Read the given stock code record in BROWSE mode */
CheckStock(stcode,mode)
char	*stcode ;
int	mode;
{
	int	err ;

	/* stck_rec.st_fund = s_sth.s_fund ; lr*/
	stck_rec.st_fund = s_sth.s_stckfund ;
	STRCPY(stck_rec.st_code, stcode) ;

	err = get_stmast(&stck_rec, mode, 0, e_mesg) ;
	if(ERROR == err) return(DBH_ERR);
	if(err < 0) {
		fomer(e_mesg) ;
		return(ERROR) ;
	}
	return(NOERROR) ;
}	/* CheckStock() */
/*----------------------------------------------------------------*/
CheckStockOrderStatus(stock_code,item_no)
char	*stock_code;
int	item_no;
{
	int err;
	double qty, disp_amnt;
	double req_qty;

	req_qty = 0;

	/* Check if this is a stock item or not */
	if(stock_code[0] == '\0' || stock_code[0] == HV_CHAR) {
		/* Make the requ item approved */
		if(s_sth.s_items[item_no].s_itm_stat[0] != COMPLETE ||
		    s_sth.s_items[item_no].s_itm_stat[0] != DISAPPROVED) {
			s_sth.s_items[item_no].s_itm_stat[0] = APPROVED;
			ret(WriteFields(STATUS_FLD,STATUS_FLD));
			return(NOERROR);
		}
	}

	err = CheckStock(stock_code,BROWSE);
	if(err < 0) {
		return(err) ;
	}	
	
	/* Calculate requisitioned quantity in linked list */
	err=checkreqqty(stock_code,CurPage,item_no,&qty);
	if(err != NOERROR) {
		qty = 0.0;
	}

	if(s_sth.s_costcenter != pa_rec.pa_wareccno) {
		err = CheckAllocation(&(CurPage->Items[item_no]),BROWSE);
		if(err < 0 && err != UNDEF) return(err) ; 
	}

	stck_req_qty = req_qty+qty;
	if(ReadAlloc(item_no)<0) return(ERROR);
	amnt_available = stck_rec.st_on_hand - alloc_qty - stck_req_qty;
	if(amnt_available < 0)
		disp_amnt = 0;
	else
		disp_amnt = amnt_available;
#ifdef ENGLISH
	sprintf(e_mesg,
	"On Hand: %.4lf  Alloc: %.4lf  Requisitioned: %.4lf  Avail:  %.4lf",
		    stck_rec.st_on_hand,alloc_qty,stck_req_qty,disp_amnt);
#else
	sprintf(e_mesg,
	"En maison: %.4lf  Alloue: %.4lf  Requisitionnne: %.4lf  Disponible %.4lf",
		stck_rec.st_on_hand,alloc_qty,stck_req_qty,disp_amnt);
#endif
	fomer(e_mesg); 

	/* Check if the amount requested is greater than in stock */
	if(s_sth.s_items[item_no].s_ord_qty > disp_amnt){
		/* Read Each Item Line from start field to ending field */
		err = ReadItem(item_no,ITM_STAT_FLD,QTY_FLD,UPDATE) ;
		if(PROFOM_ERR == err || DBH_ERR == err) return(err) ;
		if(NOERROR != err) return(NOERROR) ;	/* ESC-F */
/* Louis: This above return statement will have to be fixed */
	}

	return(NOERROR);
}	/* CheckStockOrderStatus() */
/*******************************************************************/
/* Check Over Budget  for newly added item */ 
CheckOverBudget(temppage,item_no)
Page	*temppage;
int	item_no;
{
	int 	err;
	double	diff;
	double	temp;
	double	commit_req;
	double	commit_req1; 	/* requisitioned commitments from linked list */

	net_amt = temppage->Items[item_no].s_net_amt;
		
	calctax(temppage->Items[item_no].s_gst,
			temppage->Items[item_no].s_pst,net_amt,&tax_cal);
		
	temppage->Items[item_no].s_value = tax_cal.gros_amt;

	diff = temppage->Items[item_no].s_value;

	err = calcreqcommits(s_sth.s_fund,temppage->Items[item_no].s_accno,
			&commit_req,e_mesg);
	if (err != NOERROR)
	{
		commit_req = 0.0;
		fomer(e_mesg);
		get();
	}

	/* Calculate requistion commitments in linked list */
	err=calcreqlinklist(s_sth.s_fund,temppage,item_no,&commit_req1);
	if(err != NOERROR) {
		commit_req1 = 0.0;
	}

	/* Read in Gl Record to Check Budget */
	err = CheckGlAcnt(temppage->Items[item_no].s_accno) ;
	if(err < 0) {
		return(ERROR) ;
	}

	temp = gl_rec.budcur - gl_rec.comdat - gl_rec.ytd 
			- commit_req - commit_req1;

	if(temppage->Items[item_no].s_value > DELTA_AMT && temp < diff) {
		return(OVERBUDGET);
	}
	return(NOERROR);
}
/*----------------------------------------------------------------*/
/* Check to see if budget exceeded and/or Purchase limit exceeded */
CheckBudgetPurLimit(item_no,mode)
int	item_no;
int	mode;
{
	int 	err;
	double	diff;
	double	temp;
	double	commit_req;
	double	commit_req1; 	/* requisitioned commitments from linked list */
	int	fld;

	diff = 0.00;

	net_amt = s_sth.s_items[item_no].s_net_amt;
		
	calctax(s_sth.s_items[item_no].s_gst,
			s_sth.s_items[item_no].s_pst,net_amt,&tax_cal);
		
	s_sth.s_items[item_no].s_value = tax_cal.gros_amt;

	if(mode == ADD) {
		diff += s_sth.s_items[item_no].s_value;
	}
	else {
		diff += (s_sth.s_items[item_no].s_value - 
			 CurPage->Items[item_no].s_value);
	}

	err = calcreqcommits(s_sth.s_fund,s_sth.s_items[item_no].s_accno,
			&commit_req,e_mesg);
	if (err != NOERROR)
	{
		commit_req = 0.0;
		fomer(e_mesg);
		get();
	}

	/* Calculate requistion commitments in linked list */
	err=calcreqlinklist(s_sth.s_fund,CurPage,item_no,&commit_req1);
	if(err != NOERROR) {
		commit_req1 = 0.0;
	}

	/* Read in Gl Record to Check Budget */
	err = CheckGlAcnt(s_sth.s_items[item_no].s_accno) ;
	if(err < 0) {
		return(ERROR) ;
	}

	temp = gl_rec.budcur - gl_rec.comdat - gl_rec.ytd 
			- commit_req - commit_req1;

	if(s_sth.s_items[item_no].s_value > DELTA_AMT && temp < diff) {
		s_sth.s_items[item_no].s_overbud[0] = '*';
		fld = ITEM_ST_FLD + (STEP * item_no) + ACNO_FLD + 100;
		ret(WriteFields(fld,fld));
#ifdef ENGLISH
		DispError("Not Enough Budget");
#else
		DispError("Pas assez de budget");
#endif
#ifdef ENGLISH
		STRCPY(s_sth.s_mesg,"Press ESC-F to Terminate");
#else
		STRCPY(s_sth.s_mesg,"Appuyer sur ESC-F pour terminer");
#endif
		ShowMesg();
	}

	if(s_sth.s_items[item_no].s_itm_stat[0] != DISAPPROVED) {
		err = checkpurlimit(s_sth.s_items[item_no].s_stck_cd,
							CurPage,item_no);
		if(err == ERROR) {
#ifdef ENGLISH
			fomer("Amount exceeds dollar limit set by purchasing regulations.");
#else
			fomer("Montant en exces du montant specifie par les regles d'achats.");
#endif
			get();
		}
	}

	return(NOERROR);
}	/* CheckBudgetPurLimit() */
/*----------------------------------------------------------------*/
calcreqlinklist(fund,currentpage,item_no,amount)
short	fund;
Page	*currentpage;
short	item_no;
double	*amount;
{
	Page 	*temppage;
	int	i;

	/* Initialize commit amount */	
	*amount = 0.00;

	for(temppage=FirstPage;temppage!=NULL;temppage=temppage->NextPage ) {
		for(i=0;i< temppage->NoItems;i++) {
			if(temppage==currentpage && i == item_no) {
				continue;
			}

			if((strcmp(temppage->Items[i].s_accno,
			   currentpage->Items[item_no].s_accno)==0) &&
			   (temppage->Items[i].s_itm_stat[0] == APPROVED ||
			   temppage->Items[i].s_itm_stat[0] == STOCK )) {
				*amount += temppage->Items[i].s_value;
			}
		}
		if(temppage==ReqLast) {
			break;
		}	
	}
	return(NOERROR);
}	/* caclreqlinklist() */
/*----------------------------------------------------------------*/
calcapproveamt()
{
	Page 	*temppage;
	int	i;

	s_sth.s_approve_amt = 0.00;

	for(temppage=FirstPage;temppage!=NULL;temppage=temppage->NextPage ) {
		for(i=0;i< temppage->NoItems;i++) {
			if(temppage->Items[i].s_itm_stat[0] == APPROVED ||
			   temppage->Items[i].s_itm_stat[0] == STOCK ||
			   temppage->Items[i].s_itm_stat[0] == COMPLETE) {
				s_sth.s_approve_amt+=temppage->Items[i].s_value;
			}
		}
		if(temppage==ReqLast) {
			break;
		}	
	}
	ret(WriteFields(APPAMT_FLD,APPAMT_FLD) );

	return(NOERROR);
}	/* calcapproveamt() */
/*----------------------------------------------------------------*/
checkreqqty(stock_code,currentpage,item_no,quantity)
char	*stock_code;
Page	*currentpage;
short	item_no;
double	*quantity;
{
	Page 	*temppage;
	int	i;

	/* Initialize requisitioned quantity */	
	*quantity = 0.00;

	/* only check stock items */
	if(stock_code[0] == LV_CHAR) {
		return(NOERROR);
	}
 	for(temppage=FirstPage;temppage!=NULL;temppage=temppage->NextPage ) {
		for(i=0;i< temppage->NoItems;i++) {
			if(temppage==currentpage && i == item_no) {
				continue;
			}

			if((strcmp(temppage->Items[i].s_stck_cd,stock_code)==0)
			   && temppage->Items[i].s_itm_stat[0] == STOCK) {
				*quantity += temppage->Items[i].s_ord_qty;
			}
		}
		if(temppage==ReqLast) {
			break;
		}	
	}

	return(NOERROR);
}	/* checkreqqty() */
/*----------------------------------------------------------------*/
checkpurlimit(stock_code,currentpage,item_no)
char	*stock_code;
Page	*currentpage;
short	item_no;
{
	Page 	*temppage;
	int	i;
	double 	amount;

	/* Initialize purchasing limit amount */	
	amount = 0.00;

	/* only check current item if no stock code */
	if(stock_code[0] == LV_CHAR) {
		amount += currentpage->Items[item_no].s_value;
	}	
	else {
 	  for(temppage=FirstPage;temppage!=NULL;temppage=temppage->NextPage ) {
		for(i=0;i< temppage->NoItems;i++) {
			if((strcmp(temppage->Items[i].s_stck_cd,stock_code)==0)
			   &&(temppage->Items[i].s_itm_stat[0] == APPROVED ||
			   temppage->Items[i].s_itm_stat[0] == STOCK )) {
				amount += temppage->Items[i].s_value;
			}
		}
		if(temppage==ReqLast) {
			break;
		}	
	  }
	}
	if(amount > pa_rec.pa_purlimit) {
		return(ERROR);		/* Over Purchasing Limit */
	}

	return(NOERROR);
}	/* checkpurlimit() */
/*----------------------------------------------------------------*/
/* Show Help Windows, if applicable, when user gives ESC-H in key
   and header fields */

HdrAndKeyWindowHelp()
{
	int	err ;

	switch(sr.curfld){
	case	SUPPCD_FLD	:	/* Supplier Cd: */
		err = supp_hlp(s_sth.s_supp_cd, 7, 13 );
		if(err == DBH_ERR) return(err) ;
		if(err >=0 ) redraw();
		if(err < 1) return(ERROR) ;

		STRCPY(supplier.s_supp_cd, s_sth.s_supp_cd) ;
		err = get_supplier(&supplier, UPDATE, 0, e_mesg) ;
		if(ERROR == err) return(DBH_ERR) ;
		if(err < 0) {
			fomer(e_mesg) ;
			s_sth.s_supp_cd[0] = LV_CHAR ;
			return(ERROR) ;
		}
		fomer(supplier.s_name);
		break ;
	case SHIPTO_FLD :		/* Ship To Fields */
		err = sch_hlp(&s_sth.s_shipto, 7, 13 );
		if(err == DBH_ERR) return(err) ;
		if(err >=0 ) redraw();
		if(err < 1) return(ERROR) ;	/* Not Selected */
		break ;
	default :
#ifdef ENGLISH
		fomer("No Help Window For This Field");
#else
		fomer("Pas de fenetre d'assistance pour ce champ");
#endif
	}	/* Switch sr.curfld */

	return(NOERROR) ;
}	/* HdrAndKeyWindowHelp() */
/*----------------------------------------------------------------*/
/* Show Help Windows, if applicable, when user gives ESC-H in Item fields */

ItemsWindowHelp()
{
	int	err ;
	int	fld_no, item_no ;
	int	cur_fld;
	short	reccod ;

	/* Calculate item# ans Fld# within item */
	item_no = (sr.curfld - ITEM_ST_FLD) / STEP ;
	fld_no  = (sr.curfld - ITEM_ST_FLD) % STEP ;

	switch(fld_no){
	case STCKCD_FLD :		/* Stock Code Fields */
		err = stock_hlp(s_sth.s_stckfund, 
		      s_sth.s_items[item_no].s_stck_cd, 7, 13 );
		if(err == DBH_ERR) return(err) ;
		if(err >=0 ) redraw();
		if(err < 1) return(ERROR) ;	/* Not Selected */
		
		err = CheckStock(s_sth.s_items[item_no].s_stck_cd,BROWSE);
		if(err == DBH_ERR) return(err);
		if(err < 0) {
			s_sth.s_items[item_no].s_stck_cd[0] = LV_CHAR ;
			return(ERROR) ;
		}
		/** added for description ****/
		cur_fld = ITEM_ST_FLD + (STEP * item_no) ;
		cur_fld += DESC_FLD ;
		STRCPY( s_sth.s_items[item_no].s_desc, stck_rec.st_desc);
		SetDupBuffers(cur_fld,cur_fld,2);

		s_sth.s_items[item_no].s_desc[0] = LV_CHAR ;
		sr.curfld = (ITEM_ST_FLD + (STEP * item_no) ) + STCKCD_FLD ;
		sr.endfld = (ITEM_ST_FLD + (STEP * item_no) ) + (STEP - 100) ;

		/** added for unit/cost ****/
		cur_fld = ITEM_ST_FLD + (STEP * item_no) ;
		cur_fld += PRICE_FLD ;
		s_sth.s_items[item_no].s_unit_cost = stck_rec.st_rate;
		SetDupBuffers(cur_fld,cur_fld,2);

		s_sth.s_items[item_no].s_unit_cost = LV_DOUBLE ;
		sr.curfld = (ITEM_ST_FLD + (STEP * item_no) ) + STCKCD_FLD ;
		sr.endfld = (ITEM_ST_FLD + (STEP * item_no) ) + (STEP - 100) ;

		/* Show the REQ UOM as a default UOM on stock master */
		cur_fld = ITEM_ST_FLD + (STEP * item_no) ;
		cur_fld += UOM_FLD ;
		STRCPY( s_sth.s_items[item_no].s_uom, stck_rec.st_unit);
		SetDupBuffers(cur_fld,cur_fld,2);

		s_sth.s_items[item_no].s_uom[0] = LV_CHAR ;
		sr.curfld = (ITEM_ST_FLD + (STEP * item_no) ) + STCKCD_FLD ;
		sr.endfld = (ITEM_ST_FLD + (STEP * item_no) ) + (STEP - 100) ;

		/* If not distict set cc# to cost center entering requistion */
		if(CC_no != pa_rec.pa_distccno) 
			s_sth.s_items[item_no].s_school = CC_no;

		fomer(stck_rec.st_desc);
		break ;
	case SCHOOL_FLD :		/* School Fields */
		err = sch_hlp(&s_sth.s_items[item_no].s_school, 7, 13 );
		if(err == DBH_ERR) return(err) ;
		if(err >=0 ) redraw();
		if(err < 1) return(ERROR) ;	/* Not Selected */
		break ;
	case ACNO_FLD :		/* GL Account# Fields */
		err = reqacnt_hlp(s_sth.s_fund, 
			s_sth.s_items[item_no].s_accno, 
		      	&reccod,CC_no,pa_rec.pa_cc_key, 7, 13 );
		if(err == DBH_ERR) return(err) ;
		if(err >=0 ) redraw();
		if(err < 1) return(ERROR) ;	/* Not Selected */
		if(reccod != 99) {
#ifdef ENGLISH
			fomer("Select records with 99 as Record Code only");
#else
			fomer("Choisir les fiches avec 99 seulement comme code de fiche");
#endif
			s_sth.s_items[item_no].s_accno[0] = LV_CHAR ;
			return(ERROR) ;
		}
		err = CheckGlAcnt(s_sth.s_items[item_no].s_accno) ;
		if(DBH_ERR == err) return(err) ;
		if(err < 0) {
			s_sth.s_items[item_no].s_accno[0] = LV_CHAR ;
			return(ERROR) ;
		}
		break ;
	default :
#ifdef ENGLISH
		fomer("No Help Window For This Field");
#else
		fomer("Pas de fenetre d'assistance pour ce champ");
#endif
	}	/* Switch sr.curfld */

	return(NOERROR) ;
}	/* ItemsWindowHelp() */
/*-----------------------------------------------------------------------*/
/* Take the confirmation from user for the header part */

ConfirmHdr()
{
	int	err ;

	for( ; ; ) {
#ifdef ENGLISH
		err = GetOption("A(dd Items), E(dit), C(ancel)", "AEC");
#else
		err = GetOption("R(ajouter articles), M(odifier), A(nnuler)", "RMA");
#endif
		if(err == PROFOM_ERR) return(err) ;

		switch(err) {
		case  ADDITEMS :
			return(YES) ;
		case  EDIT  :
			err = HeaderEdit();
			break ;
		case  CANCEL :
#ifdef ENGLISH
			err = GetOption("Confirm the Cancel (Y/N)?", "YN") ;
#else
			err = GetOption("Confirmer l'annulation (O/N)?", "ON") ;
#endif
			if(err == YES) return(CANCEL) ;
			break ;
		}	/* switch err */

		if(err == PROFOM_ERR) return(err) ;
		if(err == DBH_ERR) return(err) ;
	}	/* for(; ; ) */
}	/* ConfirmHdr() */
/*-----------------------------------------------------------------------*/
/* Take the confirmation from user for the header part */

ConfirmItems()
{
	int	err ;

	/* Options:
	   Approval - YEC
	   Change   - YAEHNPC
	   Inquiry  - YNP
	*/

	for( ; ; ) {
	    switch(s_sth.s_fn[0]) {
	    case  APPROVE:		/* Approve Requistion */
#ifdef ENGLISH
		err = GetOption("Y(es), E(dit), N(ext Page), P(rev Page), C(ancel)" ,"YENPC");
#else
		err = GetOption("O(ui), M(odifier), S(uivant), P(recedent), A(nnuler)" ,"OMSPA");
#endif
		break ;

	    case  CHANGE :		/* Change Req */
#ifdef ENGLISH
		err = GetOption(
		"Y(es), E(dit Item), S(tatus Edit), H(eader Edit), N(ext), P(rev), C(ancel)"
		,"YESHNPC");
#else
		err = GetOption(
		"O(ui),M(odifier article),C(hanger Etat),E(n-tete),S(uiv),P(rec),A(nnuler)"
		,"OMCESPA");
#endif
		break ;
	    case  INQUIRE :		/* Inquire Req */
#ifdef ENGLISH
		err = GetOption("Y(es), N(ext Page), P(rev Page)","YNP");
#else
		err = GetOption("O(ui), S(uivant), P(recedent)","OSP");
#endif
		break ;
	    }
	    if(err == PROFOM_ERR) return(err) ;

	    switch(err) {
	    case  YES  :
		if(s_sth.s_fn[0] == APPROVE || s_sth.s_fn[0] == CHANGE) {
			err = CheckTotal();
			if (err == ERROR) break;  
			if( s_sth.s_status[0] == APPROVED && 
				s_sth.s_fund != s_sth.s_stckfund){
				err=CheckInterfund();
				if(err == ERROR) break;
			}
		}
		return(YES);
	    case  EDIT  :
	    case  STATUSEDIT :
		if(s_sth.s_fn[0] == APPROVE) {
			err = ApproveItems();
			if(err != NOERROR) {
				break;
			}
		}
		else {
			err = ChangeItems(err);
			if(err != NOERROR) {
				break;
			}
		}
		break ;
	    case  HEADEREDIT:  
		err = HeaderEdit();
		break;	  
	    case  NEXTPAGE :
		if(CurPage == ReqLast || ReqLast == NULL) {
#ifdef ENGLISH
			fomer("No More Pages....") ;
#else
			fomer("Plus de pages....") ;
#endif
			continue ;
		}
		CurPage = CurPage->NextPage ;
		err = ShowItems(CurPage) ;
		break ;
	    case  PREVPAGE :
		if(ReqLast == NULL || CurPage == FirstPage ) {
#ifdef ENGLISH
			fomer("No More Pages....") ;
#else
			fomer("Plus de pages....") ;
#endif
			continue ;
		}
		CurPage = CurPage->PrevPage ;
		err = ShowItems(CurPage) ;
		break ;
	    case  CANCEL :
#ifdef ENGLISH
		err = GetOption("Confirm the Cancel (Y/N)?", "YN") ;
#else
		err = GetOption("Confirmer l'annulation (O/N)?", "ON") ;
#endif
		if(err == YES) return(CANCEL) ;
		break ;
	    }	/* switch err */

	    if(err == PROFOM_ERR) return(err) ;
	    if(err == DBH_ERR) return(err) ;
	}	/* for(; ; ) */
}	/* ConfirmItems() */
/*----------------------------------------------------------------------*/
/* Changing Items. Accept Item to be changed, deleted or revived.
   For change option read the item and others mark the Item */

ChangeItems(edit_type)
int	edit_type ;
{
	int	i ;
	int	start_fld;
	int	end_fld;
	int	setdup_start;
	int	setdup_end;
	int	err;

	/* save image of screen for ESC-F during approval */
	scpy((char *)&image,(char *)&s_sth,sizeof(s_struct));

	/* Get The Item to Be Modified */
	for( ; ; ) {
#ifdef ENGLISH
		STRCPY(s_sth.s_mesg,"Enter RETURN to terminate Edit");
#else
		STRCPY(s_sth.s_mesg,"Appuyer sur RETURN pour terminer l'ajustement");
#endif
		ShowMesg() ;
		sr.nextfld = CHG_FLD ;
		fomrf( (char *)&s_sth );
		ret(err_chk(&sr));

		if(s_sth.s_field == 0) break ;
		if( s_sth.s_field < 1 || CurPage == NULL ||
			s_sth.s_field > CurPage->NoItems) {
			continue ;
		}

		if(edit_type == EDIT) {
			edit_field = 0;  /* Edit whole Line */
			if(s_sth.s_items[s_sth.s_field-1].s_itm_stat[0] == COMPLETE){
#ifdef ENGLISH
				fomer("Requisition item is complete. status edit not allowed");
#else
				fomer("TRANSLATE");
#endif
				continue;
			}
			s_sth.s_total_itm -= 
				s_sth.s_items[s_sth.s_field-1].s_value;
			start_fld = ACNO_FLD;
			end_fld = REQNBR_FLD;
			setdup_start = ITEM_ST_FLD + (STEP * (s_sth.s_field-1))
					+ start_fld;
			setdup_end = ITEM_ST_FLD + (STEP * (s_sth.s_field-1))
					+ end_fld;
			/* set dup buffer on */
			SetDupBuffers(setdup_start,setdup_end,2);
			
			InitItem(s_sth.s_field-1,LV_CHAR,LV_SHORT,
					LV_LONG,LV_DOUBLE) ;
		}
		else if(edit_type == STATUSEDIT) {
			edit_field = 1;  /* status edit */
			if(s_sth.s_items[s_sth.s_field-1].s_itm_stat[0]==' ' &&
			   s_sth.s_status[0] == OPEN){
#ifdef ENGLISH
				fomer("Requisition still open. status edit not allowed");
#else
				fomer("Article de req qui est encore a l'etat Ouvert n'est pas permis");
#endif
				continue;
			}
			if(s_sth.s_items[s_sth.s_field-1].s_itm_stat[0] == COMPLETE){
#ifdef ENGLISH
				fomer("Requisition item is complete. status edit not allowed");
#else
				fomer("TRANSLATE");
#endif
				continue;
			}

		       err=CheckStockOrderStatus(CurPage->Items[s_sth.s_field-1].s_stck_cd,s_sth.s_field-1);
		       if(err != NOERROR) {
				return(err);
		       }

			start_fld = ITM_STAT_FLD;
			end_fld = ITM_STAT_FLD;
			setdup_start = ITEM_ST_FLD + (STEP * (s_sth.s_field-1))
					+ start_fld;
			setdup_end = ITEM_ST_FLD + (STEP * (s_sth.s_field-1))
					+ end_fld;
			/* set dup buffer on */
			SetDupBuffers(setdup_start,setdup_end,2);
			s_sth.s_items[s_sth.s_field-1].s_itm_stat[0] = LV_CHAR;
		}
		else {
			return(ERROR);
		}


		i = ReadItem((int)(s_sth.s_field-1),start_fld,end_fld,UPDATE);
		if(i == PROFOM_ERR) return(i) ;
		if(i == DBH_ERR) return(i) ;
		/* Copy the Item to List */

		scpy((char*)&(CurPage->Items[s_sth.s_field-1]),
		     (char*)&(s_sth.s_items[s_sth.s_field-1]),sizeof(S_item)) ;
		if(CurPage->Items[s_sth.s_field-1].s_itm_stat[0] == APPROVED) {
			CurPage->ReqReason[s_sth.s_field-1][0] = '\0';
		}

		if(s_sth.s_items[s_sth.s_field-1].s_itm_stat[0] == APPROVED) {
			err = CheckBudgetPurLimit(i,UPDATE);
		}
		if(calcapproveamt()<0) return(ERROR);

		if(edit_type == EDIT) {
			/* Calculate and Display totals at Bottom of Screen */
			s_sth.s_total_req = s_sth.s_req_amt;
			s_sth.s_total_itm += 
				s_sth.s_items[s_sth.s_field-1].s_value;
			s_sth.s_total_diff = 
				s_sth.s_total_req - s_sth.s_total_itm;

			ret(WriteFields(TOTAL_ST_FLD,TOTAL_END_FLD));
		}
	}	/* for( ; ; ) */

	s_sth.s_field = HV_SHORT ;
	fomwf( (char *)&s_sth );
	ret(err_chk(&sr));

	s_sth.s_mesg[0] = HV_CHAR;
	ShowMesg();

	return(NOERROR);
}	/* ChangeItems() */
/*-----------------------------------------------------------------------*/
/* Display message and get the option */

static
GetOption(msg,options)
char	*msg ;
char	*options ;
{
	int	i, j ;

	STRCPY(s_sth.s_mesg,msg);
	ShowMesg() ;

	sr.nextfld = END_FLD ;
	for( ; ; ) {
		fomrf( (char *)&s_sth ) ;
		ret(err_chk(&sr)) ;

		j = strlen(options) ;
		for( i = 0 ; i < j ; i++)
			if(s_sth.s_resp[0] == options[i]) break ;
		if(i != j) break ;	/* Valid Option Selected */
#ifdef ENGLISH
		fomer("Invalid Option..");
#else
		fomer("Option invalide..");
#endif
	}

	s_sth.s_mesg[0] = HV_CHAR ;
	s_sth.s_resp[0] = HV_CHAR ;
	
	ret( WriteFields(END_FLD -100, END_FLD) );

	return((int)(options[i])) ;
}	/* GetOption() */
/*-----------------------------------------------------------------------*/
/* Move req header details to Screen Header part and read req items
   into linked list and show the Req first page on screen */

ShowReq()
{
	int	err ;
	
	if( CheckFund((short)1) <0 ) 	return(-1);

	/* Initialize totals to zero */
	s_sth.s_total_req = 0.00;
	s_sth.s_total_itm = 0.00;
	s_sth.s_total_diff = 0.00;

	/* Make Items Linked List from req */
	if((err = MakeReqItemsList()) < 0) return(err) ;

	if((err = ReqHdrtoScrHdr()) < 0) return(err) ;	/* Move Header Fields */
	
	/* Get Disapproveal reason for whole requisition */
	if((err = GetReason(HEADER,0)) < 0) return(err);
	
	/* Get Req total and calculate Difference Items total calculated in
	   MakeReqItemsList() */
	s_sth.s_total_req = s_sth.s_req_amt;
	s_sth.s_total_diff = s_sth.s_total_req - s_sth.s_total_itm;	

	if((err = ShowItems(CurPage)) < 0) return(err) ;	/* Show Items */

	return(NOERROR) ;
}	/* ShowReq() */
/*-----------------------------------------------------------*/
/* Move Req Header to Screen Hdr Fields */

ReqHdrtoScrHdr()
{
	/* Copy Key */
	s_sth.s_req_no = req_hdr.code ;

	/* Copy Header Fields */
	STRCPY(s_sth.s_supp_cd,req_hdr.supp_cd);
	s_sth.s_costcenter = req_hdr.costcenter ;
	s_sth.s_req_amt = req_hdr.amount ;
	s_sth.s_entry_dt = req_hdr.date ;
	s_sth.s_due_dt = req_hdr.due_date ;
	s_sth.s_approve_amt = req_hdr.appamt ;
	s_sth.s_billto = req_hdr.billto ;
	s_sth.s_fund = req_hdr.funds ;
	s_sth.s_stckfund = req_hdr.stock_fund ;
	s_sth.s_approve_dt = req_hdr.appdate ;
	s_sth.s_shipto = req_hdr.shipto ;
	s_sth.s_period = req_hdr.period ;
	STRCPY(s_sth.s_attention,req_hdr.attention);
	STRCPY(s_sth.s_status,req_hdr.status) ;

	ret( WriteFields( KEY_START, HDR_END_FLD) ) ;

	return(NOERROR) ;
}	/* ReqHdrtoScrHdr() */
/*-----------------------------------------------------------*/
GetReason(position,item_no)
int	position;	/* 0 - header    1 - items */
int	item_no;	/* item number */
{
	int err;

	switch(position) {
	case	0:
		if(s_sth.s_status[0] == DISAPPROVED) {
			req_reason.reqr_code = req_hdr.code;
			req_reason.reqr_item_no = 0;
			err=get_reqreason((char *)&req_reason,BROWSE,0,e_mesg);
			if(err == UNDEF) {
				HdrReason[0] = '\0';
				return(NOERROR);
			}
			if(err != NOERROR) {
				fomer(e_mesg); get();
				return(err);
			}
			STRCPY(HdrReason,req_reason.reqr_reason);
		}
		else {
			HdrReason[0] = '\0';
		}
		break;
	case	1:
		if(CurPage->Items[item_no].s_itm_stat[0] == DISAPPROVED) {
			req_reason.reqr_code = req_hdr.code;
			req_reason.reqr_item_no = CurPage->ReqItemNo[item_no];
			err=get_reqreason((char *)&req_reason,BROWSE,0,e_mesg);
			if(err == UNDEF) {
				CurPage->ReqReason[item_no][0] = '\0';
				return(NOERROR);
			}
			if(err != NOERROR) {
				fomer(e_mesg); get();
				return(err);
			}
			STRCPY(CurPage->ReqReason[item_no],
						req_reason.reqr_reason);
		}
		else {
			CurPage->ReqReason[item_no][0] = '\0';
		}

		break;
	default:
		return(ERROR);
	}
	return(NOERROR);
}	/* GetReason() */
/*-----------------------------------------------------------*/
/* Read REQ Items and make Linked list */

MakeReqItemsList()	/* Make the linked list from REQ Items */
{
	int	err, i ;

	req_item.code = req_hdr.code ;
	req_item.item_no = 0;
	flg_reset(REQITEM);	/* Initialize to get first rec under givenkey */

	ReqLast = CurPage = NULL ;
	i = 0 ;

	for( ; ; ){
#ifndef ORACLE
		err = get_n_reqitem( &req_item, BROWSE, 0, FORWARD, e_mesg);
#else
		err = get_n_reqitem( &req_item, BROWSE, 0, EQUAL, e_mesg);
#endif
		if(ERROR == err) return(DBH_ERR) ;
		if(EFL == err) break ;

#ifndef ORACLE
		/* If Requisition changes break */
		if( req_item.code != req_hdr.code) break ;
#endif

		if(PAGESIZE == i) i = 0 ;
		if(0 == i)		/* 1st Item in the Page */
			if((err = MakeFreshPage(0)) < 0) return(err) ;

		CurPage->Items[i].s_sno = i + 1 ;
		STRCPY(CurPage->Items[i].s_accno, req_item.acct) ;
		if(req_item.bdgt_flag[0] == YES) {
			STRCPY(CurPage->Items[i].s_overbud, "*") ;
		}
		else {
			CurPage->Items[i].s_overbud[0]=HV_CHAR ;
		}
		STRCPY(CurPage->Items[i].s_accno, req_item.acct) ;
		STRCPY(CurPage->Items[i].s_stck_cd, req_item.st_code);
		STRCPY(CurPage->Items[i].s_itm_stat, req_item.appstat);
		CurPage->Items[i].s_school = req_item.school ;
		STRCPY(CurPage->Items[i].s_desc, req_item.desc);

		STRCPY(CurPage->Items[i].s_gst, req_item.tax1);
		STRCPY(CurPage->Items[i].s_pst, req_item.tax2);
						
		calctax(CurPage->Items[i].s_gst,CurPage->Items[i].s_pst,
			req_item.value,&tax_cal);

		CurPage->Items[i].s_ord_qty = req_item.orig_qty ;
		if (req_item.unit[0] == LV_CHAR) 
			STRCPY(CurPage->Items[i].s_uom, "    ");
		else
			STRCPY(CurPage->Items[i].s_uom, req_item.unit);
		CurPage->Items[i].s_unit_cost = req_item.unitprice ;
		CurPage->Items[i].s_net_amt = req_item.value;
		CurPage->Items[i].s_value = tax_cal.gros_amt; 

		CurPage->Items[i].s_po_nbr = req_item.pocode;
		STRCPY(CurPage->Items[i].s_act_del,ACTIVE);

		CurPage->ReqItemNo[i] = req_item.item_no ;
		CurPage->ReqStatus[i] = ' ';

		/* Calculate Items Total */
		s_sth.s_total_itm += CurPage->Items[i].s_value;

		CurPage->NoItems++ ;

		/* Get Disapproveal reason for each item */
		if((err = GetReason(ITEMS,i)) < 0) return(err);
		
		i++ ;
	} 
	seq_over(REQITEM) ;

	if(ReqLast != NULL)
		CurPage = FirstPage ;

	return(NOERROR) ;
}	/* MakeReqItemsList() */
/*-----------------------------------------------------------*/
/* Move Screen Hdr Fields to Req Header */

ScrHdrtoReqHdr(mode)
int	mode ;
{

	req_hdr.code = s_sth.s_req_no ;

	STRCPY(req_hdr.supp_cd, s_sth.s_supp_cd) ;
	req_hdr.costcenter = s_sth.s_costcenter;
	req_hdr.billto = s_sth.s_billto ;
	req_hdr.shipto = s_sth.s_shipto ;
	req_hdr.date = s_sth.s_entry_dt ;
	req_hdr.funds = s_sth.s_fund ; 
	req_hdr.stock_fund = s_sth.s_stckfund ;
	req_hdr.amount = s_sth.s_req_amt ;
	req_hdr.due_date = s_sth.s_due_dt ;
	req_hdr.period = s_sth.s_period ;
	req_hdr.appdate = s_sth.s_approve_dt ;
	req_hdr.code = s_sth.s_req_no;
	STRCPY(req_hdr.attention, s_sth.s_attention) ;
	if (mode == ADD) {
		req_hdr.print_form[0] = NO ;
	}
	req_hdr.appamt = s_sth.s_approve_amt ;
	STRCPY(req_hdr.status,s_sth.s_status) ;
	
		/* round all calculated double variables before writing CL*/

	req_hdr.amount = D_Roundoff(req_hdr.amount); 
	req_hdr.appamt = D_Roundoff(req_hdr.appamt);  

	return(NOERROR) ;
}	/* ScrHdrtoReqHdr() */
/*------------------------------------------------------------------------*/
/* Move High values to all data fields and clear the screen */

ClearScreen()
{
	int	i;

	/* Move High Values to Hedaer part */
	InitHdr(HV_CHAR, HV_SHORT, HV_LONG, HV_DOUBLE) ;

	s_sth.s_page_no    = HV_SHORT ;
	s_sth.s_dummy1[0] = HV_CHAR ;

	/* Move High Values to All items */
	for(i = 0 ; i < PAGESIZE ; i++)
		InitItem(i,HV_CHAR,HV_SHORT,HV_LONG,HV_DOUBLE) ;

	/* Only used if item disapproved */
	s_sth.s_reason[0] = HV_CHAR;

	InitTotals(HV_DOUBLE);

	ret( WriteFields(HDR_ST_FLD, (END_FLD - 200)) );

	return(NOERROR);
}	/* ClearScreen() */
/*-------------------------------------------------------------------------*/
/* Initialize Screen Header with either Low or High Values */

InitHdr( t_char, t_short, t_long, t_double )
char	t_char ;
short	t_short ;
long	t_long ;
double	t_double ;
{
	s_sth.s_supp_cd[0] = t_char ;
	s_sth.s_costcenter = t_short ;
	s_sth.s_req_amt = t_double ;
	s_sth.s_entry_dt = t_long ;
	s_sth.s_due_dt = t_long ;
	s_sth.s_approve_amt = t_double ;
	s_sth.s_billto = t_short ;
	s_sth.s_fund = t_short ;
	s_sth.s_stckfund = t_short ;
	s_sth.s_approve_dt = t_long ;
	s_sth.s_shipto = t_short ;
	s_sth.s_period = t_short ;
	s_sth.s_attention[0] = t_char ;
	s_sth.s_status[0] = t_char ;

	return(NOERROR) ;
}	/* InitHdr() */
/*-------------------------------------------------------------------------*/
/* Initialize Given screen item with either Low values or High values */

InitItem(item_no, t_char, t_short, t_long, t_double)
int	item_no ;
char	t_char ;
short	t_short ;
long	t_long ;
double	t_double ;
{

	if(t_short == HV_SHORT) {
		s_sth.s_items[item_no].s_sno = t_short ;
	}
	s_sth.s_items[item_no].s_accno[0] = t_char ;
	if(t_char == HV_CHAR) {
		s_sth.s_items[item_no].s_overbud[0] = HV_CHAR ;
	}
	s_sth.s_items[item_no].s_stck_cd[0] = t_char ;

	if(s_sth.s_fn[0] == CHANGE) {
		if(s_sth.s_items[item_no].s_itm_stat[0] != ' ') {
			s_sth.s_items[item_no].s_itm_stat[0] = t_char ;
		}
	}
	else {
		s_sth.s_items[item_no].s_itm_stat[0] = t_char ;
	}

	s_sth.s_items[item_no].s_school = t_short ;
	s_sth.s_items[item_no].s_desc[0] = t_char ;

	if(t_short == LV_SHORT) {
		s_sth.s_items[item_no].s_subhdg[0] = ' ';
	}
	else {
		s_sth.s_items[item_no].s_subhdg[0] = t_char;
	}

	s_sth.s_items[item_no].s_gst[0] = t_char;
	s_sth.s_items[item_no].s_pst[0] = t_char;
	s_sth.s_items[item_no].s_ord_qty = t_double ;
	s_sth.s_items[item_no].s_uom[0] = t_char ;
	s_sth.s_items[item_no].s_unit_cost = t_double ;
	s_sth.s_items[item_no].s_net_amt = t_double ;
	s_sth.s_items[item_no].s_value = t_double ;
	if(t_long == LV_LONG) {
		s_sth.s_items[item_no].s_po_nbr = 0;	
	}
	else {
		s_sth.s_items[item_no].s_po_nbr = t_long;	
	}
	if(t_char == HV_CHAR)  {
		s_sth.s_items[item_no].s_act_del[0] = t_char;	
	}

	return(NOERROR) ;
}	/* InitItem() */
/*-------------------------------------------------------------------------*/
/* Initialize Given screen item with either Low values or High values */
InitTotals(t_double)
double t_double;
{
	
	s_sth.s_total_req = t_double;
	s_sth.s_total_itm = t_double;
	s_sth.s_total_diff = t_double;

	return(NOERROR);
}	/* InitTotals() */
/*-------------------------------------------------------------------------*/

static
DispError(s)    /* show ERROR and wait */
char	*s;
{
	strncpy(s_sth.s_mesg,s, (sizeof(s_sth.s_mesg) - 1));
	ShowMesg();
#ifdef ENGLISH
	fomen("Press any key to continue");
#else
	fomen("Appuyer sur une touche pour continuer");
#endif
	get();
	s_sth.s_mesg[0] = HV_CHAR;
	ShowMesg();
	return(NOERROR);
}
/*-------------------------------------------------------------------------*/

ShowMesg()  /* shows or clears message field */
{
	sr.nextfld = END_FLD - 100;
	fomwf( (char *)&s_sth ) ;
	return(0);
}

/*-------------------------------------------------------------------------*/
HeaderEdit()
{

	int retval;
	int firstfld,lastfld;

	/* save image of screen for ESC-F during editing */
	scpy((char*)&image, (char*)&s_sth, sizeof(s_sth));

#ifdef ENGLISH
	STRCPY(s_sth.s_mesg,"Enter RETURN to terminate Edit");
#else
	STRCPY(s_sth.s_mesg,"Appuyer sur RETURN pour terminer l'ajustement");
#endif
	ShowMesg();


	for( ; ; ){
		/* Read number of field to be changed */
		s_sth.s_field = LV_SHORT;
		retval = ReadFields(CHG_FLD, CHG_FLD,
			KeyAndHdrValidation, HdrAndKeyWindowHelp, 0) ;
		if( retval < 0) return(retval);
		if( retval==RET_USER_ESC ){
			s_sth.s_field = HV_SHORT;
			ret(WriteFields(CHG_FLD,CHG_FLD));
			break;
		}
		if(s_sth.s_field == 0) {
			s_sth.s_field = HV_SHORT;
			ret(WriteFields(CHG_FLD,CHG_FLD));
			break;
		}
		switch(s_sth.s_field){
			case 1: 	/* Supplier code */
				firstfld = lastfld = SUPPCD_FLD;
				break;
			case 2: 	/* Requisition amount */
				firstfld = lastfld = REQAMT_FLD;
				break;
			case 3: 	/* Entry date */
				firstfld = lastfld = ENTRYDT_FLD;
				break;
			case 4: 	/* Due date */
				firstfld = lastfld = DUEDT_FLD;
				break;
			case 7: 	/* Ship To date */
				firstfld = lastfld = SHIPTO_FLD;
				break;
/*********************************
	Because the status was being changed through the Change process
	rather than the Approve process the Inventory was going negative.
	Thus this functionality was removed.
	
			case 8: 	 Status field 
				firstfld = lastfld = STATUS_FLD;
				break;
**********************************/
			case 9: 	/* Attention */
				firstfld = lastfld = ATT_FLD;
				break;
#ifdef ENGLISH
			default: fomer("Can't change specified field");
#else
			default: fomer("Ne peut pas changer le champ specifie");
#endif
				continue;
		}
		retval = ModifyField(firstfld, lastfld);
		if( retval<0 )	return(retval);
		if( retval==RET_USER_ESC ){
			s_sth.s_field = HV_SHORT;
			ret(WriteFields(CHG_FLD,CHG_FLD));
			CopyBack((char*)&s_sth,(char*)&image,firstfld,lastfld);
			break;
		}
	}
	return(0);
}
ModifyField( firstfld, lastfld )	/* Read & change the specified fields */
int firstfld,lastfld;
{
	int i, retval;

	for( i=firstfld; i<=lastfld; i+=100 ){
		fomca1( i,19,2);	/* enable dup buffers */
	}
	sr.nextfld = firstfld;
	sr.endfld = lastfld;
	fomud( (char *)&s_sth);		/* Update dup buffers */
	/* Reset fields because fomud initializes endfld to 0 */
	sr.nextfld = firstfld;
	sr.endfld = lastfld;
	switch(firstfld){
		case SUPPCD_FLD:	/* Supplier code */
			s_sth.s_supp_cd[0] = LV_CHAR;
			break;
		case REQAMT_FLD:	/* Requisition amount */
			s_sth.s_req_amt = LV_DOUBLE;
			break;
		case ENTRYDT_FLD:	/* Entry date */
			s_sth.s_entry_dt = LV_LONG;
			break;
		case DUEDT_FLD:	/* Due date */
			s_sth.s_due_dt = LV_LONG;
			break;
		case FUND_FLD:	/* Fund */
			s_sth.s_fund = LV_SHORT;
			break;
		case STCKFUND_FLD:	/* Stock Fund */
			s_sth.s_stckfund = LV_SHORT;
			break;
		case SHIPTO_FLD:	/* Ship to */
			s_sth.s_shipto = LV_SHORT;
			break;
		case ATT_FLD:	/* Attention field */
			s_sth.s_attention[0] = LV_CHAR;
			break;
/***************************
		case STATUS_FLD:	Status field 
			s_sth.s_status[0] = LV_CHAR;
			break;
***************************/
		default:
			break;
	}
	retval = ReadFields(firstfld, lastfld,
		KeyAndHdrValidation, HdrAndKeyWindowHelp, UPDATE) ;
	if( retval<0 || retval==RET_USER_ESC )	return(retval);
	for( i=firstfld; i<=lastfld; i+=100 ){
		fomca1( i,19,0);	/* disable dup buffers */
		fomca1( i,10,1);	/* enable escape flag */
	}

	/* if changing amount field update totals on botton of screen */
	if(firstfld == REQAMT_FLD) {
		/* Calculate and Display totals at Bottom of Screen */
		s_sth.s_total_req = s_sth.s_req_amt;
		s_sth.s_total_diff = s_sth.s_total_req - s_sth.s_total_itm;

		ret(WriteFields(TOTAL_ST_FLD,TOTAL_END_FLD));
	}

/*************************************
	if(firstfld == STATUS_FLD) {
		retval = ApproveItems();
		if(retval != NOERROR) {
			return(retval);
		}
	}
************************************/
	return(0);
}	/* ModifyField() */
/*-------------------- E n d   O f   P r o g r a m ---------------------*/
