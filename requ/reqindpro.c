/*-----------------------------------------------------------------------
Source Name: reqindpro.c
System     : Budgetary Financial system.
Module     : Requisition system.
Created  On: th Mar 91.
Created  By: Steven Osborne.

MakeFile :	make -f makeindp

DESCRIPTION:
	Program to perform individual processing of requisitions.  This program
	automatically creates Purchase Orders for Requisitions that are selected
	for processing.

Usage of SWITCHES when they are ON :
	SW1 :
	SW2 :
	SW3 :
	SW4 :
	SW5 :
	SW6 :
	SW7 :	
	SW8 :
		Not Used.


MODIFICATIONS:        

Programmer     YY/MM/DD       Description of modification
~~~~~~~~~~     ~~~~~~~~       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
L. Robichaud   92/12/18	      Change to print issue slips every time needed
			      rather than at the end of the session.
------------------------------------------------------------------------*/

#define	MAIN	/* Main program. This is to declare Switches */
#define MAINFL		POHDR	/* need to produce POs */

#define	SYSTEM		"REQUISITIONS"		/* Sub System Name */
#define	MOD_DATE	"-MAR-91"		/* Program Last Modified */

#include <stdio.h>
#include <cfomstrc.h>
#include <bfs_defs.h>
#include <bfs_recs.h>
#include <requ.h>

#define	SCR_NAME	"reqindpro"	/* PROFOM screen name	*/

#ifdef ENGLISH
#define INDPRO		'I'
#define NEXT    	'N'
#define PREVIOUS	'P'
#define EXIT		'E'
#define	CREATE		'C'
#else
#define INDPRO		'T'
#define NEXT    	'S'
#define PREVIOUS	'P'
#define EXIT		'F'
#define	CREATE		'A'
#endif

/* reqindpro.sth - header for C structure generated by PROFOM EDITOR */

typedef	struct	{
	char	pgm[11];	/* STRING XXXXXXXXXX field 100 */
	long	rundt;	/* DATE YYYYFMMFDD field 300 */
	char	fn[2];	/* STRING X field 400 */
	long	req_no;	/* NUMERIC 9999999999 field 500 */
	char	supp_code[11];	/* STRING XXXXXXXXXX field 700 */
	char	supp_name[31];	/* STRING x(30) field 800 */
	short	cc_no;	/* NUMERIC 99 field 900 */
	long	order_date;	/* NUMERIC 9999F99F99 field 1000 */
	double	amount;	/* NUMERIC 9999999.99 field 1100 */
	char	status[2];	/* STRING X field 1200 */
	char	mesg[78];	/* STRING field 1300 */
	char	resp[2];	/* STRING X field 1400 */
} IndPro_Screen;

IndPro_Screen	ip_sth;

#define	START_FLD	100
#define END_FLD		1400
#define	OPTION_FLD	400
#define	KEY_FLD		500

Pa_rec	pa_rec;
static Req_hdr	req_hdr;
static Supplier supplier;

static	char	e_mesg[80];
static	struct	stat_rec	sr;


main(argc,argv)
int argc;
char *argv[];
{
	long	retcode;

	if(argc < 2)
	{
#ifdef  DEVELOP
		printf("MAIN ARGUMENTS ARE NOT PROPER\n");
		printf("Usage : %s {-tterminal name}\n", argv[0]);
#endif
		exit(1);
	}

	strncpy(SYS_NAME,SYSTEM,50);	/* Sub system name */
	strncpy(CHNG_DATE,MOD_DATE,10);	/* Modification Date */

	proc_switch(argc, argv, MAINFL) ; 	/* Process Switches */

	STRCPY(sr.termnm,terminal);	/* Copy Terminal Name */

	ret(Initialize()) ;		/* Initialize screens and files */

	retcode = settax();
	if(retcode < 0) {
		fomer(e_mesg);
		get();
		fomcs();
		fomrt();

		close_dbh();	/* Close files */
		exit(1);	
	}

	retcode = get_param(&pa_rec, BROWSE, 1, e_mesg) ;
	if(retcode == ERROR)
	{
		disperror(e_mesg);
	}
	else if(retcode == UNDEF)
	{
#ifdef ENGLISH
		disperror("Parameters Are Not Setup..");
#else
		disperror("Parametres ne sont pas etablis..");
#endif
	}

	if(CC_no != pa_rec.pa_distccno) {
#ifdef ENGLISH
		fomer("Can only be run from district office");
#else
		fomer("Ne peut pas fonctionner a partir du conseil scolaire");
#endif
	} 
	else {
		retcode = Process(); 	/* Initiate Process */
	}

	/* Set terminal back to normal mode from PROFOM */
	fomcs();
	fomrt();

	close_dbh();	/* Close files */

	if(retcode != NOERROR)
	{
		exit(1);
	}

	exit(0);
} /* END OF MAIN */

/*-------------------------------------------------------------------*/
/* Initialize PROFOM and requisition file starting point.	*/
Initialize()
{
	fomin(&sr);
	/* Check for Error */
	if(err_chk(&sr) == PROFOM_ERR)
	{
		fomcs();
		fomrt();
		return(ERROR);
	}
	fomcf(1,1);	/* Enable Snap screen option */
	fomcf(2,0);	/* Fomwr should not update dup buffers */

	/* Initialize Screen */
	STRCPY(sr.scrnam,NFM_PATH);
	strcat(sr.scrnam,SCR_NAME);

	STRCPY(ip_sth.pgm,PROG_NAME);
	ip_sth.rundt = get_date();	/* get today's date in YYYYMMDD format*/

	ip_sth.fn[0] = LV_CHAR;
	ip_sth.req_no = LV_LONG;
	
	ip_sth.supp_code[0] = HV_CHAR;
	ip_sth.supp_name[0] = HV_CHAR;
	ip_sth.cc_no = HV_SHORT;
	ip_sth.order_date = HV_LONG;
	ip_sth.amount = HV_DOUBLE;
	ip_sth.status[0] = HV_CHAR;

	ip_sth.mesg[0] = HV_CHAR;
	ip_sth.resp[0] = HV_CHAR;

	sr.nextfld = START_FLD;
	sr.endfld = END_FLD;
	fomwr((char*)&ip_sth);
	ret(err_chk(&sr));

	/* Set up default key value for requisition header file.	*/
	req_hdr.code = -1;

	return(NOERROR) ;
}	/* InitProfom() */

/*-----------------------------------------------------------------------*/ 
/* Display options and process the user's choice.	*/
static	int
Process()
{
	for( ; ; )
	{
#ifdef	ENGLISH
		fomer("I(ndividual Processing), N(ext), P(revious), E(xit)");
#else
		fomer("T(raiter), S(uivant), P(recedent), F(in)");
#endif
		sr.nextfld = OPTION_FLD ;
		sr.endfld = OPTION_FLD;
		fomrf((char*)&ip_sth);
		ret(err_chk(&sr)) ;

		/* Select function corresponding to user's choice.	*/
		switch(ip_sth.fn[0])
		{
		case INDPRO :	/* Individual Processing */
			indpro();
			break;
		case NEXT :
			nextreq(FORWARD);
			break;
		case PREVIOUS :
			nextreq(BACKWARD);
			break;
		case EXIT :
			return(NOERROR);
		default :
			continue ;
		}
	}
}

/*-------------------------------------------------------------------------*/
static	int
indpro()	/* Handle individual processing of requisitions.	*/
{
	long	retcode;
	long	po_nos[MAX_PO];

	/* Get the requisition number from the user.	*/
	if (read_req_no() == ERROR)
	{
		return(NOERROR);
	}

	/* Display the requisition info on the screen.	*/
	update_screen();

	/* Process the user's choice of function.	*/
	for( ; ; )
	{
#ifdef	ENGLISH
		STRCPY(ip_sth.mesg,"C(reate), N(ext), E(nd Session)");
#else
		STRCPY(ip_sth.mesg,"A(pprobation), S(uivant), F(in de session)");
#endif
		showmesg();
		sr.nextfld = END_FLD;
		sr.endfld = END_FLD;
		fomrf((char*)&ip_sth);
		ret(err_chk(&sr)) ;

		/* Select function corresponding to user's choice.	*/
		switch(ip_sth.resp[0])
		{
		case CREATE :	/* Create Purchase Orders */
			if (req_hdr.status[0] != APPROVED)
			{
#ifdef ENGLISH
				fomer("Requisition does not have approval status");
#else
				fomer("Requisition n'a pas l'etat approuve");
#endif
				break;
			}
			if (init_po() != NOERROR)
			{
				break;
			}
			if (req_process(&req_hdr,e_mesg) != NOERROR)
			{
				disperror(e_mesg);
				break;
			}
			if (complete_po(po_nos,e_mesg) != NOERROR)
			{
				disperror(e_mesg);
				break;
			}
#ifdef ENGLISH
			sprintf(e_mesg,"Po Numbers use: %ld  %ld",po_nos[0],po_nos[1]);
#else
			sprintf(e_mesg,"Numeros BC utilises: %ld  %ld",po_nos[0],po_nos[1]);
#endif
			fomer(e_mesg);
			break;
		case NEXT :
			nextreq(FORWARD);
			break;
		case EXIT :
			break;
		default :
			continue;
		}
		if(ip_sth.resp[0] == EXIT){
			/* Get rid of the prompt and response.	*/
			ip_sth.mesg[0] = HV_CHAR;
			showmesg();
			ip_sth.resp[0] = HV_CHAR;
			sr.nextfld = END_FLD;
			fomwf((char*)&ip_sth);
			/* redraw(); lr*/
			break; /* out of for loop */
		}
	}
	return(NOERROR);
}
/*-------------------------------------------------------------------------*/
static	int
read_req_no()	/* Get the requisition number from the user.	*/

{
	long	retcode;
	long	saved_req_no;	/* Temporary variable for saving current
					requisition number from screen.	*/

	/* Save the current screen value in case of an ESC F.	*/
	saved_req_no = ip_sth.req_no;

	/* Prepare field for reading.	*/
	fomca1(KEY_FLD,19,2);
	sr.nextfld = KEY_FLD;
	sr.endfld = KEY_FLD;
	fomud((char*)&ip_sth);
	ret(err_chk(&sr));

	ip_sth.req_no = LV_LONG;

	/* Loop until we have a valid requisition number or an ESC F	*/
	for ( ; ; )
	{
		/* Read the requisition number field.	*/
		sr.nextfld = KEY_FLD;
		sr.endfld = KEY_FLD;
		fomrf((char*)&ip_sth);
		ret(err_chk(&sr));

		/* Check for user escape.	*/
		if (sr.retcode == RET_USER_ESC)
		{
			if (sr.escchar[0] == 'F' || sr.escchar[0] == 'f')
			{
				ip_sth.req_no = saved_req_no;
				return(ERROR);
			}
			if (sr.escchar[0] == 'H' || sr.escchar[0] == 'h')
			{
				fomer("There is no help available for this field.");
				continue;
			}
		}

		/* Verify that a requisition exists for this number.	*/
		req_hdr.code = ip_sth.req_no;
		retcode = get_reqhdr(&req_hdr,UPDATE,0,e_mesg);
		if (retcode == NOERROR)
		{
			break;
		}
		else
		{
			fomer(e_mesg);
			ip_sth.req_no = LV_LONG;
		}
	}

	return(NOERROR);
}

/*-------------------------------------------------------------------------*/
static	int
nextreq(direction)	/* Get the next approved requisition */

long	direction;

{
	long	retcode;

	/* Check for changes in read mode or direction and modify the key
		to go to the next key in that direction.	*/
	if (flg_start(REQHDR) != direction)
	{
		req_hdr.code = ip_sth.req_no;
		if (direction == FORWARD)
		{
			req_hdr.code++;
		}
		else
		{
			req_hdr.code--;
		}
		flg_reset(REQHDR);
	}

	/* Do a get next on the requisition header until an approved
		requisition is found or an error occurs.	*/
	for ( ; ; )
	{
		retcode = get_n_reqhdr(&req_hdr,UPDATE,0,direction,e_mesg);
		if (retcode != NOERROR || req_hdr.status[0] == APPROVED)
		{
			break;
		}
		roll_back(e_mesg);
	}

	/* If there was no error, update the screen with the values
		 from the requisition.	*/
	if (retcode == NOERROR)
	{
		update_screen();
	}
	/* Else if end of file, display the appropriate message.	*/
	else if (retcode == EFL)
	{
		fomer("No more records ...");
		get();
		req_hdr.code = ip_sth.req_no;
		flg_reset(REQHDR);
		retcode = get_reqhdr(&req_hdr,UPDATE,0,e_mesg);
		if(retcode < 0) {
			fomer(e_mesg);
			get();
		}
	}
	/* Else, display the message returned from the get.	*/
	else
	{
		fomer(e_mesg);
		get();
	}
	return(NOERROR);
}

/*-------------------------------------------------------------------------*/
static	int
update_screen()	/* Copies the requisition data to the screen.	*/

{
	long	retcode;

	/* Get the supplier name using the supplier code.	*/
	STRCPY(supplier.s_supp_cd,req_hdr.supp_cd);
	retcode = get_supplier(&supplier,BROWSE,0,e_mesg);
	if (retcode != NOERROR)
	{
		STRCPY(ip_sth.mesg,e_mesg);
		ip_sth.supp_name[0] = ' ';
	}
	else
	{
		STRCPY(ip_sth.supp_name,supplier.s_name);
	}

	ip_sth.req_no = req_hdr.code;
	STRCPY(ip_sth.supp_code,req_hdr.supp_cd);
	ip_sth.cc_no = req_hdr.billto;
	ip_sth.order_date = req_hdr.date;
	ip_sth.amount = req_hdr.amount;
	STRCPY(ip_sth.status,req_hdr.status);

	/* Display the screen.	*/
	sr.nextfld = START_FLD;
	sr.endfld = END_FLD;
	fomwr((char*)&ip_sth);
	ret(err_chk(&sr));

	return(NOERROR);
}

/*-------------------------------------------------------------------------*/
static	int
disperror(s)	/* show ERROR and wait */
char *s;
{
	STRCPY(ip_sth.mesg,s);
	showmesg();
#ifdef	ENGLISH
	fomen("Press any key to continue");
#else
        fomen("Appuyer sur une touche pour continuer");
#endif
	get();
	ip_sth.mesg[0] = HV_CHAR ;
	showmesg() ;
	roll_back(e_mesg);
	return(ERROR);
}

/*-----------------------------------------------------------*/
static int	/* Display message field */
showmesg()
{
	sr.nextfld = END_FLD - 100;
	fomwf((char*)&ip_sth);
	return(NOERROR);
}	/* showmesg() */

/*-----------------------------------------------------------*/
char		/* Display message and retrieve response. */
confirm(s)

char	*s;	/* Prompt message.	*/

{
	/* Display message.	*/
	STRCPY(ip_sth.mesg,s);
	sr.nextfld = END_FLD - 100;
	fomwf((char*)&ip_sth);

	/* Get user response.	*/
	sr.nextfld = END_FLD;
	sr.endfld = END_FLD;
	fomrf((char*)&ip_sth);
	if (err_chk(&sr) == PROFOM_ERR)
	{
		return('\0');
	}

	return(ip_sth.resp[0]);
}	/* confirm() */
/*-------------------- E n d   O f   P r o g r a m ---------------------*/
