/*-----------------------------------------------------------------------
Source Name: reqdisap.c
System     : Accounts Payables.
Created  On: 11th March 91.
Created  By: Jonathan Prescott.

DESCRIPTION:
	Program to Display Disapproved Requisition Items.

MODIFICATIONS:        

Programmer     YY/MM/DD       Description of modification

------------------------------------------------------------------------*/
#define	MAIN		/* Main program. This is to declare Switches */
#define MAINFL		REQITEM			/* main file used */

#define	SYSTEM		"REQUISITIONING"	/* Sub System Name */
#define	MOD_DATE	"11-APR-91"		/* Progran Last Modified */

#include <stdio.h>
#include <cfomstrc.h>
#include <bfs_defs.h>
#include <bfs_recs.h>
#include <requ.h>

#define	DELTA_AMT  0.005	/* To Check double values for zero */
#define	DELTA_QTY  0.00005	/* To Check double values for zero */

#define TAXABLE		'T'
#define EXEMPT		'E'

/* User Interface define constants */
#ifdef ENGLISH
#define INQUIRE		'I'
#define EXITOPT		'E'
#define	NEXT		'N'
#define	PREV		'P'

#define	YES		'Y'
#define	NEXTPAGE	'N'
#define	PREVPAGE	'P'

#else
#define INQUIRE		'I'
#define EXITOPT		'F'
#define	NEXT		'S'
#define	PREV		'P'

#define	YES		'O'
#define	NEXTPAGE	'S'
#define	PREVPAGE	'P'

#endif

/* PROFOM Releted declarations */

#define	SCR_NAME	"reqdisap"	/* PROFOM screen Name */

#define	PAGESIZE	3		/* No of Items */

/* PROFOM Screen STH file */

/* Field PROFOM numbers */

#define	ITEM_ST_FLD	1000	/* Item 1 Start Field */
#define	END_FLD		9700	/* Last Field of the screen */
#define	STEP		1500	/* NO of fields diff. between 2 items */

/* HDR Fields */
#define	FN_FLD		400	/* Fn: */
#define	KEY_START	500	/* Req Number */
#define	KEY_END		500	/* Req Number */
#define	PAGENO_FLD	600	/* Page No: */
#define CCNO_FLD	800	/* Cost Center: */
#define TEXT_FLD	900	/* Text Field */

/* Item Fields. These numbers are difference between that field
   and the 1st fld within the item */
#define	ACNO_FLD	100
#define	STCKCD_FLD	200
#define ITM_STAT_FLD	300
#define	SCHOOL_FLD	400
#define DESC_FLD	500

#define GST_FLD		700
#define	PST_FLD		800
#define	QTY_FLD		900
#define UOM_FLD		1000
#define	PRICE_FLD	1100
#define	NET_FLD		1200
#define GROSS_FLD	1300
#define REASON_FLD	1400

/* reqdisap.sth - header for C structure generated by PROFOM EDITOR */

typedef	struct	{	/* Start Fld 1000, Endfld 5400 and Step 1500 */

	short	s_sno;		/* NUMERIC 999 field 1000 */
	char	s_accno[19];	/* STRING XXXXXXXXXXXXXXXXXX Field 1100 */
	char	s_stck_cd[11];	/* STRING XXXXXXXXXX Field 1200 */
	char	s_itm_stat[2];	/* STRING XXX Field 1300 */
	short	s_school;	/* NUMERIC 99 Field 1400 */
	char	s_desc[61];	/* STRING X(60) Field 1500 */
	char	s_subhdg[2];	/* STRING X Field 1600 */
	char	s_gst[2];	/* STRING XX Field 1700 */
	char	s_pst[2];	/* STRING XX Field 1800 */
	double	s_ord_qty;	/* NUMERIC 99999.9999 Field 1900 */
	char	s_uom[7];	/* STRING XXXXXX Field 2000 */
	double	s_unit_cost;	/* NUMERIC 99999.99 Field 2100 */
	double	s_net_amt;	/* NUMERIC 9999999.99 Field 2200 */
	double	s_value;	/* NUMERIC 9999999.99 Field 2300 */
	char	s_reason[72];	/* STRING  Field 2400 */
}	S_item ;

typedef struct	{

	char	s_pgm[11];	/* STRING XXXXXXXXXX Field 100 */
	char	s_scrname[35]; 	/* STRING X(34) Field 200 */
	long	s_rundate;	/* DATE YYYYFMMFDD Field 300 */
	char	s_fn[2];	/* STRING X Field 400 */
	long	s_req_no;	/* NUMERIC 99999999 Field 500 */
	short	s_page_no;	/* NUMERIC 99 Field 600 */
	short	s_costcenter;	/* NUMERIC 99 Field 800 */
	char	s_text[44];	/* STRING X(43) Field 900 */

	S_item	s_items[PAGESIZE] ;	/* Start Fld 1000, End Fld 5400 and
					   Step 1500 */

	char	s_mesg[78];	/* STRING X[77] Field 9600 */
	char	s_resp[2];	/* STRING X Field 9700 */
} s_struct;


static  short gst_tax;
static  short pst_tax;
static  Tax_cal tax_cal;
static  double  net_amt;
double	D_Roundoff();

static	s_struct  s_sth;	/* PROFOM Screen Structure */
static	struct  stat_rec  sr;		/* PROFOM status rec */

static  Req_hdr 	req_hdr ;	/* Requisition Header Record */
static  Req_item 	req_item ;	/* Requisition Item Record */
static  Req_reason 	req_reason ;	/* Requisition Reason Record */
static	Pa_rec		pa_rec ;	/* Parameters Record */

static	char 	e_mesg[100];  		/* dbh will return err msg in this */

/*
*	Doubly linked list to maintain req items. Each node in this list
*	conatins one page full of req items. This list is freed only at the
*	time of exiting program. 
*/

typedef	struct Page {

	S_item	Items[PAGESIZE] ;	/* Items information */
	short	ReqItemNo[PAGESIZE] ;	/* Corresponding Req Item# */
	struct	Page	*PrevPage ;	/* Ptr to Previous Page */
	struct	Page	*NextPage ;	/* Ptr to Next Page */
	short	NoItems ;		/* No of Items in this page */
	short	Pageno ;		/* Page Number */

}	Page ;

static	Page	*FirstPage,		/* Address of the First Page */
		*CurPage,		/* Address of the Active Page */
		*ReqLast,		/* Address of Cur. Req Last page */
		*LastPage ;		/* Address of the Last page Memory
					   allocated */
int	Argc;
char	**Argv;

void	free() ;
char	*malloc() ;

main(argc,argv)
int argc;
char *argv[];
{
	int 	retval;

	/* These two are passed to execute() when it is called */
	Argc = argc;
	Argv = argv;

	retval = Initialize(argc,argv);	/* Initialization routine */

	if (retval == NOERROR) retval = ReqProcess();

	CloseRtn();			/* return to menu */
	if (retval != NOERROR) exit(-1);

	exit(0);
}

/*-------------------------------------------------------------------*/
/* Initialize PROFOM */

Initialize(argc, argv)
int	argc ;
char	*argv[] ;
{
	int	err ;

	/*
	*	Initialize DBH Environment
	*/
	strncpy(SYS_NAME,SYSTEM,50);	/* Sub system name */
	strncpy(CHNG_DATE,MOD_DATE,10);	/* Modification Date */

	proc_switch(argc, argv, MAINFL) ; 	/* Process Switches */

	/*
	*	Initialize PROFOM & Screen
	*/
	STRCPY(sr.termnm,terminal);	/* Copy Terminal Name */
	fomin(&sr);
	ret(err_chk(&sr)) ;		/* Check for PROFOM Error */
	fomcf(1,1);			/* Enable Snap screen option */

	err = InitScreen() ;		/* Initialize Screen */
	if(NOERROR != err) return(err) ;

	err = settax(e_mesg);	/* Set up the global tax variables.	*/
	if (err != NOERROR)
	{
		fomer(e_mesg);
		get();
		return(ERROR);
	}
	/*
	*	Get The Parameter Record
	*/
	err = get_param(&pa_rec, BROWSE, 1, e_mesg) ;
	if(err == ERROR) {
		DispError(e_mesg);
		return(ERROR) ;
	}
	else if(err == UNDEF) {
#ifdef ENGLISH
		DispError("Parameters Are Not Set Up ...");
#else
		DispError("Parametres ne sont pas etablis... ");
#endif
		return(ERROR) ;
	}

	/*
	*	Initialize Variables
	*/

	FirstPage = NULL ;
	LastPage  = NULL ;

	return(NOERROR) ;
}	/* Initialize() */

/*--------------------------------------------------------------------------*/
/* Close nessary files and environment before exiting program               */

CloseRtn() 
{
	/* Free the linked list from the end */

	/* Free all the pages except the first page */
	for( ; LastPage != FirstPage ; ) {
		LastPage = LastPage->PrevPage ;
		free((char*)LastPage->NextPage) ;
		LastPage->NextPage = NULL ;
	}
	if(FirstPage != NULL)
		free((char*)FirstPage) ;
		
	FirstPage = LastPage = NULL ;

	/* Set terminal back to normal mode from PROFOM */
	fomcs();
	fomrt();

	close_dbh();	/* Close files */

	return(NOERROR);
}	/* CloseRtn() */
/*----------------------------------------------------------------*/
/* Initialize screen before going to process options */

InitScreen()
{
	int	err ;

	/* move screen name to Profom status structure */
	STRCPY(sr.scrnam,NFM_PATH);
	strcat(sr.scrnam,SCR_NAME) ;

	STRCPY(s_sth.s_pgm,PROG_NAME);
#ifdef ENGLISH
	STRCPY(s_sth.s_scrname, "     DISAPPROVED ITEM INQUIRY     ");
#else
	STRCPY(s_sth.s_scrname, "INTERROGATION D'ARTICLE NON-APPROUVE" );
#endif
	s_sth.s_rundate = get_date();	/* get Today's Date in YYYYMMDD format*/
	s_sth.s_mesg[0] = HV_CHAR ;
	s_sth.s_resp[0] = HV_CHAR ;

	/* Initialize Key Fields. So that, if user selectes 'N' option
	   immediately after invoking program, then he gets the first
	   record in the file */

	s_sth.s_req_no = 0 ;

	/* Move High Values to data fields and Display the screen */
	err = ClearScreen() ;
	if(NOERROR != err) return(err) ;

	return(NOERROR) ;
}	/* InitScreen() */

/*-------------------------------------------------------------------*/
/* Get Option from user and call corresponding function */

ReqProcess()
{
	int err;

	for( ; ; ){

		/* Get the Fn: option from the user */
		if((err = ReadFunction()) != NOERROR) return(err) ;

		err = ProcFunction() ;	/* Process Function */

		if(QUIT == err)		return(NOERROR) ;    /* Exit */
		if(NOACCESS == err)	fomen(e_mesg);	     /* security */
		if(PROFOM_ERR == err)	return(PROFOM_ERR);  /* PROFOM ERROR */
		if(DBH_ERR == err) {
			DispError(e_mesg);
#ifdef ENGLISH
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"System Error... Iserror:",
				iserror, dberror, errno);
#else
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"Erreur du systeme... Iserror:",
				iserror, dberror, errno);
#endif
			DispError(e_mesg);
			return(DBH_ERR); /* DBH ERROR */
		}
	}      /*   end of the for( ; ; )       */
}	/* ReqProcess() */
/*----------------------------------------------------------------*/
/* Display the Function (Fn:) options and get the option from the user */

ReadFunction()
{
	/* Display Fn: options */
#ifdef ENGLISH
	fomer("I(nquire), N(ext), P(rev), E(xit)");
#else
	fomer("I(nterroger), S(uivant), P(recedent), F(in)");
#endif
	/* Read Fn: field to get the option */
	sr.nextfld = FN_FLD ;
	fomrf( (char *)&s_sth );
	ret(err_chk(&sr));	/* Check for PROFOM error */

	return(NOERROR) ;
}	/* ReadFunction() */
/*----------------------------------------------------------------*/
/* Process the user selected Fn: option */

ProcFunction()
{
	int retval;

	switch (s_sth.s_fn[0]) {
	case INQUIRE  :			/* Inquire Req */
		CHKACC(retval,BROWSE,e_mesg);
		return( InquireReq() ) ;
	case NEXT  :			/* Next Req */
		CHKACC(retval,BROWSE,e_mesg);
		return( NextReq(FORWARD) ) ;
	case PREV  :			/* Previous Req */
		CHKACC(retval,BROWSE,e_mesg);
		return( NextReq(BACKWARD) ) ;
	case EXITOPT  :			/* Exit */
		return( QUIT ) ;
	}  /*   end of the switch statement */

	return(retval);
}	/* ProcFunction() */
/*----------------------------------------------------------------------*/
/* Show the user given keys Req */

InquireReq()
{
	int	err ;

	err = SelectReq(BROWSE) ;
	if(NOERROR != err) return(err) ;

	err = ConfirmItems() ;
	if(err < 0) return(err) ;

	return(NOERROR) ;
}	/* InquireReq() */
/*----------------------------------------------------------*/
/* Show the next or previous Req */

NextReq(direction)
int	direction ;
{
	int err;

	/* Check whether file is in seq. read mode */
	if(flg_start(REQHDR) != direction) {
		req_hdr.code = s_sth.s_req_no ;
		if (direction == FORWARD)
			req_hdr.code++;
		else	req_hdr.code--;
		flg_reset(REQHDR);
	}

	for( ; ; ) {
		err = get_n_reqhdr(&req_hdr, BROWSE, 0, direction, e_mesg);
#ifndef ORACLE
		seq_over(REQHDR);
#endif
		if(ERROR == err)return(DBH_ERR) ;
		if(EFL == err) {
#ifdef	ENGLISH
			fomen("No More Records....");
#else
			fomen("Plus de fiches....");
#endif
			get();
			flg_reset(REQHDR);
			return(NOERROR) ;
		}
		/* only show requisitions for current cost center unless
		   district office */
		if(req_hdr.costcenter != CC_no &&
			CC_no != pa_rec.pa_distccno) {
			continue;
		}

		return( ShowReq() ) ;
	}
}	/* NextReq() */
/*----------------------------------------------------------------------*/
SelectReq(md)
int	md ;	/* UPDATE or BROWSE. UPDATE locks the Req */
{
	int	err ;

	for(; ;){
		err = ReadKey();
		if(err != NOERROR) return(err) ;

		/* Get the record from database */
		err = GetReqHdr(md);
		if(ERROR == err) return(DBH_ERR) ;
		if(err < 0) {		/* UNDEF or LOCKED */
			fomer(e_mesg) ;
			get() ;
			continue ;
		}

		if(req_hdr.costcenter != CC_no &&
			CC_no != pa_rec.pa_distccno) {
#ifdef ENGLISH
			fomer("Requistion does not belong to this cost center");
#else
			fomer("Requisition n'appartient pas a ce centre de couts");
#endif
			continue;
		}
		return( ShowReq() ) ;
	}
}	/* SelectReq() */
/*----------------------------------------------------------------------*/
/* Get the Req key from user. In ADD mode disable dup buffers, other
   modes enable dup buffers and show the current key as a default key */

ReadKey()
{
	int	i;
	long	req_no;

	SetDupBuffers(KEY_START,KEY_END,2);

	/* Store fields to copy back when user gives ESC-F */
	req_no = s_sth.s_req_no ;

	s_sth.s_req_no = LV_LONG ;

#ifdef ENGLISH
	STRCPY(s_sth.s_mesg,"Press ESC-F to Go Back to Fn:");
#else
	STRCPY(s_sth.s_mesg,"Appuyer sur ESC-F pour retourner a Fn:");
#endif
	ShowMesg();

	i = ReadFields(KEY_START, KEY_END);
	if(PROFOM_ERR == i || DBH_ERR == i) return(i) ;
	if(RET_USER_ESC == i){
		/* copy back key fields */
		s_sth.s_req_no = req_no ;

		ret( WriteFields(KEY_START, KEY_END) ) ;

		s_sth.s_mesg[0] = HV_CHAR;
		ShowMesg();

		return(RET_USER_ESC) ;
	}

	return(NOERROR);
}	/*  ReadKey() */
/*-----------------------------------------------------------------------*/
/* Take the confirmation from user for the header part */

ConfirmItems()
{
	int	err ;

	/* Options:
	   Inquiry  - YNP
	*/

	for( ; ; ) {
	    switch(s_sth.s_fn[0]) {
	    case  INQUIRE :		/* Inquire Req */
#ifdef ENGLISH
		err = GetOption("Y(es), N(ext Page), P(rev Page)","YNP");
#else
		err = GetOption("O(ui), S(uivant), P(recedent)","OSP");
#endif
		break ;
	    }
	    if(err == PROFOM_ERR) return(err) ;

	    switch(err) {
	    case  YES  :
		return(YES);
	    case  NEXTPAGE :
		if(CurPage == ReqLast || ReqLast == NULL) {
#ifdef ENGLISH
			fomer("No More Pages....") ;
#else
			fomer("Plus de pages....") ;
#endif
			continue ;
		}
		CurPage = CurPage->NextPage ;
		err = ShowItems(CurPage) ;
		break ;
	    case  PREVPAGE :
		if(ReqLast == NULL || CurPage == FirstPage ) {
#ifdef ENGLISH
			fomer("No More Pages....") ;
#else
			fomer("Plus de pages....") ;
#endif
			continue ;
		}
		CurPage = CurPage->PrevPage ;
		err = ShowItems(CurPage) ;
		break ;
	    }	/* switch err */

	    if(err == PROFOM_ERR) return(err) ;
	    if(err == DBH_ERR) return(err) ;
	}	/* for(; ; ) */
}	/* ConfirmItems() */
/*-----------------------------------------------------------------------*/ 
/* Copy the key fields from screen to req header record and get the
   record from data base */

GetReqHdr(md)
int	md; /* BROWSE or UPDATE */
{
	req_hdr.code = s_sth.s_req_no ;

	return(get_reqhdr(&req_hdr, md, 0, e_mesg));
}
/*------------------------------------------------------------*/
/*
*	Get the next node in linked list to add req items. If the
*	(Cur. Req last page) = (Last Page in linked List) or no
*	nodes in list, allocate node and add to linked list
*/

MakeFreshPage()
{
	Page	*tempptr ;

	/* If, no node is allocated yet or Current req used all the nodes,
	   then allocate new node */

	if( LastPage == NULL || ReqLast == LastPage ){
		tempptr= (Page *)malloc((unsigned)sizeof(Page)) ;

		if( tempptr == NULL ){
#ifdef ENGLISH
			DispError("MEMORY ALLOCATION ERROR...");
#else
			DispError("ERREUR D'ALLOCATION A LA MEMOIRE...");
#endif
			return(ERROR);
		}
		tempptr->NextPage = NULL ;

		if( LastPage == NULL ){	/* No node is allocated Yet */
			tempptr->PrevPage = NULL ;
			tempptr->Pageno = 1 ;
			FirstPage = tempptr ;
		}
		else {				/* Not a first node in list */
			tempptr->Pageno = LastPage->Pageno + 1 ;
			LastPage->NextPage = tempptr ;
			tempptr->PrevPage = LastPage ;
		}
		LastPage = tempptr ;
	}

	if(ReqLast == NULL)
		ReqLast = FirstPage ;
	else
		ReqLast = ReqLast->NextPage ;

	ReqLast->NoItems = 0 ;
	CurPage = ReqLast ;

	return(NOERROR);
}	/* MakeFreshPage() */
/*------------------------------------------------------------*/
/* Read the PROFOM Screen for a given Range of fields */

ReadFields(st_fld, end_fld, Validate, WindowHelp, mode)
int	st_fld ;
int	end_fld;
int	(*Validate)() ;
int	(*WindowHelp)() ;
int	mode ;	/* ADD or UPDATE. This is required only when reading item */
{
	int	err ;

	sr.nextfld = st_fld ;
	sr.endfld  = end_fld;
	for( ; ;){
		fomrd( (char *)&s_sth );
		ret(err_chk(&sr));

		if(sr.retcode == RET_VAL_CHK){
			err = (*Validate)(mode) ;
			if(DBH_ERR == err || PROFOM_ERR == err) return(err);
			sr.nextfld = sr.curfld ;
			continue;
		}
		if(sr.retcode == RET_USER_ESC){
			if(sr.escchar[0] == 'f' || sr.escchar[0] == 'F')
				return(RET_USER_ESC) ;
			if(sr.escchar[0] == 'h' || sr.escchar[0] == 'H'){
				err = (*WindowHelp)() ;
				if(DBH_ERR == err || PROFOM_ERR == err)
					return(err) ;
				sr.nextfld = sr.curfld ;
				continue;
			}
			continue;
		}
		/* else RET_NO_ERROR */
		break;
	}

	return(NOERROR) ;
}	/* ReadFields() */
/*------------------------------------------------------------*/
/* Write fields on Screen for a given Range */

WriteFields(st_fld, end_fld)
int	st_fld ;
int	end_fld ;
{
	sr.nextfld = st_fld ;
	sr.endfld  = end_fld ;

	fomwr( (char *)&s_sth );
	ret(err_chk(&sr));

	return(NOERROR) ;
}	/* WriteFields() */
/*----------------------------------------------------------------*/
/* Set Duplication buffers for fields 				  */
SetDupBuffers( firstfld, lastfld, value )
int	firstfld, lastfld;	/* field numbers range */
int	value;			/* ENABLE or DISABLE */
{
	int i ;

	for( i=firstfld; i<=lastfld; i+=100 )
		fomca1( i, 19, value);
	if( value==0 )
		return(0);
	sr.nextfld = firstfld;
	sr.endfld = lastfld;
	fomud( (char *)&s_sth );
	ret( err_chk(&sr) );

	return( 0 );
}
/*----------------------------------------------------------------*/
/* Copy the items form given node to screen and display */

ShowItems(pageptr)
Page	*pageptr ;
{
	int	i ;

	if(pageptr != NULL) {
		/* Copy the items to screen */
		scpy((char*)s_sth.s_items, (char*)pageptr->Items,
			(pageptr->NoItems * sizeof(S_item)) );

		s_sth.s_page_no   = pageptr->Pageno ;

		if(pageptr->NoItems==2) {
			s_sth.s_items[0].s_subhdg[0] = ' ';
			s_sth.s_items[1].s_subhdg[0] = ' ';
		}
		if(pageptr->NoItems==1) 
			s_sth.s_items[0].s_subhdg[0] = ' ';
		
		i = pageptr->NoItems ;
	}
	else {
		s_sth.s_page_no   = HV_SHORT ;
		i = 0 ;
	}

	/* Move High Values to remaining Items */
	for( ; i < PAGESIZE ; i++ )
		InitItem(i,HV_CHAR,HV_SHORT,HV_LONG,HV_DOUBLE) ;

	ret( WriteFields( PAGENO_FLD, (END_FLD - 200)) );

	return(NOERROR) ;
}	/* ShowItems() */
/*----------------------------------------------------------------*/
/* Display message and get the option */

GetOption(msg,options)
char	*msg ;
char	*options ;
{
	int	i, j ;

	STRCPY(s_sth.s_mesg,msg);
	ShowMesg() ;

	sr.nextfld = END_FLD ;
	for( ; ; ) {
		fomrf( (char *)&s_sth ) ;
		ret(err_chk(&sr)) ;

		j = strlen(options) ;
		for( i = 0 ; i < j ; i++)
			if(s_sth.s_resp[0] == options[i]) break ;
		if(i != j) break ;	/* Valid Option Selected */
#ifdef ENGLISH
		fomer("Invalid Option..");
#else
		fomer("Option invalide..");
#endif
	}

	s_sth.s_mesg[0] = HV_CHAR ;
	s_sth.s_resp[0] = HV_CHAR ;
	
	ret( WriteFields(END_FLD -100, END_FLD) );

	return((int)(options[i])) ;
}	/* GetOption() */
/*-----------------------------------------------------------------------*/
/* Move req header details to Screen Header part and read req items
   into linked list and show the Req first page on screen */

ShowReq()
{
	int	err ;
	
	/* Make Items Linked List from req */
	if((err = MakeReqItemsList()) < 0) return(err) ;

	if(CurPage == NULL) {
		err = ClearScreen();
		if(NOERROR != err) return(err) ;

		s_sth.s_req_no = req_hdr.code;
		ret(WriteFields(KEY_START,KEY_END));

#ifdef ENGLISH
		STRCPY(s_sth.s_text,"No disapproved items on this requisition");
#else
		STRCPY(s_sth.s_text,"Aucum article non-approuve sur cette req");
#endif
	}
	else {
		s_sth.s_req_no = req_hdr.code;
		ret(WriteFields(KEY_START,KEY_END));
		s_sth.s_text[0] = HV_CHAR;
	}
	s_sth.s_costcenter = req_hdr.costcenter;

	ret(WriteFields(CCNO_FLD,TEXT_FLD));
	if((err = ShowItems(CurPage)) < 0) return(err) ;	/* Show Items */

	return(NOERROR) ;
}	/* ShowReq() */
/*-----------------------------------------------------------*/
/* Read Req Items and make Linked list */

MakeReqItemsList()	/* Make the linked list from Req Items */
{
	int	err, i ;

	req_item.code = req_hdr.code ;
	req_item.item_no = 0;
	flg_reset(REQITEM);	/* Initialize to get first rec under givenkey */

	ReqLast = CurPage = NULL ;
	i = 0 ;

	for( ; ; ){
#ifndef ORACLE
		err = get_n_reqitem( &req_item, BROWSE, 0, FORWARD, e_mesg);
#else
		err = get_n_reqitem( &req_item, BROWSE, 0, EQUAL, e_mesg);
#endif
		if(ERROR == err) return(DBH_ERR) ;
		if(EFL == err) break ;

#ifndef ORACLE
		/* If Req changes break */
		if( req_item.code != req_hdr.code) break ;
#endif

		if(req_hdr.status[0] != DISAPPROVED) {
			if(req_item.appstat[0] != DISAPPROVED) {
				continue;
			}
		}

		if(PAGESIZE == i) i = 0 ;
		if(0 == i)		/* 1st Item in the Page */
			if((err = MakeFreshPage()) < 0) return(err) ;

		CurPage->Items[i].s_sno = i + 1 ;
		STRCPY(CurPage->Items[i].s_accno, req_item.acct) ;
		STRCPY(CurPage->Items[i].s_stck_cd, req_item.st_code);
		STRCPY(CurPage->Items[i].s_itm_stat, req_item.appstat);
		CurPage->Items[i].s_school = req_item.school ;
		STRCPY(CurPage->Items[i].s_desc, req_item.desc);

		STRCPY(CurPage->Items[i].s_gst, req_item.tax1);
		STRCPY(CurPage->Items[i].s_pst, req_item.tax2);
						
		calctax(CurPage->Items[i].s_gst,CurPage->Items[i].s_pst,
			req_item.value,&tax_cal);

		CurPage->Items[i].s_ord_qty = req_item.orig_qty ;
		if (req_item.unit[0] == LV_CHAR) 
			STRCPY(CurPage->Items[i].s_uom, "    ");
		else
			STRCPY(CurPage->Items[i].s_uom, req_item.unit);
		CurPage->Items[i].s_unit_cost = req_item.unitprice ;
		CurPage->Items[i].s_net_amt = req_item.value;
		CurPage->Items[i].s_value = tax_cal.gros_amt; 

		CurPage->ReqItemNo[i] = req_item.item_no ;

		if(req_hdr.status[0] == DISAPPROVED) { 
			if(req_item.item_no == 1) { 
				req_reason.reqr_code = req_item.code;
				req_reason.reqr_item_no = 0;
				err=get_reqreason(&req_reason,BROWSE,0,e_mesg);
				if(err < 0) return(DBH_ERR) ;
			}
		}
		else {
			req_reason.reqr_code = req_item.code;
			req_reason.reqr_item_no = req_item.item_no;
			err = get_reqreason(&req_reason,BROWSE,0,e_mesg);
			if(err < 0) return(DBH_ERR) ;
		}

		STRCPY(CurPage->Items[i].s_reason,req_reason.reqr_reason);

		CurPage->NoItems++ ;
		i++ ;
	} 
	seq_over(REQITEM) ;

	if(ReqLast != NULL)
		CurPage = FirstPage ;

	return(NOERROR) ;
}	/* MakeReqItemsList() */
/*------------------------------------------------------------------------*/
/* Move High values to all data fields and clear the screen */

ClearScreen()
{
	int	i;

	s_sth.s_page_no = HV_SHORT ;

	s_sth.s_costcenter = HV_SHORT;
	s_sth.s_text[0] = HV_CHAR;

	/* Move High Values to All items */
	for(i = 0 ; i < PAGESIZE ; i++)
		InitItem(i,HV_CHAR,HV_SHORT,HV_LONG,HV_DOUBLE) ;

	ret( WriteFields(ITEM_ST_FLD, (END_FLD - 200)) );

	return(NOERROR);
}	/* ClearScreen() */
/*-------------------------------------------------------------------------*/
/* Initialize Given screen item with either Low values or High values */

InitItem(item_no, t_char, t_short, t_long, t_double)
int	item_no ;
char	t_char ;
short	t_short ;
long	t_long ;
double	t_double ;
{

	if(t_short == HV_SHORT) 
		s_sth.s_items[item_no].s_sno = t_short ;

	s_sth.s_items[item_no].s_accno[0] = t_char ;
	s_sth.s_items[item_no].s_stck_cd[0] = t_char ;
	s_sth.s_items[item_no].s_itm_stat[0] = t_char ;
	s_sth.s_items[item_no].s_school = t_short ;
	s_sth.s_items[item_no].s_desc[0] = t_char ;

	if(t_short == LV_SHORT) 
		s_sth.s_items[item_no].s_subhdg[0] = ' ';
	else
		s_sth.s_items[item_no].s_subhdg[0] = t_char;

	s_sth.s_items[item_no].s_gst[0] = t_char;
	s_sth.s_items[item_no].s_pst[0] = t_char;
	s_sth.s_items[item_no].s_ord_qty = t_double ;
	s_sth.s_items[item_no].s_uom[0] = t_char ;
	s_sth.s_items[item_no].s_unit_cost = t_double ;
	s_sth.s_items[item_no].s_net_amt = t_double ;
	s_sth.s_items[item_no].s_value = t_double ;
	s_sth.s_items[item_no].s_reason[0] = t_char;	

	return(NOERROR) ;
}	/* Inititem() */
/*-------------------------------------------------------------------------*/

DispError(s)    /* show ERROR and wait */
char	*s;
{
	strncpy(s_sth.s_mesg,s, (sizeof(s_sth.s_mesg) - 1));
	ShowMesg();
#ifdef ENGLISH
	fomen("Press any key to continue");
#else
	fomen("Appuyer sur une touche pour continuer");
#endif
	get();
	s_sth.s_mesg[0] = HV_CHAR;
	ShowMesg();
	return(NOERROR);
}
/*-------------------------------------------------------------------------*/

ShowMesg()  /* shows or clears message field */
{
	sr.nextfld = END_FLD - 100;
	fomwf( (char *)&s_sth ) ;
	return(0);
}
/*-------------------- E n d   O f   P r o g r a m ---------------------*/
