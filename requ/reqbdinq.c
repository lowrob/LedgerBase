/*-----------------------------------------------------------------------
Source Name: reqbdinq.c
System     : Budgetary Financial system.
Module     : Requisition system.
Created  On: 21st March 91.
Created  By: Steven Osborne.

DESCRIPTION:
	Program to allow inquiry of budgets. 

Usage of SWITCHES when they are ON :
	SW1 : 
	SW2 : 
	SW3 :
	SW4 :
	SW5 :
	SW6 :
	SW7 :
	SW8 :
	SW9 :
		Not Used.


MODIFICATIONS:        

Programmer     YY/MM/DD       Description of modification
~~~~~~~~~~     ~~~~~~~~       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
------------------------------------------------------------------------*/

#define	MAIN	/* Main program. This is to declare Switches */
#define MAINFL	REQHDR

#define	SYSTEM		"REQUISITIONS"		/* Sub System Name */
#define	MOD_DATE	"21-MAR-91"		/* Program Last Modified */

#include <stdio.h>
#include <ctype.h>
#include <cfomstrc.h>
#include <bfs_defs.h>
#include <bfs_recs.h>
#include <requ.h>

#ifdef ENGLISH
#define INQUIRE	'I'
#define EXIT	'E'

#define YES	'Y'
#define NO	'N'
#else	/* French */
#define INQUIRE	'I'
#define EXIT	'F'

#define YES	'O'
#define NO	'N'
#endif

#define	FIRST_SCR	'1'
#define	SECOND_SCR	'2'

#define	SCR_NAME1	"budinq_1"	/* First screen */
#define	SCR_NAME2	"budinq_2"	/* Second screen */

/* PROFOM Field Numbers */

#define	FN_FLD		500	/* Fn: */
#define	KEY_START	600	/* Key Start Field */
#define	KEY_END		800	/* Key End Field */
#define	FUND_FLD	600	/* Fund Code */
#define	ACNT_FLD	700	/* Account# */
#define	RECCD_FLD	800	/* Record Code */

/*	Screen 1	*/

#define	SECTN_FLD	1000	/* Section */
#define	LAST_FLD_S1	2200	/* Last field of the first screen.	*/

/* budinq_1.sth - header for C structure generated by PROFOM EDITOR */

typedef	struct	{

	char	s_pgm[11];	/* STRING XXXXXXXXXX field 100 */
	long	s_rundt;	/* DATE YYYYFMMFDD field 300 */
	char	s_fn[2];	/* STRING X field 500 */
	short	s_fund_cd;	/* NUMERIC 999 field 600 */
	char	s_acct_no[19];	/* STRING XXXXXXXXXXXXXXXXXX field 700 */
	short	s_rec_cd;	/* NUMERIC 99 field 800 */
	short	s_section;	/* NUMERIC 9 field 1000 */
	char	s_desc[49];	/* STRING XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX field 1100 */
	short	s_bud_cd;	/* NUMERIC 9 field 1200 */
	double	s_comm_req;	/* NUMERIC S99F999F999.99 field 1300 */
	double	s_comm_po;	/* NUMERIC S99F999F999.99 field 1400 */
	double	s_ytd;	/* NUMERIC S99F999F999.99 field 1500 */
	double	s_opbal;	/* NUMERIC S99F999F999.99 field 1600 */
	double	s_cur_bud;	/* NUMERIC S99F999F999.99 field 1700 */
	double	s_pre_bud;	/* NUMERIC S99F999F999.99 field 1800 */
	double	s_pre_act;	/* NUMERIC S99F999F999.99 field 1900 */
	double	s_bud_bal;	/* NUMERIC S99F999F999.99 field 2000 */
	char	s_mesg[78];	/* STRING XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX field 2100 */
	char	s_resp[2];	/* STRING X field 2200 */
} S1_record;

/*	Screen 2	*/

#define	PERIOD_FLD	1700	/* Section */
#define	LAST_FLD_S2	7000	/* Last field of the second screen.	*/

/* budinq_2.sth - header for C structure generated by PROFOM EDITOR */

typedef struct	{
	char	s_pgm[11];	/* STRING XXXXXXXXXX field 100 */
	long	s_rundt;	/* DATE YYYYFMMFDD field 300 */
	char	s_fn[2];	/* STRING X field 500 */
	short	s_fund_cd;	/* NUMERIC 999 field 600 */
	char	s_acct_no[19];	/* STRING XXXXXXXXXXXXXXXXXX field 700 */
	short	s_rec_cd;	/* NUMERIC 99 field 800 */
	double	s_periods[13][4];	/* NUMERIC S99F999F999.99 field 1700 to field 6800 */
	char	s_mesg[78];	/* STRING XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX field 6900 */
	char	s_resp[2];	/* STRING X field 7000 */
} S2_record;

static	S1_record  s_one_sth;	/* Screen-1 Structure */
static	S2_record  s_two_sth;	/* Screen-2 Structure */

static	struct  stat_rec sr;		/* PROFOM status rec */

static	Gl_rec	gl_rec;		/* G/L Master Record */
static	Pa_rec	pa_rec ;	/* Parameters Record */
static	char 	e_mesg[80];  	/* dbh will return err msg in this */

/* Screen Control Variables */
static	int	ST_FLD;		/* Data entry starting field */
static	int	END_FLD;	/* screen end field */
static	char	*Mesg;		/* Message fld */
static	char	*Resp;		/* Response fld to user response */
static	char	*CurrentScreen;	/* Ptr to active screen */
static	short	ActiveScr ;	/* Current screen in working */


main(argc,argv)
int argc;
char *argv[];
{
	int	err;

	if(argc < 2){
#ifdef  DEVELOP
		printf("MAIN ARGUMENTS ARE NOT PROPER\n");
		printf("Usage : %s {-tterminal name}\n", argv[0]);
#endif
		exit(1);
	}

	strncpy(SYS_NAME,SYSTEM,50);	/* Sub system name */
	strncpy(CHNG_DATE,MOD_DATE,10);	/* Modification Date */

	proc_switch(argc, argv, MAINFL) ; 	/* Process Switches */

	STRCPY(sr.termnm,terminal);	/* Copy Terminal Name */

	InitProfom() ;			/* Initialize PROFOM */

	err = settax(e_mesg);	/* Set up the global tax variables.	*/
	if (err != NOERROR)
	{
		fomer(e_mesg);
		get();
		exit(1);
	}

	err = get_param(&pa_rec, BROWSE, 1, e_mesg) ;
	if(err == ERROR) {
		fomen(e_mesg);
		get() ;
	}
	else if(err == UNDEF) {
#ifdef ENGLISH
		fomen("Parameters Are Not Setup..");
#else
		fomen("Parametres ne sont pas etablis..");
#endif
		get() ;
	}
	else
		err = Process(); 		/* Initiate Process */

	/* Set terminal back to normal mode from PROFOM */
	fomcs();
	fomrt();

	free_audit() ;	/* Free the space allocated in rite_audit() */
	close_dbh();	/* Close files */

	if(err != NOERROR)exit(1);
	exit(0);
} /* END OF MAIN */

/*-------------------------------------------------------------------*/
/* Initialize PROFOM */

InitProfom()
{
	fomin(&sr);
	/* Check for Error */
	if(err_chk(&sr) == PROFOM_ERR){
		fomcs();
		fomrt();
		return(ERROR);
	}
	fomcf(1,1);	/* Enable Snap screen option */
}	/* InitProfom() */

/*-------------------------------------------------------------------*/
/* Get Option from user and call corresponding function */

Process()
{
	int err;

	InitScreens() ;

	for( ; ; ){
		/* Display Fn: options */
#ifdef	ENGLISH
		fomer("I(nquire), E(xit)");
#else
		fomer("I(nterroger), F(in)");
#endif

		/* Read Fn: field to get the option */
		sr.nextfld = FN_FLD ;
		fomrf((char*)&s_one_sth);
		ret(err_chk(&sr));	/* Check for PROFOM error */

		switch(s_one_sth.s_fn[0]){
		case INQUIRE  : 	/* Inquiry */
			CHKACC(err,BROWSE,e_mesg);
			err = InquiryRec();
			break ;
		case EXIT  :
			return(NOERROR);
		default   : 
			continue; 
		}  /*   end of the switch statement */

		if(err == NOACCESS) {
			fomer(e_mesg);
			get();
		}
		if(err == PROFOM_ERR) return(PROFOM_ERR); /* PROFOM ERROR */
		if(err == DBH_ERR) {
			DispError(e_mesg);
#ifdef	ENGLISH
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"System Error... Iserror:",
				iserror, dberror, errno);
#else
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"Erreur du systeme... Iserror:",
				iserror, dberror, errno);
#endif
			DispError(e_mesg);
			return(DBH_ERR); /* DBH ERROR */
		}
	}      /*   end of the for( ; ; )       */
}	/* Process() */

/*----------------------------------------------------------------*/
/* Initialize screens before going to process options */
InitScreens()
{
	/* set 1st screen as a active screen */
	Set1stScreen(0);

	/* Screen 1 */

	STRCPY(s_one_sth.s_pgm,PROG_NAME);
	s_one_sth.s_rundt = get_date();	/* get Today's Date in YYMMDD format */
	s_one_sth.s_mesg[0] = HV_CHAR ;
	s_one_sth.s_resp[0] = HV_CHAR ;

	/* Initialize key fields. This gets 1st record from the file
	   if user selects 'N' option immediatly after invoking */
	s_one_sth.s_fund_cd = 1 ;
	s_one_sth.s_acct_no[0] = '\0' ;
	s_one_sth.s_rec_cd = 99;

	/* Move High Values to 1st screen data fields & Display */
	MoveHighs() ;

	/* Screen 2 */
	STRCPY(s_two_sth.s_pgm,PROG_NAME);
	s_two_sth.s_rundt = s_one_sth.s_rundt ;
	s_two_sth.s_mesg[0] = HV_CHAR ;
	s_two_sth.s_resp[0] = HV_CHAR ;

	return(NOERROR) ;
}	/* InitScreens() */

/*---------------------------------------------------------------------*/
/* Set 1st screen as active screen */
Set1stScreen(flg)
int	flg ;	/* If Yes display the screen */
{
	/* move 1st screen name to Profom status structure */
	STRCPY(sr.scrnam,NFM_PATH);
	strcat(sr.scrnam,SCR_NAME1) ;

	/* Initialize Ptrs to 1st screen */
	Mesg = s_one_sth.s_mesg;
	Resp = s_one_sth.s_resp;
	CurrentScreen = (char*)&s_one_sth ;
	ActiveScr = 1 ;
	ST_FLD = SECTN_FLD ;
	END_FLD = LAST_FLD_S1 ;

	if(flg) {
		sr.nextfld = 1;
		sr.endfld = 0;
		fomwr(CurrentScreen);
		ret(err_chk(&sr));
	}
	return(NOERROR) ;
}	/* Set1stScreen() */

/*---------------------------------------------------------------------*/
/* Set 2nd screen as active screen */
Set2ndScreen()
{
	/* move 2nd screen name to Profom status structure */
	STRCPY(sr.scrnam,NFM_PATH);
	strcat(sr.scrnam,SCR_NAME2) ;

	/* Copy Key fields from 1st screen */
	STRCPY(s_two_sth.s_fn,s_one_sth.s_fn);
	s_two_sth.s_fund_cd = s_one_sth.s_fund_cd ;
	STRCPY(s_two_sth.s_acct_no,s_one_sth.s_acct_no) ;
	s_two_sth.s_rec_cd = s_one_sth.s_rec_cd ;

	/* Initialize Ptrs to 2nd screen */
	Mesg = s_two_sth.s_mesg;
	Resp = s_two_sth.s_resp;
	CurrentScreen = (char*)&s_two_sth ;
	ActiveScr = 2 ;
	ST_FLD = PERIOD_FLD ;
	END_FLD = LAST_FLD_S2 ;

	sr.nextfld = 1;
	sr.endfld = 0;
	fomwr(CurrentScreen);
	ret(err_chk(&sr));

	return(NOERROR) ;
}	/* Set2ndScreen() */

/*-----------------------------------------------------------------------*/
/* Select the Key, get the record & display */
InquiryRec()
{
	int	err ;

	err = SelectRecord(BROWSE) ;
	if(err != NOERROR) return(err) ;

	err = ReadOption() ;
	if(err < 0) return(err) ;

	return(NOERROR) ;
}

/*----------------------------------------------------------*/
/* Read the key fields, get the record with LOCK and display
   the Record */
SelectRecord(md)
int	md ;	/* BROWSE for Inquiry, UPDATE for Others */
{
	int	err ;

	for(; ;){
		err = ReadKey();
		if(err != NOERROR) return(err) ;

		/* Get the record from database */

		err = BringRecord(md);
		if(err < 0){
			fomen(e_mesg);
			get() ;
			if(err == UNDEF || err == LOCKED) continue ;
			return(DBH_ERR);
		}

		/* Verify that account belongs to the cost center.	*/
		if (CC_no != 99 && gl_rec.keys[pa_rec.pa_cc_key-1] != CC_no)
		{
#ifdef	ENGLISH
			fomer("The account does not belong to the cost center");
#else
			fomer("Le compte n'ap partient pas a ce centre de couts");
#endif
			get();
			continue;
		}

		CopyToScreen() ;
		return(NOERROR) ;
	}
}	/* SelectRecord() */

/*----------------------------------------------------------------------*/
/* Read Key Fields */
ReadKey()
{
	int	i ;
	int 	key_fund ;
	char 	key_acnt[sizeof(s_one_sth.s_acct_no)];
	int 	key_rec_cd ;
	int	err;

#ifdef	ENGLISH
	strcpy(Mesg,"Press ESC-F to Go Back to Fn:");
#else
	strcpy(Mesg,"Appuyer sur ESC-F pour retourner a Fn:");
#endif
	ShowMesg();

	fomca1(FUND_FLD,6,0);
	fomca1(RECCD_FLD,6,0);

	for(i = KEY_START ; i <= KEY_END ; i += 100)
		fomca1(i,19,2) ;

	sr.nextfld = KEY_START;
	sr.endfld = KEY_END;
	fomud((char*)&s_one_sth);

	/* Store key fields to copy back when user gives ESC-F */
	key_fund = s_one_sth.s_fund_cd ;
	STRCPY(key_acnt,s_one_sth.s_acct_no) ;
	key_rec_cd = s_one_sth.s_rec_cd;

	fund_default();
	sr.nextfld = KEY_START;
	sr.endfld = KEY_END;
	s_one_sth.s_fund_cd = LV_SHORT ;
	s_one_sth.s_acct_no[0] = LV_CHAR ;
	s_one_sth.s_rec_cd = LV_SHORT ; 
	for(; ;) {
		fomrd((char*)&s_one_sth);
		ret(err_chk(&sr));

		if(sr.retcode == RET_VAL_CHK){
			err = Validate(sr.curfld) ;
			if(err == DBH_ERR) return(err) ;
			sr.nextfld = sr.curfld;
			continue;
		}
		if(sr.retcode == RET_USER_ESC){
			if(sr.escchar[0] == 'F' || sr.escchar[0] == 'f') {
				/* copy back key fields */
				s_one_sth.s_fund_cd = key_fund ;
				STRCPY(s_one_sth.s_acct_no,key_acnt) ;
				s_one_sth.s_rec_cd = key_rec_cd ; 

				sr.nextfld = KEY_START;
				sr.endfld = KEY_END;
				fomwr((char*)&s_one_sth);

				Mesg[0] = HV_CHAR;
				ShowMesg();
				return(ERROR) ;
			}
			if(sr.escchar[0] == 'h' || sr.escchar[0] == 'H'){
				err = WindowHelp() ;
				if(err == DBH_ERR) return(err) ;
				continue;
			}
			continue;
		}
		/* else RET_NO_ERROR */
		break;
	}			/* end of for loop */

	Mesg[0] = HV_CHAR;
	ShowMesg();

	return(NOERROR);
}	/*  ReadKey() */

/*----------------------------------------------------------------*/
Validate(fld_no)	/* validate flds when PROFOM returns RET_VAL_CHK */
int	fld_no ;
{
	int	err ;
	Ctl_rec	ctl_rec ;	/* Control Record */

	switch(fld_no){
	case	FUND_FLD  :	/* Fund Code */
		ctl_rec.fund = s_one_sth.s_fund_cd ;
		err = get_ctl(&ctl_rec, BROWSE, 0, e_mesg) ;
		if(err == DBH_ERR) return(err);
		if(err < 0) {
			fomer(e_mesg) ;
			s_one_sth.s_fund_cd = LV_SHORT ;
			return(ERROR) ;
		}
		break ;
	case	ACNT_FLD :	/* Account# */
		/*
		* Check whether account# is having any invalid characters.
		*/

		if(acnt_chk(s_one_sth.s_acct_no) == ERROR) {
#ifdef	ENGLISH
			fomer("Invalid Account Number");
#else
			fomer("Numero de compte invalide");
#endif
			s_one_sth.s_acct_no[0] = LV_CHAR ;
			return(ERROR) ;
		}
		break ;
	case	RECCD_FLD  :	/* Record Code */
		/* Valid Record codes are 41 to 52, 97, 98 & 99 */
		if(s_one_sth.s_rec_cd >= 41 && s_one_sth.s_rec_cd <= 52 ||
			s_one_sth.s_rec_cd >= 97)
			break ;
#ifdef	ENGLISH
		fomer("Valid Codes Are 41 to 52, 97, 98 & 99");
#else
		fomer("Codes valables sont de 41 a 52, 97, 98 & 99");
#endif
		s_one_sth.s_rec_cd = LV_SHORT ;
		return(ERROR) ;
	default :
#ifdef ENGLISH
		sprintf(e_mesg,"No Validity Check For Field#  %d",sr.curfld);
#else
		sprintf(e_mesg,"Pas de controle de validite pour le Champ#  %d",sr.curfld);

#endif
		fomen(e_mesg);
		get();
		return(ERROR) ;
	}	/* Switch fld_no */

	return(NOERROR) ;
}	/* Validate() */

/*----------------------------------------------------------------*/
WindowHelp()	/* Display help window for applicable fields */
{
	int	err ;

	switch(sr.curfld){
	case	ACNT_FLD :	/* Account# */
	case	RECCD_FLD  :	/* Record Code */
		err = reqacnt_hlp(s_one_sth.s_fund_cd, s_one_sth.s_acct_no,
			&s_one_sth.s_rec_cd, CC_no, pa_rec.pa_cc_key, 7, 13 );
		if(err == DBH_ERR) return(err) ;
		if(err >=0 ) redraw();
		break ;
	default :
#ifdef ENGLISH
		fomer("No Help Window For This Field");
#else
		fomer("Pas de fenetre d'assistance pour ce champ");
#endif
		return(ERROR) ;
	}	/* Switch fld_no */

	sr.nextfld = sr.curfld ;
	return(NOERROR) ;
}	/* WindowHelp() */

/*-----------------------------------------------------------------------*/
/* Display the confirmation message at the bottom of the screen, take the
   option from user and call necessary functions */
ReadOption()
{
	int	err ;

	/* Options:
	   Inquiry  - Y1/2
	*/

	for( ; ; ) {
		if(ActiveScr == 1)
#ifdef	ENGLISH
		    err = GetOpt("Y(es), 2(nd screen)", "Y2");
		else	/* if ActiveScr == 1 */
		    err = GetOpt("Y(es), 1(st screen)", "Y1");
#else
		    err = GetOpt("O(ui), 2(e ecran)", "O2");
		else	/* if ActiveScr == 1 */
		    err = GetOpt("O(ui), 1(er ecran)", "O1");
#endif

	    if(err == PROFOM_ERR) return(err) ;

	    switch(err) {
	    case  YES :
		if(ActiveScr == 2) Set1stScreen(1) ;
		return(YES) ;
	    case  FIRST_SCR :
		err = Set1stScreen(1) ;
		break ;
	    case  SECOND_SCR :
		err = Set2ndScreen() ;
		break ;
	    }	/* switch err */

	    if(err == PROFOM_ERR) return(err) ;
	    if(err == DBH_ERR) return(err) ;
	}	/* for(; ; ) */
}	/* ReadOption() */

/*-----------------------------------------------------------------------*/
/* Display message and get the option */
GetOpt(msg,options)
char	*msg ;
char	*options ;
{
	int	i, j ;

	strcpy(Mesg,msg);
	ShowMesg() ;

	sr.nextfld = END_FLD ;
	for( ; ; ) {
		fomrf(CurrentScreen) ;
		ret(err_chk(&sr)) ;

		j = strlen(options) ;
		for( i = 0 ; i < j ; i++)
			if(Resp[0] == options[i]) break ;
		if(i != j) break ;	/* Valid Option Selected */
#ifdef	ENGLISH
		fomer("Invalid Option..");
#else
		fomer("Option invalide..");
#endif
	}
	Mesg[0] = HV_CHAR ;
	Resp[0] = HV_CHAR ;
	sr.nextfld = END_FLD - 100 ;
	sr.endfld = END_FLD ;
	fomwr(CurrentScreen) ;
	ret(err_chk(&sr)) ;

	return((int)(options[i])) ;
}	/* GetOpt() */

/*-----------------------------------------------------------------------*/ 
/* Copy the key fields from screen to data record and get the record from
   data base */
BringRecord(md)
int md; /* BROWSE or UPDATE */
{
	gl_rec.funds = s_one_sth.s_fund_cd ;
	STRCPY(gl_rec.accno, s_one_sth.s_acct_no);
	gl_rec.reccod = s_one_sth.s_rec_cd ;

	return(get_gl(&gl_rec, md, 0, e_mesg));
}

/*-----------------------------------------------------------------------*/
/* Copy the data record fields to Screen1 & Screen 2 records and display
   the 1st scrren */
CopyToScreen()
{
	long	err;
	long	i;

	/* Copy 1st screen fields */
	s_one_sth.s_fund_cd = gl_rec.funds ;
	STRCPY(s_one_sth.s_acct_no, gl_rec.accno);
	s_one_sth.s_rec_cd = gl_rec.reccod ;

	s_one_sth.s_section = gl_rec.sect ;

	STRCPY(s_one_sth.s_desc, gl_rec.desc) ;
	s_one_sth.s_bud_cd = gl_rec.cdbud ;
	s_one_sth.s_comm_po = gl_rec.comdat ;
	s_one_sth.s_ytd = gl_rec.ytd ;
	s_one_sth.s_opbal = gl_rec.opbal ;
	s_one_sth.s_cur_bud = gl_rec.budcur ;
	s_one_sth.s_pre_bud = gl_rec.budpre ;
	s_one_sth.s_pre_act = 0.0 ;

	s_one_sth.s_comm_req = 0.0 ;
	gl_rec.funds = s_one_sth.s_fund_cd ;
	STRCPY(gl_rec.accno, s_one_sth.s_acct_no);
	gl_rec.reccod = s_one_sth.s_rec_cd ;
	err = calcreqcommits(gl_rec.funds,gl_rec.accno,&(s_one_sth.s_comm_req),&e_mesg);
	if (err != NOERROR)
	{
		s_one_sth.s_comm_req = 0.0;
		fomer(e_mesg);
		get();
	}

	/* Copy 2nd screen fields */
	for(i = 0 ; i < pa_rec.pa_no_periods && i < NO_PERIODS ; i++) {
		s_two_sth.s_periods[i][0] = gl_rec.currel[i] ;
		s_two_sth.s_periods[i][1] = gl_rec.prerel[i] ;
		s_two_sth.s_periods[i][2] = gl_rec.curbud[i] ;
		s_two_sth.s_periods[i][3] = gl_rec.prebud[i] ;

		s_one_sth.s_pre_act += gl_rec.prerel[i] ;
	}
	for( ; i < NO_PERIODS ; i++) {
		s_two_sth.s_periods[i][0] = HV_DOUBLE ;
		s_two_sth.s_periods[i][1] = HV_DOUBLE ;
		s_two_sth.s_periods[i][2] = HV_DOUBLE ;
		s_two_sth.s_periods[i][3] = HV_DOUBLE ;
	}

	/* Calc Budget Balance on screen 1 */
	s_one_sth.s_bud_bal = s_one_sth.s_cur_bud - (s_one_sth.s_ytd +
		s_one_sth.s_comm_req + s_one_sth.s_comm_po);
	/* Display 1st Screen */
	sr.nextfld = KEY_START ;
	sr.endfld = END_FLD - 200;
	fomwr((char*)&s_one_sth);
	return(NOERROR) ; 
}

/*------------------------------------------------------------------------*/
/* Initialize 1st screen data fields with High values and display the screen */
MoveHighs()
{
	int	i;

	s_one_sth.s_section = HV_SHORT ;

	s_one_sth.s_desc[0] = HV_CHAR ;

	s_one_sth.s_bud_cd = HV_SHORT ;

	s_one_sth.s_comm_req = HV_DOUBLE ;
	s_one_sth.s_comm_po = HV_DOUBLE ;
	s_one_sth.s_ytd = HV_DOUBLE ;
	s_one_sth.s_opbal = HV_DOUBLE ;
	s_one_sth.s_cur_bud = HV_DOUBLE ;
	s_one_sth.s_pre_bud = HV_DOUBLE ;
	s_one_sth.s_pre_act = HV_DOUBLE ;
	s_one_sth.s_bud_bal = HV_DOUBLE ;

	sr.nextfld = ST_FLD ;
	sr.endfld = END_FLD - 200 ;
	fomwr((char*)&s_one_sth);
	ret(err_chk(&sr));

	return(NOERROR);
}	/* MoveHighs() */

/*-------------------------------------------------------------------------*/
static
DispError(s)    /* show ERROR and wait */
char *s;
{
	strcpy(Mesg,s);
	ShowMesg();
#ifdef	ENGLISH
	fomen("Press any key to continue");
#else
	fomen("Appuyer sur une touche pour continuer");
#endif
	get();
	Mesg[0] = HV_CHAR;
	ShowMesg();
	return(ERROR);
}

/*------------------------------------------------------------------------*/
ShowMesg()  /* shows or clears message field */
{
	sr.nextfld = END_FLD - 100;
	fomwf(CurrentScreen) ;
}

/*------------------------------------------------------------------------*/
fund_default()
{
	fomca1(FUND_FLD,19,2);
	fomca1(RECCD_FLD,19,2);
	s_one_sth.s_fund_cd = 1;
	s_one_sth.s_rec_cd = 99;
	sr.nextfld = FUND_FLD;
	fomwf(CurrentScreen);
	sr.nextfld = RECCD_FLD;
	fomwf(CurrentScreen);
	sr.nextfld = KEY_START;
	sr.endfld = KEY_END;
	fomud((char*)&s_one_sth);
}
/*-------------------- E n d   O f   P r o g r a m ---------------------*/
