/*-----------------------------------------------------------------------
Source Name: control.c
System     : Budgetary Financial system.
Module     : General Ledger system.
Created  On: 2nd May 89.
Created  By: T AMARENDRA.

COBOL Source(s): cp260---06

DESCRIPTION:
	Program to Maintain Control File. This program provides
	Add, Change, Inquiry & Delete options on Control File.
	This program needs Parameter file. So before executing this
	program Parameter file has to be created.

MODIFICATIONS:        

Programmer     YY/MM/DD       Description of modification
~~~~~~~~~~     ~~~~~~~~       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
F.Tao		90/11/29	Changed formats for new GST
A.Cormier	92/05/09	Changed formats for new Due to From Acct #
------------------------------------------------------------------------*/

#define	MAIN	/* Main program. This is to declare Switches */
#define MAINFL	CONTROL

#define	SYSTEM		"SETUP"	/* Sub System Name */
#define	MOD_DATE	"29-NOV-90"		/* Program Last Modified */

#include <stdio.h>
#include <ctype.h>
#include <cfomstrc.h>
#include <bfs_defs.h>
#include <bfs_recs.h>

#ifdef ENGLISH
#define ADDREC 	'A'
#define CHANGE 	'C'
#define DELETE	'D'
#define NEXT	'N'
#define PREV	'P'
#define INQUIRE	'I'
#define EXIT	'E'

#define EDIT	'E'
#define CANCEL	'C'
#define YES	'Y'
#define NO	'N'
#else	/* French */
#define ADDREC 	'R'
#define CHANGE 	'C'
#define DELETE	'E'
#define NEXT	'S'
#define PREV	'P'
#define INQUIRE	'I'
#define EXIT	'F'

#define EDIT	'M'
#define CANCEL	'A'
#define YES	'O'
#define NO	'N'
#endif

#define	SCR_NAME	"control"	/* PROFOM screen name */

/* PROFOM Field Numbers */

#define	ST_FLD		800	/* Data entry starting field */
#define	END_FLD		3400	/* screen end field */

#define	FN_FLD		400	/* Fn: */
#define	KEY_FLD		500	/* Control#: */
#define	CHG_FLD		600	/* Field: */
#define FUND_FLD	500

#define	ACNT_ST_FLD	1000	/* G/L Accounts Start Field. A/P Account */
#define	ACNT_END_FLD	2500	/* G/L Accounts End Field. Account 14 */

/* Field Numbers on Screen */

#define	LAST_SNO	24	/* Last Field Number on Screen */

/* control.sth - header for C structure generated by PROFOM EDITOR */

struct	s_struct{
	char	s_pgm[11];	/* STRING XXXXXXXXXX Field 100 */
	long	s_rundate;	/* DATE YYYYFMMFDD Field 300 */
	char	s_fn[2];	/* STRING X Field 400 */
	/* Key Field */
	short	s_fund_cd;	/* NUMERIC 999 Field 500 */
	short	s_field;	/* NUMERIC 99 Field 600 */
	char	s_desc[31];	/* STRING X[30] Field 800 */
	char 	s_head[2];	/* heading field 900	  */
	char	s_acnt_nos[16][19];	/* STRING X[18]  Field 1000 2500 */
	long	s_b1_chq_no;	/* NUMERIC 999999 Field 2600 */
	long	s_b2_chq_no;	/* NUMERIC 999999 Field 2700 */
	long	s_last_po;	/* NUMERIC 999999 Field 2800 */
	long	s_last_req;	/* NUMERIC 99999999 Field 2900 */
	short 	s_pst_pnt;	/* PST percentage Field 3000 */	
	short 	s_gst_pnt;	/* GST percentage Field 3100 */	
	short 	s_rbt_pnt;	/* Rebate percentage Field 3200 */	
	char	s_mesg[78];	/* STRING X[77] Field 3300 */
	char	s_resp[2];	/* STRING X Field 3400 */
	};

static	struct	s_struct  s_sth;	/* Screen Structure */

static	struct  stat_rec sr;		/* PROFOM status rec */

static	Ctl_rec	ctl_rec ,		/* Control Record */
		pre_rec ;		/* Previous Control Rec to write audit
					   info */
static  Last_po lastpo_rec;		/* Last Po Number */
static  Last_req lastreq_rec;		/* Last Requisition Number */

static	Pa_rec	pa_rec ;		/* Parameter Record */
static	char 	e_mesg[80];  		/* dbh will return err msg in this */

/*--------------------------------------------------------------------------*/
main(argc,argv)
int argc;
char *argv[];
{
	int	err;

	if(argc < 2){
#ifdef  DEVELOP
		printf("MAIN ARGUMENTS ARE NOT PROPER\n");
		printf("Usage : %s {-tterminal name}\n", argv[0]);
#endif
		exit(1);
	}

	strncpy(SYS_NAME,SYSTEM,50);	/* Sub system name */
	strncpy(CHNG_DATE,MOD_DATE,10);	/* Modification Date */

	proc_switch(argc, argv, MAINFL) ; 	/* Process Switches */

	STRCPY(sr.termnm,terminal);	/* Copy Terminal Name */

	InitProfom() ;			/* Initialize PROFOM */

	err = get_param(&pa_rec, BROWSE, 1, e_mesg) ;
	if(err == ERROR)
		DispError(e_mesg);
	else if(err == UNDEF)
#ifdef ENGLISH
		DispError("Parameters Are Not Setup..");
#else
		DispError("Parametres ne sont pas etablis..");
#endif
	else
		err = Process(); 	/* Initiate Process */

	/* Set terminal back to normal mode from PROFOM */
	fomcs();
	fomrt();

	free_audit() ;	/* Free the space allocated for Fields */
	close_dbh();	/* Close files */

	if(err != NOERROR)exit(1);
	exit(0);
} /* END OF MAIN */
/*-------------------------------------------------------------------*/
/* Initialize PROFOM 						     */
/*-------------------------------------------------------------------*/
static 
InitProfom()
{
	fomin(&sr);
	/* Check for Error */
	if(err_chk(&sr) == PROFOM_ERR){
		fomcs();
		fomrt();
		exit(1);
	}
	fomcf(1,1);	/* Enable Snap screen option */
}	/* InitProfom() */
/*-------------------------------------------------------------------*/
/* Get Option from user and call corresponding function */
/*-------------------------------------------------------------------*/
static 
Process()
{
	int err;

	InitScreen() ;

	for( ; ; ){
		/* Display Fn: options */
#ifdef	ENGLISH
		fomer("A(dd), C(hange), D(elete), N(ext), P(rev), I(nquiry), E(xit)");
#else
		fomer("R(ajouter), C(hanger), E(liminer), S(uivant), P(recedent), I(nterroger), F(in)");
#endif

		/* Read Fn: field to get the option */
		sr.nextfld = FN_FLD ;
		fomrf((char*)&s_sth);
		ret(err_chk(&sr));	/* Check for PROFOM error */

		switch(s_sth.s_fn[0]){
		case ADDREC  :	/* Add */
			CHKACC(err,ADD,e_mesg);
			err = AddNewRec();
			break;
		case CHANGE  :	/* Change */
			CHKACC(err,UPDATE,e_mesg);
			err = ChangeRec();
			break;
		case DELETE  :	/* Delete */
			CHKACC(err,P_DEL,e_mesg);
			err = DeleteRec();
			break;
		case NEXT  : 	/* Next */
			CHKACC(err,BROWSE,e_mesg);
			err = NextRec() ; 
			break ;
		case PREV  :	/* Previous */
			CHKACC(err,BROWSE,e_mesg);
			err = PrevRec() ; 
			break ;
		case INQUIRE  : 	/* Inquiry */
			CHKACC(err,BROWSE,e_mesg);
			err = InquiryRec();
			break ;
		case EXIT  :
			return(NOERROR);
		default   : 
			continue; 
		}  /*   end of the switch statement */

		if(err == NOACCESS) {
			fomer(e_mesg);
			get();
		}
		if(err == PROFOM_ERR)return(PROFOM_ERR); /* PROFOM ERROR */
		if(err == DBH_ERR) {
			DispError(e_mesg) ;
#ifdef	ENGLISH
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"System Error... Iserror:",
				iserror, dberror, errno);
#else
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"Erreur du systeme... Iserror:",
				iserror, dberror, errno);
#endif
			DispError(e_mesg);
			return(DBH_ERR); /* DBH ERROR */
		}
	}      /*   end of the for( ; ; )       */
}	/* Process() */
/*----------------------------------------------------------------*/
/* Initialize screen before going to process options */
/*-------------------------------------------------------------------*/
static
InitScreen()
{
	/* move screen name to Profom status structure */
	STRCPY(sr.scrnam,NFM_PATH);
	strcat(sr.scrnam,SCR_NAME) ;

	STRCPY(s_sth.s_pgm,PROG_NAME);
	s_sth.s_rundate = get_date();	/* get Today's Dt in YYYYMMDD format */
	s_sth.s_field = HV_SHORT ;
	s_sth.s_mesg[0] = HV_CHAR ;
	s_sth.s_resp[0] = HV_CHAR ;

	/* Initialize key field. This gets 1st record from the file
	   if user selects 'N' option immediatly after invoking */
	s_sth.s_fund_cd = 0 ;

	/* Move High Values to screen data fields & Display */
	MoveHighs() ;

	return(NOERROR) ;
}	/* InitScreen() */
/*----------------------------------------------------------------------*/
/* Read the full screen and add the record to data base */
/*----------------------------------------------------------------------*/
static
AddNewRec()
{
	int	i,err ;

	for( ; ;){
		i = ReadKey();
		if(i != NOERROR)return(i);

		/* check whether given key is already existing */
		i = BringRecord(BROWSE);
		if(i == ERROR) return(DBH_ERR) ;
		if(i == NOERROR){
			if(pa_rec.pa_funds[0] == NO) {
#ifdef	ENGLISH
				fomen("Can't Add more than 1 Control Record");
#else
				fomen("Ne peut pas ajouter plus qu'une fiche controle");
#endif
				get() ;
				CopyToScreen() ;	/* Display Record */
				return(ERROR) ;
			}
#ifdef	ENGLISH
			fomer("Given Key already in File - Please enter again") ;
#else
			fomer("Cle donnee est deja dans le dossier- Reessayer");
#endif
			continue;
		}
		/* UNDEF */
		break;
	}

	/* Change PROFOM logical field attributes */

	for(i = ST_FLD ; i <= END_FLD - 200  ; i += 100) {
		fomca1(i,19,0);		/* Disable Dup control */
		fomca1(i,10,1);		/* Enable User Escape */
	}

	i = ReadScreen() ;	/* Read fields */
	if(i != NOERROR) return(i) ;

	for( ; ; ) {
		i = ReadOption() ;
		if(i < 0) return(i) ;

		if(i == CANCEL)
			return(MoveHighs()) ;

		CopyToRecord(ADD) ;

		err = RiteRecord(ADD) ;
		if(err==NOERROR) break;
		if(err==LOCKED) {
			roll_back(e_mesg);
			continue;
		}
		if(err<0) return(err);
	}

	return(NOERROR);
}	/* AddNewRec() */
/*-----------------------------------------------------------------------*/
/* Accepts the changes to selected record and update the database */
/*----------------------------------------------------------------------*/
static
ChangeRec()
{
	int	err ;

	err = SelectRecord(UPDATE) ;
	if(err != NOERROR) return(err) ;

	err = ChangeFields();
	if(err != NOERROR) return(err);

	for( ; ; ) {
		err = ReadOption() ;
		if(err < 0) return(err) ;

		if(err == CANCEL) {
			CopyToScreen() ;    /* Display the original record */
			roll_back(e_mesg);  /* Unlocking if recs not modified */
			return(NOERROR) ;
		}

		CopyToRecord(UPDATE) ;

		err=RiteRecord(UPDATE) ;
		if(err==NOERROR) break;
		if(err==LOCKED) {
			roll_back(e_mesg);
			err = BringRecord(UPDATE);
			if(err < 0){
				fomen(e_mesg);
				get() ;
				if(err == UNDEF || err == LOCKED) continue ;
				return(DBH_ERR);
			}
			continue;
		}
		if(err<0) return(err);
	}
	return( NOERROR );
}	/* ChangeRec() */
/*----------------------------------------------------------------------*/
/* Select the record to be deleted and delete from database afetr	*/
/*   confirmation 							*/
/*----------------------------------------------------------------------*/
static
DeleteRec()
{
	int	err;

	err = SelectRecord(UPDATE) ;
	if(err != NOERROR) return(err) ;

	for( ; ; ) {
		err = ReadOption() ;
		if(err < 0) return(err) ;

		if(err == CANCEL) {
			roll_back(e_mesg);  /* Unlocking if recs not modified */
			return(NOERROR) ;
		}

		err = RiteRecord(P_DEL) ;
		if(err==NOERROR) break;
		if(err==LOCKED) {
			roll_back(e_mesg);
			err = BringRecord(UPDATE);
			if(err < 0){
				fomen(e_mesg);
				get() ;
				if(err == UNDEF || err == LOCKED) continue ;
				return(DBH_ERR);
			}
			continue;
		}
		if(err<0) return(err);
	}
	return(NOERROR);
}	/* ChangeRec() */
/*-----------------------------------------------------------------------*/
/* Get next rec from file & Display when user selected 'N' in function */
/*----------------------------------------------------------------------*/
static
NextRec()
{
	int	err;

	err = BringNext(FORWARD) ;
	if(err != NOERROR) return(err) ;

	return(NOERROR) ;
}
/*----------------------------------------------------------------------*/
/* Get Previous record from file & Display when user selected 'P' 	*/
/* in function 								*/
/*----------------------------------------------------------------------*/
static
PrevRec()
{
	int	err;

	err = BringNext(BACKWARD) ;
	if(err != NOERROR) return(err) ;

	return(NOERROR) ;
}
/*----------------------------------------------------------------------*/
/* Select the Key, get the record & display 				*/
/*----------------------------------------------------------------------*/
static
InquiryRec()
{
	int	err ;

	err = SelectRecord(BROWSE) ;
	if(err != NOERROR) return(err) ;

	return(NOERROR) ;
}
/*----------------------------------------------------------------------*/
/* Read the key fields, get the record with LOCK and display		*/
/*   the Record 							*/
/*----------------------------------------------------------------------*/
static
SelectRecord(md)
int	md ;	/* BROWSE for Inquiry, UPDATE for Others */
{
	int	err ;

	for(; ;){
		err = ReadKey();
		if(err != NOERROR) return(err) ;

		/* Get the record from database */

		err = BringRecord(md);
		if(err < 0){
			fomen(e_mesg);
			get() ;
			if(err == UNDEF || err == LOCKED) continue ;
			return(DBH_ERR);
		}
		CopyToScreen() ;
		return(NOERROR) ;
	}
}	/* SelectRecord() */
/*----------------------------------------------------------------------*/
/* Read Key Fields 							*/
/*----------------------------------------------------------------------*/
static
ReadKey()
{
	int 	key_fund_cd ;

#ifdef	ENGLISH
	STRCPY(s_sth.s_mesg,"Press ESC-F to Go Back to Fn:");
#else
	STRCPY(s_sth.s_mesg,"Appuyer sur ESC-F pour retourner a Fn:");
#endif
	ShowMesg();

	/* In parameter file if pa_funds(More Than 1 fund) is set to 'N'
	   then user can't add more than 1 one control record. In that case
	   always move 1 to control# and return instead of taking input
	   from user */
	if(s_sth.s_fn[0] == ADDREC && pa_rec.pa_funds[0] == NO) {
		s_sth.s_fund_cd = 1;
		sr.nextfld = KEY_FLD ;
		fomwf((char*)&s_sth);
		ret(err_chk(&sr));
		return(NOERROR) ;
	}
	/* In Add mode turn off dup control for key field. Other modes
	   invert it */

	if(s_sth.s_fn[0] == ADDREC) {
		fomca1(KEY_FLD,19,0) ;	/* OFF Dup Control */
	}
	else {
		fomca1(KEY_FLD,19,2) ;	/* ON Dup Control */
/*
		s_sth.s_fund_cd = LV_SHORT;
*/
		/* Update Dup Buffer */
		sr.nextfld = KEY_FLD ;
		sr.endfld = KEY_FLD ;
		fomud((char*)&s_sth);
	}

	/* Store key field to copy back when user gives ESC-F */
	key_fund_cd = s_sth.s_fund_cd ;

	sr.nextfld = KEY_FLD ;
	for(; ;) {
		fomrf((char*)&s_sth);
		ret(err_chk(&sr));

		if(sr.retcode == RET_USER_ESC){
			if(sr.escchar[0] == 'F' || sr.escchar[0] == 'f') {
				/* copy back key fields */
				s_sth.s_fund_cd = key_fund_cd ;

				sr.nextfld = KEY_FLD ;
				fomwf((char*)&s_sth);

				s_sth.s_mesg[0] = HV_CHAR;
				ShowMesg();
				return(ERROR) ;
			}
			continue;
		}
		/* else RET_NO_ERROR */
		if(s_sth.s_fund_cd < 1) {
#ifdef ENGLISH
			fomer("Invalid Fund");
#else
			fomer("Fond invalide");
#endif
			continue ;
		}
		break;
	}			/* end of for loop */

	s_sth.s_mesg[0] = HV_CHAR;
	ShowMesg();

	return(NOERROR);
}	/*  ReadKey() */
/*----------------------------------------------------------------------*/
/* Get all fields from user on screen 					*/
/*----------------------------------------------------------------------*/
static
ReadScreen()
{
	int	err ;

	/* Initialize screen with Low values */
	MoveLows() ;
	sr.nextfld = ST_FLD;
	sr.endfld = END_FLD - 200;
	for( ; ;){
		fomrd((char*)&s_sth);
		ret(err_chk(&sr));
		if(sr.retcode == RET_VAL_CHK){
			err = Validate() ;
			if(err == DBH_ERR) return(err) ;
			sr.nextfld = sr.curfld ;
			continue;
		}
		if(sr.retcode == RET_USER_ESC){
			if(sr.escchar[0] == 'f' || sr.escchar[0] == 'F') {
				roll_back(e_mesg);
				MoveHighs() ;
				return(ERROR);
			}
			if(sr.escchar[0] == 'h' || sr.escchar[0] == 'H') {
				err = WindowHelp() ;
				if(err == DBH_ERR) return(err) ;
				sr.nextfld = sr.curfld ;
			}
			continue;
		}
		/* else RET_NO_ERROR */
		break;
	}

	return(NOERROR) ;
}	/* ReadScreen() */
/*----------------------------------------------------------------------*/
/* validate flds when PROFOM returns RET_VAL_CHK 			*/
/*----------------------------------------------------------------------*/
static
Validate()	/* validate flds when PROFOM returns RET_VAL_CHK */
{
	int	err ;
	int	i ;
	Gl_rec	gl_rec ;

	if(sr.curfld >= ACNT_ST_FLD && sr.curfld <= ACNT_END_FLD) {
		/*
		* Check whether account# is having any invalid characters.
		*/

		i = (sr.curfld - ACNT_ST_FLD) / 100 ;

		if(acnt_chk(s_sth.s_acnt_nos[i]) == ERROR) {
#ifdef	ENGLISH
			fomer("Invalid Account Number");
#else
			fomer("Numero de compte invalide");
#endif
			s_sth.s_acnt_nos[i][0] = LV_CHAR ;
			return(ERROR) ;
		}
		/* In add mode or If gl Master File not present skip checking
		   existency of given code */
		if(s_sth.s_fn[0] == ADDREC || pa_rec.pa_glmast[0] == NO)
			return(NOERROR) ;

		gl_rec.funds = s_sth.s_fund_cd ;
		STRCPY(gl_rec.accno, s_sth.s_acnt_nos[i]) ;
		gl_rec.reccod = 99 ;
		err = get_gl(&gl_rec,BROWSE,0,e_mesg) ;
		if(err == DBH_ERR) return(err) ;
		if(err < 0) {
			fomer(e_mesg) ;
			s_sth.s_acnt_nos[i][0] = LV_CHAR ;
			return(ERROR) ;
		}
		return(NOERROR) ;
	}
	else {
#ifdef ENGLISH
		sprintf(e_mesg,"No Validity Check For Field#  %d",sr.curfld);
#else
		sprintf(e_mesg,"Pas de controle de validite pour le Champ# %d",sr.curfld);
#endif
		fomen(e_mesg);
		get();
	}

	return(ERROR) ;
}	/* Validate() */
/*----------------------------------------------------------------------*/
/* Display help window for applicable fields 				*/
/*----------------------------------------------------------------------*/
static
WindowHelp()	/* Display help window for applicable fields */
{
	int	err, i ;
	short	reccod ;

	if(sr.curfld >=	ACNT_ST_FLD && sr.curfld <= ACNT_END_FLD) {
		if(pa_rec.pa_glmast[0] == NO) {
#ifdef	ENGLISH
			fomer("G/L Master Not Present");
#else
			fomer("G/L maitre pas present");
#endif
			return(ERROR) ;
		}
		i = (sr.curfld - ACNT_ST_FLD) / 100 ;

		err = gl_hlp(s_sth.s_fund_cd, s_sth.s_acnt_nos[i],
			&reccod, 7, 13 );
		if(err == DBH_ERR) return(err) ;
		if(err >=0 ) redraw();
		if(err > 0 && reccod != 99) {
#ifdef	ENGLISH
			fomer("Select records with 99 only as Record Code");
#else
			fomer("Choisir fiches avec 99 seulement comme code de fiche");
#endif
			s_sth.s_acnt_nos[i][0] = LV_CHAR ;
			return(ERROR) ;
		}
		return(NOERROR) ;
	}
	else
#ifdef	ENGLISH
		fomer("No Help Window For This Field");
#else
		fomer("Pas de fenetre d'assistance pour ce champ");
#endif

	return(ERROR) ;
}	/* WindowHelp() */
/*----------------------------------------------------------------------*/
/* Changing fields. Accept fld to be changed and read that fld 		*/
/*----------------------------------------------------------------------*/
static
ChangeFields()
{
	int	i;

	/* Change PROFOM logical field attributes */

	for(i = ST_FLD ; i <= END_FLD -200  ; i += 100) {
		fomca1(i,19,2);		/* enabling Dup control */
		fomca1(i,10,1);		/* enabling User Escape */
	}

	/* Set Dup Buffers */
	sr.nextfld = ST_FLD;
	sr.endfld = END_FLD - 200;
	fomud((char*)&s_sth);  /* Updating dup buffer */
	ret(err_chk(&sr));

	/* Get The Field to Be Modified */
#ifdef	ENGLISH
	STRCPY(s_sth.s_mesg,"Enter RETURN to Terminate Edit");
#else
	STRCPY(s_sth.s_mesg,"Appuyer sur RETURN pour terminer l'ajustement");
#endif
	ShowMesg() ;

	for( ; ; ) {
		sr.nextfld = CHG_FLD ;
		fomrf((char*)&s_sth);
		ret(err_chk(&sr));

		if(s_sth.s_field == 0) break ;

		i = ReadFld() ;	/* Read Field */
		if(i == PROFOM_ERR) return(i) ;
		if(i == DBH_ERR) return(i) ;
	}	/* for( ; ; ) */

	s_sth.s_field = HV_SHORT ;
	fomwf((char*)&s_sth);
	ret(err_chk(&sr));

	s_sth.s_mesg[0] = HV_CHAR;
	ShowMesg();

	return(NOERROR);
}	/* ChangeFields() */
/*----------------------------------------------------------------------*/
/* Read the user selected field in change mode 				*/
/*----------------------------------------------------------------------*/
static
ReadFld()
{
	int	err ;

	/* Validate  Field Number */

	if( s_sth.s_field < 1 || s_sth.s_field > LAST_SNO) return (ERROR) ;

	/* Set PROFOM nextfld */
	/* The if is because of the Account Heading */
	if(s_sth.s_field == 1) 
		sr.nextfld = ST_FLD + (s_sth.s_field - 1) * 100 ;
	else
		sr.nextfld = ST_FLD + (s_sth.s_field) * 100 ;

	for( ; ; ) {
		fomrf((char*)&s_sth);
		ret(err_chk(&sr));

		if(sr.retcode == RET_VAL_CHK) {
			err = Validate() ;
			if(err == DBH_ERR) return(err) ;
			if(err == NOERROR) break;
			continue ;
		}
		if(sr.retcode == RET_USER_ESC){
			if(sr.escchar[0] == 'h' || sr.escchar[0] == 'H') {
				err = WindowHelp() ;
				if(err == DBH_ERR) return(err) ;
				if(err == NOERROR) break;
			}
			continue;
		}
		if(sr.retcode != RET_NO_ERROR) continue;
		break ;
	}
	/* If Field is Account# redisplay the right justified field. Because
	   acnt_chk() right justifies the given account# */
	if(sr.nextfld >= ACNT_ST_FLD && sr.nextfld <= ACNT_END_FLD) {
		fomwf((char*)&s_sth);
		ret(err_chk(&sr));
	}
	return(NOERROR) ;
}	/* ReadFld() */
/*----------------------------------------------------------------------*/
/*Display the confirmation message at the bottom of the screen, take the*/
/*  option from user and call necessary functions 			*/
/*----------------------------------------------------------------------*/
static
ReadOption()
{
	int	err ;

	/* Options:
	   Add      - YEC
	   Change   - YEC
	   Delete   - YC
	*/

	for( ; ; ) {
	    switch(s_sth.s_fn[0]) {
	    case	ADDREC :	/* Add */
	    case	CHANGE :	/* Change */
#ifdef	ENGLISH
		    err = GetOpt("Y(es), E(dit), C(ancel)", "YEC");
#else
		    err = GetOpt("O(ui), M(odifier), A(nnuler)", "OMA");
#endif
		break ;
	    case	DELETE :	/* Delete */
#ifdef	ENGLISH
		err = GetOpt("Y(es), C(ancel)", "YC");
#else
		err = GetOpt("O(ui), A(nnuler)", "OA");
#endif
		break ;
	    }	/* switch fn[] */

	    if(err == PROFOM_ERR) return(err) ;

	    switch(err) {
	    case  YES :
		return(YES) ;
	    case  EDIT  :
		err = ChangeFields();
		break ;
	    case  CANCEL :
#ifdef	ENGLISH
		err = GetOpt("Confirm The Cancel (Y/N)?", "YN") ;
#else
		err = GetOpt("Confirmer l'annulation (O/N)?", "ON") ;
#endif
		if(err == YES) return(CANCEL) ;
		break ;
	    }	/* switch err */

	    if(err == PROFOM_ERR) return(err) ;
	    if(err == DBH_ERR) return(err) ;
	}	/* for(; ; ) */
}	/* ReadOption() */
/*-----------------------------------------------------------------------*/
/* Display message and get the option 					*/
/*----------------------------------------------------------------------*/
static
GetOpt(msg,options)
char	*msg ;
char	*options ;
{
	int	i, j ;

	STRCPY(s_sth.s_mesg,msg);

	sr.nextfld = END_FLD - 100 ;
	sr.endfld = END_FLD ;
	for( ; ; ) {
		s_sth.s_resp[0] = LV_CHAR ;
		fomrd((char*)&s_sth) ;
		ret(err_chk(&sr)) ;

		j = strlen(options) ;
		for( i = 0 ; i < j ; i++)
			if(s_sth.s_resp[0] == options[i]) break ;
		if(i != j) break ;	/* Valid Option Selected */
#ifdef	ENGLISH
		fomer("Invalid Option..");
#else
		fomer("Option invalide..");
#endif
	}
	s_sth.s_mesg[0] = HV_CHAR ;
	s_sth.s_resp[0] = HV_CHAR ;
	sr.nextfld = END_FLD - 100 ;
	sr.endfld = END_FLD ;
	fomwr((char*)&s_sth) ;
	ret(err_chk(&sr)) ;

	return((int)(options[i])) ;
}	/* GetOpt() */
/*----------------------------------------------------------------------*/
/* Write record in data base 						*/
/*----------------------------------------------------------------------*/
static
RiteRecord(md)
int	md ;
{
	int	err;

	err = put_ctl(&ctl_rec,md,e_mesg);
	if(err != NOERROR){
#ifdef ENGLISH
		DispError("ERROR in Saving Records"); 
#else
		DispError("ERREUR en conservant les fiches");
#endif
		DispError(e_mesg);
		roll_back(e_mesg);
		MoveHighs() ;
		return(DBH_ERR);
	}

	err = rite_audit((char*)&s_sth, CONTROL, md, (char*)&ctl_rec, 
					(char*)&pre_rec, e_mesg);
	if(err==LOCKED) {
		DispError(e_mesg);
		roll_back(e_mesg);
		return(LOCKED);
	}

	if(err != NOERROR){
#ifdef ENGLISH
		DispError("ERROR in Saving Records"); 
#else
		DispError("ERREUR en conservant les fiches");
#endif
		DispError(e_mesg);
		roll_back(e_mesg);
		MoveHighs() ;
		return(DBH_ERR);
	}

	err = put_lastpo(&lastpo_rec, md, 1, e_mesg) ;

	if(err < 0){
#ifdef ENGLISH
		DispError("ERROR in Saving Records"); 
#else
		DispError("ERREUR en conservant les fiches");
#endif
		DispError(e_mesg) ;
		roll_back(e_mesg);
		MoveHighs() ;
		return(DBH_ERR);
	}

	err = put_lastreq(&lastreq_rec, md, 1, e_mesg) ;

	if(err < 0){
#ifdef ENGLISH
		DispError("ERROR in Saving Records"); 
#else
		DispError("ERREUR en conservant les fiches");
#endif
		DispError(e_mesg) ;
		roll_back(e_mesg);
		MoveHighs() ;
		return(DBH_ERR);
	}

	if(commit(e_mesg) < 0) {
#ifdef ENGLISH
		DispError("ERROR in Saving Records"); 
#else
		DispError("ERREUR en conservant les fiches");
#endif
		DispError(e_mesg);
		MoveHighs() ;
		return(DBH_ERR);
	}

	return(NOERROR);
}	/* RiteRecord() */
/*----------------------------------------------------------------------*/ 
/* Copy the key fields from screen to data record and get the record 	*/
/* from  data base 							*/
/*----------------------------------------------------------------------*/
static
BringRecord(md)
int md; /* BROWSE or UPDATE */
{
	int retval ;
	ctl_rec.fund = s_sth.s_fund_cd ;

	retval = get_ctl(&ctl_rec, md, 0, e_mesg);
	if(retval < 0) return(retval);

	/* Last PO Number and Last Requisition Number only maintained in */
	/* Fund 1 */
	retval = get_lastpo(&lastpo_rec, md, 1, e_mesg) ;
	if(retval < 0) return(retval);
	
	retval = get_lastreq(&lastreq_rec, md, 1, e_mesg) ;
	if(retval < 0) return(retval);

	return(NOERROR);
}
/*----------------------------------------------------------------------*/ 
/* Read the next record from data base 					*/
/*----------------------------------------------------------------------*/
static
BringNext(direction)
int	direction;
{
	int err;

	/* Check whether file is in seq. read mode */
	if(flg_start(CONTROL) != direction) {
		/* Set the key to next possible key and set the file to start */
		if(direction == FORWARD)
			ctl_rec.fund = s_sth.s_fund_cd + 1 ;
		else
			ctl_rec.fund = s_sth.s_fund_cd - 1 ;
		flg_reset(CONTROL);
	}

	err = get_n_ctl(&ctl_rec, BROWSE, 0, direction, e_mesg);

#ifndef	ORACLE
	seq_over(CONTROL);
#endif

	if(ERROR == err)return(DBH_ERR) ;
	if(EFL == err) {
#ifdef	ENGLISH
		fomen("No More Records....");
#else
		fomen("Plus de fiches....");
#endif
		get();
		flg_reset(CONTROL);
		return(ERROR) ;
	}

	/* Last PO Number and Last Requisition Number only maintained in */
	/* Fund 1 */
	err = get_lastpo(&lastpo_rec, BROWSE, 1, e_mesg) ;
	if(err < 0) return(err);
	
	err = get_lastreq(&lastreq_rec, BROWSE, 1, e_mesg) ;
	if(err < 0) return(err);

	CopyToScreen() ;

	return(NOERROR);
}
/*----------------------------------------------------------------------*/
/* Copy the data record fields to Screen and display the screen 	*/
/*----------------------------------------------------------------------*/
static
CopyToScreen()
{
	int	i;

	s_sth.s_fund_cd = ctl_rec.fund ;
	STRCPY(s_sth.s_desc, ctl_rec.desc) ;
	STRCPY(s_sth.s_head, " ");

	STRCPY(s_sth.s_acnt_nos[0], ctl_rec.ap_gen_acnt) ;
	STRCPY(s_sth.s_acnt_nos[1], ctl_rec.ap_cnt_acnt) ;
	STRCPY(s_sth.s_acnt_nos[2], ctl_rec.ar_gst_acnt) ;
	STRCPY(s_sth.s_acnt_nos[3], ctl_rec.dis_acnt) ;
	STRCPY(s_sth.s_acnt_nos[4], ctl_rec.expdis_acnt) ;
	STRCPY(s_sth.s_acnt_nos[5], ctl_rec.sus_acnt) ;
	STRCPY(s_sth.s_acnt_nos[6], ctl_rec.bank1_acnt) ;
	STRCPY(s_sth.s_acnt_nos[7], ctl_rec.bank2_acnt) ;
	STRCPY(s_sth.s_acnt_nos[8], ctl_rec.pst_tax_acnt) ;
	STRCPY(s_sth.s_acnt_nos[9], ctl_rec.gst_tax_acnt) ;
	STRCPY(s_sth.s_acnt_nos[10], ctl_rec.ar_acnt) ;
	STRCPY(s_sth.s_acnt_nos[11], ctl_rec.ap_gst_acnt) ;
	STRCPY(s_sth.s_acnt_nos[12], ctl_rec.inv_acnt) ;
	STRCPY(s_sth.s_acnt_nos[13], ctl_rec.p_and_l_acnt) ;
	STRCPY(s_sth.s_acnt_nos[14], ctl_rec.s_d_accm_acnt) ;
	STRCPY(s_sth.s_acnt_nos[15], ctl_rec.duetofrom_acct) ;

	s_sth.s_b1_chq_no	= ctl_rec.bank1_chq ;
	s_sth.s_b2_chq_no 	= ctl_rec.bank2_chq ;
	s_sth.s_last_po 	= lastpo_rec.last_po ;
	s_sth.s_last_req 	= lastreq_rec.last_req ;
 	s_sth.s_pst_pnt		= ctl_rec.pst_tax; 
	s_sth.s_gst_pnt		= ctl_rec.gst_tax;
	s_sth.s_rbt_pnt		= ctl_rec.rebate;


	/* display screen */
	sr.nextfld = KEY_FLD ;
	sr.endfld = END_FLD - 200;
	fomwr((char*)&s_sth);
	return(NOERROR) ; 
}
/*----------------------------------------------------------------------*/
/* Copy the Screen fields to data record 				*/
/*----------------------------------------------------------------------*/
static
CopyToRecord(md)
int md;
{
	int	i;

	/* Save the ctl_rec in pre_rec to write audit records for changed
	   fields */
	if(md != ADD) {
		ctl_rec.last_po = lastpo_rec.last_po;
		ctl_rec.last_req = lastreq_rec.last_req;
		scpy((char*)&pre_rec, (char*)&ctl_rec, sizeof(Ctl_rec)) ;
	}
	ctl_rec.fund = s_sth.s_fund_cd ;
	STRCPY(ctl_rec.desc, s_sth.s_desc) ;

	STRCPY(ctl_rec.ap_gen_acnt, 	s_sth.s_acnt_nos[0]) ;
	STRCPY(ctl_rec.ap_cnt_acnt, 	s_sth.s_acnt_nos[1]) ;
	STRCPY(ctl_rec.ar_gst_acnt, 	s_sth.s_acnt_nos[2]) ;
	STRCPY(ctl_rec.dis_acnt,	s_sth.s_acnt_nos[3]) ;
	STRCPY(ctl_rec.expdis_acnt,	s_sth.s_acnt_nos[4]) ;
	STRCPY(ctl_rec.sus_acnt,	s_sth.s_acnt_nos[5]) ;
	STRCPY(ctl_rec.bank1_acnt, 	s_sth.s_acnt_nos[6]) ;
	STRCPY(ctl_rec.bank2_acnt, 	s_sth.s_acnt_nos[7]) ;
	STRCPY(ctl_rec.pst_tax_acnt,	s_sth.s_acnt_nos[8]) ;
	STRCPY(ctl_rec.gst_tax_acnt, 	s_sth.s_acnt_nos[9]) ;
	STRCPY(ctl_rec.ar_acnt, 	s_sth.s_acnt_nos[10]) ;
	STRCPY(ctl_rec.ap_gst_acnt, 	s_sth.s_acnt_nos[11]) ;
	STRCPY(ctl_rec.inv_acnt, 	s_sth.s_acnt_nos[12]) ;
	STRCPY(ctl_rec.p_and_l_acnt, 	s_sth.s_acnt_nos[13]) ;
	STRCPY(ctl_rec.s_d_accm_acnt, 	s_sth.s_acnt_nos[14]) ;
	STRCPY(ctl_rec.duetofrom_acct, 	s_sth.s_acnt_nos[15]) ;
	
	ctl_rec.bank1_chq 	= s_sth.s_b1_chq_no ;
	ctl_rec.bank2_chq 	= s_sth.s_b2_chq_no ;

	/* Update last_po and last_req in fund file for audit report only */
	ctl_rec.last_po 	= s_sth.s_last_po ;
	ctl_rec.last_req 	= s_sth.s_last_req ;
 	ctl_rec.pst_tax 	= s_sth.s_pst_pnt; 
	ctl_rec.gst_tax		= s_sth.s_gst_pnt;
	ctl_rec.rebate		= s_sth.s_rbt_pnt;

	lastpo_rec.last_po 	= s_sth.s_last_po ;
	lastreq_rec.last_req 	= s_sth.s_last_req ;
}
/*----------------------------------------------------------------------*/
/* Initialize screen data fields with Low Values 			*/
/*----------------------------------------------------------------------*/
static
MoveLows()
{
	int	i;

	s_sth.s_desc[0] = LV_CHAR ;
	STRCPY(s_sth.s_head," ");

	for(i = 0 ; i < 16 ; i++)
		s_sth.s_acnt_nos[i][0] = LV_CHAR ;

	s_sth.s_b1_chq_no 	= LV_LONG ;
	s_sth.s_b2_chq_no 	= LV_LONG ;
	s_sth.s_last_po 	= LV_LONG ;
	s_sth.s_last_req 	= LV_LONG ;
 	s_sth.s_pst_pnt		= LV_SHORT;	
	s_sth.s_gst_pnt		= LV_SHORT;	
	s_sth.s_rbt_pnt		= LV_SHORT;	

}	/* MoveLows() */
/*----------------------------------------------------------------------*/
/* Initialize screen data fields with High values and display the screen*/
/*----------------------------------------------------------------------*/
static
MoveHighs()
{
	int	i;

	s_sth.s_desc[0] = HV_CHAR ;
	s_sth.s_head[0] = HV_CHAR;

	for(i = 0 ; i < 16 ; i++)
		s_sth.s_acnt_nos[i][0] = HV_CHAR ;

	s_sth.s_b1_chq_no 	= HV_LONG ;
	s_sth.s_b2_chq_no 	= HV_LONG ;
	s_sth.s_last_po 	= HV_LONG ;
	s_sth.s_last_req 	= HV_LONG ;
 	s_sth.s_pst_pnt		= HV_SHORT;	
	s_sth.s_gst_pnt		= HV_SHORT;	
	s_sth.s_rbt_pnt		= HV_SHORT;	


	sr.nextfld = ST_FLD ;
	sr.endfld = END_FLD - 200 ;
	fomwr((char*)&s_sth);
	ret(err_chk(&sr));

	return(NOERROR);
}	/* MoveHighs() */
/*----------------------------------------------------------------------*/
/* show ERROR and wait 							*/
/*----------------------------------------------------------------------*/
static
DispError(s)    /* show ERROR and wait */
char *s;
{
	STRCPY(s_sth.s_mesg,s);
	ShowMesg();
#ifdef	ENGLISH
	fomen("Press any key to continue");
#else
	fomen("Appuyer sur une touche pour continuer");
#endif
	get();
	s_sth.s_mesg[0] = HV_CHAR;
	ShowMesg();
	return(ERROR);
}
/*----------------------------------------------------------------------*/
/* shows or clears message field 					*/
/*----------------------------------------------------------------------*/
static
ShowMesg()  /* shows or clears message field */
{
	sr.nextfld = END_FLD - 100;
	fomwf((char*)&s_sth) ;
}
/*-------------------- E n d   O f   P r o g r a m ---------------------*/
