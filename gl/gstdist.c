/*-----------------------------------------------------------------------
Source Name: gstdist.c
System     : General Ledger.
Created  On: 07-MAY-91.
Created  By: J.Prescott.

DESCRIPTION:
	Program to Distribute GST.

MODIFICATIONS:        

Programmer     YY/MM/DD       Description of modification

------------------------------------------------------------------------*/
#define	MAIN		/* Main program. This is to declare Switches */
#define MAINFL		GSTDIST		/* main file used */

#define	SYSTEM		"GENERAL LEDGER"	/* Sub System Name */
#define	MOD_DATE	"07-MAY-91"		/* Progran Last Modified */

#include <stdio.h>
#include <cfomstrc.h>
#include <bfs_defs.h>
#include <bfs_recs.h>

#define	DELTA_AMT  0.005	/* To Check double values for zero */
#define	DELTA_QTY  0.00005	/* To Check double values for zero */

/* User Interface define constants */
#ifdef ENGLISH
#define ADDREC		'A'
#define CHANGE		'C'
#define DELETE		'D'
#define INQUIRE		'I'
#define NEXT		'N'
#define PREV		'P'
#define EXITOPT		'E'

#define	YES		'Y'
#define NO		'N'

#define ADDITEM		'A'
#define	CANCEL		'C'
#define REACTIVATE	'R'

#define ACTIVE		"ACT"
#define DELETED		"DEL"

#else
#define ADDREC		'R'
#define CHANGE		'C'
#define DELETE		'E'
#define INQUIRE		'I'
#define NEXT		'S'
#define PREV		'P'
#define EXITOPT		'F'

#define	YES		'O'
#define NO		'N'

#define ADDITEM		'R'
#define	CANCEL		'A'
#define REACTIVATE	'V'

#define ACTIVE		"ACT"
#define DELETED		"ELI"

#endif

/* PROFOM Releted declarations */

#define	SCR_NAME	"gstdist"	/* PROFOM screen Name */

#define	PAGESIZE	15		/* No of Items */

/* PROFOM Screen STH file */

/* Field PROFOM numbers */

#define HDR_ST_FLD	900
#define HDR_END_FLD	1000

#define	ITEM_ST_FLD	1100	/* Item 1 Start Field */
#define	END_FLD		5700	/* Last Field of the screen */
#define	STEP		300	/* NO of fields diff. between 2 items */

/* HDR Fields */
#define	FN_FLD		400	/* Fn: */
#define	KEY_START	500	/* Fund Number */
#define	KEY_END		600	/* Gst Account Number */
#define	CHG_FLD		700	/* Field: */
#define PAGE_FLD	800	/* Page: */

/* Item Fields. These numbers are difference between that field
   and the 1st fld within the item */
#define	ACCT_FLD	0
#define DESC_FLD	100
#define STATUS_FLD	200

/* Message/Response Fields */
#define MESSAGE_FLD	5600
#define RESP_FLD	5700

/* gstdist.sth - header for C structure generated by PROFOM EDITOR */

typedef	struct	{	/* Start Fld 1100, Endfld 5500 and Step 300 */

	char	s_accno[19];     /* STRING X(18)	Field 1100 */
	char	s_desc[49];  	 /* STRING X(48)	Field 1200 */
	char	s_status[4];	 /* STRING XXX          Field 1300 */
}	S_item ;

typedef struct	{

	char	s_pgm[11];	/* STRING XXXXXXXXXX   Field 100 */
	long	s_rundate;	/* DATE YYYYFMMFDD     Field 300 */

	char	s_fn[2];	/* STRING X            Field 400 */
	short	s_fund;		/* NUMERIC 999	       Field 500 */
	char	s_gst_accno[19];/* STRING X(18)        Filed 600 */
	short	s_field;	/* NUMERIC 99          Field 700 */

	short	s_page;		/* NUMERIC 999	       Field 900 */
	char	s_dummy[4];	/* STRING XXX	       Field 1000 */

	S_item	s_items[PAGESIZE] ;	/* Start Fld 1100, End Fld 5500 and
					   Step 300 */

	char	s_mesg[78];	/* STRING X[77] Field 5600 */
	char	s_resp[2];	/* STRING X Field 5700 */
} s_struct;


static	s_struct  s_sth;	/* PROFOM Screen Structure */
static	struct  stat_rec  sr;		/* PROFOM status rec */

static	Gl_rec		gl_rec ;	/* G/L Master File */
static	GST_dist	gst_rec,tmp_gstrec;	/* GST distribution record */
static	Ctl_rec		ctl_rec ;
static  Pa_rec		pa_rec ;	/* Parameter Record */

static	char 	e_mesg[100];  		/* dbh will return err msg in this */

/*
*	Doubly linked list to maintain items. Each node in this list
*	conatins one page full of items. This list is freed only at the
*	time of exiting program. 
*/

typedef	struct Page {

	S_item	Items[PAGESIZE] ;	/* Items information */
	struct	Page	*PrevPage ;	/* Ptr to Previous Page */
	struct	Page	*NextPage ;	/* Ptr to Next Page */
	short	NoItems ;		/* No of Items in this page */
	short	Pageno ;		/* Page Number */

}	Page ;

static	Page	*FirstPage,		/* Address of the First Page */
		*CurPage,		/* Address of the Active Page */
		*AcctLast,		/* Address of Cur. Acct. Last page */
		*LastPage ;		/* Address of the Last page Memory
					   allocated */
int	KeyAndHdrValidation() ;
int	HdrAndKeyWindowHelp() ;
int	ItemsValidation();
int	ItemsWindowHelp();

void	free() ;
char	*malloc() ;
static	int	totalitemsadded;

main(argc,argv)
int argc;
char *argv[];
{
	int 	retval;

	retval = Initialize(argc,argv);	/* Initialization routine */

	if (retval == NOERROR) retval = Process();

	CloseRtn();			/* return to menu */
	if (retval != NOERROR) exit(-1);
	exit(0);
}

/*-------------------------------------------------------------------*/
/* Initialize PROFOM */

Initialize(argc, argv)
int	argc ;
char	*argv[] ;
{
	int	err ;

	/*
	*	Initialize DBH Environment
	*/
	strncpy(SYS_NAME,SYSTEM,50);	/* Sub system name */
	strncpy(CHNG_DATE,MOD_DATE,10);	/* Modification Date */

	proc_switch(argc, argv, MAINFL) ; 	/* Process Switches */

	/*
	*	Initialize PROFOM & Screen
	*/
	STRCPY(sr.termnm,terminal);	/* Copy Terminal Name */
	fomin(&sr);
	ret(err_chk(&sr)) ;		/* Check for PROFOM Error */
	fomcf(1,1);			/* Enable Snap screen option */

	err = InitScreen() ;		/* Initialize Screen */
	if(NOERROR != err) return(err) ;

	/*
	*	Get The Parameter Record
	*/
	err = get_param(&pa_rec, BROWSE, 1, e_mesg) ;
	if(err == ERROR) {
		DispError(e_mesg);
		return(ERROR) ;
	}
	else if(err == UNDEF) {
#ifdef ENGLISH
		DispError("Parameters Are Not Set Up ...");
#else
		DispError("Parametres ne sont pas etablis... ");
#endif
		return(ERROR) ;
	}

	/*
	*	Initialize Variables
	*/

	FirstPage = NULL ;
	LastPage  = NULL ;

	return(NOERROR) ;
}	/* Initialize() */

/*--------------------------------------------------------------------------*/
/* Close nessary files and environment before exiting program               */

CloseRtn() 
{
	/* Free the linked list from the end */

	/* Free all the pages except the first page */
	for( ; LastPage != FirstPage ; ) {
		LastPage = LastPage->PrevPage ;
		free((char*)LastPage->NextPage) ;
		LastPage->NextPage = NULL ;
	}
	if(FirstPage != NULL)
		free((char*)FirstPage) ;
		
	FirstPage = LastPage = NULL ;

	/* Set terminal back to normal mode from PROFOM */
	fomcs();
	fomrt();

	close_dbh();	/* Close files */

	return(NOERROR);
}	/* CloseRtn() */
/*----------------------------------------------------------------*/
/* Initialize screen before going to process options */

InitScreen()
{
	int	err ;

	/* move screen name to Profom status structure */
	STRCPY(sr.scrnam,NFM_PATH);
	strcat(sr.scrnam,SCR_NAME) ;

	STRCPY(s_sth.s_pgm,PROG_NAME);

	s_sth.s_rundate = get_date();	/* get Today's Date in YYYYMMDD format*/
	s_sth.s_field = HV_SHORT ;
	s_sth.s_mesg[0] = HV_CHAR ;
	s_sth.s_resp[0] = HV_CHAR ;

	/* set fields to lowest value in case 'N' select first thing */
	s_sth.s_fund = 0;
	s_sth.s_gst_accno[0] = '\0';
	gst_rec.accno[0] = '\0';

	/* Move High Values to data fields and Display the screen */
	err = ClearScreen() ;
	if(NOERROR != err) return(err) ;

	return(NOERROR) ;
}	/* InitScreen() */

/*-------------------------------------------------------------------*/
/* Get Option from user and call corresponding function */

Process()
{
	int err;

	for( ; ; ){

		/* Get the Fn: option from the user */
		if((err = ReadFunction()) != NOERROR) return(err) ;

		err = ProcFunction() ;	/* Process Function */

		if(QUIT == err)		return(NOERROR) ;    /* Exit */
		if(NOACCESS == err)	fomen(e_mesg);	     /* security */
		if(PROFOM_ERR == err)	return(PROFOM_ERR);  /* PROFOM ERROR */
		if(DBH_ERR == err) {
			DispError(e_mesg);
#ifdef ENGLISH
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"System Error... Iserror:",
				iserror, dberror, errno);
#else
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"Erreur du systeme... Iserror:",
				iserror, dberror, errno);
#endif
			DispError(e_mesg);
			return(DBH_ERR); /* DBH ERROR */
		}
	}      /*   end of the for( ; ; )       */
}	/* Process() */
/*----------------------------------------------------------------*/
/* Display the Function (Fn:) options and get the option from the user */

ReadFunction()
{
	/* Display Fn: options */
#ifdef ENGLISH
	fomer("A(dd), C(hange), I(nquire), N(ext), P(rev), E(xit)");
#else
	fomer("R(ajouter), C(hanger), I(nterroger), S(uivant), P(recedent), F(in)");
#endif
	/* Read Fn: field to get the option */
	sr.nextfld = FN_FLD ;
	fomrf( (char *)&s_sth );
	ret(err_chk(&sr));	/* Check for PROFOM error */

	return(NOERROR) ;
}	/* ReadFunction() */
/*----------------------------------------------------------------*/
/* Process the user selected Fn: option */

ProcFunction()
{
	int retval;

	switch (s_sth.s_fn[0]) {
	case ADDREC  :			/* ADD */
		CHKACC(retval,ADD,e_mesg);
		return( AddGstDist() ) ;
	case DELETE  :			/* DELETE */
		CHKACC(retval,UPDATE,e_mesg);
		return( DeleteGstDist() ) ;
	case CHANGE  :			/* CHANGE */
		CHKACC(retval,UPDATE,e_mesg);
		return( ChangeGstDist() ) ;
	case INQUIRE  :		
		CHKACC(retval,BROWSE,e_mesg);
		return( Inquire() ) ;
	case NEXT  :			
		CHKACC(retval,BROWSE,e_mesg);
		return( NextGstAcct(FORWARD) ) ;
	case PREV  :		
		CHKACC(retval,BROWSE,e_mesg);
		return( NextGstAcct(BACKWARD) ) ;
	case EXITOPT  :			/* Exit */
		return( QUIT ) ;
	}  /*   end of the switch statement */

	return(retval);
}	/* ProcFunction() */
/*----------------------------------------------------------------------*/
/* Get receipt to Apply to invoices */

AddGstDist()
{
	int	err;

	err = SelectGstAcct(ADD);
	if(err != NOERROR) {
		return(err);
	}

	CurPage = NULL;
	AcctLast = NULL;

	err = ClearScreen();
	if(err != NOERROR) {
		return(err);
	}

	err = GetDetails() ;
	if(PROFOM_ERR == err || DBH_ERR == err) return(err) ;
	if(err < 0 || CANCEL == err) {
		roll_back(e_mesg) ;	/* Unlock the locked Records */
		return(ClearScreen()) ;	/* Clear the Screen */
	}

	return(NOERROR);
}	/* AddGstDist() */
/*----------------------------------------------------------*/
/* Get the Gst Account */
SelectGstAcct(mode)
int	mode;
{
	int	err ;

	for(; ;){
		err = ReadKey();
		if(err != NOERROR) return(err) ;

		/* Get the record from database */
		err = GetGstAcct(BROWSE);
		if(err == UNDEF || err == LOCKED) continue;
		if(ERROR == err) return(err) ;

		if(mode == BROWSE) {
			err = ShowGstAcct();
			if(err != NOERROR) return(err);
		}
		break;
	}
	return(NOERROR);
}	/* SelectGstAcct() */
/*----------------------------------------------------------------------*/
ReadKey()
{
	int	i;
	short	temp_fund;
	char	temp_acct[19];
	
	s_sth.s_fund = 1;
	/* In Add mode turn off dup control for key fields.
	   Other modes reverse it */
	if(s_sth.s_fn[0] == ADDREC){	/* ADD */
		SetDupBuffers(KEY_START,KEY_END,0); /* Off Dup Control */
		SetDupBuffers(KEY_START,KEY_START,2); /* Off Dup Control */
	}
	else {
		SetDupBuffers(KEY_START,KEY_END,2);
	}

	/* Store fields to copy back when user gives ESC-F */
	temp_fund = s_sth.s_fund ;
	STRCPY(temp_acct,s_sth.s_gst_accno);

	s_sth.s_fund = LV_SHORT ;
	s_sth.s_gst_accno[0] = LV_CHAR;

#ifdef ENGLISH
	STRCPY(s_sth.s_mesg,"Press ESC-F to Go Back to Fn:");
#else
	STRCPY(s_sth.s_mesg,"Appuyer sur ESC-F pour retourner a Fn:"); 
#endif
	ShowMesg();

	i = ReadFields(KEY_START, KEY_END,
		KeyAndHdrValidation, HdrAndKeyWindowHelp,0) ;
	if(PROFOM_ERR == i || DBH_ERR == i) return(i) ;
	if(RET_USER_ESC == i){
		/* copy back key fields */
		s_sth.s_fund = temp_fund ;
		STRCPY(s_sth.s_gst_accno,temp_acct);
		ret( WriteFields(KEY_START, KEY_END) ) ;

		s_sth.s_mesg[0] = HV_CHAR;
		ShowMesg();

		return(RET_USER_ESC) ;
	}

	return(NOERROR);
}	/*  ReadKey() */
/*------------------------------------------------------------*/
/* Get Gst Account for gl master file */
GetGstAcct(mode) 
int	mode;
{
	int err;
	
	gst_rec.fund = s_sth.s_fund;
	STRCPY(gst_rec.gst_accno,s_sth.s_gst_accno);
	STRCPY(gst_rec.accno,"\0");
	flg_reset(GSTDIST);	/* Initialize to get first rec under givenkey */
	err = get_n_gstacct( &gst_rec, BROWSE, 0, FORWARD, e_mesg);

	if(err != NOERROR) {
		fomen(e_mesg);
		get();
		return(err);
	}

	if((gst_rec.fund != s_sth.s_fund) ||
	   (strcmp(gst_rec.gst_accno,s_sth.s_gst_accno) != 0)) {
		fomen("Gst Account Number Does Not Exist");
		get();
		return(ERROR);
	}

	return(NOERROR);

/*
	return(get_gl(&gl_rec,BROWSE,0,e_mesg));
*/
}
/*------------------------------------------------------------*/
/* Read Item Details from the User */
AddItems()
{
	int	i, err ;

	/* If the last node of po is Partial filled then Show Page */
	if(AcctLast != NULL && AcctLast->NoItems < PAGESIZE ) {
		ret( ShowItems(AcctLast) ) ;
		i = AcctLast->NoItems ;
		CurPage = AcctLast ;
	}
	else {
		/* Calculate the page# */
		if(AcctLast != NULL) {
			i = PAGESIZE ;
			CurPage = AcctLast ;
		}
		else {
			s_sth.s_page = 1 ;
			s_sth.s_dummy[0] = ' ' ;
			ret( WriteFields(PAGE_FLD, HDR_END_FLD) ) ;
			i = 0 ;
		}
	}


	for( ; ; ) {
		if( PAGESIZE == i) {	/* Page Full */

			/* Move High Values to All items except first */
			for(i-- ; i > 0 ; i--)
				InitItem(i, HV_CHAR, HV_SHORT, HV_DOUBLE) ;

			/* Calculate the page# */
			s_sth.s_page = AcctLast->Pageno + 1 ;

			ret( WriteFields(PAGE_FLD, (END_FLD - 200)) ) ;

			i = 0 ;
		}

		err = ReadItem(i,ADD) ;		/* Read Each Item Line */
		if(PROFOM_ERR == err || DBH_ERR == err) return(err) ;
		if(NOERROR != err) break ;	/* ESC-F */

		if(0 == i)	/* First Item in the Page */
			if((err = MakeFreshPage()) < 0) return(err) ;
		
		/* Copy the Item to List */
		scpy((char*)&(CurPage->Items[i]), (char*)&(s_sth.s_items[i]),
			sizeof(S_item)) ;

		i++ ;

		CurPage->NoItems = i;
	}
	if(i == 0) 
		if((err=ShowItems(CurPage))<0) return(err) ;

	return(NOERROR) ;
}	/* AddItems() */
/*------------------------------------------------------------*/
/* Read details of given item# */

ReadItem(item_no,mode)
int	item_no ;
int	mode ;
{
	int	i, j, k ;
	int	st_fld ;
	int	end_fld ;
	totalitemsadded = 1;

#ifdef ENGLISH
	STRCPY(s_sth.s_mesg,"Press ESC-F to Terminate");
#else
	STRCPY(s_sth.s_mesg,"Appuyer sur ESC-F pour terminer");
#endif
	ShowMesg();

	st_fld  = ITEM_ST_FLD + (STEP * item_no) ;
	end_fld = st_fld + STEP - 100 ;

	/* if Update mode subtract value of item entered then later
	   add value of new item */

	/* If mode == UPDATE turn ON dup control, else OFF */
	SetDupBuffers(st_fld,end_fld,(mode == UPDATE) ? 1 : 0); 

	/* Initialize Reading Item with Low values */
	InitItem(item_no, LV_CHAR, LV_SHORT, LV_DOUBLE) ;

	STRCPY(s_sth.s_items[item_no].s_status,ACTIVE);

	i = ReadFields(st_fld,end_fld,ItemsValidation,ItemsWindowHelp,mode) ;
	if(PROFOM_ERR == i || DBH_ERR == i) return(i) ;
	if(RET_USER_ESC == i) {
		if(ADD == mode) {	/* Terminating the ADD */
			InitItem(item_no, HV_CHAR, HV_SHORT, HV_DOUBLE) ;
			ret( WriteFields(st_fld, end_fld) );
			return(RET_USER_ESC) ;
		}
		/*
		* When user gives ESC-F while changing fields, assumption is
		* he completed his changes, and remaining fields are same as
		* old. But, at this point STH will be having low values in the 
		* remaining fields. So move the old values form the linked list.
		*/

		/* Get Offset of the begining field of the Item in 'k' */
		fomfp(st_fld,&k,&j) ;
		/* Offset to the field where ESC-F Pressed in 'j' */
		fomfp(sr.curfld,&j,&i);
		i =  j - k ;	/* Offset within item */

		j = sizeof(S_item) - i ;  /* Length to copy */
       		scpy((char *)(&s_sth.s_items[item_no])+i,
			(char*)(&CurPage->Items[item_no])+i, j);

		return(RET_USER_ESC) ;
	}
	else totalitemsadded++;

	return(NOERROR) ;
}	/* ReadItem() */
/*-----------------------------------------------------------------------*/
WriteRecords()
{

	int 	i, err;
	Page	*temppage;

	/* initialze to no items written */
	if (totalitemsadded < 1 ) {
		fomen("No Items to Save. Cancel to Quit");
		return(LOCKED);
	}

	/* Copy Items and write to the file */
	if(AcctLast != NULL) {
		for(temppage = FirstPage ; temppage != NULL ;
					temppage = temppage->NextPage) {
			for(i = 0; i < temppage->NoItems ; i++) {
				err = ProcItemUpdates(temppage, i) ;
				if(err==LOCKED) {
					DispError(e_mesg);
					roll_back(e_mesg) ;
					return(LOCKED) ;
				}
				if(err != NOERROR) break ;
			}
			/* IF the process is done upto Current Acct Last Page,
			   then break */
			if(temppage == AcctLast) break ;
		    }
	}

	if(err == NOERROR)
		err = commit(e_mesg) ;
	if(err < 0) {
#ifdef ENGLISH
		DispError("ERROR in Saving Records"); 
#else
		DispError("ERREUR en conservant les fiches");
#endif
		DispError(e_mesg);
		return(err);
	}
	return(NOERROR);
}
/*-----------------------------------------------------------------------*/
ProcItemUpdates(temppage,item_no)
Page	*temppage ;
int	item_no;
{
	int 	mode, err;

	gst_rec.fund = s_sth.s_fund;
	strcpy(gst_rec.gst_accno,s_sth.s_gst_accno);
	strcpy(gst_rec.accno,temppage->Items[item_no].s_accno);
	err = get_gstacct(&gst_rec,UPDATE, 0, e_mesg);

	if(err == UNDEF) 
		mode = ADD ;
	else { if(err < 0) {
			DispError(e_mesg) ;
			return(DBH_ERR) ;
		}
		else mode = UPDATE;
	}

	scpy((char *)&tmp_gstrec,(char *)&gst_rec,sizeof(gst_rec));

	if(strcmp(temppage->Items[item_no].s_status,DELETED)==0) {
		if(mode == ADD) { 
			return(NOERROR);
		}
		else {
			mode = P_DEL;
		}
	}

	if(s_sth.s_fn[0] == DELETE) {
		mode = P_DEL;
	}

	err = UpdateWithGstAcct(mode,temppage->Items[item_no]);
	if (err < 0) return(err) ;

	return(NOERROR) ;
}	/* ProcItemUpdates() */
/*-----------------------------------------------------------------------*/ 
/* Updating files  */
UpdateWithGstAcct(mode,s_item)
int	mode ;
S_item 	s_item ;
{
	int 	err ;
	short	i;

		/* for UPDATE mode, the original value remains the amount
		   originally entered not the current value. */
	if(mode != P_DEL) {
		gst_rec.fund = s_sth.s_fund;
		STRCPY(gst_rec.gst_accno,s_sth.s_gst_accno);
		STRCPY(gst_rec.accno,s_item.s_accno);
	}
	err = put_gstacct(&gst_rec, mode,e_mesg) ;
	if(err < 0) {
		DispError(e_mesg) ;
		return(DBH_ERR) ;
	}

	if(s_sth.s_fn[0] == CHANGE && mode != ADD) {
		err = rite_audit((char*)&s_sth, GSTDIST,mode,(char*)&gst_rec,
					(char*)&tmp_gstrec,e_mesg);
		if(err==LOCKED) {
			DispError(e_mesg);
			roll_back(e_mesg) ;
			return(LOCKED) ;
		}
		if(err != NOERROR){
#ifdef	ENGLISH
			DispError("ERROR in Saving Records"); 
#else
			DispError("ERREUR en conservant les fiches");
#endif
			DispError(e_mesg);
			roll_back(e_mesg);
			return(DBH_ERR);
		}
	}

	return(NOERROR) ;
}	/* UpdateWithReqItem() */
/*-----------------------------------------------------------------------*/
DeleteGstDist() 
{
	int	err;

	err = SelectGstAcct(BROWSE);
	if(err != NOERROR) return(err);

	for( ; ; ) {
		err = ConfirmItems() ;
		if(err != YES) {
			break;
		}

		err = WriteRecords();
		if(err < 0) {
			if(err == LOCKED) continue;
			break;
		}
		break;
	}
	
	return(NOERROR);
}
/*-----------------------------------------------------------------------*/
ChangeGstDist() 
{
	int	err;

	err = SelectGstAcct(BROWSE);
	if(err != NOERROR) return(err);

	for( ; ; ) {
		err = ConfirmItems() ;
		if(err != YES) {
			break;
		}

		err = WriteRecords();
		if(err < 0) {
			if(err == LOCKED) continue;
			break;
		}
		break;
	}
	
	return(NOERROR);
}
/*-----------------------------------------------------------------------*/
Inquire()
{
	int 	err;

	err = SelectGstAcct(BROWSE);
	if(err != NOERROR) return(err);

	err = ConfirmItems() ;
	if(err < 0) return(err) ;

	return(NOERROR) ;
}	/* Inquire() */
/*----------------------------------------------------------*/
/* Show the next or previous receipt */

NextGstAcct(direction)
int	direction ;
{
	int err;

	/* Check whether file is in seq. read mode */
	if(flg_start(GSTDIST) != direction) {
		gst_rec.fund = s_sth.s_fund;
		STRCPY(gst_rec.gst_accno,s_sth.s_gst_accno);
		inc_str(gst_rec.gst_accno,sizeof(gst_rec.gst_accno)-1,
			direction);
		STRCPY(gst_rec.accno,"\0");
		flg_reset(GSTDIST);
	}

	err = get_n_gstacct(&gst_rec, BROWSE, 0, direction, e_mesg);
#ifndef ORACLE
	seq_over(GSTDIST);
#endif
	if(ERROR == err)return(DBH_ERR) ;
	if(EFL == err) {
#ifdef	ENGLISH
		fomen("No More Records....");
#else
		fomen("Plus de fiches....");
#endif
		get();
		flg_reset(GSTDIST);
		return(NOERROR) ;
	}

	/* initialize  screens to ShowGstAcct can find all the accounts */
	s_sth.s_fund = gst_rec.fund;
	STRCPY(s_sth.s_gst_accno,gst_rec.gst_accno);
	ret( WriteFields(KEY_START, KEY_END) ) ;

	return( ShowGstAcct() ) ;
}	/* NextGstAcct() */
/*-----------------------------------------------------------------------*/
/* Get Item Details.							 */
GetDetails()
{
	int	err;

	err = AddItems();
	if(err != NOERROR) {
		return(err);
	}

	for( ; ; ) {
		err = ConfirmItems() ;
		if(err != YES) {
			break;
		}

		err = WriteRecords();
		if(err < 0) {
			if(err == LOCKED) continue;
			break;
		}
		break;
	}
	if(err != NOERROR) return(err);
	return(NOERROR);
}	/* GetDetails() */
/*-----------------------------------------------------------------------*/
MakeGstItemsList()
{
	int err, i;

	gst_rec.fund = s_sth.s_fund ;
	STRCPY(gst_rec.gst_accno,s_sth.s_gst_accno);
	STRCPY(gst_rec.accno,"\0");
	flg_reset(GSTDIST);	/* Initialize to get first rec under givenkey */

	AcctLast = CurPage = NULL ;
	i = 0 ;

	for( ; ; ){
#ifndef ORACLE
		err = get_n_gstacct( &gst_rec, BROWSE, 0, FORWARD, e_mesg);
#else
		err = get_n_gstacct( &gst_rec, BROWSE, 0, EQUAL, e_mesg);
#endif
		
		if(ERROR == err) return(DBH_ERR) ;
		if(EFL == err) { 
			if(CurPage = NULL) 
				return(EFL);
			else
				break ;
		}

#ifndef ORACLE
		/* If PO changes break */
		if( gst_rec.fund != s_sth.s_fund) break ;
		if( strcmp(gst_rec.gst_accno,s_sth.s_gst_accno) != 0) break ;
#endif

		if(PAGESIZE == i) i = 0 ;
		if(0 == i)		/* 1st Item in the Page */
			if((err = MakeFreshPage()) < 0) return(err) ;

		STRCPY(CurPage->Items[i].s_accno, gst_rec.accno) ;

		err = CheckGlAcnt(gst_rec.accno) ;
		if(DBH_ERR == err) return(err) ;
		if(err < 0) {
			return(err) ;
		}

		STRCPY(CurPage->Items[i].s_desc,gl_rec.desc);

		STRCPY(CurPage->Items[i].s_status,ACTIVE);

		CurPage->NoItems++ ;
		i++ ;
	} 
	seq_over(GSTDIST) ;
	
	totalitemsadded = CurPage->NoItems ;

	if(AcctLast != NULL)
		CurPage = FirstPage ;

	return(NOERROR) ;
}	/* MakeGstItemsList() */
/*-----------------------------------------------------------------------*/
/*	Get the next node in linked list to add invoice items. If the
*	(Cur. invc last page) = (Last Page in linked List) or no
*	nodes in list, allocate node and add to linked list
*/

MakeFreshPage()
{
	Page	*tempptr ;

	/* If, no node is allocated yet or Current invoice used all the nodes,
	   then allocate new node */

	if( LastPage == NULL || AcctLast == LastPage ){
		tempptr= (Page *)malloc((unsigned)sizeof(Page)) ;

		if( tempptr == NULL ){
#ifdef ENGLISH
			DispError("MEMORY ALLOCATION ERROR...");
#else
			DispError("ERREUR D'ALLOCATION A LA MEMOIRE...");
#endif
			return(ERROR);
		}
		tempptr->NextPage = NULL ;

		if( LastPage == NULL ){	/* No node is allocated Yet */
			tempptr->PrevPage = NULL ;
			tempptr->Pageno = 1 ;
			FirstPage = tempptr ;
		}
		else {				/* Not a first node in list */
			tempptr->Pageno = LastPage->Pageno + 1 ;
			LastPage->NextPage = tempptr ;
			tempptr->PrevPage = LastPage ;
		}
		LastPage = tempptr ;
	}

	if(AcctLast == NULL)
		AcctLast = FirstPage ;
	else
		AcctLast = AcctLast->NextPage ;

	AcctLast->NoItems = 0 ;
	CurPage = AcctLast ;

	return(NOERROR);
}	/* MakeFreshPage() */
/*------------------------------------------------------------*/
/* Show Screen */
ShowGstAcct() {
	
	int	err;

	/* Make Items Linked List from gst file */
	if((err = MakeGstItemsList()) <0) return(err);

	if((err = ShowItems(CurPage)) < 0) return(err);

	return(NOERROR);
}
/*------------------------------------------------------------*/
/* Show all the items on the current page 		      */
ShowItems(pageptr)
Page	*pageptr ;
{
	int	i ;

	if(pageptr != NULL) {
		/* Copy the items to screen */
		scpy((char*)s_sth.s_items, (char*)pageptr->Items,
			(pageptr->NoItems * sizeof(S_item)) );

		s_sth.s_page   = pageptr->Pageno ;

		s_sth.s_dummy[0] = ' ' ;

		i = pageptr->NoItems ;
	}
	else {
		s_sth.s_page   = HV_SHORT ;
		s_sth.s_dummy[0] = HV_CHAR ;
		i = 0 ;
	}

	/* Move High Values to remaining Items */
	for( ; i < PAGESIZE ; i++ )
		InitItem(i, HV_CHAR, HV_LONG, HV_DOUBLE) ;

	ret( WriteFields( PAGE_FLD, (END_FLD - 200)) );

	return(NOERROR) ;
}	/* ShowItems() */
/*------------------------------------------------------------*/
ConfirmItems()
{
	int	err ;
	char	chg_status[4];

	/* Options:
	   Add      - YAENPC
	   Delete   - YC
	   Change   - YAEHSTNPC
	   Inquiry  - YNPH
	*/

	for( ; ; ) {
	    switch(s_sth.s_fn[0]) {
	    case  ADDREC :		/* Add Apply */
	    case  CHANGE :		/* Change */
#ifdef ENGLISH
		err = GetOption(
		"Y(es), A(dd Item), D(elete), R(eactivate), N(ext), P(rev), C(ancel)"
		,"YADRNPC");
#else
		err = GetOption(
		"O(ui), R(aj. article), E(lim), V(ivifier), S(uiv), P(rec), A(nnul)"
		,"ORNSPA");
#endif
		break ;
	    case DELETE :
#ifdef ENGLISH
		err = GetOption( "Y(es), C(ancel)","YC");
#else
		err = GetOption("O(ui), A(nnul)","OA");
#endif
		break ;

	    case INQUIRE :
#ifdef ENGLISH
		err = GetOption("Y(es), N(ext Page), P(rev Page)","YNP");
#else
		err = GetOption("O(ui), S(uivant), P(rec)","OSP");
#endif
		break ;
	    }
	    if(err == PROFOM_ERR) return(err) ;

	    switch(err) {
	    case  YES  :
		return(YES);
	    case  ADDITEM:
		err = AddItems();
		break;
	    case  DELETE:
	    case  REACTIVATE:
		err = ChangeStatus(err);
		break;
	    case  NEXT:
		if(CurPage == AcctLast || AcctLast == NULL) {
#ifdef ENGLISH
			fomer("No More Pages....") ;
#else
			fomer("Plus de pages....") ;
#endif
			continue ;
		}
		CurPage = CurPage->NextPage ;
		err = ShowItems(CurPage) ;
		break ;
	    case  PREV:
		if(AcctLast == NULL || CurPage == FirstPage ) {
#ifdef ENGLISH
			fomer("No More Pages....") ;
#else
			fomer("Plus de pages....") ;
#endif
			continue ;
		}
		CurPage = CurPage->PrevPage ;
		err = ShowItems(CurPage) ;
		break ;
	    case  CANCEL :
#ifdef ENGLISH
		err = GetOption("Confirm the Cancel (Y/N)?", "YN") ;
#else
		err = GetOption("Confirmer l'annulation (O/N)?", "ON") ;
#endif
		if(err == YES) return(CANCEL) ;
		break ;
	    }	/* switch err */

	    if(err == PROFOM_ERR) return(err) ;
	    if(err == DBH_ERR) return(err) ;
	}	/* for(; ; ) */
}	/* ConfirmItems() */
/*------------------------------------------------------------*/
/* Change Status. 					      */
ChangeStatus(status)
int	status;
{
	int	flag, err ;

	/* Get The Item to Be Modified */

	for( ; ; ) {
#ifdef ENGLISH
		STRCPY(s_sth.s_mesg,"Press RETURN to terminate Edit");
#else
		STRCPY(s_sth.s_mesg,"Appuyer sur RETURN pour terminer l'ajustement");
#endif
		ShowMesg() ;
		sr.nextfld = CHG_FLD ;
		fomrf( (char *)&s_sth );
		ret(err_chk(&sr));

		if(s_sth.s_field == 0) break ;
		if( s_sth.s_field < 1 || CurPage == NULL ||
				s_sth.s_field > CurPage->NoItems)
			continue ;

		if(status == REACTIVATE) {
			if(strcmp(s_sth.s_items[s_sth.s_field-1].s_status,
  			          ACTIVE)==0) {
#ifdef ENGLISH
				fomer("Item is already Active");
#else
				fomer("Article deja actif");
#endif
			}
			else {
				strcpy(s_sth.s_items[s_sth.s_field-1].s_status,
  			               ACTIVE);
				/* Update Linked List */
				strcpy(CurPage->Items[s_sth.s_field-1].s_status,
  			               ACTIVE);
				sr.nextfld = ((s_sth.s_field-1)*STEP) + 
					ITEM_ST_FLD + STATUS_FLD;
				fomwf((char *)&s_sth);
				ret(err_chk(&sr));
				totalitemsadded++;
			}
		}
		else {
			if(strcmp(s_sth.s_items[s_sth.s_field-1].s_status,
  			          DELETED)==0) {
#ifdef ENGLISH
				fomer("Item is already Deleted");
#else
				fomer("Article deja elimine");
#endif
			}
			else {
				strcpy(s_sth.s_items[s_sth.s_field-1].s_status,
  			               DELETED);
				/* Update Linked List */
				strcpy(CurPage->Items[s_sth.s_field-1].s_status,
  			               DELETED);
				sr.nextfld = ((s_sth.s_field-1)*STEP) + 
					ITEM_ST_FLD + STATUS_FLD;
				fomwf((char *)&s_sth);
				ret(err_chk(&sr));
				totalitemsadded--;
			}
		}
	}

	sr.nextfld = CHG_FLD ;
	s_sth.s_field = HV_SHORT ;
	fomwf( (char *)&s_sth );
	ret(err_chk(&sr));

	s_sth.s_mesg[0] = HV_CHAR;
	ShowMesg();
	return(NOERROR);
}
/*------------------------------------------------------------*/
/* Read the PROFOM Screen for a given Range of fields */

static
ReadFields(st_fld, end_fld, Validate, WindowHelp, mode)
int	st_fld ;
int	end_fld;
int	(*Validate)() ;
int	(*WindowHelp)() ;
int	mode ;	/* ADD or UPDATE. This is required only when reading item */
{
	int	err ;

	sr.nextfld = st_fld ;
	sr.endfld  = end_fld;
	for( ; ;){
		fomrd( (char *)&s_sth );
		ret(err_chk(&sr));

		if(sr.retcode == RET_VAL_CHK){
			err = (*Validate)(mode) ;
			if(DBH_ERR == err || PROFOM_ERR == err) return(err);
			sr.nextfld = sr.curfld ;
			continue;
		}
		if(sr.retcode == RET_USER_ESC){
			if(sr.escchar[0] == 'f' || sr.escchar[0] == 'F')
				return(RET_USER_ESC) ;
			if(sr.escchar[0] == 'h' || sr.escchar[0] == 'H'){
				err = (*WindowHelp)() ;
				if(DBH_ERR == err || PROFOM_ERR == err)
					return(err) ;
				sr.nextfld = sr.curfld ;
				continue;
			}
			continue;
		}
		/* else RET_NO_ERROR */
		break;
	}

	return(NOERROR) ;
}	/* ReadFields() */
/*------------------------------------------------------------*/
/* Write fields on Screen for a given Range */

static
WriteFields(st_fld, end_fld)
int	st_fld ;
int	end_fld ;
{
	sr.nextfld = st_fld ;
	sr.endfld  = end_fld ;

	fomwr( (char *)&s_sth );
	ret(err_chk(&sr));

	return(NOERROR) ;
}	/* WriteFields() */
/*----------------------------------------------------------------*/
/* Set Duplication buffers for fields 				  */
SetDupBuffers( firstfld, lastfld, value )
int	firstfld, lastfld;	/* field numbers range */
int	value;			/* ENABLE or DISABLE */
{
	int i;

	for( i=firstfld; i<=lastfld; i+=100 )
		fomca1( i, 19, value);
	if( value==0 )
		return(0);
	sr.nextfld = firstfld;
	sr.endfld = lastfld;
	fomud( (char *)&s_sth );
	ret( err_chk(&sr) );

	return( 0 );
}
/*----------------------------------------------------------------*/
/* Validation function() for Key and Header fields when PROFOM returns
  RET_VAL_CHK */

KeyAndHdrValidation(mode)
int	mode;
{
	int	err ;

	switch(sr.curfld){
	case	KEY_START	:	/* fund number */
		err = CheckFund(s_sth.s_fund) ;
		if(DBH_ERR == err) return(err) ;
		if(ERROR == err) {
			s_sth.s_fund = LV_SHORT ;
			return(ERROR) ;
		}
		fomer(ctl_rec.desc);
		break;
	case 	KEY_END		:	/* Gst Account Number */
		if (acnt_chk(s_sth.s_gst_accno) < 0)  {
			s_sth.s_gst_accno[0] = LV_CHAR ;
#ifdef ENGLISH
			fomer("Invalid GL Account Number");
#else
			fomer("Numero de compte G/L invalide");
#endif
			return(ERROR) ;
		}
		err = CheckGlAcnt(s_sth.s_gst_accno) ;
		if(DBH_ERR == err) return(err) ;
		if(err < 0) {
			s_sth.s_gst_accno[0] = LV_CHAR ;
			return(ERROR) ;
		}

		gst_rec.fund = s_sth.s_fund;
		STRCPY(gst_rec.gst_accno,s_sth.s_gst_accno);
		STRCPY(gst_rec.accno,"\0");
		flg_reset(GSTDIST);

		err = get_n_gstacct(&gst_rec,BROWSE,0,FORWARD,e_mesg);
		if(err < 0) {
			if(err != UNDEF && err != EFL) {
				DispError(e_mesg);
				s_sth.s_gst_accno[0] = LV_CHAR ;
				return(err);
			}
		}
		if(strcmp(gst_rec.gst_accno,s_sth.s_gst_accno) != 0 || 
								err== EFL) {
			err = UNDEF;
		}

		if(err != UNDEF) {
			if(s_sth.s_fn[0] == ADDREC) {
#ifdef ENGLISH
				fomer("GST account already has accounts linked to it");
#else
				fomer("Compte TPS a deja des comptes relies");
#endif
				s_sth.s_gst_accno[0] = LV_CHAR ;
				return(ERROR);
			}
		}
		else  {
			if(s_sth.s_fn[0] == CHANGE) {
#ifdef ENGLISH
				fomer("GST account not linked to any accounts yet");
#else
				fomer("Compte TPS n'est pas relie a aucun compte");
#endif
				s_sth.s_gst_accno[0] = LV_CHAR ;
				return(ERROR);
			}
		}
		break;
	default :
#ifdef ENGLISH
		sprintf(e_mesg,"No Validity Check For Field#  %d",sr.curfld);
#else
		sprintf(e_mesg,"Pas de controle de validite pour le Champ#  %d",sr.curfld);
#endif
		fomen(e_mesg);
		get();
		return(ERROR) ;
	}	/* Switch sr.curfld */

	return(NOERROR) ;
}	/* KeyAndHdrValidation() */
/*----------------------------------------------------------------*/
/* Show Help Windows, if applicable, when user gives ESC-H in key
   and header fields */

HdrAndKeyWindowHelp()
{
	short	reccod ;
	int	err;

	switch(sr.curfld) {
	case KEY_END	:	/* GST account Field */
		err = gl_hlp(s_sth.s_fund, s_sth.s_gst_accno,&reccod, 7, 13 );
		if(err == DBH_ERR) return(err) ;
		if(err >=0 ) redraw();
		if(err < 1) return(ERROR) ;	/* Not Selected */
		if(reccod != 99) {
#ifdef ENGLISH
			fomer("Select records with 99 as Record Code only");
#else
			fomer("Choisir les fiches avec 99 seulement comme code de fiche");
#endif
			s_sth.s_gst_accno[0] = LV_CHAR ;
			return(ERROR) ;
		}
		err = CheckGlAcnt(s_sth.s_gst_accno) ;
		if(DBH_ERR == err) return(err) ;
		if(err < 0) {
			s_sth.s_gst_accno[0] = LV_CHAR ;
			return(ERROR) ;
		}

		gst_rec.fund = s_sth.s_fund;
		STRCPY(gst_rec.gst_accno,s_sth.s_gst_accno);
		STRCPY(gst_rec.accno,"\0");
		flg_reset(GSTDIST);

		err = get_n_gstacct(&gst_rec,BROWSE,0,FORWARD,e_mesg);
		if(err < 0) {
			if(err != UNDEF && err != EFL) {
				DispError(e_mesg);
				s_sth.s_gst_accno[0] = LV_CHAR ;
				return(err);
			}
		}
		if(strcmp(gst_rec.gst_accno,s_sth.s_gst_accno) != 0 || 
								err== EFL) {
			err = UNDEF;
		}

		if(err != UNDEF) {
			if(s_sth.s_fn[0] == ADDREC) {
#ifdef ENGLISH
				fomer("GST account already has accounts linked to it");
#else
				fomer("Compte TPS a deja des comptes relies");
#endif
				s_sth.s_gst_accno[0] = LV_CHAR ;
				return(ERROR);
			}
		}
		else  {
			if(s_sth.s_fn[0] == CHANGE) {
#ifdef ENGLISH
				fomer("GST account not linked to any accounts yet");
#else
				fomer("Compte TPS n'est pas relie a aucun compte");
#endif
				s_sth.s_gst_accno[0] = LV_CHAR ;
				return(ERROR);
			}
		}
		return(NOERROR);
	}
#ifdef ENGLISH
	fomer("No Help Window For This Field");
#else
	fomer("Pas de fenetre d'assistance pour ce champ");
#endif

	return(NOERROR) ;
}	/* HdrAndKeyWindowHelp() */

/*----------------------------------------------------------------*/
ItemsValidation(mode)
int	mode ;
{
	int	err;
	int	fld_no, item_no ;

	/* Calculate item# and Fld# within item */
	item_no = (sr.curfld - ITEM_ST_FLD) / STEP ;
	fld_no  = (sr.curfld - ITEM_ST_FLD) % STEP ;

	switch(fld_no){
	case ACCT_FLD :		/* GL Account# Fields */
		if (acnt_chk(s_sth.s_items[item_no].s_accno) < 0)  {
			s_sth.s_items[item_no].s_accno[0] = LV_CHAR ;
#ifdef ENGLISH
			fomer("Invalid GL Account Number");
#else
			fomer("Numero de compte G/L invalide");
#endif
			return(ERROR) ;
		}
		err = CheckGlAcnt(s_sth.s_items[item_no].s_accno) ;
		if(DBH_ERR == err) return(err) ;
		if(err < 0) {
			s_sth.s_items[item_no].s_accno[0] = LV_CHAR ;
			return(ERROR) ;
		}

		gst_rec.fund = s_sth.s_fund;
		STRCPY(gst_rec.accno,s_sth.s_items[item_no].s_accno);

		err = get_gstacct(&gst_rec,BROWSE,1,e_mesg);
		if(err != UNDEF ) {
#ifdef ENGLISH
			fomer("Account already linked to a GST account");
#else
			fomer("Compte deja relie a un compte TPS");
#endif
			s_sth.s_items[item_no].s_accno[0] = LV_CHAR ;
			return(ERROR);
		}

		err = CheckAcctInList(s_sth.s_items[item_no].s_accno,item_no);
		if(err != NOERROR) {
#ifdef ENGLISH
			fomer("Account already linked to this GST account");
#else
			fomer("Compte deja relie a ce compte TPS");
#endif
			s_sth.s_items[item_no].s_accno[0] = LV_CHAR ;
			return(ERROR);
		}

		if(strcmp(s_sth.s_items[item_no].s_accno,s_sth.s_gst_accno)==0){
#ifdef ENGLISH
			fomer("Account is the same as the GST account");
#else
			fomer("Compte est le meme que le compte TPS");
#endif
			s_sth.s_items[item_no].s_accno[0] = LV_CHAR ;
			return(ERROR);
		}

		STRCPY(s_sth.s_items[item_no].s_desc,gl_rec.desc);
		break ;
	}	/* Switch sr.curfld */
	sr.nextfld = sr.curfld;
	return(NOERROR) ;
}	/* ItemsValidation() */
/*----------------------------------------------------------------*/
/* Show Help Windows, if applicable, when user gives ESC-H in Item fields */
ItemsWindowHelp()
{
	int	err ;
	int	fld_no, item_no ;
	int	cur_fld;
	short	reccod ;

	/* Calculate item# ans Fld# within item */
	item_no = (sr.curfld - ITEM_ST_FLD) / STEP ;
	fld_no  = (sr.curfld - ITEM_ST_FLD) % STEP ;

	switch(fld_no){
	case ACCT_FLD :		/* GL Account# Fields */
		err = gl_hlp(s_sth.s_fund, s_sth.s_items[item_no].s_accno,
			&reccod, 7, 13 );
		if(err == DBH_ERR) return(err) ;
		if(err >=0 ) redraw();
		if(err < 1) return(ERROR) ;	/* Not Selected */
		if(reccod != 99) {
#ifdef ENGLISH
			fomer("Select records with 99 as Record Code only");
#else
			fomer("Choisir les fiches avec 99 seulement comme code de fiche");
#endif
			s_sth.s_items[item_no].s_accno[0] = LV_CHAR ;
			return(ERROR) ;
		}
		err = CheckGlAcnt(s_sth.s_items[item_no].s_accno) ;
		if(DBH_ERR == err) return(err) ;
		if(err < 0) {
			s_sth.s_items[item_no].s_accno[0] = LV_CHAR ;
			return(ERROR) ;
		}

		gst_rec.fund = s_sth.s_fund;
		STRCPY(gst_rec.accno,s_sth.s_items[item_no].s_accno);

		err = get_gstacct(&gst_rec,BROWSE,1,e_mesg);
		if(err != UNDEF ) {
#ifdef ENGLISH
			fomer("Account already linked to a GST account");
#else
			fomer("Compte deja relie a un compte TPS");
#endif
			s_sth.s_items[item_no].s_accno[0] = LV_CHAR ;
			return(ERROR);
		}
		err = CheckAcctInList(s_sth.s_items[item_no].s_accno,item_no);
		if(err != NOERROR) {
#ifdef ENGLISH
			fomer("Account already linked to this GST account");
#else
			fomer("Compte deja relie a ce compte TPS");
#endif
			s_sth.s_items[item_no].s_accno[0] = LV_CHAR ;
			return(ERROR);
		}

		if(strcmp(s_sth.s_items[item_no].s_accno,s_sth.s_gst_accno)==0){
#ifdef ENGLISH
			fomer("Account is the same as the GST account");
#else
			fomer("Compte est le meme que le compte TPS");
#endif
			s_sth.s_items[item_no].s_accno[0] = LV_CHAR ;
			return(ERROR);
		}

		STRCPY(s_sth.s_items[item_no].s_desc,gl_rec.desc);
		break ;
	default :
#ifdef ENGLISH
		fomer("No Help Window For This Field");
#else
		fomer("Pas de fenetre d'assistance pour ce champ");
#endif
	}	/* Switch sr.curfld */

	return(NOERROR) ;
}	/* ItemsWindowHelp() */
/*----------------------------------------------------------------*/
/* Check to see if account entered already in linked list         */
CheckAcctInList(account,item_no)
char	*account;
int	item_no;
{
	Page	*temppage;
	int	i;

	for(temppage=FirstPage;temppage!=NULL;temppage=temppage->NextPage) {
		for(i=0;i<temppage->NoItems;i++) {
			if(temppage==CurPage && i==item_no) {
				continue;	/* skip current item */
			}
			if(strcmp(account,temppage->Items[i].s_accno)==0){
				return(ERROR);
			}
		}
		if(temppage==AcctLast) {
			break;
		}
	}

	return(NOERROR);
}
/*----------------------------------------------------------------*/
/* Check the given funds availability in file */

CheckFund(fund)
short	fund;
{
	int	err ;

	ctl_rec.fund = fund ;
	err = get_ctl(&ctl_rec, BROWSE, 0, e_mesg) ;
	if(ERROR == err) return(err);
	if(err < 0) {
		fomer(e_mesg) ; get();
		return(ERROR) ;
	}
	return(NOERROR) ;
}	/* CheckFund() */
/*----------------------------------------------------------------*/
/* Check the given GL account availability in file */

CheckGlAcnt(accno)
char	*accno ;
{
	int	err ;

	gl_rec.funds = s_sth.s_fund ;
	STRCPY( gl_rec.accno, accno);
	gl_rec.reccod = 99;
	err = get_gl(&gl_rec, BROWSE, 0, e_mesg) ;
	if(ERROR == err) return(err);
	if(err < 0) {
		fomer(e_mesg) ;
		return(ERROR) ;
	}
	return(NOERROR) ;
}	/* CheckGlAcnt() */
/*-----------------------------------------------------------------------*/
/* Display message and get the option */

GetOption(msg,options)
char	*msg ;
char	*options ;
{
	int	i, j ;

	STRCPY(s_sth.s_mesg,msg);
	ShowMesg() ;

	sr.nextfld = END_FLD ;
	for( ; ; ) {
		fomrf( (char *)&s_sth ) ;
		ret(err_chk(&sr)) ;

		j = strlen(options) ;
		for( i = 0 ; i < j ; i++)
			if(s_sth.s_resp[0] == options[i]) break ;
		if(i != j) break ;	/* Valid Option Selected */
#ifdef ENGLISH
		fomer("Invalid Option..");
#else
		fomer("Option invalide..");
#endif
	}

	s_sth.s_mesg[0] = HV_CHAR ;
	s_sth.s_resp[0] = HV_CHAR ;
	
	ret( WriteFields(END_FLD -100, END_FLD) );

	return((int)(options[i])) ;
}	/* GetOption() */
/*-----------------------------------------------------------*/
/* Move High values to all data fields and clear the screen */

ClearScreen()
{
	int	i;

	/* Move High Values to Hedaer part */
	InitHdr(HV_CHAR, HV_DOUBLE) ;

	/* Move High Values to All items */
	for(i = 0 ; i < PAGESIZE ; i++)
		InitItem(i, HV_CHAR, HV_LONG, HV_DOUBLE) ;

	ret( WriteFields(HDR_ST_FLD, (END_FLD - 200)) );

	return(NOERROR);
}	/* ClearScreen() */
/*-------------------------------------------------------------------------*/
/* Initialize Screen Header with either Low or High Values */

InitHdr( t_char, t_double )
char	t_char ;
double	t_double ;
{
	s_sth.s_page = HV_SHORT;
	s_sth.s_dummy[0] = HV_CHAR ;

	return(NOERROR) ;
}	/* InitHdr() */
/*-------------------------------------------------------------------------*/
/* Initialize Given screen item with either Low values or High values */

InitItem(item_no, t_char, t_long, t_double)
int	item_no ;
char	t_char ;
long	t_long ;
double	t_double ;
{
	s_sth.s_items[item_no].s_accno[0]  = t_char;
	s_sth.s_items[item_no].s_desc[0]   = t_char;
	s_sth.s_items[item_no].s_status[0] = t_char;

	return(NOERROR) ;
}	/* Inititem() */
/*-------------------------------------------------------------------------*/

static
DispError(s)    /* show ERROR and wait */
char	*s;
{
	strncpy(s_sth.s_mesg,s, (sizeof(s_sth.s_mesg) - 1));
	ShowMesg();
#ifdef ENGLISH
	fomen("Press any key to continue");
#else
	fomen("Appuyer sur une touche pour continuer");
#endif
	get();
	s_sth.s_mesg[0] = HV_CHAR;
	ShowMesg();
	return(NOERROR);
}
/*-------------------------------------------------------------------------*/

ShowMesg()  /* shows or clears message field */
{
	sr.nextfld = END_FLD - 100;
	fomwf( (char *)&s_sth ) ;
}
/*-------------------- E n d   O f   P r o g r a m ---------------------*/
