/*******************************************************************************
		Sourcename    : budtrans.c
		System        : Budgetary Financial system.
		Module        : Budget Entries
		Created on    : 89-07-14
		Created  By   : K HARISH.
		Cobol sources : 
*******************************************************************************
About the program:
	It allows the user to modify the budget figures in the gl master
	through budget transactions. All such transactions are written into
	a budget transaction file.
	The program allows the user to change the budget figures of any
	period in the current year, irrespective of whether the period is
	currently open or not.


HISTORY:
 Date           Programmer     Description of modification
____/__/__      __________     ___________________________
1990/12/18	F.Tao 	       Round up amounts before writing to file.
1990/12/28	F.Tao 	       Add Codes for increment serial number if 
			       needed.
1990/12/30	C.Leadbeater   Fix Default value for acct number so that
			       the first item on page is a required entry.
******************************************************************************/
#include <stdio.h>

#define MAIN
#define MAINFL	GLBDHDR

#include <bfs_defs.h>
#include <bfs_recs.h>
#include <cfomstrc.h>

#define SYSTEM		"GENERAL LEDGER"
#define MOD_DATE	"23-JAN-90"
#define SCREEN_NAME	"budtrans"
#define ITEMSPERPAGE 	15
#define EXIT		12
#define ALLOC_ERROR	13
#define ADD_MODE	16
#define INQ_MODE	17
#define RANDOM  	18
#define SEQUENTIAL	19
#define PATH_FILE_SIZE	50
#define DELTA_AMT	0.0001
#define LOW 		-1	/* LOW * HV_INT == LV_INT */
#define HIGH 		 1	/* HIGH * HV_INT == HV_INT */
#define	ACCOUNT		1
#define	AMOUNT		2
#define	INIT		1
#define	NOINIT		2
#define HL_CHAR(VAL)	VAL==HIGH ? HV_CHAR : LV_CHAR
#define ESC_F		sr.retcode==RET_USER_ESC && \
			(sr.escchar[0]=='F'||sr.escchar[0]=='f')
#define ESC_H		sr.retcode==RET_USER_ESC && \
			(sr.escchar[0]=='H'||sr.escchar[0]=='h')

#ifdef ENGLISH
#define ADDREC	'A'
#define NEXT	'N'
#define PREV	'P'
#define INQUIRE	'I'
#define EXITOPT	'E'

#define EDIT	'E'
#define CANCEL	'C'

#define REVIVE	'R'
#define YES	'Y'
#define NO	'N'
#define DELETE	'D'
#define ACTIVE	'A'
#else
#define ADDREC	'R'
#define NEXT	'S'
#define PREV	'P'
#define INQUIRE	'I'
#define EXITOPT	'F'

#define EDIT	'M'
#define CANCEL	'A'

#define REVIVE	'V'
#define YES	'O'
#define NO	'N'
#define DELETE	'E'
#define ACTIVE	'A'
#endif

typedef struct line{
	short	s_fund;	/* NUMERIC 999 */
	short	s_reccod;	/* NUMERIC 99 */
	char	s_accno[19];	/* STRING XXXXXXXXXXXXXXXXXX */
	short	s_period;	/* NUMERIC 99 */
	double	s_amount;	/* NUMERIC 999F999F999.99 */
	char	s_status[4];	/* STRING XXX */
}	Line;

/* budentry.sth - header for C structure generated by PROFOM EDITOR */

struct	bd_struct	{
	char	s_progname[11];	/* 100 STRING */
	char	s_scrhdg[23];	/* 200 STRING */
	long	s_rundt;	/* 300 DATE YYYYFMMFDD */
	char	s_fn[2];	/* 400 STRING X */
	long	s_sysdt;	/* 500 DATE YYYYFMMFDD */
	short	s_sno;		/* 600 NUMERIC 999 */
	short	s_fld_no;	/* 700 NUMERIC 999 */
	char	s_descr[25];	/* 800 STRING */
	short	s_page;		/* 900 NUMERIC 99 */
	char	s_itmhdg[4];	/* 950 STRING X */
	Line	s_entries[15];	/* 1000 to 9900 structure */
	char	s_mesg[78];	/* 10000 STRING */
	char	s_resp[2];	/* 10100 STRING X */
};

typedef struct{		/* structure to record current page & line of entry */
	short	page;	
	short	line;
}	Counter;

			/* link list node for holding one page of entries */
typedef	struct pgofitems{
	struct pgofitems *prevptr;	/* pointer to previous entry */
	int	lines_entered;		/* no of lines entered */
	Line 	fields[ITEMSPERPAGE];	/* array of lines per page */
	struct pgofitems *nextptr;	/* pointer to next entry */
}	Page;

static Page	*headptr,*tempptr,*tailptr;	/* to maintain list */
static Counter	current; /* For current line & page of journal item entry */
static struct bd_struct	s_rec;		/* screen record */
static Gl_rec 		gl_rec;		/* GL master record */
static Bd_hdr	 	tr_hdr;		/* Budget transaction header rec */
static Bd_item	 	tr_item;	/* Budget transaction item rec */
struct stat_rec 	sr;		/* profom status record */
static Pa_rec		param_rec;	/* parameter file record */
static Ctl_rec		ctl_rec;	/* control file record */

static int totalitemsadded;	/* total items added in any add session */
static int retval;	/* Global variable to store function values */
static char e_mesg[80]; /* to store error messages */

double D_Roundoff();
char	prev_pg_accno[19];	/* temp accno from last item on prev pg */


/* Initialize profom fields, call entry procedures */
main( argc, argv )
int argc;
char *argv[];
{
	strncpy( SYS_NAME, SYSTEM, 50 ); 	/* Module name */
	strncpy( CHNG_DATE, MOD_DATE, 10 );	/* Last date of change */
	proc_switch( argc,argv,MAINFL ); 	/* process the switches */

	if( Initialize(terminal) <0 )	/* initialize profom and screen */
		exit(-1);
	if( Process()<0 ){		/* process the user's options */
		close_dbh();
		CleanExit(-1);
	}
	CleanExit(0);			/* Wind up the show */
}

static
CleanExit(retval)/* clear and exit the screen , close files & exit program */
int	retval;
{
	fomcs();
	fomrt();
	exit(retval);
}
static
Initialize( terminal )	/* initialize profom and screen */
char *terminal;
{
	if( InitProfom(terminal)<0 ){	/* initialize profom */
		fomcs();
		fomrt();
		return( -1 );
	}
	if( InitScreen()<0 ){		/* initialize screen */
		fomcs();
		fomrt();
		return(-1);
	}
	fomcf(1,1);	/* Enable Snap screen option */
	return(0);
}	
static
InitProfom(terminal)	/* initialize profom */
char *terminal;
{
	STRCPY( sr.termnm, terminal );
	fomin( &sr );
	ret( err_chk(&sr) );	/* if profom error return */
	return(0);
}
static
InitScreen()		/* initialize the screen */
{
	/* initialize the profom screen variables */
	STRCPY( sr.scrnam, NFM_PATH );
	strcat( sr.scrnam, SCREEN_NAME );

	/* initialize the fields of the profom screen with high values */
	if( FillScrHdg()<0 ) 				return(-1);

	if( FillKeyFields( LOW )<0 ) 			return(-1);

	if( FillFieldNum( HIGH )<0 ) 			return(-1);
	if( FillHeaderFields( HIGH )<0 ) 		return(-1);

	if( FillLineHeading( HIGH )<0 ) 		return(-1);
	if( FillItemLines( HIGH,1,ITEMSPERPAGE )<0 )	return(-1);

	if( FillMsgRespFields( HIGH )<0 ) 		return(-1);

	if( WriteFields(1,0)<0 )			return(-1);

	return(0);
}
/* Fill the screen heading fields, the program name and the date */
static
FillScrHdg()
{
	STRCPY( s_rec.s_progname, PROG_NAME );
#ifdef ENGLISH
	STRCPY( s_rec.s_scrhdg," BUDGET  TRANSACTIONS " );
#else
	STRCPY( s_rec.s_scrhdg,"TRANSACTIONS DE BUDGET" );
#endif
	s_rec.s_rundt = get_date();
	return(0);
}
/* Fill the keyfields with high or low values */
static
FillKeyFields( value )
short value;
{
	s_rec.s_sysdt   = value * HV_LONG;
	s_rec.s_sno     = value * HV_SHORT;

	return(0);
}
/* Fill the field# field with high/low values */
static
FillFieldNum( value )
short value;
{
	s_rec.s_fld_no = value * HV_SHORT;

	return(0);
}
/* Fill the transaction header part with high/low values */
static
FillHeaderFields( value )
short value;
{
	s_rec.s_descr[0]	= HL_CHAR( value );

	return(0);
}
/* Fill the message and response fields with high or low values */
static
FillMsgRespFields( value )
short value;
{
	s_rec.s_mesg[0] = HL_CHAR( value );
	s_rec.s_resp[0] = HL_CHAR( value );

	return(0);
}
/* Fill the Xaction item heading line with high/low values */
static
FillLineHeading(val)
int val;
{
	if( val==HIGH )
		s_rec.s_itmhdg[0] = HV_CHAR;
	else
		STRCPY(s_rec.s_itmhdg,"   ");	/* three blanks */

	return(0);
}
/* Fill the Xaction item array with high or low values */
static
FillItemLines( value,firstline,lastline )
int value;
short firstline, lastline;
{
	short i;

	s_rec.s_page = value * HV_SHORT;
	for( i=firstline-1; i<lastline; i++ ){
		s_rec.s_entries[i].s_fund = value * HV_SHORT;
		s_rec.s_entries[i].s_reccod = value * HV_SHORT;
		s_rec.s_entries[i].s_accno[0] = HL_CHAR(value);
		s_rec.s_entries[i].s_period = value * HV_SHORT;
		s_rec.s_entries[i].s_amount = value * HV_DOUBLE;
		s_rec.s_entries[i].s_status[0] = HL_CHAR(value);
	}
	return(0);
}
/* Accept user's option and call the corresponding routine in a loop */
static
Process()
{
	s_rec.s_sysdt = 0;	/* initializing the key fields */
	s_rec.s_sno = 0;	/* useful if N(ext) option is selected first */
	retval = get_param( &param_rec, BROWSE, 1, e_mesg );
	if( retval<0 ){
		fomen(e_mesg);
		get();
		return(retval);
	}
	for( ; ; ){
		if( ReadFunction()<0 ) return(-1);
		switch( s_rec.s_fn[0] ){
			case ADDREC:	/* add a transaction list */
				if( SW9==0 && param_rec.pa_cur_period==0 ){
#ifdef ENGLISH
				   fomen("Not Allowed Before Yearly Closing..");
#else
				   fomen("Pas permis avant la fermeture annuelle... ");
#endif
				   get();
				   break;
				}
				CHKACC(retval,ADD,e_mesg);
				if( AddRecords()<0 ) return(-1);
				break;
			case NEXT:	/* show next Xaction list in sequence */
				CHKACC(retval,BROWSE,e_mesg);
				if( Inquire(SEQUENTIAL,FORWARD)<0 ) return(-1);
				break;
			case PREV:	/* show prev Xaction list in sequence */
				CHKACC(retval,BROWSE,e_mesg);
				if( Inquire(SEQUENTIAL,BACKWARD)<0 ) return(-1);
				break;
			case INQUIRE:	/* show selected Xaction list */
				CHKACC(retval,BROWSE,e_mesg);
				if( Inquire(RANDOM,0)<0 ) return(-1);
				break;
			case EXITOPT:	/* exit */
				return(0);
			default:
				break;
		}
		if( retval<0 ){
			fomen(e_mesg);
			get();
		}
		if( retval==DBH_ERR )
			return(retval);
	}
}
static
ReadFunction()	/* Display options at the bottom and read entry */
{
#ifdef ENGLISH
	fomer("A(dd), N(ext), P(rev), I(nquire), E(xit)");
#else
	fomer("R(ajouter), S(uivant), P(recedent), I(nterroger), F(in)");
#endif
	sr.nextfld = 400;	/* Fn field number */
	fomrf( (char *)&s_rec );
	ret( err_chk(&sr) );
	return(0);
}
/* Add a complete Xaction, with 1 header & a number of item records */
static
AddRecords()
{
	int initflag;	/* to indicate list initialization */

	initflag = INIT;

	if( ClearScreen()<0 )	return(-1);
	/* Read key fields and validate the entries */
	if( (retval=ReadKeyFields())<0 )	return(retval);
	if(retval==EXIT){
		if(ClearScreen()<0)	return(-1);
		return(retval);
	}
	/* Read the header fields if valid keys are entered */
	if( FillHeaderFields(LOW)<0 ) return(-1);
	if( (retval=ReadFields(800,800))<0 )
		return(retval);/* read header fields */
	if(retval==EXIT){
		if(ClearScreen()<0)	return(-1);
		return(retval);
	}
	/* Confirm the header field entries */
	if( (retval=ConfirmHeader())<0 )	return(retval);
	if( retval==EXIT ){
		if(ClearScreen()<0)	return(-1);
		return(retval);
	}
	/* Show the seperator line between header & item fields */
	if( FillLineHeading(LOW)<0 )	return(-1);
	if( WriteFields(950,950)<0 )	return(-1);

	/* Read items until user confirms item entries */
	for( ; ; ){
		if( (retval=ReadItemFields(initflag))<0 ){
			roll_back( e_mesg);	
			return(retval);
		}
		if( retval==EXIT ){
			roll_back( e_mesg );
			if(ClearScreen()<0)	return(-1);
			return(retval);
		}
		retval =  WriteSession();
		if( retval<0 )
			return(-1);
		if( retval==EXIT ){
			if( ShowLastPage()<0 )
				return(-1);
			initflag = NOINIT;
			continue;
		}
		else
			break;
	}
	return( FreeList() );
}
static
ReadKeyFields()	/* Display system date, generated serial#, and read period */
{
	int retval;

	if( GetNextSerialNo()<0 )
		return(-1);
	if( WriteFields(500,600)<0 )
		return(-1);
	return(0);
}
static
GetNextSerialNo()	/* Generate the next serial no. (part of the key) */
{
	char	terml[4] ;
#ifdef	ORACLE
	long	get_maxsno(), sno ;
#endif

	/* Fill the terminal#, system date in the Xaction header rec */
	if( get_tnum(tr_hdr.tr_term)<0 )	return(-1);
	STRCPY( terml, tr_hdr.tr_term );
	tr_hdr.tr_sys_dt = s_rec.s_sysdt = s_rec.s_rundt;

#ifndef	ORACLE
	/* Move highs to serial no, and access previous record in sequence */
	tr_hdr.tr_seq_no = HV_SHORT;
	flg_reset(GLBDHDR);
	retval = get_n_bdhdr( &tr_hdr,BROWSE,0,BACKWARD,e_mesg );
	if( retval==ERROR ){
		fomen(e_mesg); get();
		return(-1);
	}
	seq_over(GLBDHDR);
	/* compare the key fields after read */
	if( strncmp(tr_hdr.tr_term,terml, 3)||
	    (tr_hdr.tr_sys_dt!=s_rec.s_sysdt)||
	    retval==EFL ){		/* It is 1 if end of file is reached */
		STRCPY( tr_hdr.tr_term,terml );
		tr_hdr.tr_sys_dt = s_rec.s_sysdt;
		tr_hdr.tr_seq_no = 1;
	}
	else  /* The new serial# is one greater than that of the record read */
		tr_hdr.tr_seq_no++;
#else
	sno = get_maxsno(GLBDHDR, (char*)&tr_hdr, 0, -1, e_mesg) ;
	if(sno < 0) {
		fomen(e_mesg); get();
		return(-1);
	}
	tr_hdr.tr_seq_no = sno + 1;
#endif
	s_rec.s_sno = tr_hdr.tr_seq_no;
	return(0);
}
static
ReadFields(start,end)	/* read fields whose numbers range from start to end */
int start, end;		/* start and end fields */
{
	int retval;

	sr.nextfld = start;
	sr.endfld = end;
	for( ; ; ){
		fomrd( (char *)&s_rec );
		ret(err_chk(&sr));
		if( sr.retcode==RET_USER_ESC || sr.retcode==RET_VAL_CHK ){
			if( ESC_F ) return(EXIT);
			retval=Validate();
			if( retval<0 || retval==EXIT)	return(retval);
			continue;
		}
		break;
	}
	return(0);
}
static
WriteFields( start,end )/* write fields whose numbers range from start to end */
int start, end;
{
	sr.nextfld = start;
	sr.endfld = end;
	fomwr( (char *)&s_rec );
	ret( err_chk(&sr) );
	return(0);
}
static
ClearScreen()	/* clear the screen except fn field and screen heading */
{
	if(FillKeyFields(HIGH)<0 ) return(-1);
	if(FillFieldNum(HIGH)<0 ) return(-1);
	if(FillHeaderFields(HIGH)<0 ) return(-1);
	if(FillLineHeading(HIGH)<0 ) return(-1);
	if(FillItemLines(HIGH,1,ITEMSPERPAGE)<0 ) return(-1);
	if(FillMsgRespFields(HIGH)<0 ) return(-1);

	if( WriteFields(500,10100)<0 ) return(-1);
	
	return(0);
}
static
Validate()	/* Validate the values entered by the user */
{
	Gl_rec temp_rec;
	int	index ;
	short	reccod;
	short	*valshort;

	switch( sr.curfld ){
		case 700:	/* field # for editing */
			if( sr.fillcode==FIL_OMITTED )	return(EXIT);
			break;
		case 1000: 	/* fund */
		case 1600: 
		case 2200: 
		case 2800: 
		case 3400:
		case 4000: 
		case 4600: 
		case 5200: 
		case 5800: 
		case 6400:
		case 7000:
		case 7600:
		case 8200:
		case 8800:
		case 9400:
			if( sr.retcode==RET_USER_ESC )	break;
			index = (sr.curfld+200)/600-2;
			valshort = &s_rec.s_entries[index].s_fund;
			ctl_rec.fund = *valshort;
			index = get_ctl( &ctl_rec, BROWSE, 0, e_mesg );
			if( index==ERROR ){
				fomen(e_mesg); get();
				return(-1);
			}
			if( index!=NOERROR ){
				fomer(e_mesg);
				*valshort = LV_SHORT;
			}
			break;
		case 1100:	/* record code */ 
		case 1700: 
		case 2300: 
		case 2900: 
		case 3500:
		case 4100: 
		case 4700: 
		case 5300: 
		case 5900: 
		case 6500:
		case 7100:
		case 7700:
		case 8300:
		case 8900:
		case 9500:
			index = (sr.curfld+100)/600-2;
			valshort = &s_rec.s_entries[index].s_reccod ;
			if( *valshort<97 || *valshort>99 ){
#ifdef ENGLISH
				fomer("Valid codes are 97 to 99");
#else
				fomer("Codes valables sont de 97 a 99");
#endif
				*valshort = LV_SHORT;
			}
			break;
		case 1200:	/* account number */ 
		case 1800: 
		case 2400: 
		case 3000: 
		case 3600:
		case 4200: 
		case 4800: 
		case 5400: 
		case 6000: 
		case 6600:
		case 7200:
		case 7800:
		case 8400:
		case 9000:
		case 9600:
			index = (sr.curfld)/600-2;
			if( ESC_H ){
			   retval = gl_hlp(s_rec.s_entries[index].s_fund,
					s_rec.s_entries[index].s_accno,
					&reccod,
					7, 15 );
			   if( retval<0 )	/* error */
					return( retval );
			   if( retval==0 )	/* nothing selected  */
					redraw(); /* remove hlp window*/
			   else if( retval==1 ){/* selected */
					/* check for reccod compatibility */
				if( s_rec.s_entries[index].s_reccod!=reccod ){
				   redraw();
#ifdef ENGLISH
				   fomer("Record code mismatch.Try again");
#else
				   fomer("Disparite de code de fiche.Reessayer");
#endif
				   s_rec.s_entries[index].s_accno[0]=LV_CHAR;
				   sr.nextfld = sr.curfld;
				   break;
				}
				else{
				    redraw();
		 		    retval = VerifyAccount
						(index,&temp_rec,ACCOUNT); 
				    if( retval==ERROR )	return(-1);
				    if( retval!=NOERROR )
					s_rec.s_entries[index].s_accno[0]
						=LV_CHAR;
				    else
					ShowDistribution( &temp_rec, index );
				}
			   }
			}
			else if( sr.retcode==RET_USER_ESC )
				break;
			else{	/* user entered an account number */
			   if(acnt_chk(s_rec.s_entries[index].s_accno)==ERROR){
#ifdef ENGLISH
				fomer("Invalid Account number");
#else
				fomer("Numero de compte invalid");
#endif
				s_rec.s_entries[index].s_accno[0]=LV_CHAR;
				break;
			   }
			   retval = VerifyAccount(index,&temp_rec,ACCOUNT); 
			   if( retval==ERROR )	return(-1);
			   if( retval!=NOERROR )
				s_rec.s_entries[index].s_accno[0]=LV_CHAR;
			   else
				ShowDistribution( &temp_rec, index );
			}
			break; 
		case 1300:	/* period */ 
		case 1900: 
		case 2500: 
		case 3100: 
		case 3700:
		case 4300: 
		case 4900: 
		case 5500: 
		case 6100: 
		case 6700:
		case 7300:
		case 7900:
		case 8500:
		case 9100:
		case 9700:
			index = (sr.curfld-100)/600-2;
			valshort = &s_rec.s_entries[index].s_period;
			if( *valshort<0 || *valshort>param_rec.pa_no_periods ){
#ifdef ENGLISH
			    sprintf(	e_mesg,"Valid periods: 0 to %d",
#else
			    sprintf(	e_mesg,"Periodes valables: de 0 a %d",
#endif
					retval = (temp_rec.cdbud==2)	?
						12 			: 
						param_rec.pa_no_periods
				   ) ;
				fomer(e_mesg);
				*valshort = LV_SHORT;
			}
			else{
				if( s_rec.s_entries[index].s_period==0 )
#ifdef ENGLISH
					fomer("Uniform distribution across remaining periods");
#else
					fomer("Repartition uniforme sur les periodes qui restes");
#endif
			}
			break;
		case 1400:	/* amount */ 
		case 2000: 
		case 2600: 
		case 3200: 
		case 3800:
		case 4400: 
		case 5000: 
		case 5600: 
		case 6200: 
		case 6800:
		case 7400:
		case 8000:
		case 8600:
		case 9200:
		case 9800:
			index = (sr.curfld-200)/600-2;
			retval = VerifyAccount(index,&temp_rec,AMOUNT); 
			if( retval==ERROR )	return(-1);
			if( retval!=NOERROR )
				s_rec.s_entries[index].s_amount=LV_DOUBLE;
			break; 
	}
	sr.nextfld = sr.curfld;
	return(0);
}
static
ShowDistribution( glptr, index )
Gl_rec	*glptr;
int	index;
{
	if( glptr->cdbud==0 || glptr->cdbud==3 || glptr->cdbud==4 )
		s_rec.s_entries[index].s_period=0;

	switch( glptr->cdbud ){
		case 0:
#ifdef ENGLISH
			fomer("Adding to annual budget only");
#else
			fomer("Ajoute au budget annuel seulement");
#endif
			break;
		case 1:
		case 2:
#ifdef ENGLISH
			fomer("Manual distribution across periods");
#else
			fomer("Distribution manuelle sur les periodes");
#endif
			break;
		case 3:
		case 4:
#ifdef ENGLISH
			fomer("Automatic distribution across all periods");
#else
			fomer("Distribution automatique sur toutes les periodes");
#endif
			break;
	}

	return(0);
}
static
VerifyAccount(index,temp_rec,fldtype) /* Check for record in the GL master */
int index,fldtype;
Gl_rec *temp_rec;
{
	int ret_val;
	double amount;

	/* Get a record in UPDATE mode to check existence of the account */

	temp_rec->funds = (short)s_rec.s_entries[index].s_fund;
	STRCPY( temp_rec->accno,s_rec.s_entries[index].s_accno );
	temp_rec->reccod = (short)s_rec.s_entries[index].s_reccod;
	ret_val = get_gl( temp_rec,UPDATE,0,e_mesg );
	if(ret_val!=NOERROR ){
		fomen(e_mesg);
		get();
		return(ret_val);
	}
	if( fldtype==ACCOUNT )
		return(NOERROR);

	/*  check if the change invalidates the budget amount if for a period */
	if( s_rec.s_entries[index].s_period>0 ){
	    amount = s_rec.s_entries[index].s_amount; /* amount of change */
	    if(temp_rec->curbud[s_rec.s_entries[index].s_period-1]+amount<0.0){
#ifdef ENGLISH
		fomer("Net budget for the period becomes negative");
#else
		fomer("Budget net pour la periode devient negative");
#endif
		return( -1);
	    }
	    if( amount<DELTA_AMT && amount >(-DELTA_AMT) ){
#ifdef ENGLISH
		fomer("Amount too small for transaction");
#else
		fomer("Montant trop petit pour transaction");
#endif
		return(-1);
	    }
	}
	return(NOERROR);
}
static
ConfirmHeader()	/* Ask if user wants to edit hdr items before going to items */
{
	for( ; ; ){
#ifdef ENGLISH
		if(DisplayMessage( "A(dd items), E(dit), C(ancel)")<0 ) 
#else
		if(DisplayMessage( "R(ajouter articles), M(odifier), A(nnuler)")<0 )
#endif
			return(-1);
		sr.nextfld = 10100;
		fomrf( (char *)&s_rec );
		ret( err_chk(&sr) );
		switch( s_rec.s_resp[0] ){
			case ADDREC:	/* Go to addition of items */
				return(HideMessage());
			case EDIT:	/* Edit the fields in header */
				if( (retval=EditHeaderFields())<0 )
					return(retval);
				break;
			case CANCEL:	/* Cancel the session */
#ifdef ENGLISH
				if(DisplayMessage( 
					"Confirm the Cancel (Y/N)?")<0 ) 
					return(-1);
#else
				if(DisplayMessage(
					"Confirmer l'annulation (O/N)?")<0 )
					return(-1);
#endif
				sr.nextfld = 10100;
				fomrf( (char *)&s_rec );
				ret( err_chk(&sr) );
				if( s_rec.s_resp[0]!=YES )
					continue;
				if( HideMessage()<0 ) return(-1);
				return(EXIT);
		}
	}
}
static
DisplayMessage(mesg)	/* Display the given message in the message field */
char *mesg;
{
	STRCPY( s_rec.s_mesg, mesg );
	if( WriteFields(10000,10000)<0 )	return(-1);
	return(0);
}
static
HideMessage()	/* Hide the message field */
{
	if( FillMsgRespFields(HIGH)<0 )	return(-1);
	if( WriteFields(10000,10100)<0 ) return(-1);
	return(0);
}
static
HideFldNo()	/* Hide the 'Field#' field */
{
	if( FillFieldNum(HIGH)<0 )	return(-1);
	if( (WriteFields(700,700))<0 )
		return(-1);
	return(0);
}
static
EditHeaderFields()/* Read header field# & read corresponding field (now one)*/
{
	fomca1( 800, 19, 2 );
	sr.nextfld = sr.endfld = 800;
	fomud( (char *)&s_rec );
	sr.nextfld = sr.endfld = 800;
	s_rec.s_descr[0] = LV_CHAR;
	if( ReadFields(800,800)<0 )
		return(-1);
	fomca1( 800, 19, 0 );
	return(0);
}
static
Page *PageAllocated()	/* Allocate memory for 1 page of items on screen */
{
	return( (Page *)(malloc((unsigned)sizeof( Page ))) );
}
static
ReadItemFields(do_init)		/* Read the journal entry items */
int	do_init;	/* to init or not to init the list ? */
{
	if( do_init==INIT ){
		headptr = tailptr = tempptr = NULL; 
		current.page = 0;
		current.line = ITEMSPERPAGE;	/* Init list & counter values */
		totalitemsadded = 0;
	}

	if( AddItemsInLoop()<0 )	/* Read all the transactions */
		return(-1);
	retval = ConfirmItems(ADD_MODE);/* Allow changing of entered values */
	if( retval<0 )	return(retval);
	if( retval==EXIT ){
		if(ClearScreen()<0)		/* Clear the screen */
			return(-1);	
		return(EXIT);
	}
	return(0);
}
static
AddItemsInLoop()
{
	for( ; ; ){
		retval=ReadOneItem();   /* read one transaction line */
		if( retval<0 ){
			FreeList();
			return(-1);
		}
		if (tailptr)
			tailptr->lines_entered = current.line;
		if( retval==EXIT || retval==ALLOC_ERROR )
			break;
	}
	return(0);
}
static
ReadOneItem()	/* read one transaction (one line on screen) */
{
	int	i,fund_fld;	

	if( current.line == ITEMSPERPAGE ){ 
	
		STRCPY(prev_pg_accno, s_rec.s_entries[current.line-1].s_accno) ;
		
		retval = MakeFreshPage(); /* add new page to list */
		if( retval<0 || retval==ALLOC_ERROR )
			return( retval );
		current.page++;
		current.line = 1;
		
			/* disable dup buffers for item 1,pg 1 */
		if (current.page == 1) {
			fomca1( 1200, 19, 0 );
		}
		else{
			STRCPY(s_rec.s_entries[current.line].s_accno,prev_pg_accno) ;
		}
		
		if( PutPageNumber(current.page)<0 )
			return(-1);
	}
	else
		current.line++;

	if( current.line>1 ){
		fomca1( 1200, 19, 2 );/* enable dup buffers for amount field */
		scpy( (char *)&s_rec.s_entries[current.line-1],
		      (char *)&s_rec.s_entries[current.line-2],
		      sizeof(Line) );
		sr.nextfld = 1000+(current.line-1)*600;
		sr.endfld = 1400+(current.line-1)*600;
		/* dup buffers permanently enabled in .nfm */
		/* for all line items except amount and status */
		fomud( (char *)&s_rec );
	}

	fund_fld = 1000+(current.line-1)*600;
	fomca1(fund_fld,19,2);
	fomca1(fund_fld + 100,19,2);
	s_rec.s_entries[current.line-1].s_fund = 1;
	s_rec.s_entries[current.line-1].s_reccod = 99;
	WriteFields(fund_fld,fund_fld+100);
	fomud((char *)&s_rec);

	if( FillItemLines(LOW,current.line,current.line)<0 )
		return(-1);
#ifdef ENGLISH
	fomer("Press ESC-F to Exit");
	STRCPY(s_rec.s_entries[current.line-1].s_status, "ACT");
#else
	fomer("Appuyer sur ESC-F pour retourner");
	STRCPY(s_rec.s_entries[current.line-1].s_status, "ACT");
#endif
	retval=ReadFields( 1000+(current.line-1)*600,1500+(current.line-1)*600 );
	if(retval==EXIT || retval<0 ){
		if( FillItemLines(HIGH,current.line,current.line)<0 )
			return(-1);
		if( WriteFields( 1000+(current.line-1)*600,
		                1500+(current.line-1)*600 )<0 )
			return(-1);
		tempptr->fields[current.line-1].s_fund = HV_SHORT;
		tempptr->fields[current.line-1].s_reccod = HV_SHORT;
		tempptr->fields[current.line-1].s_accno[0] = HV_CHAR;
		tempptr->fields[current.line-1].s_period = HV_SHORT;
		tempptr->fields[current.line-1].s_amount = HV_DOUBLE;
		tempptr->fields[current.line-1].s_status[0] = HV_CHAR;
		current.line--;
		if(current.line<1){
			if( headptr==tailptr )
				headptr=tailptr=NULL;
			else{
				tailptr = tailptr->prevptr;
				tailptr->nextptr = NULL;
			}
			free( (char *)tempptr );
			tempptr = tailptr;
			current.page--;
			if( PutPageNumber(current.page)<0 )
				return(-1);
			current.line =  ITEMSPERPAGE;
			if( tempptr )
				if( ShowPage()<0 )
					return(-1);
		}
		return(retval);
	}
	else{
		tempptr->fields[current.line-1].s_fund
			= s_rec.s_entries[current.line-1].s_fund;
		tempptr->fields[current.line-1].s_reccod
			= s_rec.s_entries[current.line-1].s_reccod;
		STRCPY(tempptr->fields[current.line-1].s_accno,
		       s_rec.s_entries[current.line-1].s_accno);
		tempptr->fields[current.line-1].s_period
			= s_rec.s_entries[current.line-1].s_period;
		tempptr->fields[current.line-1].s_amount
			= s_rec.s_entries[current.line-1].s_amount;
		strncpy(tempptr->fields[current.line-1].s_status,
			 s_rec.s_entries[current.line-1].s_status, 4);
		tempptr->lines_entered = current.line;
		
		totalitemsadded++;
	}
	return(0);
}
static
ShowPage()	/* Dump contents of node pointed to by tempptr onto screen */
{
	if( ListToScreen()<0 ) return(-1);	/* transfer data */
	if( WriteFields( 1000,9900 )<0 ) return(-1); /* display on screen */
	if( PutPageNumber( current.page )<0 )return(-1); /* Paginate properly */
	return(0);
}
static
ListToScreen()	/* copy contents of *tempptr to screen (items part) */
{
	short i;

	if( tempptr==NULL )
		return(-1);
	for( i=0; i<tempptr->lines_entered; i++){ /* for entries already made */
		s_rec.s_entries[i].s_fund = tempptr->fields[i].s_fund ;
		s_rec.s_entries[i].s_reccod = tempptr->fields[i].s_reccod ;
		STRCPY( s_rec.s_entries[i].s_accno,tempptr->fields[i].s_accno );
		s_rec.s_entries[i].s_period = tempptr->fields[i].s_period ;
		s_rec.s_entries[i].s_amount = tempptr->fields[i].s_amount ;
		strncpy(s_rec.s_entries[i].s_status,tempptr->fields[i].s_status ,4);
	}
	for(i=tempptr->lines_entered; i<ITEMSPERPAGE; i++){/* for other lines */
		s_rec.s_entries[i].s_fund = HV_SHORT;
		s_rec.s_entries[i].s_reccod = HV_SHORT;
		s_rec.s_entries[i].s_accno[0] = HV_CHAR;
		s_rec.s_entries[i].s_period = HV_SHORT;
		s_rec.s_entries[i].s_amount = HV_DOUBLE;
		s_rec.s_entries[i].s_status[0] = HV_CHAR;
	}
	return(0);
}
static
MakeFreshPage()	/* Add a new node to the linked list */
{
	tempptr=PageAllocated();
	if( tempptr==NULL ){
#ifdef ENGLISH
	  fomen("Internal memory allocation error. Press a key");
#else
	  fomen("Erreur d'allocation a la memoire interne. Appuyer sur une touche");
#endif
	  get();
	  return(ALLOC_ERROR);
	}
	if( tailptr == NULL ){	/* If not a single node in the list yet */
		headptr=tailptr=tempptr;
		tempptr->prevptr = NULL;
		tempptr->nextptr = NULL;
	}
	else{			/* if at least one node exists */
		tailptr->lines_entered = current.line;
		tailptr->nextptr = tempptr;
		tempptr->prevptr = tailptr;
		tempptr->nextptr = NULL;
		tailptr = tempptr;
	}
	tempptr->lines_entered = 0;
	if( FillItemLines(HIGH,1,ITEMSPERPAGE)<0 ) 
		return(-1);
	if( WriteFields(1000,9900)<0 )
		return(-1);
	return(0);
}
static
PutPageNumber(pgno)		/* Display the given number as Page No */
short pgno;
{
	s_rec.s_page = pgno;
	return(WriteFields(900,900));
}
static
ShowLastPage()
{
	while( tempptr && tempptr->nextptr ){
		tempptr = tempptr->nextptr;
		current.page ++;
	}
	if( tempptr ){
		current.line = tempptr->lines_entered;
		if( current.line<1 )
			current.line = ITEMSPERPAGE;
		if( ShowPage()<0 ) return(-1);
	}
	return(0);
}
static
ConfirmItems( mode )	/* Allow user to change entered data in ADD_MODE only */
int mode;		/* ADD_MODE, INQ_MODE */
{
    double diff;

    for( ; ; ){
	if( mode==ADD_MODE )
#ifdef ENGLISH
	    DisplayMessage("Y(es), A(dd items), E(dit), D(elete), R(eactivate), N(ext), P(rev), C(ancel)");
#else
	    DisplayMessage("R(ajouter), M(odifier), E(lim), A(nnuler), S(uiv), P(rec), V(ivifier), O(ui)");
#endif
	else if( mode==INQ_MODE ){
		if( headptr->nextptr )
#ifdef ENGLISH
			DisplayMessage("N(ext), P(rev), Y(es)");
#else
			DisplayMessage("S(uivant), P(recedent), O(ui)");
#endif
		else
			break;
	}

	sr.nextfld = 10100;
	fomrf( (char *)&s_rec );	/* Read user's option */
	ret( err_chk(&sr) );
	switch(s_rec.s_resp[0]){
		case ADDREC:	/* Add items allowed in ADD MODE only */
			if( mode==INQ_MODE )
				break;
			if( ShowLastPage()<0 )
				return(-1);
			if( AddItemsInLoop()<0 ) return(-1);
			break;
		case EDIT:	/* Edit entered data in ADD MODE only */
			if( mode==INQ_MODE )
				break;	
			if( !tempptr )	/* if no page is being pointed to */
				break;
			retval = EditItemFields();
			if( retval<0 )
				return(-1);
			if( HideFldNo()<0 )
				return(-1);
			break;
		case DELETE:	/* Delete an item entered in ADD MODE only*/
		case REVIVE:	/* Revive an item deleted in ADD MODE only*/
			if( !tempptr )	/* if no page is being pointed to */
				break;
			if( mode==INQ_MODE )
				break;
			if( ChangeItemStatus()<0 )
				return(-1);
			if( HideFldNo()<0 )
				return(-1);
			break;
		case NEXT:	/* Display the next page of items */
			if(tempptr && tempptr->nextptr){
				tempptr = tempptr->nextptr;
				current.page ++;
				if(ShowPage()<0 ) return(-1);
			}
			else
#ifdef ENGLISH
				fomer("Last Page Displayed");
#else
				fomer("Derniere page affichee");
#endif
			break;
		case PREV:	/* Display the prev page of items */
			if(tempptr && tempptr->prevptr){
				tempptr = tempptr->prevptr;
				current.page --;
				if(ShowPage()<0 ) return(-1);
			}
			else
#ifdef ENGLISH
				fomer("First Page Displayed");
#else
				fomer("Premiere page affichee");
#endif
			break;
		case CANCEL:    /* Cancel the entire session in ADD MODE only*/
			if( mode==INQ_MODE )
				break;
#ifdef ENGLISH
			DisplayMessage("Confirm the cancel (Y/N)?"); 
#else
			DisplayMessage("Confirmer l'annulation (O/N)?");
#endif
			for( ; ; ){
				sr.nextfld = 10100;
				fomrf( (char *)&s_rec);
				if(s_rec.s_resp[0]!=YES&&
				   s_rec.s_resp[0]!=NO)
					continue;
				if( s_rec.s_resp[0]==YES ){
					FreeList();
					if(HideMessage()<0 )
						return(-1);
					return(EXIT);
				}
				else
					break;
			}
			break;
		case YES:	/* Save & Exit in ADD MODE,Exit in INQ MODE */
			if( mode==INQ_MODE )
				return( HideMessage() );
			if( totalitemsadded<1 ){
#ifdef ENGLISH
				fomer("No items to save. Cancel to Quit");
#else
				fomer("Pas d'articles a conserver. Annuler pour retourner");
#endif
				break;
			}
			return(HideMessage());
			break;
	}
	continue;
   }
}
static
EditItemFields()	/* Read the field# and allow changes on that field(s) */
{
	int retval;

	for( ; ; ){
		s_rec.s_fld_no = LV_SHORT;
		if( (retval=ReadFields(700,700)) < 0 )
			return(-1);
		if( retval==EXIT )
			return(retval);
		if( s_rec.s_fld_no<1 || s_rec.s_fld_no>ITEMSPERPAGE ) 
			continue; 
		if( (retval=LineChange(s_rec.s_fld_no)) < 0 ) /* Chg a line */ 
			return(retval);
	}
}
static
LineChange( line_no )	/* Read new values: account# & amount at given line */
int line_no;
{
	int i, firstfld, lastfld;

	/* Don't allow changes/access if item not active or not entered yet */
	if( !tempptr )	return(0);	/* if no pages, return */
	if( tempptr->fields[line_no-1].s_status[0]!=ACTIVE ){
#ifdef ENGLISH
		fomer( "Record not accessible" );
#else
		fomer( "Fiche n'est pas accessible" );
#endif
		get();
		return(0);
	}
	if( line_no>tempptr->lines_entered )
		return(0);

	firstfld = 1000+(line_no-1)*600;	/* fund field */
	lastfld = 1400+(line_no-1)*600;		/* amount field */
	fomca1( lastfld, 19, 2 );/* enable dup buffers for amount field */
	sr.nextfld = firstfld;	/* Other fields,dup buffers are already set*/
	sr.endfld = lastfld;
	fomud( (char *)&s_rec );	/* update dup buffers */
	s_rec.s_entries[line_no-1].s_fund = LV_SHORT;
	s_rec.s_entries[line_no-1].s_reccod = LV_SHORT;
	s_rec.s_entries[line_no-1].s_accno[0] = LV_CHAR;
	s_rec.s_entries[line_no-1].s_period = LV_SHORT;
	s_rec.s_entries[line_no-1].s_amount = LV_DOUBLE;
	i= ReadFields( firstfld, lastfld );
	if( i<0 )	return(i);
	fomca1( lastfld, 19, 0 );/* disable dup buffers for amount field */
	scpy( (char *)(tempptr->fields+line_no-1), 
		(char *)(s_rec.s_entries+line_no-1), 
		sizeof( Line ) );
	return(0);
}
static
ChangeItemStatus()	/* Allow deletion or revival of an item */
{
	int fld_no;

	for( ; ; ){
		s_rec.s_fld_no = LV_SHORT;
		if( (retval=ReadFields(700,700)) < 0 )
			return(-1);
		if( retval==EXIT  )
			return(retval);
		if( s_rec.s_fld_no<1 || s_rec.s_fld_no>tempptr->lines_entered )
			continue;
		switch( s_rec.s_resp[0] ){
			case DELETE:
			   if( !strcmp(s_rec.s_entries[s_rec.s_fld_no-1].s_status,"DEL"))
				break;
#ifdef ENGLISH
			   STRCPY(s_rec.s_entries[s_rec.s_fld_no-1].s_status,
									"DEL");
#else
			   STRCPY(s_rec.s_entries[s_rec.s_fld_no-1].s_status,
									"ELI");
#endif
			   totalitemsadded--;
			   break;
			case REVIVE:
#ifdef ENGLISH
			   if( !strcmp(s_rec.s_entries[s_rec.s_fld_no-1].s_status,"ACT"))
				break;
#else
			   if( !strcmp(s_rec.s_entries[s_rec.s_fld_no-1].s_status,"ACT"))
				break;
#endif
#ifdef ENGLISH
			   STRCPY(s_rec.s_entries[s_rec.s_fld_no-1].s_status,
									"ACT");
			   totalitemsadded++;
			   break;
#else
			   STRCPY(s_rec.s_entries[s_rec.s_fld_no-1].s_status,
									"ACT");
			   totalitemsadded++;
			   break;
#endif
			default:
				return(0);
		}
		STRCPY(tempptr->fields[s_rec.s_fld_no-1].s_status ,
			 s_rec.s_entries[s_rec.s_fld_no-1].s_status);
		fld_no = 1500 + (s_rec.s_fld_no-1)*600;
		if( WriteFields(fld_no,fld_no)<0 )
			return(-1);
	}
}
static
WriteSession()	/* Write header, list of items and update GL master */
{
	int i, item_no;

	if( WriteHeader()<0 ){	/* Write the header record in glbdhdr file */
		roll_back(e_mesg) ;
		return(-1);
	}
	item_no = 0;		/* useful for generating the item serial no */
	tempptr = headptr;	/* initialize tempptr to beginning of list */
	for( ; ; ){	/* to write the items in gltran file */
		if(tempptr==NULL)
			break;
		for( i=1; i<=ITEMSPERPAGE; i++){ /* for each line on page */
			if(tempptr->fields[i-1].s_amount==HV_DOUBLE)
				break;
			if(tempptr->fields[i-1].s_status[0]==DELETE)
				continue;
			item_no++;
			if( WriteItem(i,item_no)<0 ){
				roll_back(e_mesg) ;
				return(-1);
			}
			retval = UpdateGlmaster(i);
			if( retval<0 || retval==EXIT )
				return(retval);
			/* rollback is done in above fn UpdateGlmaster */
		}
		if(tempptr->fields[i-1].s_amount==HV_DOUBLE)
			break;	/* terminate when High values are found */
		tempptr=tempptr->nextptr;
	}
	if (commit(e_mesg) < 0 ){
		fomen(e_mesg) ;
		get() ;
		return(-1);
	}

	return(0);
}
static
WriteHeader()	/* Write the header of the Xaction in gltrhdr file */
{
	tr_hdr.tr_sys_dt = s_rec.s_sysdt;
	tr_hdr.tr_seq_no = (short)s_rec.s_sno;
/*	retval = get_bdhdr( &tr_hdr, UPDATE, 0, e_mesg );
 	if( retval== NOERROR ){
		tr_hdr.tr_seq_no ++;
 		if( WriteFields(500,600)<0 )
 			return(-1);
 	} 
*/
	STRCPY( tr_hdr.tr_descr,s_rec.s_descr ) ;
	retval = put_bdhdr( &tr_hdr, ADD, e_mesg );
	if( retval!=NOERROR ){
		fomen(e_mesg);get();
		roll_back(e_mesg);
		return(retval);
	}
	return(0);
}
static
UpdateGlmaster(item_no)	/* Update GLmaster file using one Xaction rec*/
{
	double amt;

	/* get the master record */
	gl_rec.funds = (short)tempptr->fields[item_no-1].s_fund;
	gl_rec.reccod = (short)tempptr->fields[item_no-1].s_reccod;
	STRCPY( gl_rec.accno, tempptr->fields[item_no-1].s_accno );
	retval = get_gl( &gl_rec,UPDATE,0,e_mesg );
	if( retval!=NOERROR ){
		fomen(e_mesg);get();
		return(DBH_ERR); 
	}

	amt = tempptr->fields[item_no-1].s_amount;

	if( tempptr->fields[item_no-1].s_period>0 ){
		amt += gl_rec.curbud[tempptr->fields[item_no-1].s_period-1];
		if( amt<0.0 ){/* if the change leaves negative budget figure */
#ifdef ENGLISH
			sprintf(e_mesg,
			  "Budget for Acct: %s Period: %d becomes less than zero",
			  gl_rec.accno, tempptr->fields[item_no-1].s_period );
#else
			sprintf(e_mesg,
			  "Budget pour le compte: %s Periode devient moins que zero",
			  gl_rec.accno, tempptr->fields[item_no-1].s_period );
#endif
			fomen(e_mesg);
			get();
			roll_back(e_mesg);
			return(EXIT);
		}
	}

	amt = tempptr->fields[item_no-1].s_amount;
	switch( gl_rec.cdbud ){
		case 0:
			break;
		case 1:
		case 2:
		    if( tempptr->fields[item_no-1].s_period > 0 )
			gl_rec.curbud[tempptr->fields[item_no-1].s_period-1] 
				+= amt;
		    else
			if( Distribute(	&gl_rec, param_rec.pa_cur_period,
					amt	)<0 ){
				roll_back(e_mesg);
				return(EXIT);
			}
			break;
		case 3:
		case 4:
			if( Distribute(&gl_rec,param_rec.pa_cur_period,amt)<0 ){
				roll_back(e_mesg);
				return(EXIT);
			}
			break;
	}
	gl_rec.curbud[tempptr->fields[item_no-1].s_period-1]   =  
	      D_Roundoff(gl_rec.curbud[tempptr->fields[item_no-1].s_period-1]); 
	gl_rec.budcur += amt;
	gl_rec.budcur = D_Roundoff(gl_rec.budcur);

	retval = put_gl( &gl_rec, UPDATE, e_mesg );
	if( retval!=NOERROR ){
		fomen(e_mesg);get();
		roll_back(e_mesg);
		return(retval);
	}
	return(0);
}
static
Distribute( glptr, beg_period, amt )
Gl_rec	*glptr;
short	beg_period;
double	amt;
{
	short	periods;	/* no. of periods for amount distribution */
	long	dist_value;	/* each period's share */
	short	last_period, i;

	switch( glptr->cdbud ){
		case 1:
		case 3:
			last_period = 13;
			break;
		case 2:
		case 4:
			last_period = 12;
			break;
	}
	periods = last_period - beg_period + 1 ;
	
	dist_value = (long)amt/(long)periods;

	glptr->curbud[last_period-1] += (double)( (long)amt % periods );
	glptr->curbud[last_period-1] = D_Roundoff(glptr->curbud[last_period-1]);

	for( i=beg_period-1; i<last_period; i++ ){
		glptr->curbud[i] += (double)( dist_value );
		glptr->curbud[i] = D_Roundoff(glptr->curbud[i]);
		if( glptr->curbud[i]<0.0 ){
#ifdef ENGLISH
			sprintf(e_mesg,
			  "Acct %s Period %d Net budget less than zero.Not writing",
			  glptr->accno, i );
#else
			sprintf(e_mesg,
			  "Compte %s periode %d budget net moins que zero. N'inscrit pas",
			  glptr->accno, i );
#endif
			fomen(e_mesg);
			get();
			return(-1);
		}
	}

	return(0);
}
static
WriteItem(line_no,item_no)/* Write one item in gltran file from *tempptr */
int line_no,item_no;
{

	STRCPY(tr_item.tr_term , tr_hdr.tr_term);
	tr_item.tr_sys_dt = tr_hdr.tr_sys_dt;
	tr_item.tr_seq_no = tr_hdr.tr_seq_no;
	tr_item.tr_item_no = item_no;

	tr_item.tr_fund = tempptr->fields[line_no-1].s_fund;
	tr_item.tr_reccod = tempptr->fields[line_no-1].s_reccod;
	STRCPY( tr_item.tr_accno, tempptr->fields[line_no-1].s_accno );
	tr_item.tr_period = tempptr->fields[line_no-1].s_period;
	tr_item.tr_amount = tempptr->fields[line_no-1].s_amount;
	tr_item.tr_amount = D_Roundoff(tr_item.tr_amount);
	tr_item.tr_status = 0;

	retval = put_bditem( &tr_item, ADD, e_mesg );
	if( retval!=NOERROR ){
		fomen(e_mesg);get();
		roll_back(e_mesg);
		return(retval);
	}
	return(0);
}
static
FreeList()	/* Free the linked list */
{
	for( tempptr=headptr; tempptr; tempptr=headptr ){
		headptr=headptr->nextptr;
		free( (char *)tempptr );
	}
	tailptr = NULL;
	return(0);
}
static
Inquire( access, direction )	/* Screen inquiry, random/sequential */
int access, direction;		/* RANDOM, SEQUENTIAL accesses */
{
	int retval;

	if( access==RANDOM ){
		retval = GetHeaderKey();	/* Read the key values */
		if(retval==UNDEF)
			return(0);
		if(retval==EXIT || retval==ERROR){
			if(ClearScreen()<0)	return(-1);
			return(retval);
		}
	}
	else{
		retval = GetNextHeader( direction );	/* Get next rec */
		if(retval==EFL)
			return(0);
	}
	if( retval<0 ){
		fomen(e_mesg);get();
		return(-1);
	}
	retval = DisplayRecord();	/* Display the header & item records */
	if( retval<0 ) return(retval);

	return( FreeList() );
}
static
DisplayRecord()	/* Get and display the header and item records */
{
	int retval;

	retval = ShowHeaderFields();	/* Display header information */
	if( retval<0 || retval==EXIT ) return(retval);

	retval = ShowItems();	/* Display first pageful of items */
	if( retval<0 || retval==EXIT ) return(retval);

	retval = ConfirmItems( INQ_MODE );	/* Allow scanning of pages */
	if( retval<0 || retval==EXIT ) return(retval);

	return(0);
}
static
GetNextHeader(direction)	/* Read the next rec in specified direction */
int	direction ;
{
	int retval;
	char tnum[5];
	
	if(get_tnum(tnum)<0 ) return(-1);	/* Get the terml number */
	if( flg_start(GLBDHDR) != direction){ 	/* file not in seq read mode */
		/* Set the least part of the key to next possible key and set
		   the file to start */
		STRCPY( tr_hdr.tr_term, tnum );
		tr_hdr.tr_sys_dt = s_rec.s_sysdt;
		if(direction == FORWARD)
			tr_hdr.tr_seq_no = (short)s_rec.s_sno + 1;
		else
			tr_hdr.tr_seq_no = (short)s_rec.s_sno - 1;
		flg_reset(GLBDHDR) ;
	}
	/* Read the next record from glbdhdr file */
	retval = get_n_bdhdr( &tr_hdr, BROWSE, 0, direction, e_mesg );
#ifndef	ORACLE
	seq_over(GLBDHDR) ;
#endif
	if( retval==EFL || strcmp( tnum, tr_hdr.tr_term) ){
#ifdef ENGLISH
		fomen("No More Records....");
#else
		fomen("Plus de fiches....");
#endif
		get();
		flg_reset(GLBDHDR);
		return(EFL);
	}
	if( retval!=NOERROR ){
		fomen(e_mesg);	get();
		return(retval);
	}
	s_rec.s_sysdt = tr_hdr.tr_sys_dt;
	s_rec.s_sno = tr_hdr.tr_seq_no;
	if( WriteFields(500,600)<0 )
		return(-1);
	return(0);
}
static
GetHeaderKey()	/* Read the header key values, get terminal info ,read rec */
{
	int i,retval;

	/* Enable dup buffers for reading key */
	for( i=500; i<=600; i+=100 )
		fomca1( i, 19, 2 );
	sr.nextfld=500; 
	sr.endfld=600;
	fomud( (char *)&s_rec );

	s_rec.s_sysdt = LV_LONG;
	s_rec.s_sno = LV_SHORT;
	if( (retval=ReadFields(500,600))<0  ||  retval==EXIT  ) 
		return(retval);
	tr_hdr.tr_sys_dt = s_rec.s_sysdt;
	tr_hdr.tr_seq_no = (short)s_rec.s_sno;
	if( get_tnum(tr_hdr.tr_term)<0 )	return(-1);
	retval = get_bdhdr( &tr_hdr, BROWSE, 0, e_mesg );
	if( retval!=NOERROR ){
		fomer(e_mesg);
		get();
		return(retval);
	}
	/* Disable dup buffers for reading key */
	for( i=500; i<=600; i+=100 )
		fomca1( i, 19, 2 );
	return(0);
}
static
ShowHeaderFields()	/* Display header info */
{
	STRCPY(s_rec.s_descr, tr_hdr.tr_descr );

	if( WriteFields(800,800)<0 ) return(-1);
	return(0);
}
static
ShowItems()	/* Display first pageful of items */
{
	if( BuildList()<0 )	/* Build linked list of pages in memory */ 
		return(-1);
	tempptr = headptr ;	/* Seek to first node/page of list */
	current.page = 1;
	if( FillLineHeading(LOW)<0 )	return(-1);
	if( WriteFields(950,950)<0 )	return(-1);
	if( ShowPage()<0 ) return(-1);	/* Display contents of page sought */ 
	return(0);
}
static
BuildList()	/* Read item by item from file and build list */
{
	int retval;

	headptr = tailptr = tempptr = NULL;

	STRCPY( tr_item.tr_term, tr_hdr.tr_term );
	tr_item.tr_sys_dt = tr_hdr.tr_sys_dt;
	tr_item.tr_seq_no = tr_hdr.tr_seq_no;
	tr_item.tr_item_no = 0;
	flg_reset(GLBDITEM);	/* Initialize to get first rec under givenkey */

	for( ; ; ){
#ifndef	ORACLE
		retval = get_n_bditem( &tr_item, BROWSE, 0, FORWARD, e_mesg);
#else
		retval = get_n_bditem( &tr_item, BROWSE, 0, EQUAL, e_mesg);
#endif
		if( retval==ERROR ){
			fomen(e_mesg);
			get();
			return(retval);
		}
		if( retval==EFL )
			break;
#ifndef	ORACLE
		if( 	strcmp(tr_item.tr_term,tr_hdr.tr_term) ||
			tr_item.tr_sys_dt != tr_hdr.tr_sys_dt  ||
			tr_item.tr_seq_no != tr_hdr.tr_seq_no  ||
			tr_item.tr_item_no<1	)
			break;	/* No more records with specified key */
#endif
		current.line = tr_item.tr_item_no % ITEMSPERPAGE;
		if( current.line==0 ) current.line = ITEMSPERPAGE;
		if( current.line==1 ){	/* New page to be formed */
		    tempptr = PageAllocated();	/* Allocate memory for page */
		    if( tempptr==NULL ){
#ifdef ENGLISH
		fomen("Internal Memory allocation error. Press a key");
#else
		fomen("Erreur d'allocation a la memoire interne. Appuyer sur une touche");
#endif
			get();
			return(-1);
		    }
		    tempptr->lines_entered = 0;
		    if( tr_item.tr_item_no==1 ){	/* First item */
			headptr = tailptr = tempptr;
			tempptr->nextptr = tempptr->prevptr = NULL;
		    }
		    else{
			tailptr->nextptr = tempptr;
			tempptr->prevptr = tailptr;
			tempptr->nextptr = NULL;
			tailptr = tempptr;
		    }
		}
		tempptr->fields[current.line-1].s_fund = tr_item.tr_fund;
		tempptr->fields[current.line-1].s_reccod = tr_item.tr_reccod;
		STRCPY(tempptr->fields[current.line-1].s_accno,tr_item.tr_accno);
		tempptr->fields[current.line-1].s_period = tr_item.tr_period;
		tempptr->fields[current.line-1].s_amount = tr_item.tr_amount;
		tempptr->fields[current.line-1].s_status[0] = HV_CHAR; 
		tempptr->lines_entered++;
	} 
	seq_over(GLBDITEM);
	if( headptr==NULL ){
#ifdef ENGLISH
		fomen("No transaction items to display. Press a key");
#else
		fomen("Pas d'articles de transaction a afficher. Appuyer sur une touche");
#endif
		get();
		return(-1);
	}
	return(0);
}

