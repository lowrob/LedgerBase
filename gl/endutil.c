#include <bfs_defs.h>
#include <bfs_recs.h>
#include <cfomstrc.h>

#define SCREEN_NAME	"endproc"
#define CURPERIOD	400
#define	START_LINE	500
#define END_LINE	1400
#define	SUBSYSTEM	1500
#define	PROCESS		1600
#define NEXTDATE	1700
#define	MESSAGE		1800
#define	RESPONSE	1900

#define EXIT		-12
#define ESC_F		(sr.retcode==RET_USER_ESC && \
			(sr.escchar[0]=='F'||sr.escchar[0]=='f'))
#define HL_CHAR(VAL)	VAL==HIGH ? HV_CHAR : LV_CHAR
#define LOW		-1
#define HIGH		1

#define MAXLINES	10
#define LINELEN		55
#define SUBSYSLEN	24
#define PROCESSLEN	47

/* endproc.sth - header for C structure generated by PROFOM EDITOR */

struct screen_lines {
	char	processline[56];	/* STRING Field 500 - 1400 */
};

struct endproc_struct{

	char	s_progname[11];	/* STRING Field 100 */
	char	s_scrhdg[13];	/* STRING Field 200 */
	long	s_rundt;	/* DATE   Field 300 */
	short	s_curperiod;	/* NUMERIC Field 400 */
	struct screen_lines line[10];   /* Fields 500 - 1400 */	
	char	s_subsystem[25];/* STRING Field 1500 */
	char	s_process[48];	/* STRING Field 1600 */
	long	s_nextdt;	/* DATE   Field 1700 */
	char	s_message[77];	/* STRING Field 1800 */
	char	s_resp[2];	/* STRING Field 1900 */
	};

struct endproc_struct	s_sth;
struct stat_rec		sr;
int initialized;

/* Add a menu item to the array of report menu items */
ListItem( line_no, string )
int	line_no;
char 	*string;
{
	if( line_no>=MAXLINES )	/* array can't accomodate any more */ 
		return(-1);
	SizeString(string,LINELEN);
	STRCPY( s_sth.line[line_no-1].processline, string );

	return(0);
}

Initialize( terminal,heading )	/* initialize profom and screen */
char *terminal;
char *heading;	
{
	if( InitProfom(terminal)<0 ){	/* initialize profom */
		fomcs();
		fomrt();
		return( -1 );
	}
	if( InitScreen(heading)<0 ){		/* initialize screen */
		fomcs();
		fomrt();
		return(-1);
	}
	initialized = 1 ;
	return(0);
}	
static
InitProfom(terminal)	/* initialize profom */
char *terminal;
{
	if ( initialized ) 
		return(0) ;
	STRCPY( sr.termnm, terminal );
	fomin( &sr );		/* initialize the screen */
	ret( err_chk(&sr) );	/* if profom error return */
	return(0);
}
static
InitScreen(heading)		/* initialize the screen */
char 	*heading;
{
	/* initialize the profom screen variables */
	STRCPY( sr.scrnam, NFM_PATH );
	strcat( sr.scrnam, SCREEN_NAME );

	/* initialize the fields of the profom screen */
	if( initialized==0 ){
		if( FillScrHdg(heading)<0 ) 		return(-1);
		if( BlankList()<0 ) 			return(-1);
		if( FillSubSystem(HIGH)<0 )		return(-1);
		if( FillProcess(HIGH)<0 )		return(-1);
		if( FillMesgResp(HIGH)<0)		return(-1);
	}

	fomcf( 1,1 ) ;		/* Enable snap screen */
	return(0);
}

/* Fill the screen heading fields, the program name and the date */
static
FillScrHdg(heading)
char *heading;
{
	STRCPY( s_sth.s_progname, PROG_NAME );
	STRCPY( s_sth.s_scrhdg, heading );
	s_sth.s_rundt = get_date();
	return(0);
}

BlankList()
{
	int	i;

	for(i=0;i < MAXLINES; i++) 
		s_sth.line[i].processline[0] = HV_CHAR;	
	
	return(0);
}
FillSubSystem(value)
int	value;
{
	s_sth.s_subsystem[0] = HL_CHAR(value); 
	return(0);
}
FillProcess(value)
int	value;
{
	s_sth.s_process[0] = HL_CHAR(value); 
	return(0);
}
FillMesgResp(value)
int	value;
{
	s_sth.s_message[0] = HL_CHAR(value); 
	s_sth.s_resp[0] = HL_CHAR(value); 
	return(0);
}
DisplayCurPeriod(period)
short 	period;
{
	s_sth.s_curperiod = period;
	return(WriteFields(CURPERIOD,CURPERIOD));
}
DisplayItems()
{
	return(WriteFields(START_LINE,END_LINE));
}
SetItemsAttribute(lineno,attribute,status)
int	lineno,
	attribute,
	status;
{
	int	field;

	field = (((lineno-1)*100) + START_LINE);
	fomca1(field,attribute,status);
	return(0);
}
SetSubSystem( string )
char	*string;
{
	SizeString(string,SUBSYSLEN);
	STRCPY(s_sth.s_subsystem,string);
	return(WriteFields( SUBSYSTEM, SUBSYSTEM ));
}
SetProcess( string )
char	*string;
{
	SizeString(string,PROCESSLEN);
	STRCPY(s_sth.s_process,string);
	return(WriteFields( PROCESS, PROCESS ));
}
static
SizeString(str, len)
char 	*str;
int	len;
{
	if(strlen(str) >= len) 
		str[len-1] = '\0';

	return(0);
}
GetNextDate(date)
long	*date;
{
	int	retval;

	s_sth.s_nextdt = *date ;
	fomca1( NEXTDATE, 19, 2 );
	sr.nextfld = NEXTDATE;
	sr.endfld = NEXTDATE;
	fomud( (char *)&s_sth );
	s_sth.s_nextdt = LV_LONG;

	retval = ReadFields( NEXTDATE, NEXTDATE );
	if( retval!=EXIT && retval>=0 )
		*date = s_sth.s_nextdt;
	fomca1( NEXTDATE, 19, 0 );

	return(retval);
}
static
ReadFields(start,end)	/* read fields whose numbers range from start to end */
int start, end;		/* start and end fields */
{
	int retval;

	sr.nextfld = start;
	sr.endfld = end;
	for( ; ; ){
		fomrd( (char *)&s_sth );
		ret(err_chk(&sr));
		if( sr.retcode==RET_USER_ESC || sr.retcode==RET_VAL_CHK ){
			if( ESC_F ) return(EXIT);
			retval=Validate();
			if( retval<0 || retval==EXIT)	return(retval);
			continue;
		}
		break;
	}
	return(0);
}
Validate()
{
	switch(sr.curfld) {
		case NEXTDATE:
			if(s_sth.s_nextdt < s_sth.s_rundt) {
#ifdef ENGLISH
			  fomen("Next date cannot be less than current date"); 
#else
			  fomen("Prochaine date ne peut pas etre plus tot que la date courante");
#endif
			  s_sth.s_nextdt = LV_LONG;
			}
			break;
		default:
			break;
	}
	sr.nextfld = sr.curfld; 
	return(0);
}
static
WriteFields( start,end )
int	start, end;
{
	sr.nextfld = start;
	sr.endfld = end;
	fomwr(( char *)&s_sth);
	ret(err_chk(&sr));
	return(0);
}
/* Display message and get the option */
GetOpt(msg,options)
char	*msg ;
char	*options ;
{
	int	i, j ;

	STRCPY(s_sth.s_message,msg);
	ShowMesg() ;

	sr.nextfld = RESPONSE;
	for( ; ; ) {
		fomrf((char *)&s_sth);
		ret(err_chk(&sr));

		j = strlen(options) ;
		for( i = 0 ; i < j ; i++)
			if(s_sth.s_resp[0] == options[i]) break ;
		if(i != j) break ;	/* Valid Option Selected */
#ifdef	ENGLISH
		fomer("Invalid Option..");
#else
		fomer("Option Invalide..");
#endif
	}
	s_sth.s_message[0] = HV_CHAR ;
	s_sth.s_resp[0] = HV_CHAR ;
	sr.nextfld = MESSAGE;
	sr.endfld = RESPONSE;
	fomwr((char *)&s_sth);
	ret(err_chk(&sr));
 
	return((int)(options[i])) ;
}	/* GetOpt() */

static
ShowMesg()  /* shows or clears message field */
{
	sr.nextfld = MESSAGE;
	fomwf((char *)&s_sth) ;
}
