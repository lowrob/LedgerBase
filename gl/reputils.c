/******************************************************************************
		Sourcename    : reputils.c
		System        : Budgetary Financial system.
		Module        : GL reports
		Created on    : 89-07-31
		Created  By   : K HARISH.
		Cobol sources : 

HISTORY:
 Date           Programmer     Description of modification
____/__/__      __________     ___________________________
1990/11/20      F.Tao          Add user calls so that they are able to
				to input the transaction type range.
1991/01/02	C.Leadbeater   Changed 'And' to 'And:' for GetPeriod()  
				(french also).
1993/01/12	L. Robichaud   Added a routine GetOpt to allow only valid 
				options. Pass to this routine the variable 
				that is to get the value and all the valid 
				answers, (ie. "YN")

Calls for the user:	( Check for the value returned: -1 on error )

int	AddMenuItem( char *name, int (* fnptr)() );
int	Initialize( char *terminalname , char *heading );
int	Process();
int	GetFund( short *);
int	GetFundRange( short *, short * );
int	GetAcct( char * );
int	GetAcctRange( char *, char * );
int	GetTrans( char * );
int	GetTransRange( char *, char * );
int	GetSeqRange( long *, long * );
int	GetReccod( short  *);
int	GetReccodRange( short *, short * );
int	GetPeriod( short  *);
int	GetPeriodRange( short *, short * );
int	DisplayMessage( char * );
int	GetResponse( char * );
int	HideMessage();
int	GetOutputon( char * );
int	GetFilename( char * );
int	GetPrinter( short * );
int	GetNbrCopies( short * );
int	GetDate( long * );
int	GetDateRange( long *, long * );
int	Confirm();		returns 1 for Yes, and 0 for anyother input

The programmer should make calls for appending menuitems in the following order.
		AddMenuItem( menuname, functionpointer );( max. 9 options )
		Initialize( screenheading );
		Process();	 for menu item selection
		{	Any "Get...." calls }
		Confirm();	It clears the screen and resets terminal
A maximum of 9 menuitems can be added, excluding one for Quitting the screen
which is automatically appended by the system.

For all the calls starting with "Get", user can pass any default values by 
initialising the corresponding variables before passing their address(es)
as parameters. The program doesnot do any validation except that it disallows
user's entry of end value ( range limit ) if it is smaller than starting value.

The last call should be "Confirm()",  which clears the profom screen and resets
the terminal characteristics

******************************************************************************/
#include <stdio.h>

#include <bfs_defs.h>
#include <cfomstrc.h>

#define SCREEN_NAME	"glrep"
#define EXIT		12
#define PATH_FILE_SIZE	50
#define STARTLINENUM	18
#define LOW 		-1
#define HIGH 		 1
#define HL_CHAR(VAL)	VAL==HIGH ? HV_CHAR : LV_CHAR
#define ESC_F		sr.retcode==RET_USER_ESC && \
			(sr.escchar[0]=='F'||sr.escchar[0]=='f')
#define HL_LONG(VAL)	VAL==HIGH ? HV_LONG : LV_LONG
#define	OPTIONLEN	36
#define MAXOPTIONS	11
#define MAXQUERYLINES	7
#define	FUND		0
#define	ACCOUNT		1
#define	RECCOD		2
#define	PERIOD		3
#define	DATE		4
#define TRAN 		5
#define SEQ		6

#ifdef ENGLISH
#define PRINTER 'P'
#define DISPLAY 'D'
#define FILE_IO	'F'
#define	YES	'Y'
#else
#define PRINTER 'I'
#define DISPLAY 'A'
#define FILE_IO	'D'
#define	YES	'O'
#endif

/* glrep.sth - header for C structure generated by PROFOM EDITOR */

static struct	s_struct	{
	char	s_progname[11];	/* 100 program name */
	char	s_scrhdg[22];	/* 200 */
	long	s_rundt;	/* 300 DATE YYYYFMMFDD */
	char	s_item[MAXOPTIONS][OPTIONLEN];	/* 400 - 1350 options */
	short	s_option;	/* 1400 user's input */
	char	s_hypline[2];	/* 1500 mask for seperator line */
	char	s_outputon[2];	/* 1600 report output on D / F / P */
	char	s_filename[16];	/* 1700 name of file if option is F */
	short	s_printer;	/* 1800 printer# if option is P */
	short	s_nbrcopies;	/* 1900 number of copies to print */
	short	s_fund1;	/* 2000 starting fund # */
	short	s_fund2;	/* 2100 ending fund # */
	char	s_acc1[19];	/* 2200 starting account  */
	char	s_acc2[19];	/* 2300 ending account  */
	short	s_rec1cod;	/* 2400 starting record code */
	short	s_rec2cod;	/* 2500 ending record code */
	short	s_per1;		/* 2600 starting period */
	char	s_prompt[5];	/* 2650 location for To: */
	short	s_per2;		/* 2700 ending period */
	long	s_date1;	/* 2800 start date */
	long	s_date2;	/* 2900 start date */
	char 	s_trans1[2];	/* 2950 trans type 1 */
	char  	s_trans2[2];	/* 2970	trans type 2 */	
 	long	s_seq1; 	/* 2980 seq no 1     */
	long	s_seq2; 	/* 2990 seq no 2     */
	char	s_mesg[77];	/* 3000 message field */
	char	s_resp[2];	/* 3100 response field */
}	s_rec;

typedef struct{
	char	name[OPTIONLEN];
	int	(* fnptr)();
	int	mainflno;
}Menu;

struct stat_rec 	sr;		/* profom status record */

static int		line[MAXQUERYLINES];/* for positioning key queries */
static short		call_no;
static short		totaloptions;
static int retval;	/* Global variable to store function values */
static Menu	menu[MAXOPTIONS];
static	int	initialised ;
extern char e_mesg[80]; 	/* to store error messages */

static
CleanExit()/* clear and exit the screen , close files & exit program */
{
	fomcs();
	fomrt();
	exit(0);
}
Initialize( terminal,heading )	/* initialize profom and screen */
char *terminal;
char *heading;	
{
	if( InitProfom(terminal)<0 ){	/* initialize profom */
		fomcs();
		fomrt();
		return( -1 );
	}
	if( InitScreen(heading)<0 ){		/* initialize screen */
		fomcs();
		fomrt();
		return(-1);
	}
	initialised = 1 ;
	return(0);
}	
static
InitProfom(terminal)	/* initialize profom */
char *terminal;
{
	if ( initialised ) 
		return(0) ;
	STRCPY( sr.termnm, terminal );
	fomin( &sr );		/* initialize the screen */
	ret( err_chk(&sr) );	/* if profom error return */
	return(0);
}
static
InitScreen(heading)		/* initialize the screen */
char 	*heading;
{
	/* initialize the profom screen variables */
	STRCPY( sr.scrnam, NFM_PATH );
	strcat( sr.scrnam, SCREEN_NAME );

	/* initialize the fields of the profom screen */
	if( initialised==0 ){
		if( FillScrHdg(heading)<0 ) 		return(-1);
		if( FillMenu()<0 ) 			return(-1);
		s_rec.s_option = HV_SHORT;
		s_rec.s_hypline[0] = LV_CHAR;
	}

	/* Move highs to inquiry area and write entire screen */
	if( ClearInquiryArea()<0 )	return(-1);

	fomcf( 1,1 ) ;		/* Enable snap screen */
	return(0);
}

/* Fill the screen heading fields, the program name and the date */
static
FillScrHdg(heading)
char *heading;
{
	STRCPY( s_rec.s_progname, PROG_NAME );
	STRCPY( s_rec.s_scrhdg, heading );
	s_rec.s_rundt = get_date();
	return(0);
}

/* Add a menu item to the array of report menu items */
AddMenuItem( menuname, fnptr, mainflno )
char 	*menuname;
int	(* fnptr)();
int	mainflno;
{
	if( totaloptions==0 ){ /* no options added to array yet */
#ifdef ENGLISH
		STRCPY( menu[totaloptions].name, "RETURN TO PREVIOUS MENU" );
#else
		STRCPY( menu[totaloptions].name, "RETOURNER AU MENU PRECEDENT");
#endif
		menu[totaloptions].fnptr = NULL;
		totaloptions++;
	}

	if( totaloptions>=MAXOPTIONS )	/* array can't accomodate any more */ 
		return(-1);
	if( menuname==NULL )		/* menu name can't be null */
		return(-1);
	STRCPY( menu[totaloptions].name, menuname );
	menu[totaloptions].fnptr = fnptr;	/* copy function pointer */
	menu[totaloptions].mainflno = mainflno;  /* copy main file used */

	totaloptions++;

	return(totaloptions-1);
}
/* Fill Menu Options with the proper names */
static
FillMenu()
{
	short	i;

	for( i=0; i<totaloptions; i++ )
		STRCPY( s_rec.s_item[i], menu[i].name );
	for( i=totaloptions; i<MAXOPTIONS; i++ )
		s_rec.s_item[i][0] = HV_CHAR;
	return(0);
}
/* Fill output details with high or low values */
static
FillOutputDetails( value )
short value;
{
	s_rec.s_outputon[0] = HL_CHAR(value);
	s_rec.s_filename[0] = HL_CHAR(value);
	s_rec.s_printer = HV_SHORT * value;
	s_rec.s_nbrcopies = HV_SHORT * value;
	return(0);
}
static
FillFund( val1, val2 )
short	val1, val2;
{
	s_rec.s_fund1 = HV_SHORT * val1;
	s_rec.s_fund2 = HV_SHORT * val2;
	return(0);
}
static
FillAccount( val1, val2 )
short	val1, val2;
{
	s_rec.s_acc1[0] = HL_CHAR( val1 );
	s_rec.s_acc2[0] = HL_CHAR( val2 );
	return(0);
}
static
FillTrans( val1, val2 )
short	val1, val2;
{

	s_rec.s_trans1[0] = HL_CHAR( val1 );
	s_rec.s_trans2[0] = HL_CHAR( val2 );
	return(0);
}
static
FillSeq(val1,val2 )
short val1,val2;
{
	s_rec.s_seq1 = HL_LONG(val1);
	s_rec.s_seq2 = HL_LONG(val2);
	return(0);
}
static
FillReccod( val1, val2 )
short	val1, val2;
{
	s_rec.s_rec1cod = HV_SHORT * val1;
	s_rec.s_rec2cod = HV_SHORT * val2;
	return(0);
}
static
FillPeriod( val1, val2 )
short	val1, val2;
{
	s_rec.s_per1 = HV_SHORT * val1;
	s_rec.s_prompt[0] = HL_CHAR( val1 );
	s_rec.s_per2 = HV_SHORT * val2;
	return(0);
}
static
FillDate( val1, val2 )
short	val1, val2;
{
	s_rec.s_date1 = HV_LONG * val1;
	s_rec.s_date2 = HV_LONG * val2;
	return(0);
}
/* Fill the message and response fields with high or low values */
static
FillMsgRespFields( value )
short value;
{
	s_rec.s_mesg[0] = HL_CHAR( value );
	s_rec.s_resp[0] = HL_CHAR( value );

	return(0);
}
/* Accept user's option and call the corresponding routine in a loop */
Process(terminal, heading)
char	*terminal ;
char	*heading  ;
{
	int	field;

	Initialize(terminal, heading) ;
	call_no = 0;	/* No get calls made yet */
	for( ; ; ){
		mainfileno = - 1;

		retval = ReadOption();
		if( retval<0 )
			return(-1);
		if( s_rec.s_option>=totaloptions ){
#ifdef ENGLISH
			fomer("Invalid option");
#else
			fomer("Option invalide");
#endif
			continue;
		}
		if( s_rec.s_option==0 ){   /* option 0 is reserved to quit */
			fomcs();
			fomrt();
			return(0);
		}
		if((retval = CheckAccess(menu[s_rec.s_option].mainflno,
					BROWSE,e_mesg))<0)
			return(retval);

		mainfileno = menu[s_rec.s_option].mainflno ;

		/* Highlight option. Dehighlight in Confirm() */
		field = 400+(s_rec.s_option*100);
		fomca1( field, 9, 3 );

		/* if a corresponding function exists, call it  */
		if( menu[s_rec.s_option].fnptr ){
			if( (*menu[s_rec.s_option].fnptr)()<0 )
				return(-1);
			fomst();
		}
		else 	/* there isn't corr. function,  return value */
			return (s_rec.s_option);

		if( ClearInquiryArea()<0 )
			return(-1);
	}
}

/*	The following Get....() calls display default values given as parameter 
*	and fill up the variable with the value entered by the user 
*	The fields for accepting input are positioned in the order in which
*	they are called. For this, they make use of variable 'call_no'
*/

GetFund( fund )
short	*fund;
{
	int	retval=0;

	if( line[FUND]==0 )	/* no fund call made yet */
		line[FUND] = STARTLINENUM + call_no++;
	fomca2( 2000,1, line[FUND], 1 );
	fomca2( 2000,2, line[FUND], 17 );
	fomca2( 2100,1, line[FUND], 40 );
	fomca2( 2100,2, line[FUND], 45 );

	s_rec.s_fund1 = *fund ;
	fomca1( 2000, 19, 2 );
	sr.nextfld = 2000;
	sr.endfld = 2000;
	fomud( (char *)&s_rec );
	s_rec.s_fund1 = LV_SHORT;
	retval = ReadFields( 2000, 2000 );
	if( retval!=EXIT && retval>=0 )
		*fund = s_rec.s_fund1;
	fomca1( 2000, 19, 0 );

	return(retval);
}
GetFundRange( fund1, fund2 )
short	*fund1, *fund2;
{
	int	retval=0;

	if( line[FUND]==0 )	/* no fund call made yet */
		line[FUND] = STARTLINENUM + call_no++;
	fomca2( 2000,1, line[FUND], 1 );
	fomca2( 2000,2, line[FUND], 17 );
	fomca2( 2100,1, line[FUND], 40 );
	fomca2( 2100,2, line[FUND], 45 );

	s_rec.s_fund1 = *fund1 ;
	s_rec.s_fund2 = *fund2 ;
	fomca1( 2000, 19, 2 );
	fomca1( 2100, 19, 2 );
	sr.nextfld = 2000;
	sr.endfld = 2100;
	fomud( (char *)&s_rec );
	if( FillFund( LOW, LOW )<0 )
		return(-1);
	retval = ReadFields( 2000, 2100 );
	if( retval!=EXIT && retval>=0 ){
		*fund1 = s_rec.s_fund1;
		*fund2 = s_rec.s_fund2;
	}
	fomca1( 2000, 19, 0 );
	fomca1( 2100, 19, 0 );

	return(retval);
}
GetAcct( acct )
char *acct;
{
	int	retval=0;

	if( line[ACCOUNT]==0 )	/* no account call made yet */
		line[ACCOUNT] = STARTLINENUM + call_no++;
	fomca2( 2200,1, line[ACCOUNT], 1 );
	fomca2( 2200,2, line[ACCOUNT], 17 );
	fomca2( 2300,1, line[ACCOUNT], 40 );
	fomca2( 2300,2, line[ACCOUNT], 45 );

	STRCPY( s_rec.s_acc1, acct );
	fomca1( 2200, 19, 2 );
	sr.nextfld = 2200;
	sr.endfld = 2200;
	fomud( (char *)&s_rec );
	s_rec.s_acc1[0] = LV_CHAR;
	retval = ReadFields( 2200, 2200 );
	if( retval!=EXIT && retval>=0 )
		strcpy( acct, s_rec.s_acc1 );
	fomca1( 2200, 19, 0 );

	return(retval);
}
GetAcctRange( acct1, acct2 )
char *acct1, *acct2;
{
	int	retval=0;

	if( line[ACCOUNT]==0 )	/* no account call made yet */
		line[ACCOUNT] = STARTLINENUM + call_no++;
	fomca2( 2200,1, line[ACCOUNT], 1 );
	fomca2( 2200,2, line[ACCOUNT], 17 );
	fomca2( 2300,1, line[ACCOUNT], 40 );
	fomca2( 2300,2, line[ACCOUNT], 45 );

	STRCPY( s_rec.s_acc1, acct1 );
	STRCPY( s_rec.s_acc2, acct2 );
	fomca1( 2200, 19, 2 );
	fomca1( 2300, 19, 2 );
	sr.nextfld = 2200;
	sr.endfld = 2300;
	fomud( (char *)&s_rec );
	s_rec.s_acc1[0] = LV_CHAR;
	s_rec.s_acc2[0] = LV_CHAR;
	retval = ReadFields( 2200, 2300 );
	if( retval!=EXIT && retval>=0 ){
		strcpy( acct1, s_rec.s_acc1 );
		strcpy( acct2, s_rec.s_acc2 );
	}

	fomca1( 2200, 19, 0 );
	fomca1( 2300, 19, 0 );

	return(retval);
}
GetReccod( reccod )
short	*reccod;
{
	int	retval=0;

	if( line[RECCOD]==0 )	/* no reccod call made yet */
		line[RECCOD] = STARTLINENUM + call_no++;
	fomca2( 2400,1, line[RECCOD], 1 );
	fomca2( 2400,2, line[RECCOD], 17 );
	fomca2( 2500,1, line[RECCOD], 40 );
	fomca2( 2500,2, line[RECCOD], 45 );

	s_rec.s_rec1cod = *reccod ;
	fomca1( 2400, 19, 2 );
	sr.nextfld = 2400;
	sr.endfld = 2400;
	fomud( (char *)&s_rec );
	s_rec.s_rec1cod = LV_SHORT;
	retval = ReadFields( 2400, 2400 );
	if( retval!=EXIT && retval>=0 )
		*reccod = s_rec.s_rec1cod;
	fomca1( 2400, 19, 0 );

	return(retval);
}
GetReccodRange( rec1cod, rec2cod )
short	*rec1cod, *rec2cod;
{
	int	retval=0;

	if( line[RECCOD]==0 )	/* no reccod call made yet */
		line[RECCOD] = STARTLINENUM + call_no++;
	fomca2( 2400,1, line[RECCOD], 1 );
	fomca2( 2400,2, line[RECCOD], 17 );
	fomca2( 2500,1, line[RECCOD], 40 );
	fomca2( 2500,2, line[RECCOD], 45 );

	s_rec.s_rec1cod = *rec1cod ;
	s_rec.s_rec2cod = *rec2cod ;
	fomca1( 2400, 19, 2 );
	fomca1( 2500, 19, 2 );
	sr.nextfld = 2400;
	sr.endfld = 2500;
	fomud( (char *)&s_rec );
	s_rec.s_rec1cod = LV_SHORT;
	s_rec.s_rec2cod = LV_SHORT;
	retval = ReadFields( 2400, 2500 );
	if( retval!=EXIT && retval>=0 ){
		*rec1cod = s_rec.s_rec1cod;
		*rec2cod = s_rec.s_rec2cod;
	}
	fomca1( 2400, 19, 0 );
	fomca1( 2500, 19, 0 );

	return(retval);
}
GetPeriod( period )
short	*period;
{
	int	retval=0;

	if( line[PERIOD]==0 )	/* no period call made yet */
		line[PERIOD] = STARTLINENUM + call_no++;
	fomca2( 2600,1, line[PERIOD], 1 );
	fomca2( 2600,2, line[PERIOD], 17 );
	fomca2( 2650,2, line[PERIOD], 40 );
	fomca2( 2700,2, line[PERIOD], 45 );

	s_rec.s_per1 = *period ;
	fomca1( 2600, 19, 2 );
	sr.nextfld = 2600;
	sr.endfld = 2600;
	fomud( (char *)&s_rec );
	s_rec.s_per1 = LV_SHORT;
	retval = ReadFields( 2600, 2600 );
	if( retval!=EXIT && retval>=0 )
		*period = s_rec.s_per1;
	fomca1( 2600, 19, 0 );

	return(retval);
}
GetPeriod2( period )
short	*period;
{
	int	retval=0;

	if( line[PERIOD]==0 )	/* no period call made yet */
		line[PERIOD] = STARTLINENUM + call_no++;
	fomca2( 2600,1, line[PERIOD], 1 );
	fomca2( 2600,2, line[PERIOD], 17 );
	fomca2( 2650,2, line[PERIOD], 40 );
	fomca2( 2700,2, line[PERIOD], 45 );

#ifdef ENGLISH
	STRCPY(s_rec.s_prompt,"And:");
#else
	STRCPY(s_rec.s_prompt,"et:");
#endif
	retval = WriteFields( 2650, 2650 );
	if(retval < 0) 	return(-1);

	s_rec.s_per2 = *period ;
	fomca1( 2700, 19, 2 );
	sr.nextfld = 2700;
	sr.endfld = 2700;
	fomud( (char *)&s_rec );
	s_rec.s_per2 = LV_SHORT;
	retval = ReadFields( 2700, 2700 );
	if( retval!=EXIT && retval>=0 )
		*period = s_rec.s_per2;
	fomca1( 2700, 19, 0 );

	return(retval);
}
GetPeriodRange( period1, period2 )
short	*period1, *period2;
{
	int	retval=0;

	if( line[PERIOD]==0 )	/* no period call made yet */
		line[PERIOD] = STARTLINENUM + call_no++;
	fomca2( 2600,1, line[PERIOD], 1 );
	fomca2( 2600,2, line[PERIOD], 17 );
	fomca2( 2650,2, line[PERIOD], 40 );
	fomca2( 2700,2, line[PERIOD], 45 );

#ifdef ENGLISH
	STRCPY(s_rec.s_prompt,"To:");
#else
	STRCPY(s_rec.s_prompt,"A :");
#endif
	s_rec.s_per1 = *period1 ;
	s_rec.s_per2 = *period2 ;
	fomca1( 2600, 19, 2 );
	fomca1( 2700, 19, 2 );
	sr.nextfld = 2600;
	sr.endfld = 2700;
	fomud( (char *)&s_rec );
	s_rec.s_per1 = LV_SHORT;
	s_rec.s_per2 = LV_SHORT;
	retval = ReadFields( 2600, 2700 );
	if( retval!=EXIT && retval>=0 ){
		*period1 = s_rec.s_per1;
		*period2 = s_rec.s_per2;
	}
	fomca1( 2600, 19, 0 );
	fomca1( 2700, 19, 0 );

	return(retval);
}
GetDate( date )
long	*date;
{
	int	retval=0;

	if( line[DATE]==0 )	/* no fund call made yet */
		line[DATE] = STARTLINENUM + call_no++;
	fomca2( 2800,1, line[DATE], 1 );
	fomca2( 2800,2, line[DATE], 17 );
	fomca2( 2900,1, line[DATE], 40 );
	fomca2( 2900,2, line[DATE], 45 );

	s_rec.s_date1 = *date ;
	fomca1( 2800, 19, 2 );
	sr.nextfld = 2800;
	sr.endfld = 2800;
	fomud( (char *)&s_rec );
	s_rec.s_date1 = LV_LONG;
	retval = ReadFields( 2800, 2800 );
	if( retval!=EXIT && retval>=0 )
		*date = s_rec.s_date1;
	fomca1( 2800, 19, 0 );

	return(retval);
}
GetDateRange( date1, date2 )
long	*date1, *date2;
{
	int	retval=0;

	if( line[DATE]==0 )	/* no date call made yet */
		line[DATE] = STARTLINENUM + call_no++;
	fomca2( 2800,1, line[DATE], 1 );
	fomca2( 2800,2, line[DATE], 17 );
	fomca2( 2900,1, line[DATE], 40 );
	fomca2( 2900,2, line[DATE], 45 );

	s_rec.s_date1 = *date1 ;
	s_rec.s_date2 = *date2 ;
	fomca1( 2800, 19, 2 );
	fomca1( 2900, 19, 2 );
	sr.nextfld = 2800;
	sr.endfld = 2900;
	fomud( (char *)&s_rec );
	if( FillDate( LOW, LOW )<0 )
		return(-1);
	retval = ReadFields( 2800, 2900 );
	if( retval!=EXIT && retval>=0 ){
		*date1 = s_rec.s_date1;
		*date2 = s_rec.s_date2;
	}
	fomca1( 2800, 19, 0 );
	fomca1( 2900, 19, 0 );

	return(retval);
}
GetTrans( trans )
char *trans;
{
	int	retval=0;

	if( line[TRAN]==0 )	
		line[TRAN] = STARTLINENUM + call_no++;
	fomca2( 2950,1, line[TRAN], 1 );
	fomca2( 2950,2, line[TRAN], 17 );
	fomca2( 2970,1, line[TRAN], 40 );
	fomca2( 2970,2, line[TRAN], 45 );

	STRCPY( s_rec.s_trans1, trans );
	fomca1( 2950, 19, 2 );
	sr.nextfld = 2950;
	sr.endfld = 2950;
	fomud( (char *)&s_rec );
	s_rec.s_trans1[0] = LV_CHAR;
	retval = ReadFields( 2950, 2950 );
	if( retval!=EXIT && retval>=0 )
		strcpy( trans, s_rec.s_trans1 );
	fomca1( 2950, 19, 0 );

	return(retval);
}
GetTransRange( trans1, trans2 )
char trans1[],trans2[];
{
	int	retval=0;

	if( line[TRAN]==0 )	/* no account call made yet */
		line[TRAN] = STARTLINENUM + call_no++;
	fomca2( 2950,1, line[TRAN], 1 );
	fomca2( 2950,2, line[TRAN], 17 );
	fomca2( 2970,1, line[TRAN], 40 );
	fomca2( 2970,2, line[TRAN], 45 );

	STRCPY( s_rec.s_trans1, trans1 );
	STRCPY( s_rec.s_trans2, trans2 );
	fomca1( 2950, 19, 2 );
	fomca1( 2970, 19, 2 );
	sr.nextfld = 2950;
	sr.endfld = 2970;
	fomud( (char *)&s_rec );
	s_rec.s_trans1[0] = LV_CHAR;
	s_rec.s_trans2[0] = LV_CHAR;
	retval = ReadFields( 2950, 2970 );
	if( retval!=EXIT && retval>=0 ){
		strcpy( trans1, s_rec.s_trans1 );
		strcpy( trans2, s_rec.s_trans2 );
	}
	fomca1( 2950, 19, 0 );
	fomca1( 2970, 19, 0 );
}

GetSeqRange( seq1, seq2 )
long *seq1,*seq2;
{
	int	retval=0;

	if( line[SEQ]==0 )	/* no account call made yet */
		line[SEQ] = STARTLINENUM + call_no++;

	fomca2( 2980,1, line[SEQ], 1 );
	fomca2( 2980,2, line[SEQ], 17 );
	fomca2( 2990,1, line[SEQ], 40 );
	fomca2( 2990,2, line[SEQ], 45 );

	s_rec.s_seq1 = *seq1;
	s_rec.s_seq2 = *seq2;
	fomca1( 2980, 19, 2 );
	fomca1( 2990, 19, 2 );
	sr.nextfld = 2980;
	sr.endfld = 2990;
	fomud( (char *)&s_rec );
	s_rec.s_seq1 = LV_LONG;
	s_rec.s_seq2 = LV_LONG;
	retval = ReadFields( 2980, 2990 );
	if( retval!=EXIT && retval>=0 ){
		*seq1 = s_rec.s_seq1;
		*seq2 = s_rec.s_seq2;
	}
	fomca1( 2980, 19, 0 );
	fomca1( 2990, 19, 0 );
}

GetOpt( var, answers)
/*   var is the variable that gets the valid answer, 
     and answers are all the valid choices. */
char 	*var;
char	*answers;

{ /* louis */
	int 	i;
	char 	ans[2];

	for (;;){
		retval = GetResponse( ans );
		if(retval < 0)  return(retval);
		for (i=0;i<(sizeof(answers));i++){
			if(ans[0] == answers[i]){
				var[0] = ans[0];
				return(NOERROR);
			}
		}
		fomer ("Invalid Option ...");
	}
}

Confirm()	/* returns 1 for yes, 0 for no, -1 for error */
{		/* Clears the profom screen when user's response is 'Y' */
	int	field;

#ifdef ENGLISH
	if( DisplayMessage("Confirm (Y/N)?")<0 )
#else
	if( DisplayMessage("Confirmer (O/N)?")<0 )
#endif
		return(-1);
	if( GetResponse(s_rec.s_resp)<0 )
		return(-1);
	field = s_rec.s_option*100 + 400;

	if( s_rec.s_resp[0]==YES ){
		fflush(stdout) ;
		fomcs();
		fomrt();
		initialised = 2 ;
		return(1);
	}

	/* Dehighlight the option which is highlighted in Process() */
	fomca1( field, 9, 5 );

	return( HideMessage() );
}

static
ClearInquiryArea()
{
	short i;

	call_no = 0;	/* Reset the call_no */
	for( i=0; i<MAXQUERYLINES; i++ )/* so that next time fields can be */
		line[i] = 0;	/* repositioned for next routine calls */
	if(FillOutputDetails(HIGH)<0 )
		return(-1);
	if(FillFund(HIGH,HIGH)<0 )
		return(-1);
	if(FillAccount(HIGH,HIGH)<0 )
		return(-1);
	if(FillReccod(HIGH,HIGH)<0 )
		return(-1);
	if(FillPeriod(HIGH,HIGH)<0 )
		return(-1);
	if(FillDate(HIGH,HIGH)<0 )
		return(-1);
	if(FillTrans(HIGH,HIGH)<0 )
		return(-1);
	if(FillSeq(HIGH,HIGH)<0 )
		return(-1);
	if(FillMsgRespFields(HIGH)<0 )
		return(-1);
	if( WriteFields(1,0)<0 )
		return(-1);
	return(0);
}
static
ReadOption()
{
	s_rec.s_option = LV_SHORT;
	if( ReadFields( 1400, 1400 )<0 )
		return(-1);
	return(0);
}
static
ReadFields(start,end)	/* read fields whose numbers range from start to end */
int start, end;		/* start and end fields */
{
	int retval;

	sr.nextfld = start;
	sr.endfld = end;
	for( ; ; ){
		fomrd( (char *)&s_rec );
		ret(err_chk(&sr));
		if( sr.retcode==RET_USER_ESC || sr.retcode==RET_VAL_CHK ){
			if( ESC_F ) return(EXIT);
			retval=Validate();
			if( retval<0 || retval==EXIT)	return(retval);
			continue;
		}
		break;
	}
	return(0);
}
static
WriteFields( start,end )/* write fields whose numbers range from start to end */
int start, end;
{
	sr.nextfld = start;
	sr.endfld = end;
	fomwr( (char *)&s_rec );
	ret( err_chk(&sr) );
	return(0);
}
static
Validate()	/* Validate the values entered by the user */
{
	int	retval;

	switch( sr.curfld ){
		case 1400:	/* menu option */
			if( s_rec.s_option<0 || s_rec.s_option>=totaloptions ){
#ifdef ENGLISH
				fomer("Invalid option");
#else
				fomer("Option invalide");
#endif
				s_rec.s_option = LV_SHORT;
			}
			break;
		case 1600:	/* output on */
			if( s_rec.s_outputon[0]!= DISPLAY &&
			    s_rec.s_outputon[0]!= PRINTER &&
			    s_rec.s_outputon[0]!= FILE_IO ){
#ifdef ENGLISH
				fomer("D(isplay), P(rinter), F(ile)");
#else
				fomer("A(fficher), I(mprimante), D(ossier)");
#endif
				s_rec.s_outputon[0] = LV_CHAR;
			}
			break;
		case 1700:	/* Filename */
			break;
		case 1800:	/* Printer */
			break;
		case 1900:	/* Page Size */
			break;
		case 2000:	/* start fund code */
			if( s_rec.s_fund1<1 ){
#ifdef ENGLISH
				fomer("Fund# can't be less than 1");
#else
				fomer("# de fond ne peut etre moins que 1");
#endif
				s_rec.s_fund1 = LV_SHORT;
			}
			break;
		case 2100:	/* end fund code */
			if( s_rec.s_fund2 < s_rec.s_fund1 ){
#ifdef ENGLISH
				fomer("Value can't be less than starting fund");
#else
				fomer("Valeur ne peut pas etre moins que le fond debutant");
#endif
				s_rec.s_fund2 = LV_SHORT;
			}
			break;
		case 2200:	/* starting account number */
			if( acnt_chk(s_rec.s_acc1)==ERROR ){
#ifdef ENGLISH
				fomer("Invalid Account number");
#else
				fomer("Numero de compte invalide");
#endif
				s_rec.s_acc1[0]=LV_CHAR;
				break;
			}
			break;
		case 2300:	/* ending account number */
			if( acnt_chk(s_rec.s_acc2)==ERROR ){
#ifdef ENGLISH
				fomer("Invalid Account number");
#else
				fomer("Numero de compte invalide");
#endif
				s_rec.s_acc2[0]=LV_CHAR;
				break;
			}
			if( strcmp( s_rec.s_acc2, s_rec.s_acc1 )<0 ){
#ifdef ENGLISH
				fomer("Ending accno can't be less than starting accno");
#else
				fomer("Numero de compte finissant peut pas etre moins que numero de compte debutant");
#endif
				s_rec.s_acc2[0] = LV_CHAR;
			}
			break; 
		case 2400:	/* starting record code */
			if( s_rec.s_rec1cod != 97 && 
			    s_rec.s_rec1cod != 98 && 
			    s_rec.s_rec1cod != 99 ) { 
#ifdef ENGLISH
				fomer("Record code must be 97, 98 or 99");
#else
				fomer("Code de fiche doit etre 97, 98 ou 99");
#endif
				s_rec.s_rec1cod = LV_SHORT ;
			}
			break;
		case 2500:	/* ending record code */
			if( s_rec.s_rec2cod < s_rec.s_rec1cod ){
#ifdef ENGLISH
				fomer("End record code can't be less than start record code");
#else
				fomer("Code de fiche de la fin ne peut pas etre moins que le code de fiche de debut");
#endif
				s_rec.s_rec2cod = LV_SHORT; 
			} 
			break; 
		case 2600:	/* start period */
			if( s_rec.s_per1<1 || s_rec.s_per1>13 ){
#ifdef ENGLISH
				fomer("Valid periods are 1 to 13");
#else
				fomer("Periodes valables sont de 1 a 13");
#endif
				s_rec.s_per1 = LV_SHORT ;
			}
			break;
		case 2700:	/* end period */
			if( s_rec.s_per2<1 || s_rec.s_per2>13 ){
#ifdef ENGLISH
				fomer("Valid periods are 1 to 13");
#else
				fomer("Periodes valables sont de 1 a 13");
#endif
				s_rec.s_per2 = LV_SHORT;
			}
			else if( s_rec.s_per2 < s_rec.s_per1 ){
#ifdef ENGLISH
				fomer("End period can't be less than start period");
#else
				fomer("Periode de fin ne peut pas etre plus tot que la periode de debut");
#endif
				s_rec.s_per2 = LV_SHORT; 
			} 
			break;
		case 2800:	/* start date */
			break;
		case 2900:	/* end date */
			if( s_rec.s_date2 < s_rec.s_date1 ){
#ifdef ENGLISH
				fomer("End date can't be less than start date");
#else
				fomer("Date de fin ne peut pas etre plus tot que la date de debut");
#endif
				s_rec.s_date2 = LV_LONG; 
			} 
			break;
		case 2950:
			break;
		case 2970:
			if( strcmp( s_rec.s_trans2, s_rec.s_trans1 )<0 ){
#ifdef ENGLISH
				fomer("Ending trans.type can't be less than starting accno");
#else
				fomer("Numero de compte finissant peut pas etre moins que numero de compte debutant");
#endif
				s_rec.s_trans2[0] = LV_CHAR;
			}
			break; 
		case 3100:
			break;
	}
	sr.nextfld = sr.curfld;
	return(0);
}
DisplayMessage(mesg)	/* Display the given message in the message field */
char *mesg;
{
	STRCPY( s_rec.s_mesg, mesg );
	if( WriteFields(3000,3000)<0 )	return(-1);
	return(0);
}
HideMessage()	/* Hide the message field */
{
	if( FillMsgRespFields(HIGH)<0 )	return(-1);
	if( WriteFields(3000,3100)<0 ) return(-1);
	return(0);
}
GetResponse( respchar )
char *respchar;
{
	int	retval;

	s_rec.s_resp[0] = LV_CHAR;
	retval = ReadFields( 3100, 3100 );
	if( retval!=EXIT && retval>=0 )
		*respchar = s_rec.s_resp[0];
	return( retval );
}
GetOutputon( outputon )
char	*outputon;
{
	int	retval;

#ifdef ENGLISH
	fomer("D(isplay), P(rinter), F(ile)");
#else
	fomer("A(fficher), I(mprimante), D(ossier)");
#endif
	STRCPY( s_rec.s_outputon, outputon );
	fomca1( 1600, 19, 2 );
	sr.nextfld = 1600;
	sr.endfld = 1600;
	fomud( (char *)&s_rec );
	s_rec.s_outputon[0] = LV_CHAR;
	retval = ReadFields(1600,1600);
	if( retval!=EXIT && retval>=0 )
		*outputon = s_rec.s_outputon[0];
	fomca1( 1600, 19, 0 );
	return( retval );
}
GetFilename( filename )
char	*filename;
{
	int	retval;

	STRCPY( s_rec.s_filename, filename );
	fomca1( 1700, 19, 2 );
	sr.nextfld = 1700;
	sr.endfld = 1700;
	fomud( (char *)&s_rec );
	s_rec.s_filename[0] = LV_CHAR;
	retval = ReadFields(1700,1700);
	if( retval!=EXIT && retval>=0 )
		strcpy( filename , s_rec.s_filename ) ;
	fomca1( 1700, 19, 0 );
	return( retval );
}
GetPrinter( printer )
short	*printer;
{
	int	retval;

	s_rec.s_printer = *printer ;
	fomca1( 1800, 19, 2 );
	sr.nextfld = 1800;
	sr.endfld = 1800;
	fomud( (char *)&s_rec );
	s_rec.s_printer = LV_SHORT;
	retval = ReadFields(1800,1800);
	if( retval!=EXIT && retval>=0 )
		*printer = s_rec.s_printer;
	fomca1( 1800, 19, 0 );
	return( retval );
}
GetNbrCopies( copies )
short	*copies;
{
	int	retval;

	s_rec.s_nbrcopies = *copies ;
	fomca1( 1900, 19, 2 );
	sr.nextfld = 1900;
	sr.endfld = 1900;
	fomud( (char *)&s_rec );
	s_rec.s_nbrcopies = LV_SHORT;
	retval = ReadFields(1900,1900);
	if( retval!=EXIT && retval>=0 )
		*copies = s_rec.s_nbrcopies;
	fomca1( 1900, 19, 0 );
	return( retval );
}

