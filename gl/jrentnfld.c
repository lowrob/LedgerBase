/******************************************************************************
		Sourcename    : jrentry.c
		System        : Budgetary Financial system.
		Module        : Journal Entries
		Created on    : 89-05-17
		Created  By   : K HARISH.
		Cobol sources : gl040f--03 

*******************************************************************************
About the program:

	It allows posting of journal entries with online update of the 
	GL master file. For each session, a transaction header record and 
	a number of transaction item records  are created. The item records
	are linked to the corresponding header by sharing a common key. The
	header key is made from the terminal_no+system_date+transaction_no.
	The key for transaction items is the header-key+itemno. The transaction
	numbers are generated by the system, by reading the key of the last
	header record from the file.

	A journal entry session comprises of the following actions.
		1. Writing a transaction record header in to transaction
			header file.
		2. Writing a number of  transaction items into transaction
			items file
		3. Modification of GL master through posting of transaction item
			entries.

	The program also allows posting of accrual entries when called with 
	switch 1.   It comprises of the following additional steps.

		4. Creation of a contra entry session ( transaction header 
			and item for the next period ) and writing them to 
			the corresponding files.
		5. Modification of the next month credit/debit field in the GL
			master for the contra entry amount.


HISTORY:
 Date           Programmer	Description of modification
YYYY/MM/DD      __________	___________________________
1990/11/20	C.Leadbeater	Addition of totals fields to screen
			      	(DEBIT,CREDIT & DIFF).	
			       	Default values for record code & fund no.
1990/12/18	F.Tao 	       	Round up amounts before writing to file.
1990/12/28	F.Tao 	       	Increment sequential number if exist in the
			       	file while someone inputing the record.
1991/02/07	J.Prescott	made tr_date default to previously entered
				date.
******************************************************************************/
#include <stdio.h>

#define MAIN
#define MAINFL	GLTRHDR

#include <bfs_defs.h>
#include <bfs_recs.h>
#include <cfomstrc.h>

#define SYSTEM		"GENERAL LEDGER"
#define MOD_DATE	"20-NOV-90"
#define SCREEN_NAME	"jrentry"
#define ITEMSPERPAGE 	10
#define EXIT		12
#define ALLOC_ERROR	13
#define DEBITS		14
#define CREDITS		15
#define ADD_MODE	16
#define INQ_MODE	17
#define RANDOM  	18
#define SEQUENTIAL	19
#define NORMAL		20
#define REVERSED	21
#define PATH_FILE_SIZE	50
#define DELTA_AMT	0.0001
#define LOW 		-1
#define HIGH 		 1
#define HL_CHAR(VAL)	VAL==HIGH ? HV_CHAR : LV_CHAR
#define ESC_F		sr.retcode==RET_USER_ESC && \
			(sr.escchar[0]=='F'||sr.escchar[0]=='f')
#define ESC_H		sr.retcode==RET_USER_ESC && \
			(sr.escchar[0]=='H'||sr.escchar[0]=='h')
#define ACCRUALS	SW1

#define FN_FLD		400
#define	KEY_START	500 
#define	KEY_END		700
#define CHG_FLD		800
#define HDR_ST_FLD	1000
#define HDR_END_FLD	1400
#define END_FLD		5500

#define FUND_FLD	500 
#define RECCOD_FLD	600
#define SYSDT_FLD	1000
#define PERIOD_FLD	1100	
#define TRTYPE_FLD	1200
#define TRDATE_FLD	1300
#define DESC_FLD	1400

#define STEP		300
#define	ITEM_ST_FLD	2100
#define ACCNO_FLD	100
#define AMT_FLD		200
#define	DEBITS_FLD	5100
#define	CREDITS_FLD	5200
#define	DIFF_FLD	5300

#ifdef ENGLISH
#define ADDREC 	'A'
#define CHANGE 	'C'
#define DELETE	'D'
#define NEXT	'N'
#define PREV	'P'
#define INQUIRE	'I'
#define EXITOPT	'E'

#define EDIT	'E'
#define CANCEL	'C'
#define REVIVE	'R'
#define YES	'Y'
#define NO	'N'
#else	/* French */
#define ADDREC 	'R'
#define CHANGE 	'C'
#define DELETE	'E'
#define NEXT	'S'
#define PREV	'P'
#define INQUIRE	'I'
#define EXITOPT	'F'

#define EDIT	'M'
#define CANCEL	'A'
#define REVIVE	'V'
#define YES	'O'
#define NO	'N'
#endif

typedef struct scr_item{	/* one line of fields for each entry item */ 
	char	s_accno[19];	/* 2100 - 4800 STRING XXXXXXXXXXXXXXXXXX */
	double	s_amount;	/* 2200 - 4900 NUMERIC 999F999F999.99 */ 
	char	s_status[4];	/* 2300 - 5000 Status Active/Deleted */ 
} Scr_item;

/* jrentry.sth - header for C structure generated by PROFOM EDITOR */
struct	jr_struct	{
	char	s_progname[11];	/* Program name field 100 */
	char	s_scrhdg[19];	/* Screen Heading field 200 */
	long	s_rundt;	/* Date field  for display only 300 */
	char	s_fn[2];	/* Function field 400 */
	short	s_fund; 	/* 500 NUMERIC 999 */
	short	s_reccod;	/* 600 NUMERIC 99 */
	long	s_sno; 		/* 700 NUMERIC 99999999 */
	short	s_fld_no;	/* 800 NUMERIC 999 */
	long	s_sysdt;	/* 1000 NUMERIC 9999999F99 */
	short	s_period;	/* 1100 NUMERIC 99 */
	char	s_tr_code[2];	/* 1200  STRING X */
	long	s_tr_date;	/* 1300 NUMERIC 9999F99F99 */
	char	s_descr[25];	/* 1400 STRING XXXXXXXXXXXXXXXXXXXXXXXX */
	char	s_seperator[2];	/* To hide a demarcating line 1500 */
	char	s_hdg1mask[2];	/* Heading mask, dummy field 1600 */
	char	s_hdg2mask[4];	/* Heading mask, dummy field 1700 */
	short	s_page;		/* Page # of items field 2000 */
	Scr_item s_entries[ITEMSPERPAGE]; /* fields 2100-5000 array */
	double	s_debits;	/* 5100 Debits total field S99F999F999.99 */
	double	s_credits;	/* 5200 Debits total field S99F999F999.99 */
	double	s_diff;		/* 5300 Debits total field S99F999F999.99 */
	char	s_mesg[78];	/* STRING X(77) 5400 */
	char	s_resp[2];	/* STRING X 5500 */
};

typedef struct{		/* structure to record current page & line of entry */
	short	page;	
	short	line;
}	Counter;

			/* link list node for holding one page of entries */
typedef	struct pgofitems{
	struct pgofitems *prevptr;	/* pointer to previous entry */
	int	lines_entered;		/* no of lines entered */
	Scr_item fields[ITEMSPERPAGE];	/* array of lines per page */
	struct pgofitems *nextptr;	/* pointer to next entry */
}	Page;

static Page	*headptr,*tempptr,*tailptr;	/* to maintain list */
static Counter	current; /* For current line & page of journal item entry */
static struct jr_struct	s_rec;		/* screen record */
static Gl_rec 		gl_rec;		/* GL master record */
static Tr_hdr 		tr_hdr;		/* GL transaction header rec */
static Tr_item 		tr_item;	/* GL transaction item rec */
struct stat_rec 	sr;		/* profom status record */
static Pa_rec		param_rec;	/* parameter file record */
static Ctl_rec		ctl_rec;	/* control file record */

static int totalitemsadded;	/* total items added in any add session */

static int retval;	/* Global variable to store function values */
static int list;	/* Flag to indicate complete or partial listing */ 
char e_mesg[80]; /* to store error messages */
static int	HdrValidation(), ItemsValidation() ;
static int first; 
int prntmode; 
static long prev_tr_date;

double D_Roundoff();

/* Initialize profom fields, call entry procedures */
main( argc, argv )
int argc;
char *argv[];
{
	strncpy( SYS_NAME, SYSTEM, 50 ); 	/* Module name */
	strncpy( CHNG_DATE, MOD_DATE, 10 );	/* Last date of change */
	proc_switch( argc,argv,MAINFL ); 	/* process the switches */

	if( Initialize(terminal) <0 )	/* initialize profom and screen */
		exit(-1);
	retval = Process();		/* process the user's options */
	CleanExit(retval);		/* Wind up the show */
}

static
CleanExit(val)/* clear and exit the screen , close files & exit program */
{
	close_dbh();
	for( ; ; ) {
#ifdef ENGLISH
		if(DisplayMessage( "Print Audit Trail (Y/N)?")<0 ) 
#else
		if(DisplayMessage( "R(ajouter art), M(odifier), A(nnuler)")<0 ) 
#endif
			return(-1);
		
		sr.nextfld = END_FLD;
		fomrf( (char *)&s_rec );	/* Read user's option */
		ret( err_chk(&sr) );

		if(s_rec.s_resp[0] == YES || s_rec.s_resp[0] == NO) {
			break;
		}
		else {
			fomer("Invalid Option");
		}
	}
	if (ACCRUALS){
		prntmode = -1;
	}
	else {
		prntmode = 1;
	}
	if(s_rec.s_resp[0] == YES) {
		val = journal(prntmode);
	}
	fomcs();
	fomrt();
	exit(val);
}
static
Initialize( terminal )	/* initialize profom and screen */
char *terminal;
{
	if( InitProfom(terminal)<0 ){	/* initialize profom */
		fomcs();
		fomrt();
		return( -1 );
	}
	if( InitScreen()<0 ){		/* initialize screen */
		fomcs();
		fomrt();
		return(-1);
	}
	fomcf(1,1);	/* Enable Snap screen option */
	return(0);
}	
static
InitProfom(terminal)	/* initialize profom */
char *terminal;
{
	STRCPY( sr.termnm, terminal );
	fomin( &sr );		/* initialize the screen */
	ret( err_chk(&sr) );	/* if profom error return */
	return(0);
}
static
InitScreen()		/* initialize the screen */
{
	/* initialize the profom screen variables */
	STRCPY( sr.scrnam, NFM_PATH );
	strcat( sr.scrnam, SCREEN_NAME );

	/* initialize the fields of the profom screen */
	if( FillScrHdg()<0 ) 				return(-1);

	if( FillKeyFields( LOW )<0 ) 			return(-1);

	if( FillFieldNum( HIGH )<0 ) 			return(-1);
	if( FillHeaderFields( HIGH )<0 ) 		return(-1);

	if( FillSeperatorLine(HIGH)<0 ) 		return(-1);
	if( FillLineHeading( HIGH )<0 ) 		return(-1);
	if( FillItemLines( HIGH,1,ITEMSPERPAGE )<0 )	return(-1);
	if(FillTotalLines(HIGH)<0 ) 			return(-1);

	if( FillMsgRespFields( HIGH )<0 ) 		return(-1);

	if( WriteFields(1,0)<0 )			return(-1);

	return(0);
}
/* Fill the screen heading fields, the program name and the date */
static
FillScrHdg()
{
	STRCPY( s_rec.s_progname, PROG_NAME );
	if( ACCRUALS )
#ifdef ENGLISH
		STRCPY( s_rec.s_scrhdg," ACCRUAL  ENTRIES " );
	else
		STRCPY( s_rec.s_scrhdg," JOURNAL  ENTRIES " );
#else
		STRCPY( s_rec.s_scrhdg," CHARGES A PAYER " );
	else
		STRCPY( s_rec.s_scrhdg,"ENTREES DE JOURNAL" );
#endif
	s_rec.s_rundt = get_date();
	return(0);
}
/* Fill the keyfields with high or low values */
static
FillKeyFields( value )
short value;
{
	s_rec.s_fund 	= value * HV_SHORT;
	s_rec.s_reccod	= value * HV_SHORT;
	s_rec.s_sno     = value * HV_LONG;

	return(0);
}
/* Fill the demarkating line field with high/low values */
static
FillSeperatorLine( value )
short value;
{
	s_rec.s_seperator[0] = HL_CHAR(value);
	return(0);
}
/* Fill the field# field with high/low values */
static
FillFieldNum( value )
short value;
{
	s_rec.s_fld_no = value * HV_SHORT;

	return(0);
}
/* Fill the transaction header part with high/low values */
static
FillHeaderFields( value )
short value;
{
	s_rec.s_sysdt   	= value * HV_LONG;
	s_rec.s_period   	= value * HV_SHORT;
	s_rec.s_tr_code[0]	= HL_CHAR( value );
	s_rec.s_tr_date 	= value * HV_LONG;
	s_rec.s_descr[0]	= HL_CHAR( value );

	return(0);
}
/* Fill the message and response fields with high or low values */
static
FillTotalLines( value )
short value;
{
	s_rec.s_debits 	= value * HV_DOUBLE;
	s_rec.s_credits = value * HV_DOUBLE;
	s_rec.s_diff 	= value * HV_DOUBLE;

	return(0);
}

/* Fill the message and response fields with high or low values */
static
FillMsgRespFields( value )
short value;
{
	s_rec.s_mesg[0] = HL_CHAR( value );
	s_rec.s_resp[0] = HL_CHAR( value );

	return(0);
}
/* Fill the Xaction item heading line with high/low values */
static
FillLineHeading(val)
int val;
{
	if( val==HIGH ){
		s_rec.s_hdg1mask[0] = HV_CHAR;
		s_rec.s_hdg2mask[0] = HV_CHAR;
	}
	else{
		s_rec.s_hdg1mask[0] = ' ';
		if( s_rec.s_fn[0]==ADDREC )	/* Show only while adding rec */
			STRCPY(s_rec.s_hdg2mask,"   ");
		else
			s_rec.s_hdg2mask[0] = HV_CHAR;
	}
	return(0);
}
/* Fill the Xaction item array with high or low values */
static
FillItemLines( value,firstline,lastline )
int value;
short firstline, lastline;
{
	short i;

	s_rec.s_page = value * HV_SHORT;
	for( i=firstline-1; i<lastline; i++ ){
		s_rec.s_entries[i].s_accno[0] = HL_CHAR(value);
		s_rec.s_entries[i].s_amount = value * HV_DOUBLE;
		s_rec.s_entries[i].s_status[0] = HL_CHAR(value);
	
	}
	return(0);
}
/* Accept user's option and call the corresponding routine in a loop */
static
Process()
{
	if(FillKeyFields(LOW)<0 ) return(-1);
	retval = get_param( &param_rec, BROWSE, 1, e_mesg );
	if( retval < 0 ){
		fomen(e_mesg);
		get();
		return(retval);
	}
	s_rec.s_fund = 1;
	s_rec.s_reccod = 99;
	s_rec.s_sno = 0;	/* useful if N(ext) option is selected first */
	for( ; ; ){
		if( ReadFunction()<0 ) return(-1);
		switch( s_rec.s_fn[0] ){
			case ADDREC:	/* add a transaction list */
				if( SW9==0 && param_rec.pa_cur_period==0 ){
#ifdef ENGLISH
				   fomen("Not Allowed Before Yearly Closing..");
#else
				   fomen("Pas permis avant la fermeture annuelle..");
#endif
				   get();
				   break;
				}
				CHKACC(retval,ADD,e_mesg);
				if( AddRecords()<0 ) return(-1);
				break;
			case NEXT:	/* show next Xaction list in sequence */
				CHKACC(retval,BROWSE,e_mesg);
				if( Inquire(SEQUENTIAL,FORWARD)<0 ) return(-1);
				break;
			case PREV:	/* show prev Xaction list in sequence */
				CHKACC(retval,BROWSE,e_mesg);
				if( Inquire(SEQUENTIAL,BACKWARD)<0 ) return(-1);
				break;
			case INQUIRE:	/* show selected Xaction list */
				CHKACC(retval,BROWSE,e_mesg);
				if( Inquire(RANDOM,0)<0 ) return(-1);
				break;
			case EXITOPT:	/* exit */
				return(0);
			default:
				break;
		}
		if( retval<0 ){
			fomen(e_mesg);
			get();
		}
		if( retval==DBH_ERR )
			return(retval);
	}
}
static
ReadFunction()	/* Display options at the bottom and read entry */
{
#ifdef ENGLISH
	fomer("A(dd), N(ext), P(rev), I(nquire), E(xit)");
#else
	fomer("R(ajouter), S(uivant), P(recedent), I(nterroger), F(in)");
#endif
	sr.nextfld = FN_FLD;	/* Fn field number */
	fomrf( (char *)&s_rec );
	ret( err_chk(&sr) );
	return(0);
}
/* Add a complete Xaction, with 1 header & a no. of item records */
static
AddRecords()
{
	long	seqno;

	if(ClearScreen()<0)	return(-1);
	if( (retval=ReadKeyFields())<0 )	return(retval);
	if(retval==EXIT){
		if(ClearScreen()<0)	return(-1);
		return(retval);
	}
	if( FillHeaderFields(LOW)<0 ) return(-1);
	s_rec.s_sysdt = HV_LONG;
	if( ACCRUALS ){		/* Impose transaction type and date */
		s_rec.s_period = HV_SHORT;
		s_rec.s_tr_code[0] = 'A';	/* accrual type */
		s_rec.s_tr_date = s_rec.s_rundt;	/* system date */
	}
	else if (SW9 == 1) s_rec.s_period = HV_SHORT ;
	s_rec.s_sysdt = get_date();

	/* used to set tr_date to previous date entered */
	if(first==0) {
		s_rec.s_tr_date = s_rec.s_rundt;	/* system date */
		first=1;
	}
	else  
		s_rec.s_tr_date = prev_tr_date;

	if( SW9==1 && param_rec.pa_cur_period==0 )	
		s_rec.s_period = param_rec.pa_no_periods;
	else
		s_rec.s_period = param_rec.pa_cur_period;

	if( !ACCRUALS ) 
		s_rec.s_tr_code[0] = '7';	

	fomca1( SYSDT_FLD, 19, 2 );
	fomca1( PERIOD_FLD, 19, 2 );
	fomca1( TRTYPE_FLD, 19, 2 );
	fomca1( TRDATE_FLD, 19, 2 );
	sr.nextfld = SYSDT_FLD ; 
	sr.endfld = TRDATE_FLD;
	fomud( (char *)&s_rec );
	if (!ACCRUALS && SW9!=1) s_rec.s_period = LV_SHORT ;
	if (!ACCRUALS) s_rec.s_tr_code[0] = LV_CHAR;
	s_rec.s_tr_date = LV_LONG ;
	if( (retval=ReadFields(HDR_ST_FLD,HDR_END_FLD,HdrValidation))<0 )
		return(retval);/* read header fields */
	fomca1( PERIOD_FLD, 19, 0 );	
	fomca1( TRTYPE_FLD, 19, 0 );
	fomca1( SYSDT_FLD, 19, 0 );	
	fomca1( TRDATE_FLD, 19, 0 );

	/* set trans date to previous date entered */
	prev_tr_date = s_rec.s_tr_date;

	if(retval==EXIT){
		if(ClearScreen()<0)	return(-1);
		return(retval);
	}
	if( (retval=ConfirmHeader())<0 )	return(retval);
	if( retval==EXIT ){
		if(ClearScreen()<0)	return(-1);
		return(retval);
	}
	if( FillSeperatorLine(LOW)<0 ) return(-1);
	if( FillLineHeading(LOW)<0 )	return(-1);
	if( WriteFields(1500,1700)<0 )	return(-1);
	if( (retval=ReadItemFields())<0 ){
		roll_back(e_mesg);
		return(retval);
	}
	if( retval==EXIT ){
		if(ClearScreen()<0)	return(-1);
		roll_back(e_mesg);
		return(retval);
	}

	for( ; ; ) {
		retval=WriteSession(NORMAL);
		if(retval < 0) {
			if(retval == DUPE) {
				roll_back(e_mesg);
				s_rec.s_sno++;
				if(WriteFields(KEY_END,KEY_END)<0)
					return(-1);
			}
			else {
				roll_back(e_mesg);
				return(-1);
			}
		}
		else
			break;


		retval = ConfirmItems(ADD_MODE);
		if( retval<0 )	return(retval);
		if( retval==EXIT ){
			if(ClearScreen()<0)		/* Clear the screen */
				return(-1);	
			return(EXIT);
		}
	}

	if( ACCRUALS ){
		s_rec.s_tr_code[0] = 'R';	/* REVERSED entry */
		if(s_rec.s_period > 11) {
			seqno = s_rec.s_sno;
			s_rec.s_period = 1;
			/* write reverse entries to new year */
			if( WriteToNewYear() < 0) 
				return(-1);
			s_rec.s_sno = seqno;
		}
		else {
			s_rec.s_period++ ;
			/* inc. serial no. on screen and tr_hdr */
			s_rec.s_sno++;	
			tr_hdr.th_seq_no = s_rec.s_sno;
			/* write reverse entries to current year */
			if( WriteSession(REVERSED)<0 )	
				return(-1);
			/* dec. serial no. on screen to avoid confusion */
			s_rec.s_sno--; /* while viewing records in sequence */
		}
		tr_hdr.th_seq_no = (short)s_rec.s_sno;
	}
	return( FreeList() );
}
static
ReadKeyFields()	/* Display system date, generated serial#, and read period */
{
	int retval, i;
	short	fund,reccod ;
	long	sno;

	fund = s_rec.s_fund ;
	reccod = s_rec.s_reccod ;
	sno = s_rec.s_sno ;

        	/* Enable duplication for key field default values */
	for( i=KEY_START; i<=KEY_END; i+=100 )
		fomca1( i,19, 2 );
	sr.nextfld = KEY_START;
	sr.endfld  = KEY_END;
	fomud( (char *)&s_rec );

	s_rec.s_fund = LV_SHORT; 
	s_rec.s_reccod = LV_SHORT; 
	s_rec.s_sno = 0 ;
	if( (retval=ReadFields(KEY_START,KEY_END,HdrValidation))<0 )
		return(retval);/* read header fields */
	if( retval == EXIT) {
		s_rec.s_fund = fund ;
		s_rec.s_reccod = reccod ;
		s_rec.s_sno = sno ;
		if( WriteFields(KEY_START,KEY_END)<0 )
			return(-1);
		return(retval) ;
	}
	if( GetNextSerialNo()<0 )
		return(-1);
	if( WriteFields(KEY_START,KEY_END)<0 )
		return(-1);
	ret(err_chk(&sr));

	return(0);
}
static
GetNextSerialNo()	/* Generate the next serial no. (part of the key) */
{
	/****
	char	terml[4] ;
	****/
#ifdef	ORACLE
	long	get_maxsno(), sno ;
#endif

	/* Fill the terminal#, system date in the Xaction header rec */
	/****
	if( get_tnum(tr_hdr.tr_term)<0 )	return(-1);
	STRCPY( terml, tr_hdr.tr_term );
	*****/
	tr_hdr.th_fund = s_rec.s_fund ;
	tr_hdr.th_reccod = s_rec.s_reccod ;
	tr_hdr.th_create[0] = 'E' ;
#ifndef	ORACLE
	/* Move highs to serial no, and access previous record in sequence */
	tr_hdr.th_seq_no = HV_SHORT;
	flg_reset(GLTRHDR);
	retval = get_n_trhdr( &tr_hdr,BROWSE,0,BACKWARD,e_mesg );
	seq_over(GLTRHDR);
	if( retval==ERROR ){
		fomen(e_mesg); get();
		return(-1);
	}
	
	if( tr_hdr.th_fund != s_rec.s_fund ||
	    tr_hdr.th_reccod != s_rec.s_reccod ||
	    tr_hdr.th_create[0] != 'E' ||
	    retval==EFL ){		/* It is 1 if end of file is reached */
		tr_hdr.th_fund = s_rec.s_fund ;
		tr_hdr.th_reccod = s_rec.s_reccod ;
		tr_hdr.th_create[0] = 'E' ;
		tr_hdr.th_seq_no = 1;
	}
	else  /* The new serial# is one greater than that of the record read */
		tr_hdr.th_seq_no++;
#else
	sno = get_maxsno(GLTRHDR, (char*)&tr_hdr, 0, -1, e_mesg) ;
	if(sno < 0) {
		fomen(e_mesg); get();
		return(-1);
	}
	tr_hdr.th_seq_no = sno + 1;
#endif
	s_rec.s_sno = tr_hdr.th_seq_no;
	return(0);
}
static
ReadFields(start,end,Validate)	/* read fields whose numbers range from  */
int start, end;			/* start and end fields */
int (*Validate)();
{
	int retval;

	sr.nextfld = start;
	sr.endfld = end;
	for( ; ; ){
		fomrd( (char *)&s_rec );
		ret(err_chk(&sr));
		if( sr.retcode==RET_USER_ESC || sr.retcode==RET_VAL_CHK ){
			if( ESC_F ) return(EXIT);
			retval=(*Validate)();
			if( retval<0 || retval==EXIT)	return(retval);
			continue;
		}
		break;
	}
	return(0);
}
static
WriteFields( start,end )/* write fields whose numbers range from start to end */
int start, end;
{
	sr.nextfld = start;
	sr.endfld = end;
	fomwr( (char *)&s_rec );
	ret( err_chk(&sr) );
	return(0);
}
static
ClearScreen()	/* clear the screen except fn field and screen heading */
{
	if(FillFieldNum(HIGH)<0 ) return(-1);
	if(FillHeaderFields(HIGH)<0 ) return(-1);
	if(FillSeperatorLine(HIGH)<0 ) return(-1);
	if(FillLineHeading(HIGH)<0 ) return(-1);
	if(FillItemLines(HIGH,1,ITEMSPERPAGE)<0 ) return(-1);
	if(FillTotalLines(HIGH)<0 ) return(-1);
	if(FillMsgRespFields(HIGH)<0 ) return(-1);

	if( WriteFields(KEY_START,END_FLD )<0 ) return(-1);
	
	return(0);
}
static
HdrValidation()	/* Validate the values entered by the user */
{
	Gl_rec temp_rec;
	int index;
	short	reccod;
	double 	amount;

	switch( sr.curfld ){
		case PERIOD_FLD:	/* period */
			if( s_rec.s_period<
			    param_rec.pa_cur_period-param_rec.pa_open_per || 
			    s_rec.s_period>
			    param_rec.pa_cur_period ||
			    s_rec.s_period == 0){
#ifdef ENGLISH
				fomer("Period invalid or not open");
#else
				fomer("Periode invalide ou pas ouverte");
#endif
				s_rec.s_period = LV_SHORT;
			}

			break;
		case RECCOD_FLD:	/* record code */
			if( s_rec.s_reccod<97 || s_rec.s_reccod>99 ){
#ifdef ENGLISH
				fomer("Valid codes are 97 to 99");
#else
				fomer("Codes valables sont de 97 a 99");
#endif
				s_rec.s_reccod = LV_SHORT;
			}
			break;
		case FUND_FLD:	/* fund code */
			if( sr.retcode==RET_USER_ESC )	break;
			ctl_rec.fund = (short)s_rec.s_fund;
			index = get_ctl( &ctl_rec, BROWSE, 0, e_mesg );
			if( index==ERROR ){
				fomen(e_mesg); get();
				return(-1);
			}
			if( index!=NOERROR ){
				fomer(e_mesg);
				s_rec.s_fund = LV_SHORT;
			}
			break;
		case TRTYPE_FLD:	/* transaction code */
			if( (s_rec.s_tr_code[0]<'7' || s_rec.s_tr_code[0]>'8')){
#ifdef ENGLISH
				fomer("Valid codes are 7 and 8");
#else
				fomer("Codes valables sont 7 et 8");
#endif
				s_rec.s_tr_code[0] = LV_CHAR;
			}
			break;
		case TRDATE_FLD:	/* date of transaction */
			if( sr.fillcode==FIL_OMITTED )
				s_rec.s_tr_date = s_rec.s_rundt;
			if( s_rec.s_tr_date>s_rec.s_rundt ){
#ifdef ENGLISH
				fomer("Invalid transaction date");
#else
				fomer("Date de transaction invalide");
#endif
				s_rec.s_tr_date = LV_LONG;
			}
			break;
		case CHG_FLD:		/* Change Field Validation */
			if( s_rec.s_fld_no == 0 )
				return(EXIT) ;
			break;
	}
	sr.nextfld = sr.curfld;
	return(0);
}
static
ItemsValidation()	/* Validate the values entered by the user */
{
	Gl_rec temp_rec;
	int index;
	short	reccod;
	double 	amount;
	double	temp, diff, CumulativeUncommited() ;
	int	err, cur_fld, end_fld ;
	int	fld_no, item_no ;

	/* Caluculate item# ans Fld# within item */
	item_no = (sr.curfld - ITEM_ST_FLD) / STEP ;
	fld_no  = ((sr.curfld - ITEM_ST_FLD) % STEP) + 100;

	switch(fld_no){
	case AMT_FLD:
			amount = s_rec.s_entries[item_no].s_amount ;
			if( amount <DELTA_AMT && amount>(-DELTA_AMT) ){
#ifdef ENGLISH
				fomer("Amount too small for transaction");
#else
				fomer("Montant trop petit pour transaction");
#endif
				s_rec.s_entries[item_no].s_amount = LV_DOUBLE;
			}
			break;
	case ACCNO_FLD:
			if( ESC_H ){
			   retval = gl_hlp(s_rec.s_fund,
					s_rec.s_entries[item_no].s_accno,
					&reccod,
					7, 15 );
			   if( retval<0 )	/* error */
					return( retval );
			   if( retval==0 )	/* nothing selected  */
					redraw(); /* remove hlp window */
			   else if( retval==1 ){/* selected */
					/* check for reccod compatibility */
				if( s_rec.s_reccod!=reccod ){
				   redraw();
#ifdef ENGLISH
				   fomer("Record code mismatch.Try again");
#else
				   fomer("Disparite de code de fiche. Reessayer");
#endif
				   s_rec.s_entries[item_no].s_accno[0]=LV_CHAR;
				   sr.nextfld = sr.curfld;
				   break;
				}
				else{
					redraw();
					/* lock the record */
					retval = VerifyAccount(item_no,&temp_rec);
					if( retval==ERROR )	return(retval);
					if( retval!=NOERROR )
						s_rec.s_entries[item_no].s_accno[0]=LV_CHAR;
					else
						fomer(temp_rec.desc);
				}
			   }
			}
			else if( sr.retcode==RET_USER_ESC )
				break;
			else{	/* user entered an account number */
			   if(acnt_chk(s_rec.s_entries[item_no].s_accno)==ERROR){
#ifdef ENGLISH
				fomer("Invalid Account number");
#else
				fomer("Numero de compte invalide");
#endif
				s_rec.s_entries[item_no].s_accno[0]=LV_CHAR;
				break;
			   }
			   retval = VerifyAccount(item_no,&temp_rec); 
			   if( retval==ERROR )	return(-1);
			   if( retval!=NOERROR )
				s_rec.s_entries[item_no].s_accno[0]=LV_CHAR;
			   else
				fomer(temp_rec.desc);
			}
			break; 
	}
	sr.nextfld = sr.curfld;
	return(0);
}
static
VerifyAccount(index,temp_rec) /* Check if a record exists in the GL master */
int index;
Gl_rec *temp_rec;
{
	int ret_val;

	temp_rec->funds = (short)s_rec.s_fund;
	STRCPY( temp_rec->accno,s_rec.s_entries[index].s_accno );
	temp_rec->reccod = (short)s_rec.s_reccod;
	ret_val = get_gl( temp_rec,UPDATE,0,e_mesg );
	if(ret_val!=NOERROR ){
		fomen(e_mesg);
		get();
		return(ret_val);
	}
	return(0);
}
static
ConfirmHeader()	/* Ask if user wants to edit hdr items before going to items */
{
	for( ; ; ){
#ifdef ENGLISH
		if(DisplayMessage( "A(dd items), E(dit), C(ancel)")<0 ) 
#else
		if(DisplayMessage( "R(ajouter art), M(odifier), A(nnuler)")<0 ) 
#endif
			return(-1);
		sr.nextfld = END_FLD;
		fomrf( (char *)&s_rec );
		ret( err_chk(&sr) );
		switch( s_rec.s_resp[0] ){
			case ADDREC:	/* Go to addition of items */
				return(HideMessage());
			case EDIT:	/* Edit the fields in header */
				if( (retval=EditHeaderFields())<0 )
					return(retval);
				break;
			case CANCEL:	/* Cancel the session */
				if(DisplayMessage( 
#ifdef ENGLISH
					"Confirm the Cancel (Y/N)?")<0 ) 
#else
					"Confirmer l'annulation (O/N)?")<0 ) 
#endif
					return(-1);
				sr.nextfld = END_FLD;
				fomrf( (char *)&s_rec );
				ret( err_chk(&sr) );
				if( s_rec.s_resp[0]!=YES)
					continue;
				if( HideMessage()<0 ) return(-1);
				return(EXIT);
		}
	}
}
static
DisplayMessage(mesg)	/* Display the given message in the message field */
char *mesg;
{
	STRCPY( s_rec.s_mesg, mesg );
	if( WriteFields(END_FLD-100,END_FLD-100)<0 )	return(-1);
	return(0);
}
static
HideMessage()	/* Hide the message field */
{
	if( FillMsgRespFields(HIGH)<0 )	return(-1);
	if( WriteFields(END_FLD-100,END_FLD)<0 ) return(-1);
	return(0);
}
static
HideFldNo()	/* Hide the 'Field#' field */
{
	if( FillFieldNum(HIGH)<0 )	return(-1);
	if( (WriteFields(CHG_FLD,CHG_FLD))<0 )
		return(-1);
	return(0);
}
static
EditHeaderFields()	/* Read the header field number and read corresponding field */
{
	int fld;

	for( ; ; ){
		if(HideMessage()<0 )
			return(-1);
		/* Get The Field to Be Modified */
#ifdef	ENGLISH
		DisplayMessage("Enter RETURN to terminate Edit");
#else
		DisplayMessage("Appuyer sur RETURN pour terminer l'ajustement");
#endif
        
		if( FillFieldNum(LOW)<0 )	return(-1);
		if( (retval = ReadFields(CHG_FLD,CHG_FLD,HdrValidation))<0 ) return(-1);
		if( retval==EXIT ){
			if( HideFldNo()<0 ) return(-1);
			break;
		}
		if( s_rec.s_fld_no<1 || s_rec.s_fld_no>5 ){
#ifdef ENGLISH
			fomer("Invalid field number");
#else
			fomer("Numero de champ invalide");
#endif
			continue;
		}
		if( s_rec.s_fld_no == 1) {
#ifdef ENGLISH
			fomer("Not accessible");
#else
			fomer("N'est pas accessible");
#endif
			continue;
		}

		if( ACCRUALS ){	/* Don't allow access to Xaction code & date */
			if(s_rec.s_fld_no==3 || s_rec.s_fld_no==4){
#ifdef ENGLISH
				fomer("Not accessible in Accrual Entries");
#else
				fomer("N'est pas accessible dans les charges a payer");
#endif
				continue;
			}
		}
		switch(s_rec.s_fld_no){
			case 1: fld=SYSDT_FLD;	/* System Date */
				break;
			case 2: fld=PERIOD_FLD;	/* period number */
				break;
			case 3: fld=TRTYPE_FLD;	/* Xaction code */
				break;
			case 4: fld=TRDATE_FLD;	/* Xaction date */
				break;
			case 5: fld=DESC_FLD;	/* Xaction description */
				break;
		}
		retval = ModifyField(fld);
		if( retval<0 )	return(retval);
		if( retval==EXIT ){
			if( HideFldNo()<0 ) return(-1);
			break;
		}
	}
	return(0);
}
static
ModifyField( fld )		/* Read & change the specified field */
int fld;
{
	sr.nextfld = sr.endfld = fld;
	fomca1( fld,19,2);	/* enable dup buffers - salvage old values */
	fomud( (char *)&s_rec);
	switch(fld){
		case PERIOD_FLD:	/* period number */
			s_rec.s_period = LV_SHORT;
			break;
		case TRTYPE_FLD:	/* transaction code */
			s_rec.s_tr_code[0] = LV_CHAR;
			break;
		case TRDATE_FLD:	/* transaction date */
			s_rec.s_tr_date = LV_LONG;
			break;
		case DESC_FLD:	/* description */
			s_rec.s_descr[0] = LV_CHAR;
			break;
	}
	retval = ReadFields( fld,fld,HdrValidation );
	if( retval<0 || retval==EXIT)	return(retval);
	sr.nextfld = sr.endfld = fld;
	fomca1( fld,19,0);	/* disable dup buffers */
	return(0);
}
static
Page *PageAllocated()	/* Allocate memory for 1 page of items on screen */
{
	return( (Page *)(malloc((unsigned)sizeof( Page ))) );
}
static
ReadItemFields()		/* Read the journal entry items */
{
	headptr = tailptr = tempptr = NULL; 
	current.page = 0;
	current.line = ITEMSPERPAGE;	/* Initialize list & counter values */ 
	totalitemsadded = 1;

	if( AddItemsInLoop()<0 )	/* Read all the transactions */
		return(-1);
	retval = ConfirmItems(ADD_MODE);/* Allow changing of entered values */
	if( retval<0 )	return(retval);
	if( retval==EXIT ){
		if(ClearScreen()<0)		/* Clear the screen */
			return(-1);	
		return(EXIT);
	}
	return(0);
}
static
AddItemsInLoop()		/*  */
{
	for( ; ; ){
		retval=ReadOneItem(); /* read one transaction-account#,amount */

 		if( retval<0 ){
			FreeList();
			return(-1);
		}
		if (tailptr)
			tailptr->lines_entered = current.line;
		if( retval==EXIT || retval==ALLOC_ERROR )
			break;

		retval=CalcDbCr();
		if( retval<0 )		return(-1);
	
	}
	return(0);
}
static
ReadOneItem()	/* read one transaction (one line on screen) */
{
	if( current.line == ITEMSPERPAGE ){ 
		retval = MakeFreshPage(); /* add new page to list */
		if( retval<0 || retval==ALLOC_ERROR )
			return( retval );
		current.page++;
		current.line = 1;
		if( PutPageNumber(current.page)<0 )
			return(-1);
	}
	else
		current.line++;

	if( FillItemLines(LOW,current.line,current.line)<0 )
		return(-1);
#ifdef ENGLISH
	fomer("Press ESC-F to Exit");
	STRCPY(s_rec.s_entries[current.line-1].s_status, "ACT");
#else
	fomer("Appuyer sur ESC-F pour retourner");
	STRCPY(s_rec.s_entries[current.line-1].s_status, "ACT");
#endif
	retval=ReadFields( 2100+(current.line-1)*STEP,2300+(current.line-1)*STEP,ItemsValidation );
	if(retval==EXIT || retval<0 ){
		if( FillItemLines(HIGH,current.line,current.line)<0 )
			return(-1);
		if( WriteFields( 2100+(current.line-1)*300,
		                2300+(current.line-1)*300 )<0 )
			return(-1);
		tempptr->fields[current.line-1].s_accno[0] = HV_CHAR;
		tempptr->fields[current.line-1].s_amount = HV_DOUBLE;
		tempptr->fields[current.line-1].s_status[0] = HV_CHAR;
		current.line--;
		if(current.line<1){
			if( headptr==tailptr )
				headptr=tailptr=NULL;
			else{
				tailptr = tailptr->prevptr;
				tailptr->nextptr = NULL;
			}
			free( (char *)tempptr );
			tempptr = tailptr;
			current.page--;
			if( PutPageNumber(current.page)<0 )
				return(-1);
			current.line =  ITEMSPERPAGE;
			if( tempptr )
				if( ShowPage()<0 )
					return(-1);
		}
		return(retval);
	}
	else{
		STRCPY(tempptr->fields[current.line-1].s_accno,
		       s_rec.s_entries[current.line-1].s_accno);
		tempptr->fields[current.line-1].s_amount
			= s_rec.s_entries[current.line-1].s_amount;
		strncpy(tempptr->fields[current.line-1].s_status,
			 s_rec.s_entries[current.line-1].s_status, 4);
		tempptr->lines_entered = current.line;
		totalitemsadded++;
	}
	return(0);
}

static 
CalcDbCr()
{
	
	s_rec.s_debits = 0.0;
	s_rec.s_credits = 0.0;
	s_rec.s_diff = 0.0;

	TotalAmount(DEBITS, &s_rec.s_debits );
	TotalAmount(CREDITS, &s_rec.s_credits );
	s_rec.s_diff = s_rec.s_debits - s_rec.s_credits;

	s_rec.s_credits *= -1;	/* make credits negative for display */

	if( WriteFields( DEBITS_FLD, DIFF_FLD )<0 ) 	return(-1); 

	s_rec.s_credits *= -1;	/* make credit positive for calculations */ 
	return(NOERROR);
}

static
ShowPage()	/* Dump contents of node pointed to by tempptr onto screen */
{
	if( ListToScreen()<0 ) return(-1);	/* transfer data */
	if( WriteFields( 2100,5000 )<0 ) return(-1); /* display on screen */
	if( PutPageNumber( current.page )<0 )return(-1); /* Paginate properly */
	return(0);
}
static
ListToScreen()	/* copy contents of *tempptr to screen (items part) */
{
	short i;

	if( tempptr==NULL )
		return(-1);
	for( i=0; i<tempptr->lines_entered; i++){ /* for entries already made */
		STRCPY( s_rec.s_entries[i].s_accno,tempptr->fields[i].s_accno );
		s_rec.s_entries[i].s_amount = tempptr->fields[i].s_amount ;
		strncpy(s_rec.s_entries[i].s_status,tempptr->fields[i].s_status ,4);
	}
	for(i=tempptr->lines_entered; i<ITEMSPERPAGE; i++){/* for other lines */
		s_rec.s_entries[i].s_accno[0] = HV_CHAR;
		s_rec.s_entries[i].s_amount = HV_DOUBLE;
		s_rec.s_entries[i].s_status[0] = HV_CHAR;
	}
	return(0);
}
static
MakeFreshPage()	/* Add a new node to the linked list */
{
	tempptr=PageAllocated();
	if( tempptr==NULL ){
#ifdef ENGLISH
             fomen("Internal memory allocation error. Press a key");
#else
             fomen("Erreur d'allocation a la memoire interne. Appuyer sur une touche");
#endif
	  get();
	  return(ALLOC_ERROR);
	}
	if( tailptr == NULL ){	/* If not a single node in the list yet */
		headptr=tailptr=tempptr;
		tempptr->prevptr = NULL;
		tempptr->nextptr = NULL;
	}
	else{			/* if at least one node exists */
		tailptr->lines_entered = current.line;
		tailptr->nextptr = tempptr;
		tempptr->prevptr = tailptr;
		tempptr->nextptr = NULL;
		tailptr = tempptr;
	}
	tempptr->lines_entered = 0;
	if( FillItemLines(HIGH,1,ITEMSPERPAGE)<0 ) 
		return(-1);
	if( WriteFields(2100,5000)<0 )
		return(-1);
	return(0);
}
static
PutPageNumber(pgno)		/* Display the given number as Page No */
short pgno;
{
	s_rec.s_page = pgno;
	return(WriteFields(2000,2000));
}
static
ConfirmItems( mode )	/* Allow user to change entered data in ADD_MODE only */
int mode;		/* ADD_MODE, INQ_MODE */
{
    double diff;

    for( ; ; ){
	if( mode==ADD_MODE )
#ifdef ENGLISH
	    DisplayMessage("Y(es), A(dd items), E(dit), D(elete), R(eactivate), N(ext), P(rev), C(ancel)"); 
#else
	    DisplayMessage("O(ui), R(ajouter), M(odifier), E(lim), V(ivifier), S(uiv), P(rec), A(nnuler)");
#endif
	else if( mode==INQ_MODE ){
		if( headptr->nextptr )
#ifdef ENGLISH
			DisplayMessage("N(ext), P(rev), Y(es)");
#else
			DisplayMessage("S(uivant), P(recedent), O(ui)");
#endif
		else
			break;
	}

	sr.nextfld = END_FLD;
	fomrf( (char *)&s_rec );	/* Read user's option */
	ret( err_chk(&sr) );
	switch(s_rec.s_resp[0]){
		case ADDREC:	/* Add items allowed in ADD MODE only */
			if( mode==INQ_MODE )
				break;
			while( tempptr && tempptr->nextptr ){
				tempptr = tempptr->nextptr;
				current.page ++;
			}
			if( tempptr ){
				current.line = tempptr->lines_entered;
				if( current.line<1 )
					current.line = ITEMSPERPAGE;
				if( ShowPage()<0 ) return(-1);
			}
			if( AddItemsInLoop()<0 ) return(-1);
			break;
		case EDIT:	/* Edit entered data in ADD MODE only */
			if( mode==INQ_MODE )
				break;	
			if( !tempptr )	/* if no page is being pointed to */
				break;
			retval = EditItemFields();
			if( retval<0 )
				return(-1);
			if( HideFldNo()<0 )
				return(-1);
			if( CalcDbCr()<0 ) 
				return(-1);
			break;
		case DELETE:	/* Delete an item entered in ADD MODE only*/
		case REVIVE:	/* Revive an item deleted in ADD MODE only*/
			if( !tempptr )	/* if no page is being pointed to */
				break;
			if( mode==INQ_MODE )
				break;
			if( ChangeItemStatus()<0 )
				return(-1);
			if( HideFldNo()<0 )
				return(-1);
			if( CalcDbCr()<0 ) 
				return(-1);
			break;
		case NEXT:	/* Display the next page of items */
			if(tempptr && tempptr->nextptr){
				tempptr = tempptr->nextptr;
				current.page ++;
				if(ShowPage()<0 ) return(-1);
			}
			else
#ifdef ENGLISH
				fomer("Last Page Displayed");
#else
				fomer("Derniere page affichee");
#endif
			break;
		case PREV:	/* Display the prev page of items */
			if(tempptr && tempptr->prevptr){
				tempptr = tempptr->prevptr;
				current.page --;
				if(ShowPage()<0 ) return(-1);
			}
			else
#ifdef ENGLISH
				fomer("First Page Displayed");
#else
				fomer("Premiere page affichee");
#endif
			break;
		case CANCEL:    /* Cancel the entire session in ADD MODE only*/
			if( mode==INQ_MODE )
				break;
#ifdef ENGLISH
			DisplayMessage("Confirm the Cancel (Y/N)?"); 
#else
			DisplayMessage("Confirmer l'annulation (O/N)?"); 
#endif
			for( ; ; ){
				sr.nextfld = END_FLD;
				fomrf( (char *)&s_rec);
				if(s_rec.s_resp[0]!=YES&&
				   s_rec.s_resp[0]!=NO)
					continue;
				if( s_rec.s_resp[0]==YES ){
					FreeList();
					if(HideMessage()<0 )
						return(-1);
					return(EXIT);
				}
				else
					break;
			}
			break;
		case YES:	/* Save & Exit in ADD MODE,Exit in INQ MODE */
			if( mode==INQ_MODE )
				return( HideMessage() );
			if( totalitemsadded<1 ){
#ifdef ENGLISH
				fomer("No items to save. Cancel to Quit");
#else
				fomer("Pas d'articles a conserver. Annuler pour retourner");
#endif
				break;
			}
			if( s_rec.s_reccod!=99 ) return(HideMessage());
			TotalAmount(DEBITS, &tr_hdr.th_debits );
			TotalAmount(CREDITS, &tr_hdr.th_credits );
			diff=tr_hdr.th_debits-tr_hdr.th_credits;
			if( diff>DELTA_AMT || diff<(-DELTA_AMT) ){
#ifdef ENGLISH
			    sprintf(e_mesg,
				"Unbalanced : Debits: %.2lf, Credits: %.2lf, Diff : %.2lf",
				tr_hdr.th_debits,tr_hdr.th_credits,diff);
#else
			    sprintf(e_mesg,
				"Non-Solde :  Debits: %.2lf, Credits: %.2lf, Diff : %.2lf",
				tr_hdr.th_debits,tr_hdr.th_credits,diff);
#endif
				    fomer( e_mesg );
			}
			else
				return(HideMessage());
			break;
	}
	continue;
   }
}
static
EditItemFields()	/* Read the field# and allow changes on that field(s) */
{
	int retval;

	for( ; ; ){
		if(HideMessage()<0 )
			return(-1) ;
		/* Get The Field to Be Modified */
#ifdef	ENGLISH
		DisplayMessage("Enter RETURN to terminate Edit");
#else
		DisplayMessage("Entrer RETURN pour terminer l'ajustement");
#endif
		s_rec.s_fld_no = LV_SHORT;
		if( (retval=ReadFields(CHG_FLD,CHG_FLD,HdrValidation)) < 0 )
			return(-1);
		if( retval==EXIT )
			return(retval);
		if( s_rec.s_fld_no<1 || s_rec.s_fld_no>ITEMSPERPAGE*10+2 )
			continue;
		if( s_rec.s_fld_no>0 && s_rec.s_fld_no<=ITEMSPERPAGE ){
						/* Chg a line */ 
			if( (retval=LineChange(s_rec.s_fld_no)) < 0 )
				return(retval);
		}
		else {		/* Change a field - account# or amount */
			if( (retval=FieldChange(s_rec.s_fld_no/10,
					      s_rec.s_fld_no%10))< 0)
				return(retval); 
		} 
	}
}
static
LineChange( line_no )	/* Read new values: account# & amount at given line */
int line_no;
{
	int i, firstfld, lastfld;

	/* Don't allow changes/access if item not active or not entered yet */
	if( !tempptr )	return(0);	/* if no pages, return */
	if( tempptr->fields[line_no-1].s_status[0]!='A' ){
#ifdef ENGLISH
		fomer( "Record not active. Revive first" );
#else
		fomer( "Fiche n'est pas active. Vivifier premierement" );
#endif
		get();
		return(0);
	}
	if( line_no>tempptr->lines_entered )
		return(0);

	firstfld = 2100+(line_no-1)*300;	/* account number field */
	lastfld = 2200+(line_no-1)*300;		/* amount field */
	for( i = firstfld; i <= lastfld; i+=100 )
		fomca1( i, 19, 2 );		/* enable dup buffers */
	sr.nextfld = firstfld;
	sr.endfld = lastfld;
	fomud( (char *)&s_rec );		/* update dup buffers */
	s_rec.s_entries[line_no-1].s_accno[0] = LV_CHAR;
	s_rec.s_entries[line_no-1].s_amount = LV_DOUBLE;
	i= ReadFields( firstfld, lastfld, ItemsValidation );
	if( i<0 )	return(i);
	for( i = firstfld; i <= lastfld; i+=100 )
		fomca1( i, 19, 0 );		/* disable dup buffers */
	scpy( (char *)(tempptr->fields+line_no-1), 
		(char *)(s_rec.s_entries+line_no-1), 
		sizeof( Scr_item ) );
	return(0);
}
static
FieldChange( line_no, col_no )	/* Allow change on specified field */
int line_no, col_no;
{
	int fld_no;

	if( !tempptr )	return(0);	/* if no pages, return */
	if( tempptr->fields[line_no-1].s_status[0]!='A' ){
#ifdef ENGLISH
		fomer( "Record not active. Revive first" );
#else
		fomer( "Fiche n'est pas active. Vivifier premierement" );
#endif
		get();
		return(0);
	}
	if( line_no>tempptr->lines_entered )
		return(0);
	if( col_no<1 || col_no>2 )
		return(0);
	fld_no = 2100+(col_no-1)*100 + (line_no-1)*300;
	fomca1( fld_no, 19, 2 );
	sr.nextfld = sr.endfld = fld_no;
	fomud( (char *)&s_rec );
	switch( col_no ){
		case 1:
			s_rec.s_entries[line_no-1].s_accno[0]=LV_CHAR;
			break;
		case 2:
			s_rec.s_entries[line_no-1].s_amount=LV_DOUBLE;
			break;
		default:
			break;
	}
	if( ReadFields( fld_no, fld_no, ItemsValidation ) < 0 )
		return(-1);
	switch( col_no ){
		case 1:
			STRCPY(tempptr->fields[line_no-1].s_accno,
			       s_rec.s_entries[line_no-1].s_accno);
			break;
		case 2:
			tempptr->fields[line_no-1].s_amount
			= s_rec.s_entries[line_no-1].s_amount;
			break;
		default:
			break;
	}
	fomca1( fld_no, 19, 0 );
	return(0);
}
static
ChangeItemStatus()	/* Allow deletion or revival of an item */
{
	int fld_no;

	for( ; ; ){
		s_rec.s_fld_no = LV_SHORT;
		if( (retval=ReadFields(CHG_FLD,CHG_FLD,HdrValidation)) < 0 )
			return(-1);
		if( retval==EXIT )
			return(retval);
		if( s_rec.s_fld_no<1 || s_rec.s_fld_no>tempptr->lines_entered )
			continue;
		switch( s_rec.s_resp[0] ){
			case DELETE:
#ifdef ENGLISH
			   if( !strcmp(s_rec.s_entries[s_rec.s_fld_no-1].s_status,"DEL"))
				break;
#else
			   if( !strcmp(s_rec.s_entries[s_rec.s_fld_no-1].s_status,"ELI"))
				break;
#endif
#ifdef ENGLISH
			   STRCPY(s_rec.s_entries[s_rec.s_fld_no-1].s_status,
									"DEL");
			   totalitemsadded--;
			   break;
#else
			   STRCPY(s_rec.s_entries[s_rec.s_fld_no-1].s_status,
								       "ELI");
			   totalitemsadded--;
			   break;
#endif
			case REVIVE:
#ifdef ENGLISH
			   if( !strcmp(s_rec.s_entries[s_rec.s_fld_no-1].s_status,"ACT"))
				break;
#else
			   if( !strcmp(s_rec.s_entries[s_rec.s_fld_no-1].s_status,"ACT"))
				break;
#endif
#ifdef ENGLISH
			   STRCPY(s_rec.s_entries[s_rec.s_fld_no-1].s_status,
									"ACT");
			   totalitemsadded++;
			   break;
#else
			   STRCPY(s_rec.s_entries[s_rec.s_fld_no-1].s_status,
									"ACT");
			   totalitemsadded++;
			   break;
#endif
			default:
				return(0);
		}
		STRCPY(tempptr->fields[s_rec.s_fld_no-1].s_status ,
			 s_rec.s_entries[s_rec.s_fld_no-1].s_status);
		fld_no = 2300 + (s_rec.s_fld_no-1)*300;
		if( WriteFields(fld_no,fld_no)<0 )
			return(-1);
		break;
	}
	return(0);
}
static
WriteSession(entrytype)	/* Write header, list of items and update GL master */
int	entrytype;	/* REVERSED or NORMAL entry */
{
	int i, item_no;

	if( WriteHeader()<0 ){	/* Write record in gltrhdr file */
		roll_back(e_mesg) ;
		return(-1);
	}
	item_no = 0;		/* useful for generating the item serial no */
	tempptr = headptr;	/* initialize tempptr to beginning of list */
	for( ; ; ){	/* to write the items in gltran file */
		if(tempptr==NULL)
			break;
		for( i=1; i<=ITEMSPERPAGE; i++){ /* for each line on page */
			if(tempptr->fields[i-1].s_amount==HV_DOUBLE)
				break;
			if(tempptr->fields[i-1].s_status[0]==DELETE)
				continue;
			if( UpdateGlmaster(i,entrytype)<0 ){
				roll_back(e_mesg) ;
				return(-1);
			} /* section from this gl_rec is copied to item rec */
			item_no++;
			if( WriteItem(i,item_no,entrytype)<0 ){
				roll_back(e_mesg) ;
				return(-1);
			}
		}
		if(tempptr->fields[i-1].s_amount==HV_DOUBLE)
			break;	/* terminate when High values are found */
		tempptr=tempptr->nextptr;
	}
	if ( ACCRUALS && entrytype == NORMAL) return(0) ;

	if (commit(e_mesg) < 0 ){
		fomen(e_mesg) ;
		get() ;
		return(-1);
	}
	return(0);
}
WriteToNewYear()
{
	int i, item_no;

	if( GetNextNYSerialNo()<0 )
		return(-1);
	/* Write record in gltrhdr file */
	if( WriteNewYearHeader()<0 ){
		roll_back(e_mesg) ;
		return(-1);
	}
	item_no = 0;		/* useful for generating the item serial no */
	tempptr = headptr;	/* initialize tempptr to beginning of list */
	for( ; ; ){	/* to write the items in gltran file */
		if(tempptr==NULL)
			break;
		for( i=1; i<=ITEMSPERPAGE; i++){ /* for each line on page */
			if(tempptr->fields[i-1].s_amount==HV_DOUBLE)
				break;
			if(tempptr->fields[i-1].s_status[0]==DELETE)
				continue;
			
			if( UpdateGlmaster(i,REVERSED)<0 ){
				roll_back(e_mesg) ;
				return(-1);
			} /* section from this gl_rec is copied to item rec */
			item_no++;
			if( WriteNewYearItem(i,item_no,REVERSED)<0 ){
				roll_back(e_mesg) ;
				return(-1);
			}
		}
		if(tempptr->fields[i-1].s_amount==HV_DOUBLE)
			break;	/* terminate when High values are found */
		tempptr=tempptr->nextptr;
	}
	if (commit(e_mesg) < 0 ){
		fomen(e_mesg) ;
		get() ;
		return(-1);
	}
	return(NOERROR);
}
static
GetNextNYSerialNo()	/* Generate the next serial no. (part of the key) */
{
	/****
	char	terml[4] ;
	****/
#ifdef	ORACLE
	long	get_maxsno(), sno ;
#endif

	/* Fill the terminal#, system date in the Xaction header rec */
	/****
	if( get_tnum(tr_hdr.tr_term)<0 )	return(-1);
	STRCPY( terml, tr_hdr.tr_term );
	*****/
	tr_hdr.th_fund = s_rec.s_fund ;
	tr_hdr.th_reccod = s_rec.s_reccod ;
	tr_hdr.th_create[0] = 'E' ;
#ifndef	ORACLE
	/* Move highs to serial no, and access previous record in sequence */
	tr_hdr.th_seq_no = HV_SHORT;
	flg_reset(GLTRHDR);
	retval = get_n_trhdrny( &tr_hdr,BROWSE,0,BACKWARD,e_mesg );
	seq_over(GLTRHDR);
	if( retval==ERROR ){
		fomen(e_mesg); get();
		return(-1);
	}
	
	if( tr_hdr.th_fund != s_rec.s_fund ||
	    tr_hdr.th_reccod != s_rec.s_reccod ||
	    tr_hdr.th_create[0] != 'E' ||
	    retval==EFL ){		/* It is 1 if end of file is reached */
		tr_hdr.th_fund = s_rec.s_fund ;
		tr_hdr.th_reccod = s_rec.s_reccod ;
		tr_hdr.th_create[0] = 'E' ;
		tr_hdr.th_seq_no = 1;
	}
	else  /* The new serial# is one greater than that of the record read */
		tr_hdr.th_seq_no++;
#else
	sno = get_maxsno(GLTRHDRNY, (char*)&tr_hdr, 0, -1, e_mesg) ;
	if(sno < 0) {
		fomen(e_mesg); get();
		return(-1);
	}
	tr_hdr.th_seq_no = sno + 1;
#endif
	s_rec.s_sno = tr_hdr.th_seq_no;
	return(0);
}
static
WriteNewYearHeader()	/* Write the header of the Xaction in gltrhdr file */
{
	static	char	buffer[10] ;
	tr_hdr.th_fund = s_rec.s_fund;
	tr_hdr.th_reccod = s_rec.s_reccod;
	tr_hdr.th_create[0] = 'E' ;
	tr_hdr.th_seq_no = s_rec.s_sno;
	retval = get_trhdrny( &tr_hdr, UPDATE, 0, e_mesg );
	if( retval==NOERROR ){
		s_rec.s_sno ++; 
		if( WriteFields(KEY_START,KEY_END)<0 )
			return(-1);
	}
	tr_hdr.th_fund = s_rec.s_fund;
	tr_hdr.th_reccod = s_rec.s_reccod;
	tr_hdr.th_create[0] = 'E';
	tr_hdr.th_seq_no = s_rec.s_sno;
	tr_hdr.th_sys_dt = s_rec.s_sysdt;
	STRCPY(tr_hdr.th_userid, User_Id);
	tr_hdr.th_period = s_rec.s_period;
	tr_hdr.th_date = s_rec.s_tr_date;
	STRCPY( tr_hdr.th_descr,s_rec.s_descr ) ;
	tr_hdr.th_supp_cd[0] = '\0' ;
	STRCPY( tr_hdr.th_reference, "JE#  ") ;
	sprintf(buffer,"%ld",s_rec.s_sno);
	strcat( tr_hdr.th_reference, buffer) ;
	tr_hdr.th_type[0] = s_rec.s_tr_code[0];
	retval = put_trhdrny( &tr_hdr, ADD, e_mesg );
	if( retval!=NOERROR ){
		fomen(e_mesg);get();
		roll_back(e_mesg);
		return(retval);
	}
	return(0);
}

static
WriteNewYearItem(line_no,item_no,entrytype)/* Write one item in gltran file from *tempptr */
int line_no,item_no,entrytype;
{
	int flag;

	tr_item.ti_fund = (short)s_rec.s_fund;
	tr_item.ti_reccod = tr_hdr.th_reccod;
	tr_item.ti_create[0] = tr_hdr.th_create[0];
	tr_item.ti_seq_no = tr_hdr.th_seq_no;
	tr_item.ti_item_no = item_no;
	tr_item.ti_sys_dt = tr_hdr.th_sys_dt;
	tr_item.ti_period = tr_hdr.th_period;
	STRCPY( tr_item.ti_accno, tempptr->fields[line_no-1].s_accno );
	tr_item.ti_section = gl_rec.sect;/* From corr. recently updated Glmast*/

	if( entrytype==NORMAL )	flag = 1;
	else	flag = -1;	/* REVERSED entry */
	tr_item.ti_amount = tempptr->fields[line_no-1].s_amount * flag;
	tr_item.ti_amount = D_Roundoff(tr_item.ti_amount);
	tr_item.ti_status = 0;
	retval = put_tritemny( &tr_item, ADD, e_mesg );
	if( retval!=NOERROR ){
		fomen(e_mesg);get();
		roll_back(e_mesg);
		return(retval);
	}
	return(0);
}
static
TotalAmount( flag, total )	/* Calculate the total of Credits/Debits */
int flag;
double *total;
{
	int i, itemcount;
	double amount;
	Page *ptr;

	itemcount = 1;
	amount = 0.0;
	ptr = headptr;
	for( ; ; ){	/* for each page in the list */
		if(ptr==NULL)
			break;
		for(i=1;i<=ITEMSPERPAGE;i++){	/* for each line in the page */

			if(itemcount==totalitemsadded)
				break;
			if(ptr->fields[i-1].s_amount==HV_DOUBLE)
				break;
			if(ptr->fields[i-1].s_status[0]==DELETE)
				continue;
			
			itemcount++;		
			
			switch(flag){
				case DEBITS:
					if(ptr->fields[i-1].s_amount>DELTA_AMT )
					amount += ptr->fields[i-1].s_amount;
					break;
				case CREDITS:
					if(ptr->fields[i-1].s_amount<-DELTA_AMT )
					amount += ptr->fields[i-1].s_amount;
					break;
			}
		}
		ptr=ptr->nextptr;
	}
	if( flag==CREDITS )
		*total = (-amount);
	else
		*total = amount;
	return(0);
}
static
WriteHeader()	/* Write the header of the Xaction in gltrhdr file */
{
	static	char	buffer[10] ;
	tr_hdr.th_fund = s_rec.s_fund;
	tr_hdr.th_reccod = s_rec.s_reccod;
	tr_hdr.th_create[0] = 'E' ;
	tr_hdr.th_seq_no = s_rec.s_sno;
	retval = get_trhdr( &tr_hdr, UPDATE, 0, e_mesg );
	if( retval==NOERROR ){
		s_rec.s_sno ++; 
		if( WriteFields(KEY_START,KEY_END)<0 )
			return(-1);
	}
	tr_hdr.th_fund = s_rec.s_fund;
	tr_hdr.th_reccod = s_rec.s_reccod;
	tr_hdr.th_create[0] = 'E';
	tr_hdr.th_seq_no = s_rec.s_sno;
	tr_hdr.th_sys_dt = s_rec.s_sysdt;
	STRCPY(tr_hdr.th_userid, User_Id);
	tr_hdr.th_period = s_rec.s_period;
	tr_hdr.th_date = s_rec.s_tr_date;
	STRCPY( tr_hdr.th_descr,s_rec.s_descr ) ;
	tr_hdr.th_supp_cd[0] = '\0' ;
	STRCPY( tr_hdr.th_reference, "JE#  ") ;
	sprintf(buffer,"%ld",s_rec.s_sno);
	strcat( tr_hdr.th_reference, buffer) ;
	tr_hdr.th_type[0] = s_rec.s_tr_code[0];
	tr_hdr.th_print[0] = NO;
	tr_hdr.th_print[1] = '\0';
	retval = put_trhdr( &tr_hdr, ADD, e_mesg );
	if( retval!=NOERROR ){
		fomen(e_mesg);get();
		roll_back(e_mesg);
		return(retval);
	}
	return(0);
}
static
UpdateGlmaster(item_no,entrytype)	/* Update GLmaster file using one Xaction rec*/
int item_no, entrytype;	/* REVERSING or NORMAL */
{
	double amt;

	gl_rec.funds = (short)s_rec.s_fund;
	STRCPY( gl_rec.accno, tempptr->fields[item_no-1].s_accno );
	gl_rec.reccod = (short)s_rec.s_reccod;
	retval = get_gl( &gl_rec,UPDATE,0,e_mesg );
	if( retval!=NOERROR ){
		fomen(e_mesg);get();
		return(DBH_ERR); 
	}
	amt = tempptr->fields[item_no-1].s_amount;
	if( entrytype==NORMAL ){
		if( amt > 0.0 ) /* amount is +ve inc debit bal */
			gl_rec.curdb += amt;
		else	/* amount is -ve, inc credit bal */
			gl_rec.curcr += amt;
		gl_rec.ytd += amt;
		gl_rec.currel[s_rec.s_period-1] += amt;
	}
	else{	/* nextdb = total credits and vice versa */
		if( amt > 0.0 )
			gl_rec.nextdb += amt * -1.0 ;
		else
			gl_rec.nextcr += amt * -1.0 ;
	}
	gl_rec.curdb 	= D_Roundoff(gl_rec.curdb);
	gl_rec.curcr 	= D_Roundoff(gl_rec.curcr);
	gl_rec.ytd 	= D_Roundoff(gl_rec.ytd);
	gl_rec.currel[s_rec.s_period-1] = 
				 D_Roundoff(gl_rec.currel[s_rec.s_period-1]);
	gl_rec.nextdb = D_Roundoff(gl_rec.nextdb);
	gl_rec.nextcr = D_Roundoff(gl_rec.nextcr);
	retval = put_gl( &gl_rec, UPDATE, e_mesg );
	if( retval!=NOERROR ){
		fomen(e_mesg);get();
		roll_back(e_mesg);
		return(retval);
	}
	return(0);
}
static
WriteItem(line_no,item_no,entrytype)/* Write one item in gltran file from *tempptr */
int line_no,item_no,entrytype;
{
	int flag;

/* F.Tao  01/03/91
	if ( ACCRUALS && entrytype == REVERSED && s_rec.s_fund == 1) return(0);
*/
	tr_item.ti_fund = (short)s_rec.s_fund;
	tr_item.ti_reccod = tr_hdr.th_reccod;
	tr_item.ti_create[0] = tr_hdr.th_create[0];
	tr_item.ti_seq_no = tr_hdr.th_seq_no;
	tr_item.ti_item_no = item_no;
	tr_item.ti_sys_dt = tr_hdr.th_sys_dt;
	tr_item.ti_period = tr_hdr.th_period;
	STRCPY( tr_item.ti_accno, tempptr->fields[line_no-1].s_accno );
	tr_item.ti_section = gl_rec.sect;/* From corr. recently updated Glmast*/

	if( entrytype==NORMAL )	flag = 1;
	else	flag = -1;	/* REVERSED entry */
	tr_item.ti_amount = tempptr->fields[line_no-1].s_amount * flag;
	tr_item.ti_amount = D_Roundoff(tr_item.ti_amount);
	tr_item.ti_status = 0;
	retval = put_tritem( &tr_item, ADD, e_mesg );
	if( retval!=NOERROR ){
		fomen(e_mesg);get();
		roll_back(e_mesg);
		return(retval);
	}
	return(0);
}
static
FreeList()	/* Free the linked list */
{
	for( tempptr=headptr; tempptr; tempptr=headptr ){
		headptr=headptr->nextptr;
		free( (char *)tempptr );
	}
	tailptr = NULL;
	return(0);
}
static
Inquire( access, direction )	/* Screen inquiry, random/sequential */
int access, direction;		/* RANDOM, SEQUENTIAL accesses */
{
	int retval;

	if( access==RANDOM ){
		retval = GetHeaderKey();	/* Read the key values */
		if(retval==UNDEF)
			return(0);
		if( retval==EXIT || retval==ERROR ){
			if(ClearScreen()<0)	return(-1);
			return(retval);
		}
	}
	else{
		retval = GetNextHeader( direction );	/* Get next rec */
		if(retval==EFL)
			return(0);
		else if( retval<0 ){
			fomen(e_mesg);get();
			return(retval);
		}
	}

	retval = DisplayRecord();	/* Display the header & item records */
	if( retval<0 ) return(retval);

	return( FreeList() );
}
static
DisplayRecord()	/* Get and display the header and item records */
{
	int retval;

	retval = ShowHeaderFields();	/* Display header information */
	if( retval<0 || retval==EXIT ) return(retval);

	retval = ShowItems();	/* Display first pageful of items */
	if( retval<0 || retval==EXIT ) return(retval);

	retval = CalcDbCr();
	if( retval<0 ) return(retval);
	
	retval = ConfirmItems( INQ_MODE );	/* Allow scanning of pages */
	if( retval<0 || retval==EXIT ) return(retval);

	return(0);
}
static
GetNextHeader(direction)	/* Read the next rec in specified direction */
int	direction ;
{
	int retval;
	
	if( flg_start(GLTRHDR) != direction ){ 	/* file not in seq read mode */
		/* Set the least part of the key to next possible key and set
		   the file to start */
		tr_hdr.th_fund = s_rec.s_fund ;
		tr_hdr.th_reccod = s_rec.s_reccod ;
		tr_hdr.th_create[0] = 'E' ;
		if(direction == FORWARD)
			tr_hdr.th_seq_no = s_rec.s_sno + 1;
		else {
			tr_hdr.th_seq_no = s_rec.s_sno - 1;
		}
		flg_reset(GLTRHDR) ;
	}
	if (tr_hdr.th_seq_no == 0) {
		tr_hdr.th_seq_no = 99999999;
		tr_hdr.th_reccod = s_rec.s_reccod - 1;
		flg_reset(GLTRHDR) ;
	}
	for (;;) {
	/* Read the next record from gltrhdr file */
	retval = get_n_trhdr( &tr_hdr, BROWSE, 0, direction, e_mesg );
	if(tr_hdr.th_create[0] == 'E' || retval==EFL ||
		tr_hdr.th_fund != s_rec.s_fund) {
			break ;
	}
	else {
		if(direction == FORWARD)
			tr_hdr.th_reccod = tr_hdr.th_reccod + 1 ;
		else
			tr_hdr.th_reccod = tr_hdr.th_reccod - 1 ;
		tr_hdr.th_create[0] = 'E' ;
		if(direction == FORWARD)
			tr_hdr.th_seq_no = 0;
		else
			tr_hdr.th_seq_no = 99999999;
		flg_reset(GLTRHDR) ;
	}
	}
#ifndef	ORACLE
	seq_over(GLTRHDR) ;
#endif
	if( retval==EFL || tr_hdr.th_fund != s_rec.s_fund ){
#ifdef ENGLISH
		fomen("No More Records....");
#else
		fomen("Plus de fiches....");
#endif
		get();
		flg_reset(GLTRHDR);
		return(EFL);
	}
	if( retval!=NOERROR ){
		fomen(e_mesg);	get();
		return(retval);
	}
	s_rec.s_fund = tr_hdr.th_fund ;
	s_rec.s_reccod = tr_hdr.th_reccod ;
	s_rec.s_sno = tr_hdr.th_seq_no;
	if( WriteFields(KEY_START,KEY_END)<0 )
		return(-1);
	return(0);
}
static
GetHeaderKey()	/* Read the header key values, get terminal info ,read rec */
{
	int i,retval;
	short	fund, reccod ;
	long	sno ;

	fund = s_rec.s_fund ;
	reccod = s_rec.s_reccod ;
	sno = s_rec.s_sno ;
	/* Enable dup buffers for reading key */
	for( i=KEY_START; i<=KEY_END; i+=100 )
		fomca1( i, 19, 2 );
	sr.nextfld=KEY_START; 
	sr.endfld=KEY_END;
	fomud( (char *)&s_rec );

	s_rec.s_fund = LV_SHORT;
	s_rec.s_reccod = LV_SHORT;
	s_rec.s_sno = LV_LONG ;
	if( (retval = ReadFields(KEY_START,KEY_END,HdrValidation))<0 )  
		return(retval);
	if (retval == EXIT) {
		s_rec.s_fund = fund ;	
		s_rec.s_reccod = reccod ;
		s_rec.s_sno = sno ;
		if( WriteFields(KEY_START,KEY_END)<0 )
			return(-1);
		return(retval) ;
	}
	tr_hdr.th_fund = s_rec.s_fund;
	tr_hdr.th_reccod = s_rec.s_reccod;
	tr_hdr.th_create[0] = 'E' ;
	tr_hdr.th_seq_no = s_rec.s_sno;
	retval = get_trhdr( &tr_hdr, BROWSE, 0, e_mesg );
	if( retval!=NOERROR ){
		fomer(e_mesg);
		get();
		return(retval);
	}
	/* Disable dup buffers */
	for( i=KEY_START; i<=KEY_END; i+=100 )
		fomca1( i, 19, 0 );
	return(0);
}
static
ShowHeaderFields()	/* Display header info */
{
	s_rec.s_sysdt = tr_hdr.th_sys_dt;
	s_rec.s_period = tr_hdr.th_period;
	s_rec.s_tr_code[0] = tr_hdr.th_type[0];
	s_rec.s_tr_date = tr_hdr.th_date;
	STRCPY(s_rec.s_descr, tr_hdr.th_descr );
	if( WriteFields(HDR_ST_FLD,HDR_END_FLD)<0 ) return(-1);
	return(0);
}
static
ShowItems()	/* Display first pageful of items */
{
	if( BuildList()<0 )	/* Build linked list of pages in memory */ 
		return(-1);
	tempptr = headptr ;	/* Seek to first node/page of list */
	current.page = 1;
	if( FillSeperatorLine(LOW)<0 ) return(-1);
	if( FillLineHeading(LOW)<0 )	return(-1);
	if( WriteFields(1500,1700)<0 )	return(-1);
	if( ShowPage()<0 ) return(-1);	/* Display contents of page sought */ 
	return(0);
}
static
BuildList()	/* Read item by item from file and build list */
{
	int retval, itemno;

	itemno = 1;
	headptr = tailptr = tempptr = NULL;

	tr_item.ti_fund = tr_hdr.th_fund ;
	tr_item.ti_reccod = tr_hdr.th_reccod ;
	tr_item.ti_create[0] = 'E';
	tr_item.ti_seq_no = tr_hdr.th_seq_no;
	tr_item.ti_item_no = 0;
  
	flg_reset(GLTRAN);	/* Initialize to get first rec under givenkey */

	for( ; ; ){
#ifndef	ORACLE
		retval = get_n_tritem( &tr_item, BROWSE, 0, FORWARD, e_mesg);
#else
		retval = get_n_tritem( &tr_item, BROWSE, 0, EQUAL, e_mesg);
#endif
		if( retval==ERROR ){
			fomen(e_mesg);
			get();
			return(retval);
		}
		if( retval==EFL )
			break;
#ifndef	ORACLE
		if( 	tr_item.ti_fund != tr_hdr.th_fund ||
			tr_item.ti_reccod != tr_hdr.th_reccod ||
			tr_item.ti_create[0] != 'E' || 
			tr_item.ti_seq_no != tr_hdr.th_seq_no  ||
			tr_item.ti_item_no<1	)
			break;	/* No more records with specified key */
#endif
		current.line = tr_item.ti_item_no % ITEMSPERPAGE;
		if( current.line==0 ) current.line = ITEMSPERPAGE;
		if( current.line==1 ){	/* New page to be formed */
		    tempptr = PageAllocated();	/* Allocate memory for page */
		    if( tempptr==NULL ){
#ifdef ENGLISH
			fomen("Internal Memory allocation error. Press a key");
#else
			fomen("Erreur d'allocation a la memoire interne. Appuyersur une touche");
#endif
			get();
			return(-1);
		    }
		    tempptr->lines_entered = 0;
		    if( tr_item.ti_item_no==1 ){	/* First item */
			headptr = tailptr = tempptr;
			tempptr->nextptr = tempptr->prevptr = NULL;
		    }
		    else{
			tailptr->nextptr = tempptr;
			tempptr->prevptr = tailptr;
			tempptr->nextptr = NULL;
			tailptr = tempptr;
		    }
		}
		STRCPY(tempptr->fields[current.line-1].s_accno,tr_item.ti_accno);
		tempptr->fields[current.line-1].s_amount = tr_item.ti_amount;
		tempptr->fields[current.line-1].s_status[0] = HV_CHAR; 
		tempptr->lines_entered++;
		
		itemno++; 	
	} 
	seq_over(GLTRAN) ;
	if( headptr==NULL ){
#ifdef ENGLISH
                 fomen("No Transaction Items to Display. Press a key");
#else
                 fomen("Pas d'articles de transaction a afficher.Appuyer sur une touche");
#endif
		get();
		return(-1);
	}
	totalitemsadded = itemno;

	if( CalcDbCr()<0 ) 	return(-1);
	return(0);
}

