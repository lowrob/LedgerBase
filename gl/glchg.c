/******************************************************************************
		Sourcename    : glchg.c
		System        : Budgetary Financial System.
		Subsystem     : General Ledger System 
		Module        : General Ledger 
		Created on    : Nov 7, 90.
		Created  By   : J Prescott.
		Cobol sources : 

HISTORY:
 Date           Programmer     Description of modification
____/__/__      __________     ___________________________

******************************************************************************/
#include <stdio.h>

#define MAIN
#define MAINFL		GLMAST	/* main file used */

#include <bfs_defs.h>
#include <bfs_recs.h>
#include <cfomstrc.h>

#define SYSTEM		"General Ledger"
#define MOD_DATE	"07-NOV-90"
#define SCREEN_NAME	"glchg"
#define ESCAPE		12	/* flag indicates discontinuation of entries */
#define LOW 		-1
#define HIGH 		 1
#define HL_CHAR(VAL)	(VAL==HIGH) ? HV_CHAR : LV_CHAR
#define NO_HLP_WIN	(sr.curfld!=800)
#define ESC_H		(sr.retcode==RET_USER_ESC && \
			(sr.escchar[0]=='H'||sr.escchar[0]=='h'))

#ifdef ENGLISH
#define CHANGE 		'C'
#define EXITOPT		'E'

#define EDIT		'E'
#define CANCEL		'C'
#define YES		'Y'
#define NO		'N'
#else	/* FRENCH */
#define CHANGE 		'C'
#define EXITOPT		'F'

#define EDIT		'M'
#define CANCEL		'A'
#define YES		'O'
#define NO		'N'
#endif

#define FUNC_FLD	400
#define FUND1_FLD	700
#define ACCT1_FLD	800
#define RECCOD1_FLD	900
#define FUND2_FLD	1000
#define ACCT2_FLD	1100
#define RECCOD2_FLD	1200
#define MESG_FLD	4300
#define RESP_FLD	4400

/* receipts.sth - header for C structure generated by PROFOM EDITOR */

struct	gl_struct {
	char	s_progname[11];	/* 100 program name */
	long	s_rundt;	/* 300 system date */
	char	s_fn[2];	/* 400 function */
	short	s_fund1;	/* 700 fund number */
	char	s_acctno1[19];	/* 800 G/L account number */
	short   s_reccod1;	/* 900 record code */
	short	s_fund2;	/* 1000 fund number */
	char	s_acctno2[19];	/* 1100 G/L account number */
	short   s_reccod2;	/* 1200 record code */
	char	s_mesg[78];	/* 4300 message field */
	char	s_resp[2];	/* 4400 response field */
};
struct gl_struct	s_rec;		/* screen record */

struct stat_rec		sr;

Gl_rec	gl_rec, pre_rec;	/* glmast reccord and previod record */
Pa_rec  pa_rec;
Ctl_rec ctl_rec;

int retval;	/* Global variable to store function values */
char e_mesg[80]; /* to store error messages */
/* Initialize profom fields, call entry procedures */
main( argc, argv )
int argc;
char *argv[];
{
	strncpy( SYS_NAME, SYSTEM, 50 ); /* Module name */
	strncpy( CHNG_DATE, MOD_DATE, 10 );/* Last date of change */
	
	proc_switch( argc,argv,MAINFL );/* process the switches */

	retval = get_param(&pa_rec, BROWSE, 1, e_mesg) ;
	if(retval < 1) {
		fomen(e_mesg);  get();
		close_dbh() ;
		exit(-1) ;
	}
	if( Initialize()<0 )	/* Initialize profom enviroment */
		exit(-1);
	
	retval = Process();	/* Interact with the user */
	CleanExit();
}

CleanExit()
{
	/* clear and exit the screen , close files & exit program */
	free_audit();	/* free memory allocated for writing audit rec */
	fomcs();
	fomrt();
	close_dbh();
	free_audit();
	exit(retval);
}

Initialize()
{
	/* initialize the profom status variables */
	STRCPY( sr.scrnam, NFM_PATH );
	strcat( sr.scrnam, SCREEN_NAME );
	STRCPY( sr.termnm, terminal );

	/* initialize the fields and the profom screen */
	if( FillScrHdg()<0 ) 			return(-1);
	if( FillNonKeyFlds( HIGH )<0 ) 		return(-1);
	if( FillMesgRespFlds( HIGH )<0 ) 	return(-1);
	if( InitProfom()<0 ){
		fomcs();
		fomrt();
		return(-1);
	}
	return(0);
}
/* initialize the profom and the screen */
InitProfom()
{
	fomin( &sr );			/* initialize profom */
	ret( err_chk(&sr) );		/* if profom error return */
	if( WriteFields(1,0)<0 )	/* Write all fields once */
		return(-1);
	fomcf(1,1);			/* Enable snap-screen option */
	return(0);
}
/* Fill the screen heading fields: the program name and the date */
FillScrHdg()
{
	STRCPY( s_rec.s_progname, PROG_NAME );
	s_rec.s_rundt = get_date();
	return(0);
}
/* Fill the non key fields with high/low values */
FillNonKeyFlds( value )
short value;
{
	s_rec.s_fund1		= value * HV_SHORT;
	s_rec.s_acctno1[0] 	= HL_CHAR(value);
	s_rec.s_reccod1 	= value * HV_SHORT;
	s_rec.s_fund2 		= value * HV_SHORT;
	s_rec.s_acctno2[0] 	= HL_CHAR(value);
	s_rec.s_reccod2 	= value * HV_SHORT;

	return(0);
}
/* Fill the message and response fields with high or low values */
FillMesgRespFlds( value )
short value;
{
	s_rec.s_mesg[0] = HL_CHAR(value);
	s_rec.s_resp[0] = HL_CHAR(value);
	return(0);
}
/* Accept user's option and call the corresponding routine in a loop */
Process()
{
	int retval;

	for( ; ; ){
		if( ReadFunction()<0 ) return(-1);
		switch( s_rec.s_fn[0] ){
			case CHANGE:	/* change to applied */
				CHKACC(retval,UPDATE,e_mesg);
				if(ChangeRec()<0) return(-1);
				break;
			case EXITOPT:	/* exit */
				return(0);
			default:
				break;
		}
		if( retval<0 ){
			fomen(e_mesg);
			get();
		}
		if( retval==DBH_ERR )
			return(retval);
	}
}
ChangeRec()
{
	int err;

	err=SelectRecord();
	if(err != NOERROR) return(err);

	/* set duplication buffers */
	s_rec.s_fund2 = s_rec.s_fund1 ;
	STRCPY(s_rec.s_acctno2, s_rec.s_acctno1);
	s_rec.s_reccod2 = s_rec.s_reccod1 ;

	SetDupBuffers(FUND2_FLD,RECCOD2_FLD,1);

	for( ; ; ) {
		s_rec.s_fund2 = LV_SHORT;
		s_rec.s_acctno2[0] = LV_CHAR;
		s_rec.s_reccod2 = LV_SHORT;

		err = ReadFields(FUND2_FLD,RECCOD2_FLD);
		if(err != NOERROR) return(err) ;

		err=BringRecord(s_rec.s_fund2,s_rec.s_acctno2,s_rec.s_reccod2);
		if(err == NOERROR){
			fomen("G/L Account already Exists");
			get() ;
			continue;
		}
		if(err == UNDEF) break;
	}

	if((retval=EditFlds())<0) return(retval);	
	if(retval == ESCAPE) {
		if(ClearScreen()<0) return(-1);
		return(retval);
	}
	
	if(WriteRecords()<0) return(-1);

	return(NOERROR);
}
SelectRecord()
{
	int	err ;

	for(; ;){
		if(FillNonKeyFlds( LOW )<0) return(-1);
		err = ReadFields(FUND1_FLD,RECCOD1_FLD);
		if(err != NOERROR) return(err) ;

		/* Get the record from database */

		err=BringRecord(s_rec.s_fund1,s_rec.s_acctno1,s_rec.s_reccod1);
		if(err < 0){
			fomen(e_mesg);
			get() ;
			if(err == UNDEF || err == LOCKED) continue ;
			return(DBH_ERR);
		}
		fomer(gl_rec.desc);
		return(NOERROR) ;
	}
}	/* SelectRecord() */

BringRecord(fund,account,reccod)
short	fund;
char	*account;
short	reccod;
{
	gl_rec.funds = fund ;
	STRCPY(gl_rec.accno, account);
	gl_rec.reccod = reccod ;

	return(get_gl(&gl_rec, BROWSE , 0, e_mesg));
}

SetDupBuffers(firstfld,lastfld,value)
int	firstfld;
int	lastfld;
int	value;
{
	int i; 

	for( i=firstfld; i<=lastfld; i+=100 )
		fomca1( i, 19, value);
	if( value==0 )
		return(0);
	sr.nextfld = firstfld;
	sr.endfld = lastfld;
	fomud( (char *)&s_rec );
	ret( err_chk(&sr) );

	return( 0 );
}
ReadFunction()	/* Display options at the bottom, and read entry */
{
#ifdef ENGLISH
	fomer("C(hange) or E(xit)");
#else
	/** XXXXXX **/
	fomer(" ou F(in)");
#endif
	sr.nextfld = FUNC_FLD;	/* Fn field number */
	fomrf( (char *)&s_rec );
	ret( err_chk(&sr) );
	return(0);
}
static
ReadFields( start,end )	/* Read the given range of fields */
{
	sr.nextfld = start;
	sr.endfld = end;
	for( ; ; ){	/* Do in a loop */
		fomrd( (char *)&s_rec );	/* Profom call */
		ret(err_chk(&sr));		/* Check for profom error */
		if( sr.retcode==RET_USER_ESC || sr.retcode==RET_VAL_CHK ){
		    if( sr.retcode==RET_USER_ESC ){
			if(( sr.escchar[0]=='F' || sr.escchar[0]=='f') && s_rec.s_resp[0] != EDIT)
				return( ESCAPE );
			else if( sr.escchar[0]=='H' || sr.escchar[0]=='h' ){
				if( NO_HLP_WIN )
					continue;
			}
			else
				continue;
		    }
		    retval=Validate();
		    if(retval<0 || retval==ESCAPE)
			return(retval);
		    else
			continue;
		}
		break;
	}
	return(0);
}
static
WriteFields( start,end )	/* write the given range of fields */
int start, end;			/* start & end profom field numbers */
{
	sr.nextfld = start;
	sr.endfld = end;
	fomwr( (char *)&s_rec );
	ret( err_chk(&sr) );
	return(0);
}
ClearScreen()	/* clear the screen except fn field key flds & screen heading */
{
	if(FillNonKeyFlds(HIGH)<0 ) return(-1);
	if(FillMesgRespFlds(HIGH)<0 ) return(-1);

	if( WriteFields(FUND1_FLD,MESG_FLD)<0 ) return(-1);
	
	return(0);
}
Validate()	/* Validate the values entered by the user */
{
	int index;

	switch( sr.curfld ){
		case FUND1_FLD:	/* fund # */
			ctl_rec.fund = s_rec.s_fund1 ;
			retval = get_ctl(&ctl_rec, BROWSE, 0, e_mesg) ;
			if(retval < 0) {
				fomer(e_mesg) ;
				get();
				s_rec.s_fund1 = LV_SHORT ;
			}
			break; 
		case ACCT1_FLD:	/* G/L account */
			if( ESC_H ){
			   retval = gl_hlp(s_rec.s_fund1,s_rec.s_acctno1,&s_rec.s_reccod1,7,13);
			   if(retval == DBH_ERR) return(retval) ;
			   if(retval >=0 ) redraw();
			   if(retval < 0) return(ERROR);  /* Not Selected */
			   if(retval == 0) break;
			}
			/* check if account # is numeric */
			if( acnt_chk(s_rec.s_acctno1)==ERROR){
#ifdef ENGLISH
				fomer("Invalid Account number");
#else
				fomer("Numero de compte invalide");
#endif
				s_rec.s_acctno1[0]=LV_CHAR;
				break;
			}
			break;
		case RECCOD1_FLD:
		/* Valid Record codes are 41 to 52, 97, 98 & 99 */
			if(s_rec.s_reccod1 >= 41 && s_rec.s_reccod1 <= 52 ||
				s_rec.s_reccod1 >= 97)
				break ;
#ifdef	ENGLISH
			fomer("Valid Codes Are 41 to 52, 97, 98 & 99");
#else
			fomer("Codes valables sont de 41 a 52, 97, 98 & 99");
#endif
			s_rec.s_reccod1= LV_SHORT ;
			break;
		case FUND2_FLD:	/* fund # */
			ctl_rec.fund = s_rec.s_fund2;
			retval = get_ctl(&ctl_rec, BROWSE, 0, e_mesg) ;
			if(retval < 0) {
				fomer(e_mesg) ;
				get();
				s_rec.s_fund2 = LV_SHORT ;
			}
			break; 
		case ACCT2_FLD:	/* G/L account */
			/* check if account # is numeric */
			if( acnt_chk(s_rec.s_acctno2)==ERROR){
#ifdef ENGLISH
				fomer("Invalid Account number");
#else
				fomer("Numero de compte invalide");
#endif
				s_rec.s_acctno2[0]=LV_CHAR;
				break;
			}
			break;
		case RECCOD2_FLD:
		/* Valid Record codes are 41 to 52, 97, 98 & 99 */
			if(s_rec.s_reccod2 >= 41 && s_rec.s_reccod2 <= 52 ||
				s_rec.s_reccod2 >= 97)
				break ;
#ifdef	ENGLISH
			fomer("Valid Codes Are 41 to 52, 97, 98 & 99");
#else
			fomer("Codes valables sont de 41 a 52, 97, 98 & 99");
#endif
			s_rec.s_reccod2 = LV_SHORT ;
			break;
		default:
			break;
	}
	sr.nextfld = sr.curfld;
	return(0);
}
EditFlds()	/* Ask if user wants to edit fields before saving */
{
	for( ; ; ){
#ifdef ENGLISH
		if(DisplayMessage( "E(dit),C(ancel),Y(es) ")<0 ) 
#else
		if(DisplayMessage( "M(odifier),A(nnuler),O(ui) ")<0 ) 
#endif
			return(-1);
		sr.nextfld = RESP_FLD;
		fomrf( (char *)&s_rec );
		ret( err_chk(&sr) );
		switch( s_rec.s_resp[0] ){
			case EDIT:	/* Edit the fields */
				if((retval=ModifyField(FUND1_FLD,
						RECCOD2_FLD))<0)
					return(retval);
				break;
			case CANCEL:	/* Cancel the session */
#ifdef ENGLISH
				if( DisplayMessage("Confirm the cancel (Y/N)?")<0 )
#else
				if( DisplayMessage("Confirmer l'annulation (O/N)?")<0 )
#endif
					return(-1);
				sr.nextfld = RESP_FLD;	/* response field */
				fomrf( (char *)&s_rec );
				ret( err_chk(&sr) );
				if( s_rec.s_resp[0]==YES ){
					if( HideMessage()<0 ) return(-1);
					return(ESCAPE);
				}
				break;
			case YES:
				if( HideMessage()<0 ) return(-1);
				return(0);
		}
	}
}
DisplayMessage(mesg)	/* Display the given message in the message field */
char *mesg;
{
	STRCPY( s_rec.s_mesg, mesg );
	if( WriteFields(MESG_FLD,MESG_FLD)<0 )	return(-1);
	return(0);
}
HideMessage()	/* Hide the message & response fields */
{
	if( FillMesgRespFlds(HIGH)<0 )	return(-1);
	if( WriteFields(MESG_FLD,RESP_FLD)<0 ) return(-1);
	return(0);
}
ModifyField(firstfld,lastfld)	/* Read & change the specified fields */
int	firstfld, lastfld;
{
	int i,err;

	SetDupBuffers(firstfld,lastfld,1);

	if((err=SelectRecord())<0) return(err);

	for( ; ; ) {
		s_rec.s_fund2 = LV_SHORT;
		s_rec.s_acctno2[0] = LV_CHAR;
		s_rec.s_reccod2 = LV_SHORT;

		err = ReadFields(FUND2_FLD,RECCOD2_FLD);
		if(err != NOERROR) return(err) ;

		err=BringRecord(s_rec.s_fund2,s_rec.s_acctno2,s_rec.s_reccod2);
		if(err == NOERROR){
			fomen("G/L Account already Exists");
			get() ;
			continue;
		}
		if(err == UNDEF) break;
	}

	for( i=firstfld; i<=lastfld; i+=100 ){
		fomca1( i,19,0);	/* disable dup buffers */
		fomca1( i,10,1);	/* enable escape flag */
	}
	return(0);
}

WriteRecords()
{
	gl_rec.funds = s_rec.s_fund1;
	STRCPY( gl_rec.accno, s_rec.s_acctno1 );
	gl_rec.reccod = s_rec.s_reccod1; 
	retval = get_gl( &gl_rec, UPDATE, 0, e_mesg );
	if( retval!=NOERROR ){
		DispError();
		roll_back(e_mesg);
		return(-1);
	}

	/* copy gl record to prev record for audit file */
	scpy((char *)&pre_rec, (char *)&gl_rec, sizeof(Gl_rec));

	retval = put_gl( &gl_rec, P_DEL, e_mesg);
	if( retval!=NOERROR ){
		DispError();
		roll_back(e_mesg);
		return(-1);
	}

	gl_rec.funds = s_rec.s_fund2;
	STRCPY( gl_rec.accno, s_rec.s_acctno2 );
	gl_rec.reccod = s_rec.s_reccod2; 
	retval = put_gl( &gl_rec, ADD, e_mesg );
	if( retval!=NOERROR ){
		DispError();
		roll_back(e_mesg);
		return(-1);
	}
	retval = rite_audit((char*)&s_sth, GLMAST,UPDATE,(char*)&gl_rec,
				(char*)&pre_rec,e_mesg);

	if(retval != NOERROR){
#ifdef ENGLISH
		DispError("ERROR in Saving Records"); 
#else
		DispError("ERREUR en conservant les fiches");
#endif
		DispError(e_mesg) ;
		roll_back(e_mesg);
		ClearScreen();
		return(DBH_ERR);
	}

	if( commit(e_mesg)<0 ){
		fomen(e_mesg);
		get();
		return(-1);
	}

	return(0);
}

static
DispError()
{
	if(DisplayMessage(e_mesg)<0)
		return(-1);
#ifdef ENGLISH
	fomen("Press any key");
#else
	fomen("Appuyer sur une touche");
#endif
	get();
	sprintf(e_mesg,"iserror: %d, dberror: %d, errno: %d",
			iserror, dberror, errno );
	if(DisplayMessage(e_mesg)<0)
		return(-1);
#ifdef ENGLISH
	fomen("Press any key");
#else
	fomen("Appuyer sur une touche");
#endif
	get();
	return(HideMessage());
}
