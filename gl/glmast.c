/*-----------------------------------------------------------------------
Source Name: glmast.c
System     : Budgetary Financial system.
Module     : General Ledger system.
Created  On: 2nd May 89.
Created  By: T AMARENDRA.

COBOL Source(s): gl090f--04 & gl010f-cre

DESCRIPTION:
	Program to Maintain G/L Master File. This program provides
	Add, Change, Inquiry & Delete options on G/L Master File.
	This Program also writes Audit records for the changes.

Usage of SWITCHES when they are ON :
	SW1 - (Hospital):
		Shows Budget Code, Projection Code & Unit Measure
		on Screen and accepts input for these.
	SW2 - (Budget):
		Does the following additional checks, while updating files.

		1. Budget Cur. Year = Total of 13 periods Budget Cur. Year.

		2. Budget Pre. Year = Total of 13 periods Budget Pre. Year.
	SW3 :
		Not Used.
	SW4 - (No Key) :
		Doesn't accept input for Keys 4,5,6,11 & 12.
	SW5 - (No Modifications) :
		Doesn't accept input for Commitments to Date, Year to Date,
		Opening Bal., Budget Cur. Year, Budget Pre. Year & Actual
		last Year fields in 1st screen and for all the fields in 2nd
		screen.
	SW6 - (No Budget) :
		Accepts input for Budget Code, Budget Cur. Year & Budget
		Pre. Year fields in 1st screen and Budget fields in 2nd screen.
		Otherwise these fields are not allowed to change.
	SW7 - (Company) :
		Shows different Prompts for some of the fields. Valid codes
		range for Section expands to 5 (else 1 to 4) and for 
		Admissibility(Print) code expands to 9 (else 0 to 5).
	SW8 :
		Not Used.


	NOTE: SW2, SW4 & SW6 are inverted to their COBOL program's meaning.
	      And SW8 not used here, but it creates GLINDX in COBOL program.

MODIFICATIONS:        

Programmer     YY/MM/DD       Description of modification
~~~~~~~~~~     ~~~~~~~~       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
M. Cormier     90/11/20		Move the gl account description to the top
				 of the screen.	
P.Ralph	       91/02/06		Default fund to 1 && record code to 99

------------------------------------------------------------------------*/

#define	MAIN	/* Main program. This is to declare Switches */
#define MAINFL	GLMAST

#define	SYSTEM		"GENERAL LEDGER"	/* Sub System Name */
#define	MOD_DATE	"23-JAN-90"		/* Program Last Modified */

#include <stdio.h>
#include <ctype.h>
#include <cfomstrc.h>
#include <bfs_defs.h>
#include <bfs_recs.h>

#ifdef ENGLISH
#define ADDREC 	'A'
#define CHANGE 	'C'
#define DELETE	'D'
#define NEXT	'N'
#define PREV	'P'
#define INQUIRE	'I'
#define EXIT	'E'

#define EDIT	'E'
#define CANCEL	'C'
#define YES	'Y'
#define NO	'N'
#else	/* French */
#define ADDREC 	'R'
#define CHANGE 	'C'
#define DELETE	'E'
#define NEXT	'S'
#define PREV	'P'
#define INQUIRE	'I'
#define EXIT	'F'

#define EDIT	'M'
#define CANCEL	'A'
#define YES	'O'
#define NO	'N'
#endif

#define EXIT_RTN	12

#define	FIRST_SCR	'1'
#define	SECOND_SCR	'2'

#define	SCR_NAME1	"glmast_1"	/* First screen */
#define	SCR_NAME2	"glmast_2"	/* Second screen */

/* PROFOM Field Numbers */

#define	FN_FLD		500	/* Fn: */
#define	KEY_START	700	/* Key Start Field */
#define	KEY_END		900	/* Key End Field */
#define	CHG_FLD		1000	/* Field: */
#define	FUND_FLD	700	/* Fund Code */
#define	ACNT_FLD	800	/* Account# */
#define	RECCD_FLD	900	/* Record Code */
#define	SECTN_FLD	1200	/* Section */
#define	ADMIS_FLD	1400	/* Admissibility or Report Code */
#define	KEY1_FLD	1500	/* Key1 Field */
#define	KEY12_FLD	2600	/* Key12 Field */
#define	PROJCD_FLD	2800	/* Projection Code */
#define	UNIT_FLD	2900	/* Unit Measure */
#define GSTACCT_FLD	4300	/* GST Account */
/* Screen 1 STH file */

/* Field Numbers on Screen */

#define SECTN		1	/* Section */
#define ADMIS		3	/* Admisibility field #3 */
#define	KEY_4		7	/* Key 4 */
#define	KEY_6		9	/* Key 6 */
#define	KEY_11		14	/* Key 11 */
#define	KEY_12		15	/* Key 12 */
#define	BUD_CD		16	/* Budget Code */
#define	UNIT_MESR	18	/* Unit Measure */
#define	COMM_DT		19	/* Commitments to Date */
#define	CUR_BUD1	22	/* Budget Cur. Year */
#define	PRE_BUD1	23	/* Budget Pre. Year */
#define	ACT_LAST_YR	24	/* Actual Last Year */
#define GST_ACCNO	25	/* GST Account number */
#define	LAST_SNO1	25	/* Last Field Number on Screen */

/* glmast_1.sth - header for C structure generated by PROFOM EDITOR */

struct	s1_struct	{

	char	s1_pgm[11];	/* STRING XXXXXXXXXX Field 100 */
	long	s1_rundate;	/* DATE YYYYFMMFDD Field 300 */
	char	s1_fn[2];	/* STRING X Field 500 */

	/* Key Fields */
	/* Next fld is variable prompt for Fund Cd depends on switch */
	char	s1_co_fund[6];	/* STRING XXXXX Field 600 */
	short	s1_fund_cd;	/* NUMERIC 999 Field 700 */
	char	s1_acnt_no[19];	/* STRING XXXXXXXXXXXXXXXXXX Field 800 */
	short	s1_rec_cd;	/* NUMERIC 99 Field 900 */

	short	s1_field;	/* NUMERIC 99 Field 1000 */

	short	s1_section;	/* NUMERIC 9 Field 1200 */
	char	s1_desc[49];	/* STRING X[48] Field 1300 */
	short	s1_admis;	/* NUMERIC 9 Field 1400 */

	long	s1_keys[12];	/* NUMERIC 99999 Field 1500 to 2600 */

	short	s1_bud_cd;	/* NUMERIC 9 Field 2700 */
	short	s1_proj_cd;	/* NUMERIC 9 Field 2800 */
	short	s1_units;	/* NUMERIC 999 Field 2900 */
	double	s1_comm;	/* NUMERIC S99F999F999.99 Field 3000 */
	double	s1_ytd;		/* NUMERIC S99F999F999.99 Field 3100 */
	double	s1_opbal;	/* NUMERIC S99F999F999.99 Field 3200 */
	double	s1_cur_yr;	/* NUMERIC S99F999F999.99 Field 3300 */
	double	s1_pre_yr;	/* NUMERIC S99F999F999.99 Field 3400 */
	double	s1_lst_yr;	/* NUMERIC S99F999F999.99 Field 3500 */

	/* Variable Prompt Flds depends on switch */
	char	s1_adms_pr[15];		/* STRING XXXXXXXXXXXXXX Field 3600 */
	char	s1_k1_prmpt[10];	/* STRING XXXXXXXXX Field 3700 */
	char	s1_k2_prmpt[10];	/* STRING XXXXXXXXX Field 3800 */
	char	s1_k3_prmpt[10];	/* STRING XXXXXXXXX Field 3900 */
	char	s1_k4_prmpt[10];	/* STRING XXXXXXXXX Field 4000 */
	char	s1_k5_prmpt[10];	/* STRING XXXXXXXXX Field 4100 */
	char	s1_k6_prmpt[10];	/* STRING XXXXXXXXX Field 4200 */

	char	s1_gst_accno[19];	/* STRING X[18] Field 4300 */
	char	s1_mesg[78];	/* STRING X[77] Field 4400 */
	char	s1_resp[2];	/* STRING X Field 4500 */
	};

/* Screen 2 STH file */

/* Field Numbers on Screen */
#define	CUR_BUD2	3	/* Budget Cur. Year */
#define	PRE_BUD2	4	/* Budget Pre. Year */
#define	LAST_COL	4	/* Last Column Number on Screen */
#define	LAST_ROW	13	/* Last Period Number on Screen */

/* glmast_2.sth - header for C structure generated by PROFOM EDITOR */

struct	s2_struct	{

	char	s2_pgm[11];	/* STRING XXXXXXXXXX Field 100 */
	long	s2_rundate;	/* DATE YYYYFMMFDD Field 300 */
	char	s2_fn[2];	/* STRING X Field 500 */

	/* Key Fields */
	/* Next fld is variable prompt for Fund Cd depends on switch */
	char	s2_co_fund[6];	/* STRING XXXXX Field 600 */
	short	s2_fund_cd;	/* NUMERIC 999 Field 700 */
	char	s2_acnt_no[19];	/* STRING XXXXXXXXXXXXXXXXXX Field 800 */
	short	s2_rec_cd;	/* NUMERIC 99 Field 900 */

	short	s2_field;	/* NUMERIC 999 Field 1000 */

	double	s2_periods[13][4] ;	/* NUMERIC S99F999F999.99 Field 1900 to
						7000 */

	char	s2_mesg[78];	/* STRING X[77] Field 7100 */
	char	s2_resp[2];	/* STRING X Field 7200 */
	};

static	struct	s1_struct  s1_sth;	/* Screen-1 Structure */
static	struct	s2_struct  s2_sth;	/* Screen-2 Structure */

static	struct  stat_rec sr;		/* PROFOM status rec */

static	Gl_rec	gl_rec ,	/* G/L Master Record */
		pre_rec; 	/* Previous G/L Rec to write audit info */
static	GST_dist gst_rec,	/* Gst distribution file */
		pre_gst;	/* Previous GST rec to write audit info */
static	Tr_item	tr_item;	/* Gl Transaction item record */
static	Pa_rec	pa_rec ;	/* Parameters Record */
static	char 	e_mesg[80];  	/* dbh will return err msg in this */

/* Screen Control Variables */
static	int	ST_FLD;		/* Data entry starting field */
static	int	END_FLD;	/* screen end field */
static	short	*Field;		/* Ptr to Change Field number */
static	char	*Mesg;		/* Message fld */
static	char	*Resp;		/* Response fld to user response */
static	char	*CurrentScreen;	/* Ptr to active screen */
static	short	ActiveScr ;	/* Current screen in working */

main(argc,argv)
int argc;
char *argv[];
{
	int	err;

	if(argc < 2){
#ifdef  DEVELOP
		printf("MAIN ARGUMENTS ARE NOT PROPER\n");
		printf("Usage : %s {-tterminal name}\n", argv[0]);
#endif
		exit(1);
	}

	strncpy(SYS_NAME,SYSTEM,50);	/* Sub system name */
	strncpy(CHNG_DATE,MOD_DATE,10);	/* Modification Date */

	proc_switch(argc, argv, MAINFL) ; 	/* Process Switches */

	STRCPY(sr.termnm,terminal);	/* Copy Terminal Name */

	InitProfom() ;			/* Initialize PROFOM */

	err = get_param(&pa_rec, BROWSE, 1, e_mesg) ;
	if(err == ERROR) {
		fomen(e_mesg);
		get() ;
	}
	else if(err == UNDEF) {
#ifdef ENGLISH
		fomen("Parameters Are Not Setup..");
#else
		fomen("Parametres ne sont pas etablis..");
#endif
		get() ;
	}
	else
		err = Process(); 		/* Initiate Process */

	/* Set terminal back to normal mode from PROFOM */
	fomcs();
	fomrt();

	free_audit() ;	/* Free the space allocated in rite_audit() */
	close_dbh();	/* Close files */

	if(err != NOERROR)exit(1);
	exit(0);
} /* END OF MAIN */

/*-------------------------------------------------------------------*/
/* Initialize PROFOM */

InitProfom()
{
	fomin(&sr);
	/* Check for Error */
	if(err_chk(&sr) == PROFOM_ERR){
		fomcs();
		fomrt();
		exit(1);
	}
	fomcf(1,1);	/* Enable Snap screen option */
}	/* InitProfom() */
/*-------------------------------------------------------------------*/
/* Get Option from user and call corresponding function */

Process()
{
	int err;

	InitScreens() ;

	for( ; ; ){
		/* Display Fn: options */
#ifdef	ENGLISH
		fomer("A(dd), C(hange), D(elete), N(ext), P(rev), I(nquire), E(xit)");
#else
		fomer("R(ajouter), C(hanger), E(liminer), S(uivant), P(recedent), I(nterroger), F(in)");
#endif

		/* Read Fn: field to get the option */
		sr.nextfld = FN_FLD ;
		fomrf((char*)&s1_sth);
		ret(err_chk(&sr));	/* Check for PROFOM error */

		switch(s1_sth.s1_fn[0]){
		case ADDREC  :	/* Add */
			CHKACC(err,ADD,e_mesg);
			err = AddNewRec();
			break;
		case CHANGE  :	/* Change */
			CHKACC(err,UPDATE,e_mesg);
			err = ChangeRec();
			break;
		case DELETE  :	/* Delete */
			CHKACC(err,P_DEL,e_mesg);
			err = DeleteRec();
			break;
		case NEXT  : 	/* Next */
			CHKACC(err,BROWSE,e_mesg);
			err = NextRec() ; 
			break ;
		case PREV  :	/* Previous */
			CHKACC(err,BROWSE,e_mesg);
			err = PrevRec() ; 
			break ;
		case INQUIRE  : 	/* Inquiry */
			CHKACC(err,BROWSE,e_mesg);
			err = InquiryRec();
			break ;
		case EXIT  :
			return(NOERROR);
		default   : 
			continue; 
		}  /*   end of the switch statement */

		if(err == NOACCESS) {
			fomer(e_mesg);
			get();
		}
		if(err == PROFOM_ERR)return(PROFOM_ERR); /* PROFOM ERROR */
		if(err == DBH_ERR) {
			DispError(e_mesg);
#ifdef	ENGLISH
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"System Error... Iserror:",
				iserror, dberror, errno);
#else
			sprintf(e_mesg,"%s %d Dberror: %d Errno: %d",
				"Erreur du systeme... Iserror:",
				iserror, dberror, errno);
#endif
			DispError(e_mesg);
			return(DBH_ERR); /* DBH ERROR */
		}
	}      /*   end of the for( ; ; )       */
}	/* Process() */
/*----------------------------------------------------------------*/
/* Initialize screens before going to process options */
InitScreens()
{
	/* set 1st screen as a active screen */
	Set1stScreen(0);

	/* Screen 1 */

	if(SW7)
#ifdef ENGLISH
		STRCPY(s1_sth.s1_co_fund," Co.:");
	else
		STRCPY(s1_sth.s1_co_fund,"Fund:");
#else
		STRCPY(s1_sth.s1_co_fund," Cie:");
	else
		STRCPY(s1_sth.s1_co_fund,"Fond:");
#endif

	STRCPY(s1_sth.s1_pgm,PROG_NAME);
	s1_sth.s1_rundate = get_date();	/* get Today's Date in YYMMDD format */
	s1_sth.s1_field = HV_SHORT ;
	s1_sth.s1_mesg[0] = HV_CHAR ;
	s1_sth.s1_resp[0] = HV_CHAR ;

	/* Initialize key fields. This gets 1st record from the file
	   if user selects 'N' option immediatly after invoking */
	s1_sth.s1_fund_cd = 1 ;
	s1_sth.s1_acnt_no[0] = '\0' ;
	s1_sth.s1_rec_cd = 99;

	/* Move High Values to 1st screen data fields & Display */
	MoveHighs() ;

	/* Screen 2 */
	if(SW7)
#ifdef ENGLISH
		STRCPY(s2_sth.s2_co_fund," Co.:");
	else
		STRCPY(s2_sth.s2_co_fund,"Fund:");
#else
		STRCPY(s2_sth.s2_co_fund," Cie:");
	else
		STRCPY(s2_sth.s2_co_fund,"Fond:");
#endif

	STRCPY(s2_sth.s2_pgm,PROG_NAME);
	s2_sth.s2_rundate = s1_sth.s1_rundate ;
	s2_sth.s2_field = HV_SHORT ;
	s2_sth.s2_mesg[0] = HV_CHAR ;
	s2_sth.s2_resp[0] = HV_CHAR ;

	return(NOERROR) ;
}	/* InitScreens() */
/*---------------------------------------------------------------------*/
/* Set 1st screen as active screen */
Set1stScreen(flg)
int	flg ;	/* If Yes display the screen */
{
	/* move 1st screen name to Profom status structure */
	STRCPY(sr.scrnam,NFM_PATH);
	strcat(sr.scrnam,SCR_NAME1) ;

	/* Initialize Ptrs to 1st screen */
	Field = &s1_sth.s1_field ;
	Mesg = s1_sth.s1_mesg;
	Resp = s1_sth.s1_resp;
	CurrentScreen = (char*)&s1_sth ;
	ActiveScr = 1 ;
	ST_FLD = 1200 ;
	END_FLD = 4500 ;

	if(flg) {
		sr.nextfld = 1;
		sr.endfld = 0;
		fomwr(CurrentScreen);
		ret(err_chk(&sr));
	}
	return(NOERROR) ;
}	/* Set1stScreen() */
/*---------------------------------------------------------------------*/
/* Set 2nd screen as active screen */
Set2ndScreen()
{
	/* move 2nd screen name to Profom status structure */
	STRCPY(sr.scrnam,NFM_PATH);
	strcat(sr.scrnam,SCR_NAME2) ;

	/* Copy Key fields from 1st screen */
	STRCPY(s2_sth.s2_fn,s1_sth.s1_fn);
	s2_sth.s2_fund_cd = s1_sth.s1_fund_cd ;
	STRCPY(s2_sth.s2_acnt_no,s1_sth.s1_acnt_no) ;
	s2_sth.s2_rec_cd = s1_sth.s1_rec_cd ;

	/* Initialize Ptrs to 2nd screen */
	Field = &s2_sth.s2_field ;
	Mesg = s2_sth.s2_mesg;
	Resp = s2_sth.s2_resp;
	CurrentScreen = (char*)&s2_sth ;
	ActiveScr = 2 ;
	ST_FLD = 1900 ;
	END_FLD = 7200 ;

	sr.nextfld = 1;
	sr.endfld = 0;
	fomwr(CurrentScreen);
	ret(err_chk(&sr));

	return(NOERROR) ;
}	/* Set2ndScreen() */
/*----------------------------------------------------------------------*/
/* Read the full screen and add the record to data base */
AddNewRec()
{
	int	i, j ;

	for( ; ;){
		i = ReadKey();
		if(i != NOERROR)return(i);

		/* check whether given key is already existing */
		i = BringRecord(BROWSE);
		if(i == ERROR) return(DBH_ERR) ;
		if(i == NOERROR){
#ifdef	ENGLISH
			fomer("Given Key already in File - Please enter again") ;
#else
			fomer("Cle donnee deja dans le dossier - reessayer") ;
#endif
			continue;
		}
		/* UNDEF */
		break;
	}

	/* If 1st G/L Record is being enterted lock parameter record
	   to update G/L master present flag */
	if(pa_rec.pa_glmast[0] != YES) {
		i = get_param(&pa_rec, UPDATE, 1, e_mesg) ;
		if(i < 0) {
			DispError(e_mesg) ;
			return(DBH_ERR) ;
		}
	}

	/* Change PROFOM logical field attributes */

	for(i = ST_FLD ; i <= END_FLD - 200  ; i += 100) {
		fomca1(i,19,0); /* Disable Dup control */
		fomca1(i,10,1);	/* Enable User Esacpe */
	}

	/* Enable Dup Control for Key fields, to show the current values
	   as default values */
	for(i = KEY1_FLD ; i <= KEY12_FLD ; i += 100)
		fomca1(i,19,2); /* Enable Dup control */

	i = ReadScreen() ;	/* Read 1st screen fields */
	if(i != NOERROR) return(i) ;

	/* Initialize all periods fields to zero in 2nd screen */
	for(i = 0 ; i < pa_rec.pa_no_periods && i < NO_PERIODS ; i++)
		for(j = 0 ; j < 4 ; j++)
			s2_sth.s2_periods[i][j] = 0.0 ;
	for( ; i < NO_PERIODS ; i++)
		for(j = 0 ; j < 4 ; j++)
			s2_sth.s2_periods[i][j] = HV_DOUBLE ;

	i = ReadOption() ;
	if(i < 0) return(i) ;

	if(i == CANCEL) {
		roll_back(e_mesg) ;
		return(MoveHighs()) ;
	}

	CopyToRecord(ADD) ;

	return( RiteRecord(ADD) );
}	/* AddNewRec() */
/*-----------------------------------------------------------------------*/
/* Accepts the changes to selected record and update the database */
ChangeRec()
{
	int	err ;

	err = SelectRecord(UPDATE) ;
	if(err != NOERROR) return(err) ;

	err = ChangeFields();
	if(err != NOERROR) return(err);

	err = ReadOption() ;
	if(err < 0) return(err) ;

	if(err == CANCEL) {
		CopyToScreen() ;	/* Display the original record */
		roll_back(e_mesg);  /* Unlocking if recs not modified */
		return(NOERROR) ;
	}

	CopyToRecord(UPDATE) ;

	return( RiteRecord(UPDATE) );
}	/* ChangeRec() */
/*-----------------------------------------------------------------------*/
/* Select the record to be deleted and delete from database afetr
   confirmation */
DeleteRec()
{
	int	err;

	err = SelectRecord(UPDATE) ;
	if(err != NOERROR) return(err) ;

	err = ReadOption() ;
	if(err < 0) return(err) ;

	if(gl_rec.comdat > 0){
#ifdef ENGLISH
		DispError("Not Deleted - Non Zero Balance in Commitments");
#else
		DispError("Pas elimine - Solde dans engaements n'est pas zero");
#endif
		return(NOERROR);
	}
		
	if(err == CANCEL) {
		roll_back(e_mesg);  /* Unlocking if recs not modified */
		return(NOERROR) ;
	}

	return( RiteRecord(P_DEL) );
}	/* DeleteRec() */
/*-----------------------------------------------------------------------*/
/* Get next rec from file & Display when user selected 'N' in function */
NextRec()
{
	int	err;

	err = BringNext(FORWARD) ;
	if(err != NOERROR) return(err) ;

#ifdef	SHOW_2_SCREENS
	err = ReadOption() ;
	if(err < 0) return(err) ;
#endif

	return(NOERROR) ;
}
/*-----------------------------------------------------------------------*/
/* Get Previous record from file & Display when user selected 'P' in function */
PrevRec()
{
	int	err;

	err = BringNext(BACKWARD) ;
	if(err != NOERROR) return(err) ;

#ifdef	SHOW_2_SCREENS
	err = ReadOption() ;
	if(err < 0) return(err) ;
#endif

	return(NOERROR) ;
}
/*-----------------------------------------------------------------------*/
/* Select the Key, get the record & display */
InquiryRec()
{
	int	err ;

	err = SelectRecord(BROWSE) ;
	if(err != NOERROR) return(err) ;

	err = ReadOption() ;
	if(err < 0) return(err) ;

	return(NOERROR) ;
}
/*----------------------------------------------------------*/
/* Read the key fields, get the record with LOCK and display
   the Record */
SelectRecord(md)
int	md ;	/* BROWSE for Inquiry, UPDATE for Others */
{
	int	err ;

	for(; ;){
		err = ReadKey();
		if(err != NOERROR) return(err) ;

		/* Get the record from database */

		err = BringRecord(md);
		if(err < 0){
			fomen(e_mesg);
			get() ;
			if(err == UNDEF || err == LOCKED) continue ;
			return(DBH_ERR);
		}
		CopyToScreen() ;
		return(NOERROR) ;
	}
}	/* SelectRecord() */
/*----------------------------------------------------------------------*/
/* Read Key Fields */
ReadKey()
{
	int	i ;
	int 	key_fund ;
	char 	key_acnt[sizeof(s1_sth.s1_acnt_no)];
	int 	key_rec_cd ;
	int	err;

#ifdef	ENGLISH
	strcpy(Mesg,"Press ESC-F to Go Back to Fn:");
#else
	strcpy(Mesg,"Appuyer sur ESC-F pour retourner a Fn:");
#endif
	ShowMesg();

	/* In Add mode set validity check on for Fund & Record Code fields and
	   turn off dup control for key fields. Other modes reverse it */
	if(s1_sth.s1_fn[0] == ADDREC){	/* ADD */
		fomca1(FUND_FLD,6,1);	/* On Validity Check */
		fomca1(RECCD_FLD,6,1);	/* On Validity Check */

		for(i = KEY_START ; i <= KEY_END ; i += 100)
			fomca1(i,19,0) ;	/* Off Dup Control */
	}
	else {
		fomca1(FUND_FLD,6,0);
		fomca1(RECCD_FLD,6,0);

		for(i = KEY_START ; i <= KEY_END ; i += 100)
			fomca1(i,19,2) ;

		sr.nextfld = KEY_START;
		sr.endfld = KEY_END;
		fomud((char*)&s1_sth);
	}

	/* Store key fields to copy back when user gives ESC-F */
	key_fund = s1_sth.s1_fund_cd ;
	STRCPY(key_acnt,s1_sth.s1_acnt_no) ;
	key_rec_cd = s1_sth.s1_rec_cd;

	fund_default();
	sr.nextfld = KEY_START;
	sr.endfld = KEY_END;
	s1_sth.s1_fund_cd = LV_SHORT ;
	s1_sth.s1_acnt_no[0] = LV_CHAR ;
	s1_sth.s1_rec_cd = LV_SHORT ; 
	for(; ;) {
		fomrd((char*)&s1_sth);
		ret(err_chk(&sr));

		if(sr.retcode == RET_VAL_CHK){
			err = Validate(sr.curfld) ;
			if(err == DBH_ERR) return(err) ;
			sr.nextfld = sr.curfld;
			continue;
		}
		if(sr.retcode == RET_USER_ESC){
			if(sr.escchar[0] == 'F' || sr.escchar[0] == 'f') {
				/* copy back key fields */
				s1_sth.s1_fund_cd = key_fund ;
				STRCPY(s1_sth.s1_acnt_no,key_acnt) ;
				s1_sth.s1_rec_cd = key_rec_cd ; 

				sr.nextfld = KEY_START;
				sr.endfld = KEY_END;
				fomwr((char*)&s1_sth);

				Mesg[0] = HV_CHAR;
				ShowMesg();
				return(ERROR) ;
			}
			if(sr.escchar[0] == 'h' || sr.escchar[0] == 'H'){
				err = WindowHelp() ;
				if(err == DBH_ERR) return(err) ;
				continue;
			}
			continue;
		}
		/* else RET_NO_ERROR */
		break;
	}			/* end of for loop */

	Mesg[0] = HV_CHAR;
	ShowMesg();

	return(NOERROR);
}	/*  ReadKey() */
/*------------------------------------------------------------*/
/* Get all fields from user on 1st screen */
ReadScreen()
{
	int	err ;

	/* Initialize screen with Low values */
	MoveLows() ;
	sr.nextfld = ST_FLD;
	sr.endfld = END_FLD-200;
	for( ; ;){
		fomrd((char*)&s1_sth);
		ret(err_chk(&sr));
		if(sr.retcode == RET_VAL_CHK){
			err = Validate(sr.curfld) ;
			if(err == DBH_ERR) return(err) ;
			sr.nextfld = sr.curfld;
			continue;
		}
		if(sr.retcode == RET_USER_ESC){
			if(sr.escchar[0] == 'f' || sr.escchar[0] == 'F') {
				roll_back(e_mesg);
				MoveHighs() ;
				return(ERROR);
			}
			continue;
		}
		/* else RET_NO_ERROR */
		break;
	}

	return(NOERROR) ;
}	/* ReadScreen() */
/*----------------------------------------------------------------*/
Validate(fld_no)	/* validate flds when PROFOM returns RET_VAL_CHK */
int	fld_no ;
{
	int	err ;
	Ctl_rec	ctl_rec ;	/* Control Record */

	switch(fld_no){
	case	FUND_FLD  :	/* Fund Code */
		ctl_rec.fund = s1_sth.s1_fund_cd ;
		err = get_ctl(&ctl_rec, BROWSE, 0, e_mesg) ;
		if(err == DBH_ERR) return(err);
		if(err < 0) {
			fomer(e_mesg) ;
			s1_sth.s1_fund_cd = LV_SHORT ;
			return(ERROR) ;
		}
		break ;
	case	ACNT_FLD :	/* Account# */
		/*
		* Check whether account# is having any invalid characters.
		*/

		if(acnt_chk(s1_sth.s1_acnt_no) == ERROR) {
#ifdef	ENGLISH
			fomer("Invalid Account Number");
#else
			fomer("Numero de compte invalide");
#endif
			s1_sth.s1_acnt_no[0] = LV_CHAR ;
			return(ERROR) ;
		}
		break ;
	case	RECCD_FLD  :	/* Record Code */
		/* Valid Record codes are 41 to 52, 97, 98 & 99 */
		if(s1_sth.s1_rec_cd >= 41 && s1_sth.s1_rec_cd <= 52 ||
			s1_sth.s1_rec_cd >= 97)
			break ;
#ifdef	ENGLISH
		fomer("Valid Codes Are 41 to 52, 97, 98 & 99");
#else
		fomer("Codes valables sont de 41 a 52, 97, 98 & 99");
#endif
		s1_sth.s1_rec_cd = LV_SHORT ;
		return(ERROR) ;
	case	SECTN_FLD :	/* Section */
		/* Valid codes are 1 to 4. 5 is also valid when SW7 is ON */
		if(s1_sth.s1_section >= 1 && s1_sth.s1_section <= 4) break;
		if(SW7 && s1_sth.s1_section == 5) break;
#ifdef	ENGLISH
		if(SW7)
			fomer("Valid Codes Are 1 to 5");
		else
			fomer("Valid Codes Are 1 to 4");
#else
		if(SW7)
			fomer("Codes valables sont de 1 a 5");
		else
			fomer("Codes valables sont de 1 a 4");
#endif
		s1_sth.s1_section = LV_SHORT ;
		return(ERROR) ;
	case	ADMIS_FLD :	/* Admissibility or Report Code */
		/* Valid codes are 0 to 5. 6 to 9 are also valid when SW7
		   is ON */
		if(s1_sth.s1_admis >= 0 && s1_sth.s1_admis <= 5) break;
		if(SW7 && s1_sth.s1_admis >= 6 && s1_sth.s1_admis <= 9) break;
#ifdef	ENGLISH
		if(SW7)
			fomer("Valid Codes Are 0 to 9");
		else
			fomer("Valid Codes Are 0 to 5");
#else
		if(SW7)
			fomer("Codes valables sont de 0 a 9");
		else
			fomer("Codes valables sont de 0 a 5");
#endif
		s1_sth.s1_admis = LV_SHORT ;
		return(ERROR) ;
	case	PROJCD_FLD  :	/* Projection Code */
		/* Valid codes are 0 to 7 */
		if(s1_sth.s1_proj_cd >= 0 && s1_sth.s1_proj_cd <= 7) break;
#ifdef	ENGLISH
		fomer("Valid Codes Are 0 to 7");
#else
		fomer("Codes valables sont de 0 a 7");
#endif
		s1_sth.s1_proj_cd = LV_SHORT ;
		return(ERROR) ;
	case	UNIT_FLD  :	/* Unit Measure */
		/* 0 and 1 are valid codes when record code = 98. 1 to 10 are
		   valid codes when record code = 97 */
		if( s1_sth.s1_rec_cd == 98 && s1_sth.s1_units < 2) break ;
		if( s1_sth.s1_rec_cd == 97 &&
			s1_sth.s1_units >= 1 && s1_sth.s1_units <= 10 ) break ;
#ifdef	ENGLISH
		if( s1_sth.s1_rec_cd == 98 )
			fomer("Valid Codes Are 0 and 1");
		else
			fomer("Valid Codes Are 1 to 10");
#else
		if( s1_sth.s1_rec_cd == 98 )
			fomer("Codes valables sont 0 et 1");
		else
			fomer("Codes valables sont de 1 a 10");
#endif
		s1_sth.s1_units = LV_SHORT ;
		return(ERROR) ;
	case GSTACCT_FLD:
		/*
		* Check whether account# is having any invalid characters.
		*/
		if(s1_sth.s1_gst_accno[0] == '\0') {
			STRCPY(s1_sth.s1_gst_accno," ");
			break;
		}
		if(acnt_chk(s1_sth.s1_gst_accno) == ERROR) {
#ifdef	ENGLISH
			fomer("Invalid Account Number");
#else
			fomer("Numero de compte invalide");
#endif
			s1_sth.s1_gst_accno[0] = LV_CHAR ;
			return(ERROR) ;
		}

		err = CheckGSTAcct(s1_sth.s1_gst_accno);
		if(err == DBH_ERR) return(err);
		if(err < 0) {
			fomer(e_mesg);
			s1_sth.s1_gst_accno[0] = LV_CHAR ;
			return(ERROR);
		}	
		if(strcmp(s1_sth.s1_gst_accno,s1_sth.s1_acnt_no)==0) {
#ifdef ENGLISH
			fomer("GST account can not be the same as the account being using");
#else 
			fomer("Compte TPS ne peut etre le meme que celui utilise");
#endif
			s1_sth.s1_gst_accno[0] = LV_CHAR ;
		}
		/* Show Right Justified Account Number */
		sr.nextfld = sr.curfld;
		fomwf((char*)&s1_sth);
		ret(err_chk(&sr));

		if(s1_sth.s1_fn[0] == CHANGE) {
			/* Get Gl record back because checking the gst account
			   moves the file pointer. */
			err = BringRecord(UPDATE); 
			if(err < 0){
				fomen(e_mesg);
				get() ;
				return(DBH_ERR);
			}
		}
		break;
	default :
#ifdef ENGLISH
		sprintf(e_mesg,"No Validity Check For Field#  %d",sr.curfld);
#else
		sprintf(e_mesg,"Pas de controle de validite pour le Champ#  %d",sr.curfld);

#endif
		fomen(e_mesg);
		get();
		return(ERROR) ;
	}	/* Switch fld_no */

	return(NOERROR) ;
}	/* Validate() */
/*----------------------------------------------------------------*/
WindowHelp()	/* Display help window for applicable fields */
{
	int	err ;

	switch(sr.curfld){
	case	ACNT_FLD :	/* Account# */
	case	RECCD_FLD  :	/* Record Code */
		/* ADD mode need not give help because user going to
		   add new key */
		if(s1_sth.s1_fn[0] == ADDREC) break ;

		err = gl_hlp(s1_sth.s1_fund_cd, s1_sth.s1_acnt_no,
			&s1_sth.s1_rec_cd, 7, 13 );
		if(err == DBH_ERR) return(err) ;
		if(err >=0 ) redraw();
		break ;
	default :
#ifdef ENGLISH
		fomer("No Help Window For This Field");
#else
		fomer("Pas de fenetre d'assistance pour ce champ");
#endif
		return(ERROR) ;
	}	/* Switch fld_no */

	sr.nextfld = sr.curfld ;
	return(NOERROR) ;
}	/* WindowHelp() */
/*----------------------------------------------------------------------*/
/* Changing fields. Accept fld to be changed and read that fld */
/* This function is common function for both the screens */
ChangeFields()
{
	int	i;

	/* Change PROFOM logical field attributes */

	for(i = ST_FLD ; i <= END_FLD - 200  ; i += 100) {
		fomca1(i,19,2); /* enabling Dup control */
		fomca1(i,10,0);	/* Disable User Esacpe */
	}

	/* Set Dup Buffers */
	sr.nextfld = ST_FLD;
	sr.endfld = END_FLD-200;
	fomud(CurrentScreen);  /* Updating dup buffer */
	ret(err_chk(&sr));

	/* Get The Field to Be Modified */
#ifdef	ENGLISH
	strcpy(Mesg,"Enter RETURN to terminate Edit");
#else
	strcpy(Mesg,"Appuyer sur RETURN pour terminer l'ajustement");
#endif
	ShowMesg() ;

	for( ; ; ) {
		sr.nextfld = CHG_FLD ;
		fomrf(CurrentScreen);
		ret(err_chk(&sr));

		if(*Field == 0) break ;

		i = ReadFld() ;	/* Read Field */
		if(i == PROFOM_ERR) return(i) ;
		if(i == DBH_ERR) return(i) ;
	}	/* for( ; ; ) */

	*Field = HV_SHORT ;
	fomwf(CurrentScreen);
	ret(err_chk(&sr));

	Mesg[0] = HV_CHAR;
	ShowMesg();

	return(NOERROR);
}	/* ChangeFields() */
/*-----------------------------------------------------------------------*/
/* Read the user selected field in change mode */
ReadFld()
{
	int	err ;
	short	row, col ;

	/* Validate  Field Number */
	/* Changes are not allowed for some of the flds in following
	   conditions */
	/*
	*  SCREEN-1
	*
	*  If SW4 (No Key) is ON don't allow for keys 4,5,6,11 & 12.
	*
	*  If SW1 (Hospital) is OFF don't allow for Budget Cd, Projection Code &
	*  Unit Measure.
	*
	*  If record code is not 97 or 98 don't allow for Unit Measure.
	*
	*  If SW5 (No Mod) is ON don't allow for Comm. to date, Year to date
	*  Op. Bal, Budget Cur. Year, Budget Pre. Year & Actual last year.
	*
	*  If SW6 (No Bud) is OFF don't allow for Budget Cd, Budget Cur. Year &
	*  Budget Pre. Year.
	*
	*  SCREEN-2
	*
	*  If SW6 (No Bud) is OFF don't allow for Budget fields in
	*  all 13 periods.
	*/

	if(ActiveScr == 1) {	/* 1st screen */
		if( *Field < 1 || *Field > LAST_SNO1) return (ERROR) ;
		if(SW4)	/* No Key */
			if((*Field >= KEY_4 && *Field <= KEY_6) ||
				*Field == KEY_11 || *Field == KEY_12)
					return (ERROR);
		if(!SW1)	/* Not Hospital */
			if(*Field >= BUD_CD && *Field <= UNIT_MESR)
					return (ERROR);
		if(s1_sth.s1_rec_cd < 97 || s1_sth.s1_rec_cd > 98)
			if(*Field == UNIT_MESR)
				return (ERROR);
		if(SW5) {	/* No  Mod */
			if(*Field >= COMM_DT && *Field <= ACT_LAST_YR)
				return (ERROR);
			if(*Field == ADMIS || *Field == SECTN || 
				(*Field >= BUD_CD && *Field <= UNIT_MESR))
				return(ERROR);
		}
		if(!SW6)	/* No Bud */
			if(*Field == BUD_CD || *Field == CUR_BUD1 ||
				*Field == PRE_BUD1) return (ERROR);

		if(*Field == GST_ACCNO) {
			sr.nextfld = GSTACCT_FLD;
		}
		else {
			/* Set PROFOM nextfld */
			sr.nextfld = ST_FLD + (*Field - 1) * 100 ;
		}
	}
	else {	/* 2nd Screen */
		row = *Field / 10 ;
		col = *Field % 10 ;
		if(row < 1 || row > LAST_ROW || row > pa_rec.pa_no_periods)
			return (ERROR) ;
		if(col < 1 || col > LAST_COL) return (ERROR) ;

		if(!SW6)	/* No Bud */
			if(col == CUR_BUD2 || col == PRE_BUD2) return (ERROR);

		/* Set PROFOM nextfld */
		sr.nextfld = ST_FLD + ( (row - 1) * 4 + (col - 1) ) * 100 ;
	}

	for( ; ; ) {
		fomrf(CurrentScreen);
		ret(err_chk(&sr));

		if(sr.retcode == RET_VAL_CHK) {
			if(ActiveScr == 1) {	/* 1st screen */
				err = Validate(sr.curfld) ;
			}
			else	/* 2nd Screen */
				err = Validate(-1) ; /* Display Error Message */
			if(err == NOERROR) break;
			if(err == DBH_ERR) return(err) ;
			continue ;
		}
		if(sr.retcode != RET_NO_ERROR) continue;
		break ;
	}
	return(NOERROR) ;
}	/* ReadFld() */
/*-----------------------------------------------------------------------*/
/* Display the confirmation message at the bottom of the screen, take the
   option from user and call necessary functions */
ReadOption()
{
	int	err ;

	/* Options:
	   Add      - YEC1/2
	   Change   - YEC1/2
	   Delete   - YC
	   Next     - Y1/2
	   Previous - Y1/2
	   Inquiry  - Y1/2
	*/

	for( ; ; ) {
	    switch(s1_sth.s1_fn[0]) {
	    case	ADDREC :	/* Add */
	    case	CHANGE :	/* Change */
		if(ActiveScr == 1)
#ifdef	ENGLISH
		    err = GetOpt("Y(es), E(dit), C(ancel), 2(nd screen)",
							"YEC2");
#else
		    err = GetOpt("O(ui), M(odifier), A(nnuler), 2(e ecran)",
							"OMA2");
#endif
		else	/* if ActiveScr == 1 */
#ifdef	ENGLISH
		    /* Changes to 2nd Screen is not allowed when SW5 is ON */
		    if(SW5)	/* No Mod */
			err = GetOpt("Y(es), C(ancel), 1(st screen)",
							"YC1");
		    else
			err = GetOpt("Y(es), E(dit), C(ancel), 1(st screen)",
							"YEC1");
#else
		    /* Changes to 2nd Screen is not allowed when SW5 is ON */
		    if(SW5)	/* No Mod */
			err = GetOpt("O(ui), A(nnuler), 1(er ecran)",
							"OA1");
		    else
			err = GetOpt("O(ui), M(odifier), A(nnuler), 1(er ecran)",
							"OMA1");
#endif
		break ;
	    case	DELETE :	/* Delete */
#ifdef	ENGLISH
		err = GetOpt("Y(es), C(ancel)", "YC");
#else
		err = GetOpt("O(ui), A(nnuler)", "OA");
#endif
		break ;
#ifdef	SHOW_2_SCREENS
	    case	NEXT :	/* Next Record */
	    case	PREV :	/* Previous Record */
#endif
	    case	INQUIRE :	/* Inquiry */
		if(ActiveScr == 1)
#ifdef	ENGLISH
		    err = GetOpt("Y(es), 2(nd screen)", "Y2");
		else	/* if ActiveScr == 1 */
		    err = GetOpt("Y(es), 1(st screen)", "Y1");
#else
		    err = GetOpt("O(ui), 2(e ecran)", "O2");
		else	/* if ActiveScr == 1 */
		    err = GetOpt("O(ui), 1(er ecran)", "O1");
#endif
		break ;
	    }	/* switch fn[] */

	    if(err == PROFOM_ERR) return(err) ;

	    switch(err) {
	    case  YES :
		if(ActiveScr == 2) Set1stScreen(1) ;
		if(s1_sth.s1_fn[0] == ADDREC || s1_sth.s1_fn[0] == CHANGE) {
			err = CheckTotals() ;
			if(err == ERROR) continue ;
			return(YES) ;
		}
		/*
		*  While deleting records YTD and current year budget
		*  must be zero.
		*/
		if(s1_sth.s1_fn[0] == DELETE) {
			if(s1_sth.s1_ytd < -0.005 || s1_sth.s1_ytd > 0.005) {
#ifdef ENGLISH
			    fomen("Not DELETED. Year-to-Date is not 0");
#else
			    fomen("Pas ELIMINE. cumul n'est pas 0 ");
#endif
				get();
				return(CANCEL) ;
			}
			else {
			if(s1_sth.s1_cur_yr < -0.005 ||
						s1_sth.s1_cur_yr > 0.005) {
#ifdef ENGLISH
			    fomen("Not DELETED. Current Year Budget is not 0");
#else
			    fomen("Pas ELIMINE. budget de l'annee courante n'est pas zero");
#endif
				get();
				return(CANCEL) ;
			}
			}

		}
		if(s1_sth.s1_fn[0] == DELETE) {
			tr_item.ti_fund = s1_sth.s1_fund_cd;
			tr_item.ti_reccod = s1_sth.s1_rec_cd;
			strcpy(tr_item.ti_accno, s1_sth.s1_acnt_no);
			tr_item.ti_period = 0;
			tr_item.ti_seq_no = 0;
			tr_item.ti_item_no = 0;
			flg_reset(GLTRAN);

			err = get_n_tritem( &tr_item,BROWSE,1,FORWARD,e_mesg);
			if( err < 0 ) {
				if( err == EFL ) return(YES);
				else	return(CANCEL);
			}
			if (tr_item.ti_fund == s1_sth.s1_fund_cd &&
			    tr_item.ti_reccod == s1_sth.s1_rec_cd &&
			    strcmp(tr_item.ti_accno, s1_sth.s1_acnt_no) == 0) {
#ifdef ENGLISH
			    fomen("Not DELETED. Transactions Exist for the Account");
#else
			    fomen("Pas ELIMINE. Transactions existent pour ce compt");
#endif
			    get();
			    return(CANCEL);
			}
		}

		return(YES) ;
	    case  EDIT  :
		err = ChangeFields();
		break ;
	    case  CANCEL :
#ifdef	ENGLISH
		err = GetOpt("Confirm the Cancel (Y/N)?", "YN") ;
#else
		err = GetOpt("Confirmer l'annulation (O/N)?", "ON") ;
#endif
		if(err == YES) {
			if(ActiveScr == 2) Set1stScreen(1) ;
			return(CANCEL) ;
		}
		break ;
	    case  FIRST_SCR :
		err = Set1stScreen(1) ;
		break ;
	    case  SECOND_SCR :
		err = Set2ndScreen() ;
		break ;
	    }	/* switch err */

	    if(err == PROFOM_ERR) return(err) ;
	    if(err == DBH_ERR) return(err) ;
	}	/* for(; ; ) */
}	/* ReadOption() */
/*-----------------------------------------------------------------------*/
/* Display message and get the option */
GetOpt(msg,options)
char	*msg ;
char	*options ;
{
	int	i, j ;

	strcpy(Mesg,msg);
	ShowMesg() ;

	sr.nextfld = END_FLD ;
	for( ; ; ) {
		fomrf(CurrentScreen) ;
		ret(err_chk(&sr)) ;

		j = strlen(options) ;
		for( i = 0 ; i < j ; i++)
			if(Resp[0] == options[i]) break ;
		if(i != j) break ;	/* Valid Option Selected */
#ifdef	ENGLISH
		fomer("Invalid Option..");
#else
		fomer("Option invalide..");
#endif
	}
	Mesg[0] = HV_CHAR ;
	Resp[0] = HV_CHAR ;
	sr.nextfld = END_FLD - 100 ;
	sr.endfld = END_FLD ;
	fomwr(CurrentScreen) ;
	ret(err_chk(&sr)) ;

	return((int)(options[i])) ;
}	/* GetOpt() */
/*-----------------------------------------------------------------------*/
/* After Adding/Changing do the following checks before writing record on
   file */
CheckTotals()
{
	double	temp, year_to_dt, act_lst_yr, bud_cur_yr, bud_pre_yr ;
	short	i ;

	/*
	*  CHECKS:
	*
	*  Check-1:
	*	Op Bal + Total of 13 periods Actual Cur. Yr = Year To Date.
	*  Check-2:
	*	Actual Last year = Total of 13 periods Actual Pre. Year.
	*
	*  If SW2 (Budget) is ON then only do next 2 checks.
	*
	*  Check-3:
	*	Budget Cur. Year = Total of 13 periods Budget Cur. Year.
	*  Check-4:
	*	Budget Pre. Year = Total of 13 periods Budget Pre. Year.
	*/

	/* Cumulate Periods */
	year_to_dt = s1_sth.s1_opbal ;
	act_lst_yr = 0.0 ;
	bud_cur_yr = 0.0 ;
	bud_pre_yr = 0.0 ;
	
	for( i = 0 ; i < pa_rec.pa_no_periods && i < NO_PERIODS ; i++) {
		year_to_dt += s2_sth.s2_periods[i][0] ;
		act_lst_yr += s2_sth.s2_periods[i][1] ;

		if(!SW2) continue ;	/* Budget */

		bud_cur_yr += s2_sth.s2_periods[i][2] ;
		bud_pre_yr += s2_sth.s2_periods[i][3] ;
	}
	/* Check-1 */
	temp = year_to_dt - s1_sth.s1_ytd ;
	if( temp < -0.005 || temp > 0.005) {
#ifdef	ENGLISH
		fomen("YTD Totals Don't Balance");
#else
		fomen("Totaux du cumul ne balancent pas");
#endif
		get() ;
		return(ERROR) ;
	}
	/* Check-2 */
	temp = act_lst_yr - s1_sth.s1_lst_yr ;
	if( temp < -0.005 || temp > 0.005) {
#ifdef	ENGLISH
		fomen("Actual Last Year Totals Don't Balance");
#else
		fomen("Totaux de l'actuel de l'annee passee ne balancent pas");
#endif
		get() ;
		return(ERROR) ;
	}

	if(!SW2) return(NOERROR) ;

	/* Check-3 */
	temp = bud_cur_yr - s1_sth.s1_cur_yr ;
	if( temp < -0.005 || temp > 0.005) {
#ifdef	ENGLISH
		fomen("Budget Current Year Totals Don't Balance");
#else
		fomen("Totaux du budget de l'annee courante ne balancent pas");
#endif
		get() ;
		return(ERROR) ;
	}
	/* Check-4 */
	temp = bud_pre_yr - s1_sth.s1_pre_yr ;
	if( temp < -0.005 || temp > 0.005) {
#ifdef	ENGLISH
		fomen("Budget Previous Year Totals Don't Balance");
#else
		fomen("Totaux du budget de l'annee precedente ne balancent pas");
#endif
		get() ;
		return(ERROR) ;
	}
	return(NOERROR) ;
}	/* CheckTotals() */
/*-----------------------------------------------------------------------*/
/* Write record in data base */
RiteRecord(md)
int	md ;
{
	int	err;

	err = put_gl(&gl_rec,md,e_mesg);
	if(err != NOERROR){
#ifdef ENGLISH
		DispError("ERROR in Saving Records"); 
#else
		DispError("ERREUR en conservant les fiches");
#endif
		DispError(e_mesg) ;
		roll_back(e_mesg);
		MoveHighs() ;
		return(DBH_ERR);
	}

	/* Turn ON the Gl Master present flag in Parameter file */

	if(pa_rec.pa_glmast[0] != YES) {
		err = get_param(&pa_rec, UPDATE, 1, e_mesg) ;
		if(err < 0) {
#ifdef ENGLISH
			DispError("ERROR in Saving Records"); 
#else
			DispError("ERREUR en conservant les fiches");
#endif
			DispError(e_mesg) ;
			roll_back(e_mesg);
			MoveHighs() ;
			return(DBH_ERR) ;
		}
		pa_rec.pa_glmast[0] = YES ;
		err = put_param(&pa_rec,UPDATE,1,e_mesg);
		if(err < 0){
#ifdef ENGLISH
			DispError("ERROR in Saving Records"); 
#else
			DispError("ERREUR en conservant les fiches");
#endif
			DispError(e_mesg) ;
			roll_back(e_mesg);
			MoveHighs() ;
			return(DBH_ERR);
		}
	}

	err = rite_audit((char*)&s1_sth, GLMAST, md, (char*)&gl_rec, 
						(char*)&pre_rec, e_mesg);

	if(err != NOERROR){
#ifdef ENGLISH
		DispError("ERROR in Saving Records"); 
#else
		DispError("ERREUR en conservant les fiches");
#endif
		DispError(e_mesg) ;
		roll_back(e_mesg);
		MoveHighs() ;
		return(DBH_ERR);
	}

	if(pa_rec.pa_dist_gst[0] == YES) {
		if((err = WriteGSTRecord(md))<0) {
#ifdef ENGLISH
			DispError("ERROR in Saving Records"); 
#else
			DispError("ERREUR en conservant les fiches");
#endif
			DispError(e_mesg) ;
			roll_back(e_mesg);
			MoveHighs() ;
			return(DBH_ERR);
		}
		if(err == EXIT_RTN) {
			roll_back(e_mesg);
			return(NOERROR);
		}
	}

	if(commit(e_mesg) < 0) {
#ifdef ENGLISH
		DispError("ERROR in Saving Records"); 
#else
		DispError("ERREUR en conservant les fiches");
#endif
		DispError(e_mesg) ;
		MoveHighs() ;
		return(DBH_ERR);
	}

	return(NOERROR);
}	/* RiteRecord() */
/*-----------------------------------------------------------------------*/ 
WriteGSTRecord(md) 
int	md;
{
	int err;

	if((md == UPDATE && strcmp(s1_sth.s1_gst_accno,"\0")==0) ||
	   (md == ADD && strcmp(s1_sth.s1_gst_accno,"\0")==0) ||
	   (md == ADD && strcmp(s1_sth.s1_gst_accno," ")==0)){
		return(NOERROR);
	}

	gst_rec.fund = s1_sth.s1_fund_cd;
	STRCPY(gst_rec.accno, s1_sth.s1_acnt_no);
	
	err = get_gstacct(&gst_rec,UPDATE,1,e_mesg);
	if(err < 0) {
		if(err != UNDEF) {
			return(err);
		}
	}

	if(md == P_DEL) {	/* if deleteing record */
		if(err == NOERROR) { /* if link exists */
			err = put_gstacct(&gst_rec,P_DEL,e_mesg);
			if(err != NOERROR) {
				return(err);
			}
		}
		else {	   /* check to see if accounts linked to this account */
			gst_rec.fund = s1_sth.s1_fund_cd;
			STRCPY(gst_rec.gst_accno, s1_sth.s1_acnt_no);
			gst_rec.accno[0] = '\0';
	
			err = get_n_gstacct(&gst_rec,UPDATE,0,FORWARD,e_mesg);
			if(err < 0) {
				if(err != EFL) {
					return(err);
				}
				else	return(NOERROR);
			}
			/* if no accounts links to this accounts */
			if(strcmp(gst_rec.gst_accno,s1_sth.s1_acnt_no)!=0) {
				return(NOERROR);
			}
			else {
#ifdef ENGLISH
				DispError("Can not delete because other accounts are linked to it");
#else
				DispError("Ne peut eliminer parce que d'autres comptes sont relies a celui-ci");
#endif
				return(EXIT_RTN);
			}
		}
	}
	else {
		if(md == UPDATE && err == NOERROR) {
			scpy((char*)&pre_gst,(char*)&gst_rec,sizeof(GST_dist));
			err = put_gstacct(&gst_rec,P_DEL,e_mesg);
			if(err != NOERROR) {
				return(err);
			}
		}
		/* add new link */
		gst_rec.fund = s1_sth.s1_fund_cd;
		STRCPY(gst_rec.accno, s1_sth.s1_acnt_no);
		STRCPY(gst_rec.gst_accno, s1_sth.s1_gst_accno);
		err = put_gstacct(&gst_rec,ADD,e_mesg);
		if(err != NOERROR) {
			return(err);
		}
	}

	if(md != ADD) {
		err = rite_audit((char*)&s1_sth, GSTDIST,md,(char*)&gst_rec,
			 (char*)&pre_gst,e_mesg);
		if(err < 0) {
			return(err);
		}

	}
	
	return(NOERROR);
}
/*-----------------------------------------------------------------------*/ 
/* Copy the key fields from screen to data record and get the record from
   data base */
BringRecord(md)
int md; /* BROWSE or UPDATE */
{
	gl_rec.funds = s1_sth.s1_fund_cd ;
	STRCPY(gl_rec.accno, s1_sth.s1_acnt_no);
	gl_rec.reccod = s1_sth.s1_rec_cd ;

	return(get_gl(&gl_rec, md, 0, e_mesg));
}
/*-----------------------------------------------------------------------*/ 
/* Make sure GST account exists in the G/L Master File */
CheckGSTAcct(acctno)
char	*acctno;
{
	gl_rec.funds = s1_sth.s1_fund_cd ;
	STRCPY(gl_rec.accno, acctno);
	gl_rec.reccod = s1_sth.s1_rec_cd ;

	return(get_gl(&gl_rec,BROWSE, 0, e_mesg));
}
/*-----------------------------------------------------------------------*/ 
/* Read the next record from data base */
BringNext(direction)
int	direction;
{
	int err;

	/* Check whether file is in seq. read mode */
	if(flg_start(GLMAST) != direction) {
		/* Set the least part of the key to next possible key and
		   set file to to_start.  This action starts the file before
		   next seq read call */
		gl_rec.funds = s1_sth.s1_fund_cd ;
		STRCPY(gl_rec.accno, s1_sth.s1_acnt_no);
		if(direction == FORWARD)
			gl_rec.reccod = s1_sth.s1_rec_cd + 1;
		else
			gl_rec.reccod = s1_sth.s1_rec_cd - 1;

		flg_reset(GLMAST);
	}

	err = get_n_gl(&gl_rec, BROWSE, 0, direction, e_mesg);

#ifndef	ORACLE
	seq_over(GLMAST);
#endif

	if(ERROR == err)return(DBH_ERR) ;
	if(EFL == err) {
#ifdef	ENGLISH
		fomen("No More Records....");
#else
		fomen("Plus de fiches....");
#endif
		get();
		flg_reset(GLMAST) ;
		return(ERROR) ;
	}

	CopyToScreen() ;

	return(NOERROR);
}
/*-----------------------------------------------------------------------*/
/* Copy the data record fields to Scrren1 & Screen 2 records and display
   the 1st scrren */
CopyToScreen()
{
	int	i;
	int	err;

	/* Copy 1st screen fields */
	s1_sth.s1_fund_cd = gl_rec.funds ;
	STRCPY(s1_sth.s1_acnt_no, gl_rec.accno);
	s1_sth.s1_rec_cd = gl_rec.reccod ;

	s1_sth.s1_section = gl_rec.sect ;
/*	s1_sth.s1_admis = gl_rec.admis ; 		  */
	for(i = 0 ; i < NO_KEYS ; i++)
		s1_sth.s1_keys[i] = gl_rec.keys[i] ;

	if(SW1) {	/* Hospital */
		s1_sth.s1_bud_cd = gl_rec.cdbud ;
/*		s1_sth.s1_proj_cd = gl_rec.cdpro ;
		s1_sth.s1_units = gl_rec.cdunit ;          */
	}

	STRCPY(s1_sth.s1_desc, gl_rec.desc) ;
	s1_sth.s1_comm = gl_rec.comdat ;
	s1_sth.s1_ytd = gl_rec.ytd ;
	s1_sth.s1_opbal = gl_rec.opbal ;
	s1_sth.s1_cur_yr = gl_rec.budcur ;
	s1_sth.s1_pre_yr = gl_rec.budpre ;

	s1_sth.s1_lst_yr = 0.0 ;


	if(pa_rec.pa_dist_gst[0] == YES)  {
		gst_rec.fund = gl_rec.funds;
		STRCPY(gst_rec.accno,gl_rec.accno);
		err = get_gstacct(&gst_rec,BROWSE,1,e_mesg);
		if(err < 0) {
			if(err == UNDEF || err == EFL) {
				s1_sth.s1_gst_accno[0] = LV_CHAR;	
			}
			else {
				DispError(e_mesg);
				return(err);
			}
		}
		else {
			if(s1_sth.s1_rec_cd == 99) {
				STRCPY(s1_sth.s1_gst_accno,gst_rec.gst_accno);
			} 
			else {
				s1_sth.s1_gst_accno[0] = LV_CHAR;	
			}
		}
	}
	/* Copy 2nd screen fileds */
	for(i = 0 ; i < pa_rec.pa_no_periods && i < NO_PERIODS ; i++) {
		s2_sth.s2_periods[i][0] = gl_rec.currel[i] ;
		s2_sth.s2_periods[i][1] = gl_rec.prerel[i] ;
		s2_sth.s2_periods[i][2] = gl_rec.curbud[i] ;
		s2_sth.s2_periods[i][3] = gl_rec.prebud[i] ;

		s1_sth.s1_lst_yr += gl_rec.prerel[i] ;
	}
	for( ; i < NO_PERIODS ; i++) {
		s2_sth.s2_periods[i][0] = HV_DOUBLE ;
		s2_sth.s2_periods[i][1] = HV_DOUBLE ;
		s2_sth.s2_periods[i][2] = HV_DOUBLE ;
		s2_sth.s2_periods[i][3] = HV_DOUBLE ;
	}

	MovePrompts();

	/* Display 1st Screen */
	sr.nextfld = KEY_START ;
	sr.endfld = END_FLD - 200;
	fomwr((char*)&s1_sth);
	return(NOERROR) ; 
}
/*-----------------------------------------------------------------------*/
/* Copy the Scrren1 & Screen 2 fileds to data record */
CopyToRecord(md)
int md;
{
	int	i;

	/* Save the gl_rec in pre_rec to write audit records for changed
	   fields */
	if(md != ADD)
		scpy((char*)&pre_rec, (char*)&gl_rec, sizeof(Gl_rec)) ;

	/* Copy form 1st screen */
	gl_rec.funds = s1_sth.s1_fund_cd ;
	STRCPY(gl_rec.accno, s1_sth.s1_acnt_no);
	gl_rec.reccod = s1_sth.s1_rec_cd ;

	gl_rec.sect = s1_sth.s1_section ;
/*	gl_rec.admis = s1_sth.s1_admis ;			*/
	gl_rec.admis = 0 ;
	for(i = 0 ; i < NO_KEYS ; i++)
		gl_rec.keys[i] = s1_sth.s1_keys[i] ;

	if(SW1) {	/* Hospital */
		gl_rec.cdbud = s1_sth.s1_bud_cd ;
/*		gl_rec.cdpro = s1_sth.s1_proj_cd ;
		gl_rec.cdunit = s1_sth.s1_units ;		*/
		gl_rec.cdpro = 0 ;
		gl_rec.cdunit = 0 ;
	}
	else if(md == ADD) {
		gl_rec.cdbud = 0 ;
		gl_rec.cdpro = 0 ;
		gl_rec.cdunit = 0 ;
	}

	STRCPY(gl_rec.desc, s1_sth.s1_desc) ;
	gl_rec.comdat = s1_sth.s1_comm ;
	gl_rec.ytd = s1_sth.s1_ytd ;
	gl_rec.opbal = s1_sth.s1_opbal ;
	gl_rec.budcur = s1_sth.s1_cur_yr ;
	gl_rec.budpre = s1_sth.s1_pre_yr ;

	/* Copy from 2nd screen */
	for(i = 0 ; i < pa_rec.pa_no_periods && i < NO_PERIODS ; i++) {
		gl_rec.currel[i] = s2_sth.s2_periods[i][0] ;
		gl_rec.prerel[i] = s2_sth.s2_periods[i][1] ;
		gl_rec.curbud[i] = s2_sth.s2_periods[i][2] ;
		gl_rec.prebud[i] = s2_sth.s2_periods[i][3] ;

		/***
		if(md == ADD) gl_rec.budrep[i] = 0.0 ;
		***/
	}
	for( ; i < NO_PERIODS ; i++) {
		gl_rec.currel[i] = 0.0 ;
		gl_rec.prerel[i] = 0.0 ;
		gl_rec.curbud[i] = 0.0 ;
		gl_rec.prebud[i] = 0.0 ;
		/**
		gl_rec.budrep[i] = 0.0 ;
		***/
	}

	if(md == ADD) {
		gl_rec.grad = 0.0;
		gl_rec.curdb = 0.0;
		gl_rec.curcr = 0.0;
		gl_rec.nextdb = 0.0;
		gl_rec.nextcr = 0.0;
	}
}
/*------------------------------------------------------------------------*/
/* Initialize 1st screen data fields with Low Values */
MoveLows()
{
	int	i;

	s1_sth.s1_section = LV_SHORT ;
/*	s1_sth.s1_admis = LV_SHORT ;	*/
	s1_sth.s1_admis = HV_SHORT ;

	s1_sth.s1_desc[0] = LV_CHAR ;

	/* Read Keys 1 to 3 & 7 to 10 always */
	for(i = 0 ; i < 3 ; i++)
		s1_sth.s1_keys[i] = LV_LONG ;
	for(i = 6 ; i < 10 ; i++)
		s1_sth.s1_keys[i] = LV_LONG ;

	/* Don't read keys 4 to 6 , 11 & 12 when SW4 (No Key) is ON */
	if(SW4) {
		for(i = 3 ; i < 6 ; i++)
			s1_sth.s1_keys[i] = 0 ;

		s1_sth.s1_keys[10] = 0 ;
		s1_sth.s1_keys[11] = 0 ;
	}
	else {
		for(i = 3 ; i < 6 ; i++)
			s1_sth.s1_keys[i] = LV_LONG ;

		s1_sth.s1_keys[10] = LV_LONG ;
		s1_sth.s1_keys[11] = LV_LONG ;
	}
	/* Read Budget Cd, Proj. Cd & Unit measure only when SW1 (Hospital)
	   is ON */
	if(SW1) {
		s1_sth.s1_proj_cd = HV_SHORT ;
		s1_sth.s1_units = HV_SHORT ;
		/* if SW6 (No Budget) is OFF don't read Budget Code */
		if(SW6)
			s1_sth.s1_bud_cd = LV_SHORT ;
		else
			s1_sth.s1_bud_cd = 0 ;
/*
		s1_sth.s1_proj_cd = LV_SHORT ;

		 Don't read Unit measure if record code is not
		   97 or 98 
		if(s1_sth.s1_rec_cd < 97 || s1_sth.s1_rec_cd > 98)
			s1_sth.s1_units = 0;
		else
			s1_sth.s1_units = LV_SHORT ;       */
	}
	else {
		s1_sth.s1_bud_cd = HV_SHORT ;
		s1_sth.s1_proj_cd = HV_SHORT ;
		s1_sth.s1_units = HV_SHORT ;
	}

	/* If SW5 (No Mod) is ON don't read Commitments to Date, Year to date,
	   Op. Bal, Budget Pre. Year, Budget Cur. Year & Actual Last Year */
	if(SW5) {
		s1_sth.s1_comm = 0 ;
		s1_sth.s1_ytd = 0 ;
		s1_sth.s1_opbal = 0 ;
		s1_sth.s1_cur_yr = 0 ;
		s1_sth.s1_pre_yr = 0 ;
		s1_sth.s1_lst_yr = 0 ;
	}
	else {
		s1_sth.s1_comm = LV_DOUBLE ;
		s1_sth.s1_ytd = LV_DOUBLE ;
		s1_sth.s1_opbal = LV_DOUBLE ;

		/* if SW6 (No Budget) is OFF don't read Budget Pre. Year &
		   Budget Cur. Year */
		if(SW6) {
			s1_sth.s1_cur_yr = LV_DOUBLE ;
			s1_sth.s1_pre_yr = LV_DOUBLE ;
		}
		else {
			s1_sth.s1_cur_yr = 0 ;
			s1_sth.s1_pre_yr = 0 ;
		}
		s1_sth.s1_lst_yr = LV_DOUBLE ;
	}
	if(pa_rec.pa_dist_gst[0] == YES) {
		s1_sth.s1_gst_accno[0] = LV_CHAR;
	}

	MovePrompts();
}	/* MoveLows() */
/*------------------------------------------------------------------------*/
/* Move the prompts to variable prompt fields */
MovePrompts()
{
	if(SW7) {
#ifdef ENGLISH
		STRCPY(s1_sth.s1_adms_pr, "Report Code  :") ;
		STRCPY(s1_sth.s1_k1_prmpt, "Sequence:") ;
		STRCPY(s1_sth.s1_k2_prmpt, "Dept    :") ;
		STRCPY(s1_sth.s1_k3_prmpt, "ReGroup :") ;
		STRCPY(s1_sth.s1_k4_prmpt, "Succ    :") ;
		STRCPY(s1_sth.s1_k5_prmpt, "Reg Succ:") ;
		STRCPY(s1_sth.s1_k6_prmpt, "Reg Dept:") ;
#else
		STRCPY(s1_sth.s1_adms_pr, "Code rapport:") ;
		STRCPY(s1_sth.s1_k1_prmpt, "Sequence:") ;
		STRCPY(s1_sth.s1_k2_prmpt, "Dept    :") ;
		STRCPY(s1_sth.s1_k3_prmpt, "ReGroup :") ;
		STRCPY(s1_sth.s1_k4_prmpt, "Succ    :") ;
		STRCPY(s1_sth.s1_k5_prmpt, "Reg succ:") ;
		STRCPY(s1_sth.s1_k6_prmpt, "Reg dept:") ;
#endif
	}
	else {
		s1_sth.s1_adms_pr[0] = HV_CHAR ;
#ifdef ENGLISH
/*		STRCPY(s1_sth.s1_adms_pr, "Admissibility:") ;  */
		STRCPY(s1_sth.s1_k1_prmpt, "Key-01  :") ;
		STRCPY(s1_sth.s1_k2_prmpt, "Key-02  :") ;
		STRCPY(s1_sth.s1_k3_prmpt, "Key-03  :") ;
		STRCPY(s1_sth.s1_k4_prmpt, "Key-04  :") ;
		STRCPY(s1_sth.s1_k5_prmpt, "Key-05  :") ;
		STRCPY(s1_sth.s1_k6_prmpt, "Key-06  :") ;
#else
/*		STRCPY(s1_sth.s1_adms_pr, "Admissibilite:") ;  */
		STRCPY(s1_sth.s1_k1_prmpt, "Cle-01  :") ;
		STRCPY(s1_sth.s1_k2_prmpt, "Cle-02  :") ;
		STRCPY(s1_sth.s1_k3_prmpt, "Cle-03  :") ;
		STRCPY(s1_sth.s1_k4_prmpt, "Cle-04  :") ;
		STRCPY(s1_sth.s1_k5_prmpt, "Cle-05  :") ;
		STRCPY(s1_sth.s1_k6_prmpt, "Cle-06  :") ;
#endif
	}
}	/* MovePrompts() */
/*------------------------------------------------------------------------*/
/* Initialize 1st screen data fields with High values and display the screen */
MoveHighs()
{
	int	i;

	s1_sth.s1_section = HV_SHORT ;
	s1_sth.s1_admis = HV_SHORT ;

	s1_sth.s1_desc[0] = HV_CHAR ;

	for(i = 0 ; i < 12 ; i++)
		s1_sth.s1_keys[i] = HV_LONG ;

	s1_sth.s1_bud_cd = HV_SHORT ;
	s1_sth.s1_proj_cd = HV_SHORT ;
	s1_sth.s1_units = HV_SHORT ;

	s1_sth.s1_comm = HV_DOUBLE ;
	s1_sth.s1_ytd = HV_DOUBLE ;
	s1_sth.s1_opbal = HV_DOUBLE ;
	s1_sth.s1_cur_yr = HV_DOUBLE ;
	s1_sth.s1_pre_yr = HV_DOUBLE ;
	s1_sth.s1_lst_yr = HV_DOUBLE ;

	/* Move High values to dynamic prompts */
	s1_sth.s1_adms_pr[0]  = HV_CHAR ;
	s1_sth.s1_k1_prmpt[0] = HV_CHAR ;
	s1_sth.s1_k2_prmpt[0] = HV_CHAR ;
	s1_sth.s1_k3_prmpt[0] = HV_CHAR ;
	s1_sth.s1_k4_prmpt[0] = HV_CHAR ;
	s1_sth.s1_k5_prmpt[0] = HV_CHAR ;
	s1_sth.s1_k6_prmpt[0] = HV_CHAR ;

	s1_sth.s1_gst_accno[0] = HV_CHAR;

	sr.nextfld = ST_FLD ;
	sr.endfld = END_FLD - 200 ;
	fomwr((char*)&s1_sth);
	ret(err_chk(&sr));

	return(NOERROR);
}	/* MoveHighs() */
/*-------------------------------------------------------------------------*/
static
DispError(s)    /* show ERROR and wait */
char *s;
{
	strcpy(Mesg,s);
	ShowMesg();
#ifdef	ENGLISH
	fomen("Press any key to continue");
#else
	fomen("Appuyer sur une touche pour continuer");
#endif
	get();
	Mesg[0] = HV_CHAR;
	ShowMesg();
	return(ERROR);
}
/*------------------------------------------------------------------------*/
ShowMesg()  /* shows or clears message field */
{
	sr.nextfld = END_FLD - 100;
	fomwf(CurrentScreen) ;
}
fund_default()
{
	fomca1(FUND_FLD,19,2);
	fomca1(RECCD_FLD,19,2);
	s1_sth.s1_fund_cd = 1;
	s1_sth.s1_rec_cd = 99;
	sr.nextfld = FUND_FLD;
	fomwf(CurrentScreen);
	sr.nextfld = RECCD_FLD;
	fomwf(CurrentScreen);
	sr.nextfld = KEY_START;
	sr.endfld = KEY_END;
	fomud((char*)&s1_sth);
}
/*-------------------- E n d   O f   P r o g r a m ---------------------*/

