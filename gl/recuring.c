/******************************************************************************
		Sourcename    : recuring.c
		System        : Budgetary Financial system.
		Module        : Recurring Entries
		Created on    : 89-07-23
		Created  By   : K HARISH.
		Cobol sources : 
*******************************************************************************

About the program:
	It allows storing of recurring transactions for periodical review by
	the system. Each session writes a recurring transaction header record
	and a number of recurring transaction items. The program does not 
	post transactions to the GL master. The records thus created are 
	read by the end-of-day/end-of-month/end-of-year processes for posting
	the recurring entries. The system allows deletion of transaction items
	at any item. If there are no recurring transaction items under a 
	header, the header record is automatically deleted.


HISTORY:
 Date           Programmer     Description of modification
____/__/__      __________     ___________________________
1990/11/20	peter ralph	Add delete record option
				Show current date for date posted
				display message "Enter RETURN to terminate Edit"

1991/01/02	C.Leadbeater	Default start period to current period.
1991/01/07	F.Tao 		Fixed Change Option, reset RETVAL to 0 while
				item is undefined.  
				Use global pre-defined variable for screen 
				variable in both French and English.

1991/02/06	P. Ralph	Default record code to 99
******************************************************************************/
#include <stdio.h>

#define MAIN
#define MAINFL	RECHDR

#include <bfs_defs.h>
#include <bfs_recs.h>
#include <cfomstrc.h>

#define SYSTEM		"GENERAL LEDGER"
#define MOD_DATE	"23-JAN-90"
#define SCREEN_NAME	"recuring"
#define ITEMSPERPAGE 	10
#define EXIT		12
#define ALLOC_ERROR	13
#define DEBITS		14
#define CREDITS		15
#define RANDOM  	18
#define SEQUENTIAL	19
#define PATH_FILE_SIZE	50
#define DELTA_AMT	0.0001
#define LOW 		-1
#define HIGH 		 1
#define HL_CHAR(VAL)	VAL==HIGH ? HV_CHAR : LV_CHAR
#define ESC_F		sr.retcode==RET_USER_ESC && \
			(sr.escchar[0]=='F'||sr.escchar[0]=='f')
#define	ESC_H		sr.retcode==RET_USER_ESC && \
			(sr.escchar[0]!='H'||sr.escchar[0]=='h')

#ifdef ENGLISH
#define ADDREC 	'A'
#define CHANGE 	'C'
#define DELETE	'D'
#define NEXT	'N'
#define PREV	'P'
#define INQUIRE	'I'
#define EXITOPT	'E'

#define EDIT	'E'
#define CANCEL	'C'
#define REVIVE	'R'
#define YES	'Y'
#define NO	'N'

#define DAILY		'D'
#define WEEKLY		'W'
#define BIWEEKLY	'B'
#define MONTHLY		'M'
#define QUARTERLY	'Q'
#define HALFYEARLY	'H'
#define YEARLY		'Y'
#else	/* French */
#define ADDREC 	'R'
#define CHANGE 	'C'
#define DELETE	'E'
#define NEXT	'S'
#define PREV	'P'
#define INQUIRE	'I'
#define EXITOPT	'F'

#define EDIT	'M'
#define CANCEL	'A'
#define REVIVE	'V'
#define YES	'O'
#define NO	'N'

#define DAILY		'Q'
#define WEEKLY		'H'
#define BIWEEKLY	'B'
#define MONTHLY		'M'
#define QUARTERLY	'T'
#define HALFYEARLY	'S'
#define YEARLY		'A'
#endif

#define	FUND_FLD	500

typedef struct scr_item{	/* one line of fields for each entry item */
	short	s_sno;		/* transaction item serial no */
	char	s_accno[19];	/* account number */
	double	s_amount;	/* amount 99F999F999.99 */
	char	s_status[4];	/* status Active/Deleted */
} Scr_item;

/* recur.sth - header for C structure generated by PROFOM EDITOR */
struct	re_struct	{
	char	s_progname[11];	/* Program name field 100 */
	char	s_scrhdg[20];	/* Screen Heading field 200 */
	long	s_rundt;	/* Date field  for display only 300 */

	char	s_fn[2];	/* Function field 400 */
	short	s_fund;		/* fund code field 500 */
	short	s_sno;		/* Serial no. for Xaction field 600 */
	short	s_fld_no;	/* To read field# for editing field 700 */

	short	s_reccod;	/* Record code field 900 */
	char	s_tr_code[2];	/* Transaction code field 1000 */
	char	s_descr[25];	/* Description field 1100 */
	long	s_lastdate;	/* Last posted date field 1125 */

	char	s_seperator[2];	/* To hide a demarcating line 1200 */
	char	s_hdg1mask[2];	/* Heading mask, dummy field 1300 */
	char	s_hdg2mask[2];	/* Heading mask, dummy field 1400 */
	short	s_page;		/* Page # of items field 1500 */
	Scr_item s_entries[ITEMSPERPAGE]; /* fields 1600-5500 array */

	char	s_mesg[78];	/* Message field 5600*/
	char	s_resp[2];	/* Response field 5700 */
};

typedef struct{		/* structure to record current page & line of entry */
	short	page;	
	short	line;
}	Counter;

			/* link list node for holding one page of entries */
typedef	struct pgofitems{
	struct pgofitems *prevptr;	/* pointer to previous entry */
	int	lines_entered;		/* no of lines entered */
	Scr_item fields[ITEMSPERPAGE];	/* array of lines per page */
	struct pgofitems *nextptr;	/* pointer to next entry */
}	Page;

static Page	*headptr,*tempptr,*tailptr;	/* to maintain list */
static Counter	current; /* For current line & page of journal item entry */
static struct re_struct	s_rec;		/* screen record */
static Pa_rec		pa_rec;		/* Parameter record */
static Re_hdr 	re_hdr,ore_hdr;		/* recurring Xaction header rec */
static Re_item 	re_item,ore_item;	/* recurring Xsaction item rec */
struct stat_rec 	sr;		/* profom status record */
static Ctl_rec		ctl_rec;	/* control file record */

long	date_plus(), days();
static short lastitemnumber;	/* keeps track of the last item number */
static int totalitemsactive;	/* total items added in any add session */
static int retval;	/* Global variable to store function values */
static int list;	/* Flag to indicate complete or partial listing */ 
static char e_mesg[80]; /* to store error messages */

/* Initialize profom fields, call entry procedures */
main( argc, argv )
int argc;
char *argv[];
{
	strncpy( SYS_NAME, SYSTEM, 50 ); 	/* Module name */
	strncpy( CHNG_DATE, MOD_DATE, 10 );	/* Last date of change */
	proc_switch( argc,argv,MAINFL ); 	/* process the switches */

	if( Initialize(terminal) <0 )	/* initialize profom and screen */
		exit(0);
	retval = Process();

	CleanExit();			/* Wind up the show */
}

static
CleanExit()/* clear and exit the screen , close files & exit program */
{
	fomcs();
	fomrt();
	close_dbh();
	free_audit();
	exit( retval );
}
static
Initialize( terminal )	/* initialize profom and screen */
char *terminal;
{
	if( InitProfom(terminal)<0 ){	/* initialize profom */
		fomcs();
		fomrt();
		return( -1 );
	}
	if( InitScreen()<0 ){		/* initialize screen */
		fomcs();
		fomrt();
		return(-1);
	}
	fomcf(1,1);	/* Enable Snap screen option */
	return(0);
}	
static
InitProfom(terminal)	/* initialize profom */
char *terminal;
{
	STRCPY( sr.termnm, terminal );
	fomin( &sr );		/* initialize the screen */
	ret( err_chk(&sr) );	/* if profom error return */
	return(0);
}
static
InitScreen()		/* initialize the screen */
{
	/* initialize the profom screen variables */
	STRCPY( sr.scrnam, NFM_PATH );
	strcat( sr.scrnam, SCREEN_NAME );

	/* initialize the fields of the profom screen */
	if( FillScrHdg()<0 ) 				return(-1);

	if( FillKeyFields( LOW )<0 ) 			return(-1);

	if( FillFieldNum( HIGH )<0 ) 			return(-1);
	if( FillHeaderFields( HIGH )<0 ) 		return(-1);

	if( FillSeperatorLine(HIGH)<0 ) 		return(-1);
	if( FillLineHeading( HIGH )<0 ) 		return(-1);
	if( FillItemLines( HIGH,1,ITEMSPERPAGE )<0 )	return(-1);

	if( FillMsgRespFields( HIGH )<0 ) 		return(-1);

	if( WriteFields(1,0)<0 )			return(-1);

	return(0);
}
/* Fill the screen heading fields, the program name and the date */
static
FillScrHdg()
{
	STRCPY( s_rec.s_progname, PROG_NAME );
#ifdef ENGLISH
	STRCPY( s_rec.s_scrhdg," RECURRING ENTRIES " );
#else
	STRCPY( s_rec.s_scrhdg,"ENTREES REPETITIVES" );
#endif
	s_rec.s_rundt = get_date();
	return(0);
}
/* Fill the keyfields with high or low values */
static
FillKeyFields( value )
short value;
{
	s_rec.s_fund   = value * HV_SHORT;
	s_rec.s_sno     = value * HV_SHORT;

	return(0);
}
/* Fill the demarkating line field with high/low values */
static
FillSeperatorLine( value )
short value;
{
	s_rec.s_seperator[0] = HL_CHAR(value);
	return(0);
}
/* Fill the field# field with high/low values */
static
FillFieldNum( value )
short value;
{
	s_rec.s_fld_no = value * HV_SHORT;

	return(0);
}
/* Fill the transaction header part with high/low values */
static
FillHeaderFields( value )
short value;
{
	s_rec.s_reccod 		= value * HV_SHORT;
	s_rec.s_tr_code[0]	= HL_CHAR( value );
	s_rec.s_descr[0]	= HL_CHAR( value );
	s_rec.s_lastdate	= value * HV_LONG;

	return(0);
}
/* Fill the message and response fields with high or low values */
static
FillMsgRespFields( value )
short value;
{
	s_rec.s_mesg[0] = HL_CHAR( value );
	s_rec.s_resp[0] = HL_CHAR( value );

	return(0);
}
/* Fill the Xaction item heading line with high/low values */
static
FillLineHeading(val)
int val;
{
	if( val==HIGH ){
		s_rec.s_hdg1mask[0] = HV_CHAR;
		s_rec.s_hdg2mask[0] = HV_CHAR;
	}
	else{
		s_rec.s_hdg1mask[0] = ' ';
	/*	if( s_rec.s_fn[0]==ADDREC||s_rec.s_fn[0]==CHANGE )	*/
			/* Show only while adding or changing rec */
			STRCPY(s_rec.s_hdg2mask,"   ");
/*		else
			s_rec.s_hdg2mask[0] = HV_CHAR;
*/	}
	return(0);
}
/* Fill the Xaction item array with high or low values */
static
FillItemLines( value,firstline,lastline )
int value;
short firstline, lastline;
{
	short i;

	s_rec.s_page = (short)value * HV_SHORT;
	for( i=firstline-1; i<lastline; i++ ){
		s_rec.s_entries[i].s_sno = value * HV_SHORT;
		s_rec.s_entries[i].s_accno[0] = HL_CHAR(value);
		s_rec.s_entries[i].s_amount = value * HV_DOUBLE;
		s_rec.s_entries[i].s_status[0] = HL_CHAR(value);
	}
	return(0);
}
/* Accept user's option and call the corresponding routine in a loop */
static
Process()
{
	s_rec.s_fund = 1;	/* initializing the key fields */
	s_rec.s_sno = 0;	/* useful if N(ext) option is selected first */
	if( get_param( &pa_rec, BROWSE, 1, e_mesg ) != 1 ){
		fomen(e_mesg); get(0);
		return(-1);
	}
	for( ; ; ){
		if( ReadFunction()<0 ) return(-1);
		switch( s_rec.s_fn[0] ){
			case ADDREC:	/* add a transaction list */
				CHKACC(retval,ADD,e_mesg);
				if( AddRecords()<0 ) return(-1);
				break;
			case CHANGE:	/* change a transaction list */
				CHKACC(retval,UPDATE,e_mesg);
				if( Inquire(RANDOM,0,UPDATE)<0 ) 
					return(-1);
				break;
			case DELETE:    /* delete a transaction list */
				CHKACC(retval,UPDATE,e_mesg);
				if( DeleteRecords()<0 ) return(-1);
				break;
			case NEXT:	/* show next Xaction list in sequence */
				CHKACC(retval,BROWSE,e_mesg);
				if( Inquire(SEQUENTIAL,FORWARD,BROWSE)<0 ) 
					return(-1);
				break;
			case PREV:	/* show prev Xaction list in sequence */
				CHKACC(retval,BROWSE,e_mesg);
				if( Inquire(SEQUENTIAL,BACKWARD,BROWSE)<0 ) 
					return(-1);
				break;
			case INQUIRE:	/* show selected Xaction list */
				CHKACC(retval,BROWSE,e_mesg);
				if( Inquire(RANDOM,0,BROWSE)<0 ) 
					return(-1);
				break;
			case EXITOPT:	/* exit */
				return(0);
			default:
				break;
		}
		if( retval<0 ){
			fomen(e_mesg);
			get();
		}
		if( retval==DBH_ERR )
			return(retval);
	}
}
static
ReadFunction()	/* Display options at the bottom and read entry */
{
#ifdef ENGLISH
	fomer("A(dd), C(hange), D(el), N(ext), P(rev), I(nquire), E(xit)");
#else
	fomer("R(ajouter), C(hanger), E(lim), S(uivant), P(recedent), I(nterroger), F(in)");
#endif
	sr.nextfld = 400;	/* Fn field number */
	fomrf( (char *)&s_rec );
	ret( err_chk(&sr) );
	return(0);
}
/* Add a complete Xaction, with 1 header & a no. of item records */
static
AddRecords()
{

	if( ClearScreen()<0 )	return(-1);
	if( (retval=ReadKeyFields())<0 )	return(retval);
	if(retval==EXIT){
		if(ClearScreen()<0)	return(-1);
		return(retval);
	}

	/* s_rec.s_lastdate = date_plus( get_date(), -1 ); */
	s_rec.s_lastdate = get_date(); 
	fomca1( 1125, 19, 2 );
	sr.nextfld = 1125;
	sr.endfld = 1125;
	fomud( (char *)&s_rec );

	/* put default value for account code */
	fomca1(900, 19, 2 );
	s_rec.s_reccod = 99;
	sr.nextfld = 900;
	fomwf((char *)&s_rec);
	
	if( FillHeaderFields(LOW)<0 ) return(-1);
	if( (retval=ReadFields(900,1125))<0 )
		return(retval);/* read header fields */
	if(retval==EXIT){
		if(ClearScreen()<0)	return(-1);
		return(retval);
	}

	fomca1( 1125, 19, 0 );
	if( (retval=ConfirmHeader())<0 ){
		if(ClearScreen()<0)	return(-1);
		return(retval);
	}
	if(retval==EXIT){
		if(ClearScreen()<0)	return(-1);
		return(retval);
	}
	if( FillSeperatorLine(LOW)<0 ) return(-1);
	if( FillLineHeading(LOW)<0 )	return(-1);
	if( WriteFields(1200,1400)<0 )	return(-1);
	if( (retval=ReadItemFields())<0 )	return(retval);
	if( retval==EXIT ){
		if(ClearScreen()<0)	return(-1);
		return(retval);
	}
	for( ; ; ) {
		retval=WriteSession(ADD);
		if(retval==NOERROR) break;
		if(retval==LOCKED) {
			roll_back(e_mesg);
			retval = ConfirmItems(ADD);
			if( retval<0 )	return(retval);
			if( retval==EXIT ){
				if(ClearScreen()<0)	/* Clear the screen */
					return(-1);	
				return(EXIT);
			}
			
			continue;
		}
		if(retval<0) return(retval);
	}	
	return( FreeList() );
}
static
DeleteRecords()	
{
	int retval;

	retval = GetHeaderKey(UPDATE);	/* Read the key values */
	if(retval==UNDEF)
		return(0);
	if(retval==EXIT || retval==ERROR){
		if(ClearScreen()<0)	return(-1);
		return(retval);
	}
	if( retval<0 ){
		fomen(e_mesg);get();
		return(-1);
	}
	retval = ShowHeaderFields();	/* Display header information */
	if( retval<0 || retval==EXIT ) return(retval);

	retval = ShowItems();	/* Display first pageful of items */
	if( retval<0 || retval==EXIT ) return(retval);

	for( ; ; ) {
#ifdef ENGLISH
		STRCPY(s_rec.s_mesg,"Y(es), C(ancel)");
#else
		STRCPY(s_rec.s_mesg,"O(ui), A(nnuler)");
#endif
		sr.nextfld = 5600;
		fomwf((char*)&s_rec);

		s_rec.s_mesg[0]=LV_CHAR;
		for(;;){
			s_rec.s_resp[0]=LV_CHAR;
			if(ReadFields(5700,5700) < 0) return(-1);
			if (s_rec.s_resp[0] == YES){	
				retval = DeleteItems();

				if(retval==NOERROR) break;
				if(retval==LOCKED) {
					roll_back(e_mesg);
					re_hdr.rh_fund = s_rec.s_fund;
					re_hdr.rh_sno = (short)s_rec.s_sno;
					retval=get_rehdr(&re_hdr,UPDATE,0
								,e_mesg);
					if(retval==LOCKED) continue;
					if(retval<0) {
						fomen(e_mesg); get();
						roll_back(e_mesg);
						return(retval);
					}
					continue ;
				}
				if(retval<0) return(retval);

				ClearScreen();
				break;
			}else if (s_rec.s_resp[0] == CANCEL ) {
			/*
#ifdef	ENGLISH
				fomen("Record Not Deleted, Press a Key");
#else
				fomen("La fiche n'est pas eliminee, appuyer sur une touche");
#endif
				get();
			*/
				if(FillLineHeading(HIGH)<0 ) return(-1);
				if(FillItemLines(HIGH,1,ITEMSPERPAGE)<0)
					return(-1);
				if(FillMsgRespFields(HIGH)<0 ) return(-1);
				if(WriteFields(500,5700) <0) return(-1);
				retval = NOERROR;
				break;
			}else
#ifdef ENGLISH
				fomer("Invalid Option.");
#else
				fomer("Option Invalide");
#endif
		}
		if(retval==NOERROR) break;
	}
	return(retval);
}
/*-------------------------------------------------------------------------*/
static
DeleteItems()	/* Write header, list of items and update GL master */
{
	int i;

	/* to write the items in gltran file */
	for( tempptr=headptr; tempptr!=NULL; tempptr=tempptr->nextptr){	
		for( i=1; i<=ITEMSPERPAGE; i++){ /* for each line on page */
			if(tempptr->fields[i-1].s_amount==HV_DOUBLE)
				break;
			if((retval=WriteItem(i,P_DEL))<0 ){
				roll_back(e_mesg) ;
				return(retval);
			}
		}
		if(tempptr->fields[i-1].s_amount==HV_DOUBLE)
			break;	/* terminate when High values are found */
	}
	tempptr = headptr;

	if((retval=WriteHeader(P_DEL))<0 ){/* Write the header record file */
		roll_back(e_mesg) ;
		return(retval);
	}

	if (commit(e_mesg) < 0 ){
		fomen(e_mesg) ;
		get() ;
		return(-1);
	}
	return(0);
}

/*------------------------------------------------------------------------*/
static
ReadKeyFields()	/* Display system date, generated serial#, and read period */
{
	int retval;
	fomca1(FUND_FLD,19,2);
	s_rec.s_fund = 1;
	if( WriteFields(FUND_FLD,FUND_FLD)<0 )
		return(-1);
	
	if( FillKeyFields(LOW)<0 )
		return(-1);
	retval = ReadFields( 500, 500 );
	if( retval<0 || retval==EXIT )
		return(retval);
	if( GetNextSerialNo()<0 )
		return(-1);
	if( WriteFields(600,600)<0 )
		return(-1);
	return(0);
}
static
GetNextSerialNo()	/* Generate the next serial no. (part of the key) */
{
	char	terml[4] ;
#ifdef	ORACLE
	long	get_maxsno(), sno ;
#endif

	re_hdr.rh_fund = s_rec.s_fund;

#ifndef	ORACLE
	/* Move highs to serial no, and access previous record in sequence */
	re_hdr.rh_sno = HV_SHORT;
	flg_reset(RECHDR);
	retval = get_n_rehdr( &re_hdr,BROWSE,0,BACKWARD,e_mesg );
	if( retval==ERROR ){
		fomen(e_mesg); get();
		return(-1);
	}
	seq_over(RECHDR);
	if( re_hdr.rh_fund != s_rec.s_fund  || retval==EFL ){
		re_hdr.rh_fund = s_rec.s_fund;
		re_hdr.rh_sno = 1;
	}
	else  /* The new serial# is one greater than that of the record read */
		re_hdr.rh_sno++;
#else
	sno = get_maxsno(RECHDR, (char*)&re_hdr, 0, -1, e_mesg) ;
	if(sno < 0) {
		fomen(e_mesg); get();
		return(-1);
	}
	re_hdr.rh_sno = sno + 1;
#endif
	s_rec.s_sno = re_hdr.rh_sno;
	return(0);
}
static
ReadFields(start,end)	/* read fields whose numbers range from start to end */
int start, end;		/* start and end fields */
{
	int retval;

	sr.nextfld = start;
	sr.endfld = end;
	for( ; ; ){
		fomrd( (char *)&s_rec );
		ret(err_chk(&sr));
		if( sr.retcode==RET_USER_ESC || sr.retcode==RET_VAL_CHK ){
			if( ESC_F ) return(EXIT);
			retval=Validate();
			if( retval<0 || retval==EXIT)	return(retval);
			continue;
		}
		break;
	}
	return(0);
}
static
WriteFields( start,end )/* write fields whose numbers range from start to end */
int start, end;
{
	sr.nextfld = start;
	sr.endfld = end;
	fomwr( (char *)&s_rec );
	ret( err_chk(&sr) );
	return(0);
}
static
ClearScreen()	/* clear the screen except fn field and screen heading */
{
	if(FillKeyFields(LOW)<0 ) return(-1);
	if(FillFieldNum(HIGH)<0 ) return(-1);
	if(FillHeaderFields(HIGH)<0 ) return(-1);
	if(FillSeperatorLine(HIGH)<0 ) return(-1);
	if(FillLineHeading(HIGH)<0 ) return(-1);
	if(FillItemLines(HIGH,1,ITEMSPERPAGE)<0 ) return(-1);
	if(FillMsgRespFields(HIGH)<0 ) return(-1);

	if( WriteFields(500,5700)<0 ) return(-1);
	
	return(0);
}
static
Validate()	/* Validate the values entered by the user */
{
	Gl_rec temp_rec;
	short	reccod;	
	int index;
	double 	amount;

	switch( sr.curfld ){
		case 500:	/* fund code */
			if( sr.retcode==RET_USER_ESC )	break;
			ctl_rec.fund = (short)s_rec.s_fund;
			index = get_ctl( &ctl_rec, BROWSE, 0, e_mesg );
			if( index==ERROR ){
				fomen(e_mesg); get();
				return(-1);
			}
			if( index!=NOERROR ){
				fomer(e_mesg);
				s_rec.s_fund = LV_SHORT;
			}
			break;
		case 700:	/* field # for editing */
			if( sr.fillcode==FIL_OMITTED )	return(EXIT);
			break;
		case 900:	/* record code */
			if( s_rec.s_reccod<97 || s_rec.s_reccod>99  ){
#ifdef ENGLISH
				fomer("Valid codes are 97, 98, 99");
#else
				fomer("Codes valables sont 97, 98, 99");
#endif
				s_rec.s_reccod = LV_SHORT;
			}
			break;
		case 1000:	/* transaction code */
			switch( s_rec.s_tr_code[0] ){
				case DAILY:		/* daily */
				case WEEKLY:		/* weekly */
				case BIWEEKLY:		/* bi-weekly */
				case MONTHLY:		/* monthly */
				case QUARTERLY:		/* quarterly */
				case HALFYEARLY:	/* half-yearly */
				case YEARLY:		/* yearly */
					break;
				default:
#ifdef ENGLISH
					fomer("Valid types: D, W, B, M, Q, H, Y");
#else
					fomer("Genres valables: Q, H, B, M, T, S, A");
#endif
					s_rec.s_tr_code[0] = LV_CHAR;
					break;
			}
			break;
		case 1125:	/* last date of posting: validation disabled */
			if(s_rec.s_lastdate < s_rec.s_rundt ){
#ifdef ENGLISH
				fomer("Not allowed as next posting date");
#else
				fomer("Pas permis comme prochaine date ecrite");
#endif
				s_rec.s_lastdate = LV_LONG;
			} 
			break;
		case 1700:	/* account number fields */ 
		case 2100: 
		case 2500: 
		case 2900: 
		case 3300: 
		case 3700: 
		case 4100: 
		case 4500:
		case 4900:
		case 5300:
			index = (sr.curfld-100)/400-4;
			if( ESC_H ){
			   retval = gl_hlp(s_rec.s_fund,
					s_rec.s_entries[index].s_accno,
					&reccod,
					7, 15 );
			   if( retval<0 )	/* error */
					return( retval );
			   if( retval==0 )	/* nothing selected  */
					redraw(); /* remove hlp window*/
			   else if( retval==1 ){/* selected */
					/* check for reccod compatibility */
				if( s_rec.s_reccod!=reccod ){
				   redraw();
#ifdef ENGLISH
				   fomer("Record code mismatch.Try again");
#else
				   fomer("Disparite de code de fiche. Reessayer");
#endif
				   s_rec.s_entries[index].s_accno[0]=LV_CHAR;
				   sr.nextfld = sr.curfld;
				   break;
				}
				else{
					redraw();
					retval = VerifyAccount(index,&temp_rec);
					if( retval==ERROR )	return(-1);
					if( retval!=NOERROR )
					    s_rec.s_entries[index].s_accno[0]
								=LV_CHAR;
					else
						fomer(temp_rec.desc);
				}
			   }
			}
			else if( sr.retcode==RET_USER_ESC )	
				break;
			else{	/* user entered an account number */
			   if(acnt_chk(s_rec.s_entries[index].s_accno)==ERROR){
#ifdef ENGLISH
				fomer("Invalid Account number");
#else
				fomer("Numero de compte invalide");
#endif
				s_rec.s_entries[index].s_accno[0]=LV_CHAR;
				break;
			   }
			   retval = VerifyAccount(index,&temp_rec); 
			   if( retval==ERROR )	return(-1);
			   if( retval!=NOERROR )
				s_rec.s_entries[index].s_accno[0]=LV_CHAR;
			   else
				fomer(temp_rec.desc);
			}
			break; 
		case 1800:	/* amount fields */
		case 2200:
		case 2600:
		case 3000:
		case 3400:
		case 3800:
		case 4200:
		case 4600:
		case 5000:
		case 5400:
			index = (sr.curfld-200)/400-4;
			amount = s_rec.s_entries[index].s_amount ;
			if( amount <DELTA_AMT && amount>(-DELTA_AMT) ){
#ifdef ENGLISH
				fomer("Amount too small for transaction");
#else
				fomer("Montant trop petit pour transaction");
#endif
				s_rec.s_entries[index].s_amount = LV_DOUBLE;
			}
			break;
	}
	sr.nextfld = sr.curfld;
	return(0);
}
static
VerifyAccount(index,temp_rec) /* Check if a record exists in the GL master */
int index;
Gl_rec *temp_rec;
{
	int ret_val;

	temp_rec->funds = (short)s_rec.s_fund;
	STRCPY( temp_rec->accno,s_rec.s_entries[index].s_accno );
	temp_rec->reccod = (short)s_rec.s_reccod;
	ret_val = get_gl( temp_rec,UPDATE,0,e_mesg );
	if(ret_val!=NOERROR ){
		fomen(e_mesg);
		get();
		return(ret_val);
	}
	return(0);
}
static
ConfirmHeader()	/* Ask if user wants to edit hdr items before going to items */
{
	for( ; ; ){
#ifdef ENGLISH
		if(DisplayMessage( "A(dd items), E(dit), C(ancel)")<0 ) 
			return(-1);
#else
		if(DisplayMessage( "R(ajouter articles), M(odifier), A(nnuler)")<0 )
			return(-1);
#endif
		sr.nextfld = 5700;
		fomrf( (char *)&s_rec );
		ret( err_chk(&sr) );
		switch( s_rec.s_resp[0] ){
			case ADDREC:	/* Go to addition of items */
				return(HideMessage());
			case EDIT:	/* Edit the fields in header */
				if( (retval=EditHeaderFields())<0 )
					return(retval);
				break;
			case CANCEL:	/* Cancel the session */
#ifdef ENGLISH
				if(DisplayMessage( 
					"Confirm the Cancel (Y/N)?")<0 ) 
					return(-1);
#else
				if(DisplayMessage( 
					"Confirmer l'annulation (O/N)?")<0 ) 
					return(-1);
#endif
				sr.nextfld = 5700;
				fomrf( (char *)&s_rec );
				ret( err_chk(&sr) );
				if( s_rec.s_resp[0]!=YES )
					continue;
				if( HideMessage()<0 ) return(-1);
				return(EXIT);
		}
	}
}
static
DisplayMessage(mesg)	/* Display the given message in the message field */
char *mesg;
{
	STRCPY( s_rec.s_mesg, mesg );
	if( WriteFields(5600,5600)<0 )	return(-1);
	return(0);
}
static
HideMessage()	/* Hide the message field */
{
	if( FillMsgRespFields(HIGH)<0 )	return(-1);
	if( WriteFields(5600,5700)<0 ) return(-1);
	return(0);
}
static
HideFldNo()	/* Hide the 'Field#' field */
{
	if( FillFieldNum(HIGH)<0 )	return(-1);
	if( (WriteFields(700,700))<0 )
		return(-1);
	return(0);
}
static
EditHeaderFields()	/* Read the header field number and read corresponding field */
{
	int fld;

	for( ; ; ){
		if( FillFieldNum(LOW)<0 )	return(-1);
		if( (retval = ReadFields(700,700))<0 ) return(-1);
		if( retval==EXIT ){
			if( HideFldNo()<0 ) return(-1);
			break;
		}
		if( s_rec.s_fld_no<1 || s_rec.s_fld_no>5 ){
#ifdef ENGLISH
			fomer("Invalid field number");
#else
			fomer("Numero de champ invalide");
#endif
			continue;
		}
		if( s_rec.s_fld_no==2 ){
#ifdef ENGLISH
			fomer("Editing of this field not allowed");
			continue;
#else
			fomer("Les ajustements ne sont pas permis pour ce champ");
			continue;
#endif
		}

		if(( s_rec.s_fld_no==5 )&&(s_rec.s_tr_code[0] != HALFYEARLY) &&
		   	(s_rec.s_tr_code[0] != YEARLY) &&
			(s_rec.s_tr_code[0] != QUARTERLY)) {  
#ifdef ENGLISH
			fomer("Editing of this field not allowed");
			continue;
#else
			fomer("Les ajustements ne sont pas permis pour ce champ");
			continue;
#endif
		}

		switch(s_rec.s_fld_no){
			case 1: fld=900;	/* record code */
				break;
			case 3: fld=1100;	/* Xaction description */
				break;
			case 4: fld = 1125;	/* last date posted */
				break;
		}
		retval = ModifyField(fld);
		if( retval<0 )	return(retval);
		if( retval==EXIT ){
			if( HideFldNo()<0 ) return(-1);
			break;
		}
	}
	return(0);
}
static
ModifyField( fld )		/* Read & change the specified field */
int fld;
{
	fomca1( fld,19,2);	/* enable dup buffers - salvage old values */
	sr.nextfld = sr.endfld = fld;
	fomud( (char *)&s_rec);
	switch(fld){
		case 900:	/* record code */
			s_rec.s_reccod = LV_SHORT;
			break;
		case 1000:	/* transaction code */
			s_rec.s_tr_code[0] = LV_CHAR;
			break;
		case 1100:	/* description */
			s_rec.s_descr[0] = LV_CHAR;
			break;
		case 1125:	/* last date posted */
			s_rec.s_lastdate = LV_LONG;
			break;
	}
	retval = ReadFields( fld,fld );
	if( retval<0 || retval==EXIT)	return(retval);
	sr.nextfld = sr.endfld = fld;
	fomca1( fld,19,0);	/* disable dup buffers */
	return(0);
}
static
Page *PageAllocated()	/* Allocate memory for 1 page of items on screen */
{
	return( (Page *)(malloc((unsigned)sizeof( Page ))) );
}
static
ReadItemFields()	/* Read the journal entry items */
{
	headptr = tailptr = tempptr = NULL; 
	current.page = 0;
	current.line = ITEMSPERPAGE;	/* Init list & counter values */
	totalitemsactive = 0;
	lastitemnumber = 0;

	if( AddItemsInLoop(ADD)<0 )	/* Read all the transactions */
		return(-1);
	retval = ConfirmItems(ADD);/* Allow changing of entered values */
	if( retval<0 )	return(retval);
	if( retval==EXIT ){
		if(ClearScreen()<0)		/* Clear the screen */
			return(-1);	
		return(EXIT);
	}
	return(0);
}
static
AddItemsInLoop(mode)		/*  */
int mode;
{
	for( ; ; ){
		/* read one transaction- account#,amount */
		retval=ReadOneItem(mode);   
		if( retval<0 ){
			FreeList();
			return(-1);
		}
		if (tailptr)
			tailptr->lines_entered = current.line;
		if( retval==EXIT || retval==ALLOC_ERROR )
			break;
	}
	return(0);
}
static
ReadOneItem(mode)	/* read one transaction (one line on screen) */
int mode;
{
	if( current.line >= ITEMSPERPAGE ){ 
		retval = MakeFreshPage(); /* add new page to list */
		if( retval<0 || retval==ALLOC_ERROR )
			return( retval );
		current.page++;
		current.line = 1;
		if( PutPageNumber(current.page)<0 )
			return(-1);
	}
	else
		current.line++;

	if( FillItemLines(LOW,current.line,current.line)<0 )
		return(-1);
#ifdef ENGLISH
	fomer("Press ESC-F to Exit");
	STRCPY(s_rec.s_entries[current.line-1].s_status, "ACT");
#else
	fomer("Appuyer sur ESC-F pour retourner");
	STRCPY(s_rec.s_entries[current.line-1].s_status, "ACT");
#endif

	s_rec.s_entries[current.line-1].s_sno = ++lastitemnumber;
	retval=ReadFields(1600+(current.line-1)*400,1900+(current.line-1)*400 );

	if(retval==EXIT || retval<0 ){
		if( FillItemLines(HIGH,current.line,current.line)<0 )
			return(-1);
		if( WriteFields( 1600+(current.line-1)*400,
		                1900+(current.line-1)*400 )<0 )
			return(-1);
		tempptr->fields[current.line-1].s_sno = HV_SHORT;
		tempptr->fields[current.line-1].s_accno[0] = HV_CHAR;
		tempptr->fields[current.line-1].s_amount = HV_DOUBLE;
		tempptr->fields[current.line-1].s_status[0] = HV_CHAR;
		lastitemnumber--;
		current.line--;
		if(current.line<1){
			if( headptr==tailptr )
				headptr=tailptr=NULL;
			else{
				tailptr = tailptr->prevptr;
				tailptr->nextptr = NULL;
			}
			free( (char *)tempptr );
			tempptr = tailptr;
			current.page--;
			if( PutPageNumber(current.page)<0 )
				return(-1);
			current.line =  ITEMSPERPAGE;
			if( tempptr )
				if( ShowPage()<0 )
					return(-1);
		}
		return(retval);
	}
	else{
		tempptr->fields[current.line-1].s_sno
			= s_rec.s_entries[current.line-1].s_sno;
		STRCPY(tempptr->fields[current.line-1].s_accno,
		       s_rec.s_entries[current.line-1].s_accno);
		tempptr->fields[current.line-1].s_amount
			= s_rec.s_entries[current.line-1].s_amount;
		strncpy(tempptr->fields[current.line-1].s_status,
			 s_rec.s_entries[current.line-1].s_status, 4);
		tempptr->lines_entered = current.line;
		totalitemsactive++;
	}
	return(0);
}
static
ShowPage()	/* Dump contents of node pointed to by tempptr onto screen */
{
	if( ListToScreen()<0 ) return(-1);	/* transfer data */
	if( WriteFields( 1600,5500 )<0 ) return(-1); /* display on screen */
	if( PutPageNumber( current.page )<0 )return(-1); /* Paginate properly */
	return(0);
}
static
ListToScreen()	/* copy contents of *tempptr to screen (items part) */
{
	short i;

	if( tempptr==NULL )
		return(-1);
	for( i=0; i<tempptr->lines_entered; i++){ 
		s_rec.s_entries[i].s_sno = tempptr->fields[i].s_sno ;
		STRCPY( s_rec.s_entries[i].s_accno,tempptr->fields[i].s_accno );
		s_rec.s_entries[i].s_amount = tempptr->fields[i].s_amount ;
		strncpy(s_rec.s_entries[i].s_status,tempptr->fields[i].s_status ,4);
	}
	for( ; i<ITEMSPERPAGE; i++){ 
		s_rec.s_entries[i].s_sno = HV_SHORT;
		s_rec.s_entries[i].s_accno[0] = HV_CHAR;
		s_rec.s_entries[i].s_amount = HV_DOUBLE;
		s_rec.s_entries[i].s_status[0] = HV_CHAR;
	}
	return(0);
}
static
MakeFreshPage()	/* Add a new node to the linked list */
{
	tempptr=PageAllocated();
	if( tempptr==NULL ){
#ifdef ENGLISH
	  fomen("Internal memory allocation error. Press a key");
#else
	  fomen("Erreur d'allocation a la memoire interne. Appuyer sur une touche");
#endif
	  get();
	  return(ALLOC_ERROR);
	}
	if( tailptr == NULL ){	/* If not a single node in the list yet */
		headptr=tailptr=tempptr;
		tempptr->prevptr = NULL;
		tempptr->nextptr = NULL;
	}
	else{			/* if at least one node exists */
		tailptr->lines_entered = current.line;
		tailptr->nextptr = tempptr;
		tempptr->prevptr = tailptr;
		tempptr->nextptr = NULL;
		tailptr = tempptr;
	}
	tempptr->lines_entered = 0;
	if( FillItemLines(HIGH,1,ITEMSPERPAGE)<0 ) 
		return(-1);
	if( WriteFields(1600,5500)<0 )
		return(-1);
	return(0);
}
static
PutPageNumber(pgno)		/* Display the given number as Page No */
short pgno;
{
	s_rec.s_page = pgno;
	return(WriteFields(1500,1500));
}
static
ConfirmItems( mode )	/* Allow user to change entered data */
int mode;		/* ADD, BROWSE, UPDATE */
{
    double diff;

    for( ; ; ){
	if( mode==ADD || mode==UPDATE )
#ifdef ENGLISH
	    DisplayMessage("Y(es), A(dd items), E(dit), D(elete), R(eactivate), N(ext), P(rev), C(ancel)");
#else
	    DisplayMessage("O(ui), R(ajouter), M(odifier), E(lim), V(ivifier), S(uiv), P(rec), A(nnuler)");
#endif
	else if( mode==BROWSE ){
		if( headptr->nextptr )
#ifdef ENGLISH
			DisplayMessage("N(ext), P(rev), Y(es)");
#else
			DisplayMessage("S(uivant), P(recedent), O(ui)");
#endif
		else
			break;
	}

	sr.nextfld = 5700;
	fomrf( (char *)&s_rec );	/* Read user's option */
	ret( err_chk(&sr) );
	switch(s_rec.s_resp[0]){
		case ADDREC:	/* Add items allowed in ADD MODE only */
			if( mode==BROWSE )
				break;
			while( tempptr && tempptr->nextptr ){
				tempptr = tempptr->nextptr;
				current.page ++;
			}
			if( tempptr ){
				current.line = tempptr->lines_entered;
				if( current.line<1 )
					current.line = ITEMSPERPAGE;
				if( ShowPage()<0 ) return(-1);
			}
			if( AddItemsInLoop(mode)<0 ) return(-1);
			break;
		case EDIT:	/* Edit entered data in ADD MODE only */
			if( mode==BROWSE )
				break;	
			if( !tempptr )	/* if no page is being pointed to */
				break;
			retval = EditItemFields(mode);
			if( retval<0 )
				return(-1);
			if( HideFldNo()<0 )
				return(-1);
			break;
		case DELETE:	/* Delete an item entered in ADD/UPDATE only*/
		case REVIVE:	/* Revive an item deleted in ADD/UPDATE only*/
			if( !tempptr )	/* if no page is being pointed to */
				break;
			if( mode==BROWSE )
				break;
			if( ChangeItemStatus()<0 )
				return(-1);
			if( HideFldNo()<0 )
				return(-1);
			break;
		case NEXT:	/* Display the next page of items */
			if(tempptr && tempptr->nextptr){
				tempptr = tempptr->nextptr;
				current.page ++;
				if(ShowPage()<0 ) return(-1);
			}
			else
#ifdef ENGLISH
				fomer("Last Page Displayed");
#else
				fomer("Derniere page affichee");
#endif
			break;
		case PREV:	/* Display the prev page of items */
			if(tempptr && tempptr->prevptr){
				tempptr = tempptr->prevptr;
				current.page --;
				if(ShowPage()<0 ) return(-1);
			}
			else
#ifdef ENGLISH
				fomer("First Page Displayed");
#else
				fomer("Premiere page affichee");
#endif
			break;
		case CANCEL:    /* Cancel the entire session in ADD MODE only*/
			if( mode==BROWSE )
				break;
#ifdef ENGLISH
			DisplayMessage("Confirm the cancel (Y/N)?"); 
#else
			DisplayMessage("Confirmer l'annulation (O/N)?");
#endif
			for( ; ; ){
				sr.nextfld = 5700;
				fomrf( (char *)&s_rec);
				if(s_rec.s_resp[0]!=YES&&
				   s_rec.s_resp[0]!=NO)
					continue;
				if( s_rec.s_resp[0]==YES ){
					if(HideMessage()<0 )
						return(-1);
					if( mode==UPDATE )
						return(EXIT);
					FreeList();
					return(EXIT);
				}
				else
					break;
			}
			break;
		case YES:	/* Save & Exit in ADD/UPDATE,Exit in INQ MODE */
			if( mode==BROWSE )
				return( HideMessage() );
			if( mode==ADD && totalitemsactive<1 ){
#ifdef ENGLISH
				fomer("No items to save. Cancel to Quit");
#else
				fomer("Pas d'articles a conserver. Annuler pour retourner");
#endif
				break;
			}
			if( s_rec.s_reccod!=99 )
				return(HideMessage());/* Cr need not be=Db */
			TotalAmount(DEBITS, &re_hdr.rh_debits );
			TotalAmount(CREDITS, &re_hdr.rh_credits );
			diff=re_hdr.rh_debits-re_hdr.rh_credits;
			if( diff>DELTA_AMT || diff<(-DELTA_AMT) ){
			    sprintf(e_mesg,
#ifdef ENGLISH
				"Unbalanced : Debits: %.2lf, Credits: %.2lf, Diff : %.2lf",
#else
				"Non-solde  : Debits: %.2lf, Credits: %.2lf, Diff : %.2lf",
#endif
				re_hdr.rh_debits,re_hdr.rh_credits,diff);
				    fomer( e_mesg );
			}
			else
				return(HideMessage());
			break;
	}
	continue;
   }
}
static
EditItemFields(mode)	/* Read the field# and allow changes on that field(s) */
int	mode;
{
	int retval;

	for( ; ; ){
#ifdef ENGLISH
		STRCPY(s_rec.s_mesg,"Enter RETURN to terminate Edit");
#else
		STRCPY(s_rec.s_mesg,"Appuyer sur RETURN pour terminer l'ajustement");
#endif
		if(WriteFields(5600,5600)<0) return(-1);
		
		s_rec.s_fld_no = LV_SHORT;
		if( (retval=ReadFields(700,700)) < 0 )
			return(-1);
		if( retval==EXIT )
			return(retval);
		if( s_rec.s_fld_no<1 || s_rec.s_fld_no>ITEMSPERPAGE*10+2 )
			continue;
		if( s_rec.s_fld_no>0 && s_rec.s_fld_no<=ITEMSPERPAGE ){
						/* Chg a line */ 
			if( (retval=LineChange(mode,s_rec.s_fld_no)) < 0 )
				return(retval);
		}
		else {		/* Change a field - account# or amount */
			if( (retval=FieldChange(mode,s_rec.s_fld_no/10,
					      s_rec.s_fld_no%10))< 0)
				return(retval); 
		} 
	}
}
static
LineChange(mode,line_no )/* Read new values: account# & amount at given line */
int line_no, mode;
{
	int i, firstfld, lastfld;

	/* Don't allow changes/access if item not active or not entered yet */
	if( !tempptr )	return(0);	/* if no pages, return */
	if( tempptr->fields[line_no-1].s_status[0]!='A' ){
#ifdef ENGLISH
		fomen( "Record inactive. Press a key" );
#else
		fomen( "Fiche inactive. Appuyer sur une touche" );
#endif
		get();
		return(0);
	}
	if( line_no>tempptr->lines_entered )
		return(0);

	firstfld = 1700+(line_no-1)*400;	/* account number field */
	lastfld = 1800+(line_no-1)*400;		/* amount field */
	for( i = firstfld; i <= lastfld; i+=100 )
		fomca1( i, 19, 2 );		/* enable dup buffers */
	sr.nextfld = firstfld;
	sr.endfld = lastfld;
	fomud( (char *)&s_rec );		/* update dup buffers */
	if( mode==ADD )	/* Allow changing in ADD mode only */
		s_rec.s_entries[line_no-1].s_accno[0] = LV_CHAR;
	s_rec.s_entries[line_no-1].s_amount = LV_DOUBLE;
	i= ReadFields( firstfld, lastfld );
	if( i<0 )	return(i);
	for( i = firstfld; i <= lastfld; i+=100 )
		fomca1( i, 19, 0 );		/* disable dup buffers */
	scpy( (char *)(tempptr->fields+line_no-1), 
		(char *)(s_rec.s_entries+line_no-1), 
		sizeof( Scr_item ) );
	return(0);
}
static
FieldChange( mode, line_no, col_no )	/* Allow change on specified field */
int mode, line_no, col_no;
{
	int fld_no;

	if( !tempptr )	return(0);	/* if no pages, return */
	if( tempptr->fields[line_no-1].s_status[0]!='A' ){
#ifdef ENGLISH
		fomer( "Record not active. Revive first" );
#else
		fomer( "Fiche inactive. Vivifier premierement");
#endif
		get();
		return(0);
	}
	if( line_no>tempptr->lines_entered )
		return(0);
	if( col_no<1 || col_no>2 )
		return(0);
	fld_no = 1700+(col_no-1)*100 + (line_no-1)*400;
	fomca1( fld_no, 19, 2 );
	sr.nextfld = sr.endfld = fld_no;
	fomud( (char *)&s_rec );
	switch( col_no ){
		case 1:
			if( mode==ADD )/* Changeable in ADD mode only */
				s_rec.s_entries[line_no-1].s_accno[0]=LV_CHAR;
			break;
		case 2:
			s_rec.s_entries[line_no-1].s_amount=LV_DOUBLE;
			break;
		default:
			break;
	}
	if( ReadFields( fld_no, fld_no ) < 0 )
		return(-1);
	switch( col_no ){
		case 1:
			STRCPY(tempptr->fields[line_no-1].s_accno,
			       s_rec.s_entries[line_no-1].s_accno);
			break;
		case 2:
			tempptr->fields[line_no-1].s_amount
			= s_rec.s_entries[line_no-1].s_amount;
			break;
		default:
			break;
	}
	fomca1( fld_no, 19, 0 );
	return(0);
}
static
ChangeItemStatus()	/* Allow deletion or revival of an item */
{
	int fld_no;

	for( ; ; ){
		s_rec.s_fld_no = LV_SHORT;
		if( (retval=ReadFields(700,700)) < 0 )
			return(-1);
		if( retval==EXIT )
			return(retval);
		if( s_rec.s_fld_no<1 || s_rec.s_fld_no>tempptr->lines_entered )
			continue;
		switch( s_rec.s_resp[0] ){
			case DELETE:
#ifdef ENGLISH
			   if( !strcmp(s_rec.s_entries[s_rec.s_fld_no-1].s_status,"DEL"))
				break;
#else
			   if( !strcmp(s_rec.s_entries[s_rec.s_fld_no-1].s_status,"ELI"))
				break;
#endif
#ifdef ENGLISH
			   STRCPY(s_rec.s_entries[s_rec.s_fld_no-1].s_status,
									"DEL");
			   totalitemsactive--;
			   break;
#else
			   STRCPY(s_rec.s_entries[s_rec.s_fld_no-1].s_status,
									"ELI");
			   totalitemsactive--;
			   break;
#endif
			case REVIVE:
#ifdef ENGLISH
			   if( !strcmp(s_rec.s_entries[s_rec.s_fld_no-1].s_status,"ACT"))
				break;
#else
			   if( !strcmp(s_rec.s_entries[s_rec.s_fld_no-1].s_status,"ACT"))
				break;
#endif
#ifdef ENGLISH
			   STRCPY(s_rec.s_entries[s_rec.s_fld_no-1].s_status,
									"ACT");
			   totalitemsactive++;
			   break;
#else
			   STRCPY(s_rec.s_entries[s_rec.s_fld_no-1].s_status,
									"ACT");
			   totalitemsactive++;
			   break;
#endif
			default:
				return(0);
		}
		STRCPY(tempptr->fields[s_rec.s_fld_no-1].s_status ,
			 s_rec.s_entries[s_rec.s_fld_no-1].s_status);
		fld_no = 1900 + (s_rec.s_fld_no-1)*400;
		if( WriteFields(fld_no,fld_no)<0 )
			return(-1);
		break;
	}
	return(0);
}
static
WriteSession(mode)	/* Write header, list of items and update GL master */
int	mode;		/* ADD  or  UPDATE */
{
	int i, err;

	if( mode==ADD ){
		if((err=WriteHeader(ADD))<0 ){/* Write the header record file */
			roll_back(e_mesg) ;
			return(err);
		}
	}
		
	/* to write the items in gltran file */
	for( tempptr=headptr; tempptr!=NULL; tempptr=tempptr->nextptr){	
		for( i=1; i<=ITEMSPERPAGE; i++){ /* for each line on page */
			if(tempptr->fields[i-1].s_amount==HV_DOUBLE)
				break;
			if((err=WriteItem(i,mode))<0 ){
				roll_back(e_mesg) ;
				return(err);
			}
		}
		if(tempptr->fields[i-1].s_amount==HV_DOUBLE)
			break;	/* terminate when High values are found */
	}
	tempptr = headptr;

	/* if all the recurring transaction items are deleted, delete header */
	if( mode==UPDATE && totalitemsactive==0 ){
		if((err=WriteHeader(P_DEL))<0 ){/* Write the header rec. file */
			roll_back(e_mesg) ;
			return(err);
		}
	}

	if (commit(e_mesg) < 0 ){
		fomen(e_mesg) ;
		get() ;
		return(-1);
	}
	return(0);
}

static
TotalAmount( flag, total )	/* Calculate the total of Credits/Debits */
int flag;
double *total;
{
	int i;
	double amount;
	Page *ptr;

	amount = 0.0;
	ptr = headptr;
	for( ; ; ){	/* for each page in the list */
		if(ptr==NULL)
			break;
		for(i=1;i<=ITEMSPERPAGE;i++){	/* for each line in the page */
			if( ptr->nextptr==NULL && i>ptr->lines_entered )
				break;
			if(ptr->fields[i-1].s_amount==HV_DOUBLE)
				break;
			if(ptr->fields[i-1].s_status[0]==DELETE)
				continue;
			switch(flag){
				case DEBITS:
					if(ptr->fields[i-1].s_amount>DELTA_AMT )
					amount += ptr->fields[i-1].s_amount;
					break;
				case CREDITS:
					if(ptr->fields[i-1].s_amount<-DELTA_AMT )
					amount += ptr->fields[i-1].s_amount;
					break;
			}
		}
		ptr=ptr->nextptr;
	}
	if( flag==CREDITS )
		*total = (-amount);
	else
		*total = amount;
	return(0);
}
static
WriteHeader(mode)	/* Write the header of the Xaction in gltrhdr file */
int	mode;	/* ADD or P_DEL */
{
	if (mode == ADD){
		re_hdr.rh_fund = s_rec.s_fund;
		re_hdr.rh_sno = (short)s_rec.s_sno;
		retval = get_rehdr( &re_hdr, UPDATE, 0, e_mesg );
 		if( retval==NOERROR ){
 			s_rec.s_sno ++; 
 			if( WriteFields(500,600)<0 )
 				return(-1);
 		} 
	}

	re_hdr.rh_fund = s_rec.s_fund;
	re_hdr.rh_sno = (short)s_rec.s_sno;
	STRCPY( re_hdr.rh_descr,s_rec.s_descr ) ;
	re_hdr.rh_reccod = (short)s_rec.s_reccod;
	re_hdr.rh_type[0] = s_rec.s_tr_code[0];
	re_hdr.rh_date = s_rec.s_lastdate;
	re_hdr.rh_speriod = 0;
	re_hdr.rh_lperiod = 0;
	retval = put_rehdr( &re_hdr, mode, e_mesg );
	if( retval!=NOERROR ){
		fomen(e_mesg);get();
		roll_back(e_mesg);
		return(retval);
	}
	retval = rite_audit((char*)&s_rec, RECHDR,mode,(char *)&re_hdr,
				(char *)&ore_hdr,e_mesg);

	if(retval==LOCKED) {
		fomen(e_mesg);get();
		roll_back(e_mesg);
		return(LOCKED);
	}

	if( retval<0 ){
		fomen(e_mesg);get();
		roll_back(e_mesg);
		return(retval);
	}
	return(0);
}

static
WriteItem(line_no,mode)/* Write one item in gltran file from *tempptr */
int line_no,mode;	/* ADD / UPDATE */
{
	int flag = -1;

	re_item.ri_fund = re_hdr.rh_fund;
	re_item.ri_sno = re_hdr.rh_sno;
	re_item.ri_item_no = (short)tempptr->fields[line_no-1].s_sno;
	STRCPY( re_item.ri_accno, tempptr->fields[line_no-1].s_accno );
	re_item.ri_amount = tempptr->fields[line_no-1].s_amount;

	if( mode==ADD ){	
		if( tempptr->fields[line_no-1].s_status[0]!=DELETE )
			flag = ADD;
	}
	else if( mode==UPDATE || mode == P_DEL ){/*Supposing the record exists*/
		retval = get_reitem( &re_item, UPDATE, 0, e_mesg ); 
		switch(retval){
		   case ERROR:
			break;
		   case UNDEF:
			if(mode == P_DEL) flag = -1;
			else if(tempptr->fields[line_no-1].s_status[0]!=DELETE )
				flag = ADD;
			retval = 0;
			break;
		   case NOERROR:
			if (mode == P_DEL) flag = P_DEL;
			else if( tempptr->fields[line_no-1].s_status[0]==DELETE)
				flag = P_DEL;
			else{
				scpy( (char *)&ore_item,
					(char *)&re_item,
					sizeof(Re_item) );
				re_item.ri_item_no = 
					(short)tempptr->fields[line_no-1].s_sno;
				STRCPY( re_item.ri_accno, 
					tempptr->fields[line_no-1].s_accno );
				re_item.ri_amount = 
					tempptr->fields[line_no-1].s_amount;

				flag = UPDATE;
			}
			break;
		}
	}
	if( flag!=-1 ){
	    retval = put_reitem( &re_item, flag, e_mesg ); 
	    if( retval!=NOERROR ){
		fomen(e_mesg);get();
		roll_back(e_mesg);
		return(retval);
	    }

	    retval = rite_audit((char*)&s_rec, RECTRAN,flag,(char *)&re_item,
					(char *)&ore_item,e_mesg);

	    if(retval==LOCKED) {
		fomen(e_mesg);get();
		roll_back(e_mesg);
		return(LOCKED);
	    }

	    if( retval<0 ){
		fomen(e_mesg);get();
		roll_back(e_mesg);
		return(retval);
	    }
	}
	return(0);
}
static
FreeList()	/* Free the linked list */
{
	for( tempptr=headptr; tempptr; tempptr=headptr ){
		headptr=headptr->nextptr;
		free( (char *)tempptr );
	}
	tailptr = NULL;
	return(0);
}
static
Inquire(access,direction,mode)	/* Screen inquiry, random/sequential */
int access, direction,mode;	/* RANDOM, SEQUENTIAL accesses */
				/* BROWSE, UPDATE modes */
{
	int retval,err;

	if( access==RANDOM ){
		retval = GetHeaderKey(mode);	/* Read the key values */
		if(retval==UNDEF)
			return(0);
		if(retval==EXIT || retval==ERROR){
			if(ClearScreen()<0)	return(-1);
			return(retval);
		}
	}
	else{
		retval = GetNextHeader( direction );	/* Get next rec */
		if(retval==EFL)
			return(0);
	}
	if( retval<0 ){
		fomen(e_mesg);get();
		return(-1);
	}
	retval = DisplayRecord(mode);	/* Display the header & item records */
	if( retval<0 ) return(retval);
	if( retval==EXIT ) {		/* if cancel unlock records */
		roll_back(e_mesg);
		return(retval);
	}

	if( mode==UPDATE ) {	/* Changes made */
		for( ; ; ) {
			retval = WriteSession(mode);
			if(retval==NOERROR) break;
			if(retval==LOCKED) {
				roll_back(e_mesg);
				retval = ConfirmItems(mode);
				if( retval<0 || retval==EXIT ) return(retval);
					continue;
			}
			if(retval<0) return(err);
		}
	}

	return( FreeList() );
}
static
DisplayRecord(mode)	/* Get and display the header and item records */
int	mode;
{
	int retval;

	retval = ShowHeaderFields();	/* Display header information */
	if( retval<0 || retval==EXIT ) return(retval);

	retval = ShowItems();	/* Display first pageful of items */
	if( retval<0 || retval==EXIT ) return(retval);

	retval = ConfirmItems(mode);	/* Allow scanning of pages */
	if( retval<0 || retval==EXIT ) return(retval);
	return(0);
}
static
GetNextHeader(direction)	/* Read the next rec in specified direction */
int	direction ;
{
	int retval;
	char string[6];
	
	if( flg_start(RECHDR) != direction){ 	/* file not in seq read mode */
		/* Set the least part of the key to next possible key and set
		   the file to start */
		re_hdr.rh_fund = s_rec.s_fund;
		if(direction == FORWARD)
			re_hdr.rh_sno = s_rec.s_sno + 1;
		else
			re_hdr.rh_sno = s_rec.s_sno - 1;
		flg_reset(RECHDR) ;
	}
	/* Read the next record from gltrhdr file */
	retval = get_n_rehdr( &re_hdr, BROWSE, 0, direction, e_mesg );
#ifndef	ORACLE
	seq_over(RECHDR) ;
#endif
	if( retval==EFL ){
#ifdef ENGLISH
		fomen("No More Records....");
#else
		fomen("Plus de fiches....");
#endif
		get();
		flg_reset(RECHDR);
		return(EFL);
	}
	if( retval!=NOERROR ){
		fomen(e_mesg);	get();
		return(retval);
	}
	s_rec.s_fund = re_hdr.rh_fund;
	s_rec.s_sno = re_hdr.rh_sno;
	if( WriteFields(500,600)<0 )
		return(-1);
	return(0);
}
static
GetHeaderKey(mode)/* Read the header key values, get terminal info ,read rec */
int	mode;	/* UPDATE, BROWSE */
{
	int i, retval;

	/* Enable dup buffers for reading key */
	for( i=500; i<=600; i+=100 )
		fomca1( i, 19, 2 );
	sr.nextfld=500; 
	sr.endfld=600;
	fomud( (char *)&s_rec );

	s_rec.s_fund = LV_SHORT;
	s_rec.s_sno = LV_SHORT;
	if( (retval=ReadFields(500,600))<0 || retval==EXIT ) 
		return(retval);
	re_hdr.rh_fund = s_rec.s_fund;
	re_hdr.rh_sno = (short)s_rec.s_sno;
	retval = get_rehdr( &re_hdr, mode, 0, e_mesg );
	if( retval!=NOERROR ){
		fomer(e_mesg);
		get();
		return(retval);
	}
	/* Disable dup buffers for reading key */
	for( i=500; i<=600; i+=100 )
		fomca1( i, 19, 2 );
	return(0);
}
static
ShowHeaderFields()	/* Display header info */
{
	STRCPY(s_rec.s_descr, re_hdr.rh_descr );
	s_rec.s_reccod = re_hdr.rh_reccod;
	s_rec.s_tr_code[0] = re_hdr.rh_type[0];
	s_rec.s_lastdate = re_hdr.rh_date;

	if( WriteFields(900,1125)<0 ) return(-1);
	return(0);
}
static
ShowItems()	/* Display first pageful of items */
{
	if( FillSeperatorLine(LOW)<0 ) return(-1);
	if( FillLineHeading(LOW)<0 )	return(-1);
	if( WriteFields(1200,1400)<0 )	return(-1);

	if( BuildList()<0 )	/* Build linked list of pages in memory */ 
		return(-1);
	if( headptr==NULL ){	/* No items present */
#ifdef ENGLISH
		fomen("No transaction items");
#else
		fomen("Pas d'articles de transaction");
#endif
		get();
		return( EXIT );
	}
	tempptr = headptr ;	/* Seek to first node/page of list */
	current.page = 1;
	if( ShowPage()<0 ) return(-1);	/* Display contents of page sought */ 
	return(0);
}
static
BuildList()	/* Read item by item from file and build list */
{
	int retval,i;

	headptr = tailptr = tempptr = NULL;
	re_item.ri_fund = re_hdr.rh_fund;
	re_item.ri_sno = re_hdr.rh_sno;
	re_item.ri_item_no = 0;
	flg_reset(RECTRAN);	/* Initialize to get first rec under givenkey */

	totalitemsactive = 0;
	for( ; ; ){
#ifndef	ORACLE
		retval = get_n_reitem( &re_item, BROWSE, 0, FORWARD, e_mesg);
#else
		retval = get_n_reitem( &re_item, BROWSE, 0, EQUAL, e_mesg);
#endif
		if( retval==ERROR ){
			fomen(e_mesg);
			get();
			return(retval);
		}
		if( retval==EFL )
			break;
#ifndef	ORACLE
		if( 	re_item.ri_fund != re_hdr.rh_fund ||
			re_item.ri_sno != re_hdr.rh_sno  ||
			re_item.ri_item_no<1	)
			break;	/* No more records with specified key */
#endif
		current.line = (totalitemsactive+1) % ITEMSPERPAGE;
		if( current.line==0 ) current.line = ITEMSPERPAGE;
		if( current.line==1 ){	/* New page to be formed */
		    tempptr = PageAllocated();	/* Allocate memory for page */
		    if( tempptr==NULL ){
#ifdef ENGLISH
			fomen("Internal Memory allocation error. Press a key");
#else
			fomen("Erreur d'allocation a la memoire interne. Appuyer sur une touche");
#endif
			get();
			return(-1);
		    }
		    tempptr->lines_entered = 0;
		    if( totalitemsactive==0 ){	/* First item */
			headptr = tailptr = tempptr;
			tempptr->nextptr = tempptr->prevptr = NULL;
		    }
		    else{
			tailptr->nextptr = tempptr;
			tempptr->prevptr = tailptr;
			tempptr->nextptr = NULL;
			tailptr = tempptr;
		    }
		}
		tempptr->fields[current.line-1].s_sno = re_item.ri_item_no;
		STRCPY(tempptr->fields[current.line-1].s_accno,re_item.ri_accno);
		tempptr->fields[current.line-1].s_amount = re_item.ri_amount;
#ifdef ENGLISH
		STRCPY(tempptr->fields[current.line-1].s_status,"ACT"); 
#else
		STRCPY(tempptr->fields[current.line-1].s_status,"ACT"); 
#endif
		tempptr->lines_entered++;
		totalitemsactive++;
		lastitemnumber = re_item.ri_item_no;
	} 
	seq_over(RECTRAN);

	if( headptr==NULL ){
#ifdef ENGLISH
		fomen("No items to display. Press a key");
#else
		fomen("Pas d'articles a afficher. Appuyer sur une touche");
#endif
		get();
		return(-1);
	}

	/* upto current.line values have been entered */
	/* now fill high values for rest of the page */
	for(i=current.line+1;i<=ITEMSPERPAGE;i++){
		tempptr->fields[i-1].s_sno = HV_SHORT;
		tempptr->fields[i-1].s_accno[0] = HV_CHAR;
		tempptr->fields[i-1].s_amount = HV_DOUBLE;
		tempptr->fields[i-1].s_status[0]= HV_CHAR; 
	}
	return(0);
}

