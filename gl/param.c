/*-----------------------------------------------------------------------
Source Name: param.c
System     : Budgetary Financial system.
Module     : General Ledger system.
Created  On: 2nd May 89.
Created  By: T AMARENDRA.

COBOL Source(s): cp000---02 & cp000-read

DESCRIPTION:
	Program to Creat PARAMETER file.
	If Parameter file exists this program just displays. No changes are
	accepted once parameter file is created.

	NOTE: G/L Indx Required & Fixed Entry Flags removed form the parameter
	      file.

Usage of SWITCHES when they are ON :
	SW1 :
	SW2 :
	SW3 :
	SW4 :
	SW5 :
	SW6 :
	SW7 :
	SW8 :
		Not Used.


MODIFICATIONS:        

Programmer     YY/MM/DD       Description of modification
J.PRESCOTT     90/06/01       Added District Cost Center Number
p ralph	       90/11/20       Added 2 new fields.
			      1. "Move Budget Amt's at Year End(Y/N)"
			      2. "No of Days Due Default." - use as default
				  due date in po.c,apinv12.c & arsinv.c
F.Tao	       90/12/04	      Add Registration Number field.
J.Prescott     91/02/13       Added No of Days Due Default (PO) & (AP).
			      Added GST/PST Tax Field Defaults.
J.Prescott     91/02/16       Added Budget Key's and Cost Center key.
A.Cormier      92/10/27       Changed cost center number from a 2 digits to 
                              a 4 digits
S.Whittaker	93/06/20	Added the consumption Key to the param.
------------------------------------------------------------------------*/

#define	MAIN	/* Main program. This is to declare Switches */
#define MAINFL		PARAM		/* main file used */

#define	SYSTEM		"SETUP"		/* Sub System Name */
#define	MOD_DATE	"16-FEB-91"	/* Program Last Modified */

#include <stdio.h>
#include <ctype.h>
#include <cfomstrc.h>
#include <bfs_defs.h>
#include <bfs_recs.h>

#ifdef ENGLISH
#define EDIT	'E'
#define CANCEL	'C'
#define YES	'Y'
#define NO	'N'

#define COMPANY	'C'
#define SCH_FLG	'S'

#define TAXABLE	'T'
#define EXEMPT	'E'
#else	/* French */
#define EDIT	'M'
#define CANCEL	'A'
#define YES	'O'
#define NO	'N'

#define COMPANY	'C'
#define SCH_FLG	'S'

#define TAXABLE	'T'
#define EXEMPT	'E'
#endif

#define	SCR_NAME	"param"		/* PROFOM screen name */

/* PROFOM Field Numbers */
#define	ST_FLD		300		/* Data entry starting field */
#define	END_FLD		4400		/* screen end field */
#define	COMP_FLD	700		/* Company/District Field */
#define	APS_FLD		800		/* A/P System Present Field */
#define	INV_FLD		1100		/* INV System Present Field */
#define OPNPER_FLD	2300		/* No. of open periods field */
#define BDGT_KEY_FLD	2600		/* Budget keys starting field */
#define CONS_KEY_FLD	3300		/* Consumption key field */
#define CC_KEY_FLD	3400		/* Cost Center key field */
#define TB_KEY_FLD	3500		/* Cost Center key field */
#define PURLIMIT_FLD	3600		/* Purchasing limit field */
#define DUEPO_FLD	3700		/* Due Days Po Field */
#define GST_FLD		4100		/* GST Tax Default Field */
#define PST_FLD		4200		/* PST Tax Default Field */

#define USER_KEYS	7		/* The 7 budget keys */

/* param.sth - header for C structure generated by PROFOM EDITOR */
struct	s_struct	{
	char	s_pgm[11];	/* STRING XXXXXXXXXX Field 100 */
	long	s_rundate;	/* DATE YYYYFMMFDD Field 300 */
	char	s_comp_nm[51];	/* STRING X[50] Field 400 */
	short	s_distccno;	/* NUMERIC 99 Field 500 */
	short	s_wareccno;	/* NUMERIC 99 Field 600 */
	char	s_co_dist[2];	/* STRING X Field 700 */
	int	s_aps;		/* YES/NO B Field 800 */
	int	s_requisition;	/* YES/NO B Field 900 */
	int	s_poinv;	/* YES/NO B Field 1000 */
	int	s_stores;	/* YES/NO B Field 1100 */
	int	s_fa;		/* YES/NO B Field 1200 */
	int	s_ars;		/* YES/NO B Field 1300 */
	int	s_tendering;	/* YES/NO B Field 1400 */
	int	s_rotational;	/* YES/NO B Field 1500 */
	int	s_cancel_po;	/* YES/NO B Field 1600 */
	int	s_budget;	/* YES/NO B FIELD 1700 */ 
	int	s_more_cntl;	/* YES/NO B Field 1800 */
	int	s_gl_present;	/* YES/NO B Field 1900 */
	int	s_grp_chqs;	/* YES/NO B Field 2000 */
	int	s_dist_gst;	/* YES/NO B Field 2100 */
	short	s_no_periods;	/* NUMERIC 99 Field 2200 */
	short	s_open_per;	/* NUMERIC 99 Field 2300 */
	short	s_cur_period;	/* NUMERIC 99 Field 2400 */
	char	s_key_hdg[2];	/* STRING X Field 2500 */
	short	s_bdgt_keys[7];	/* NUMERIC 99 Fields 2600 - 3100 */
	short	s_cons_key;	/* NUMERIC 99 Fields 3300 */
	short	s_cc_key;	/* NUMERIC 99 Fields 3200 */
	short	s_tb_key;	/* NUMERIC 99 Fields 3300 */
	double	s_purlimit;	/* NUMERIC 9999999.99 Field 3400 */
	short	s_due_days_po;	/* NUMERIC 99 Field 3500 */
	short	s_due_days_ap;	/* NUMERIC 99 Field 3600 */
	short	s_due_days_ar;	/* NUMERIC 99 Field 3700 */
	char	s_regist[11];	/* STRING X[11] Field 3800 */	
	char	s_gst_tax[2];	/* STRING X Field 3900 */
	char	s_pst_tax[2];	/* STRING X Field 4000 */
	char	s_mesg[78];	/* STRING X[77] Field 4100 */
	char	s_resp[2];	/* STRING X Field 4200 */
	};

static	struct	s_struct  s_sth;	/* PROFOM Screen Structure */

static	struct  stat_rec sr;		/* PROFOM status rec */

static	Pa_rec	pa_rec, pre_rec;	/* Parameters Structure */

static	int	pa_exist ;		/* 0 - Rec exists, 1 - Added */
static	int	chg_flg ;		/* 0 - Rec Not change, 1 - Changed */

static	char	e_mesg[80] ;		/* Message string, passed to DBH */

main(argc,argv)
int argc;
char *argv[];
{
	int	err;

	if(argc < 2){
#ifdef  DEVELOP
		printf("MAIN ARGUMENTS ARE NOT PROPER\n");
		printf("Usage : %s {-tterminal name}\n", argv[0]);
#endif
		exit(1);
	}

	strncpy(SYS_NAME,SYSTEM,50);	/* Sub system name */
	strncpy(CHNG_DATE,MOD_DATE,10);	/* Modification Date */

	proc_switch(argc, argv, MAINFL) ; 	/* Process Switches */

	STRCPY(sr.termnm,terminal);	/* Copy Terminal Name */

	InitProfom() ;			/* Initialize PROFOM */
	
	err = Process(); 		/* Initiate Process */

	/* Set terminal back to normal mode from PROFOM */
	fomcs();
	fomrt();

	free_audit() ;	 /* Free the space allocated in rite_audit() */

	close_dbh() ;

	if(err != NOERROR) exit(1);
	exit(0);
} /* END OF MAIN */

/*-------------------------------------------------------------------*/
/* Initialize PROFOM */

InitProfom()
{
	fomin(&sr);
	/* Check for Error */
	if(err_chk(&sr) == PROFOM_ERR){
		fomcs();
		fomrt();
		exit(1);
	}

	fomcf(1,1);	/* Enable Snap screen option */

	/* move screen name to Profom status structure */
	STRCPY(sr.scrnam,NFM_PATH);
	strcat(sr.scrnam,SCR_NAME) ;

	STRCPY(s_sth.s_pgm,PROG_NAME);
	s_sth.s_rundate = get_date();	/* get Today's Dt in YYYYMMDD format */
	s_sth.s_mesg[0] = HV_CHAR ;
	s_sth.s_resp[0] = HV_CHAR ;

	return(NOERROR) ;
}	/* InitProfom() */
/*-------------------------------------------------------------------*/
/* Show if Param exits else take data from user and create Param file */
Process()
{
	int err;

	if(CheckAccess(MAINFL,BROWSE,e_mesg)==NOACCESS) {
		fomen(e_mesg);
		get();
		return(NOERROR);
	}
	err = ReadParam(BROWSE) ;
	if(err == ERROR) return(ERROR) ;

	/* Initialize Change Flag to Zero */
	chg_flg = 0;

	if(err == UNDEF) {	/* Param not exits */
		if(CheckAccess(MAINFL,ADD,e_mesg)==NOACCESS) {
			fomen(e_mesg);
			get();
			return(NOERROR);
		}
		pa_exist = 1 ;
		err = AddParam() ;
		if(err == PROFOM_ERR) return(PROFOM_ERR); /* PROFOM ERROR */
	}
	else {
		pa_exist = 0 ;
		scpy((char *)&pre_rec,(char *)&pa_rec,sizeof(pa_rec));
	}
	for( ; ; ) {
		err = ReadOption() ;
		if(err == PROFOM_ERR) return(err) ;

		if(err != YES) return(NOERROR) ;

		err= RiteRecord();
		if(err==NOERROR) break;
		if(err==LOCKED) {
			roll_back(e_mesg);
			continue;
		}
		if(err<0) return(err);
		break;
	}
	return(NOERROR) ;
}	/* Process() */
/*--------------------------------------------------------------*/
/* checks whether param is created. If yes Display the screen */
ReadParam(mode)
int	mode;	/* Browse or Update */
{
	int	code ;

	code = get_param(&pa_rec,mode,1,e_mesg);
	if(code == UNDEF) {
		return(code) ;
	}
	if(code == ERROR) {
#ifdef ENGLISH
		DispError("ERROR in Saving Records"); 
#else
		DispError("ERREUR en conservant les fiches");
#endif
		return(DispError(e_mesg));
	}

	if(mode == BROWSE)
		CopyToScreen();

	return(NOERROR);
}	/* ReadParam() */
/*----------------------------------------------------------------------*/
/* Turn off Dup Control, read the screen and turn on dup control for
   later changes */
AddParam()
{
	int	i ;

	/* Change PROFOM logical field attributes */

	for(i = ST_FLD ; i <= END_FLD - 200  ; i += 100)
		fomca1(i,19,0); /* Disable Dup control */

	i = ReadScreen() ;	/* Read 1st screen fields */
	if(i != NOERROR) return(i) ;

	/* Change PROFOM logical field attributes */

	for(i = ST_FLD ; i <= END_FLD - 200  ; i += 100)
		fomca1(i,19,2); /* Enable Dup control */

	/* Update Dup Buffers */
	sr.nextfld = ST_FLD ;
	sr.endfld = END_FLD - 200 ;
	fomud((char*)&s_sth);
	ret(err_chk(&sr));

	return(NOERROR) ;
}	/* AddParam() */
/*----------------------------------------------------------------------*/
/* reads fields */
ReadScreen()
{
	MoveLows();
	sr.nextfld = ST_FLD;
	sr.endfld = END_FLD - 200;
	for( ; ;){
		fomrd((char*)&s_sth);
		ret(err_chk(&sr));
		if(sr.retcode == RET_VAL_CHK){
			Validate();
			continue;
		}
		break;
	}

	return(NOERROR);
}	/* ReadScreen() */
/*-----------------------------------------------------------------------*/ 
Validate()	/* validates given input */
{
	char	e_mesg[80] ;
	int	i,j;

	switch(sr.curfld){
	case COMP_FLD :	/* Company or School District */
		if(s_sth.s_co_dist[0] != COMPANY && 
				s_sth.s_co_dist[0] != SCH_FLG) {
#ifdef	ENGLISH
			fomer("Enter C or S");
#else
			fomer("Entrer C ou S");
#endif
			s_sth.s_co_dist[0] = LV_CHAR ;
		}
		break ;
	case APS_FLD :	/* A/P System Present? */
		/* If A/P System not present skip reading of fields,
		   Cancel POs & Consolidated Chequing */
		if(!s_sth.s_aps) {	/* If not present */
			s_sth.s_cancel_po = 0 ;
			s_sth.s_grp_chqs = 0 ;
		}
		break ;
	case INV_FLD :	/* INV System Present? */
		/* If INV System present skip reading of fields,
		   Cancel POs */
		if(s_sth.s_stores) 	/* If present */
			s_sth.s_cancel_po = 0 ;
		break ;
	case OPNPER_FLD:	/* no. of open periods */
		if( s_sth.s_open_per > s_sth.s_no_periods ){
#ifdef ENGLISH
			fomen("No. of open periods can't exceed No. of periods");
#else
			fomen("Nombre de periodes ouvertes ne peut pas depasser le nombre de periodes");
#endif
			s_sth.s_open_per = LV_SHORT;
		}
		break;
	case BDGT_KEY_FLD:	 	/* Budget Key 1 */
	case BDGT_KEY_FLD + 100:	/* Budget Key 2 */
	case BDGT_KEY_FLD + 200:	/* Budget Key 3 */
	case BDGT_KEY_FLD + 300:	/* Budget Key 4 */
	case BDGT_KEY_FLD + 400:	/* Budget Key 5 */
	case BDGT_KEY_FLD + 500:	/* Budget Key 6 */
	case BDGT_KEY_FLD + 600:	/* Budget Key 7 */
		i = (sr.curfld - BDGT_KEY_FLD) / 100 ;

		if(s_sth.s_bdgt_keys[i] > NO_KEYS) {
#ifdef ENGLISH
			fomer("Should Be Between 0 and 12") ;
#else
			fomer("Devrait etre entre 0 et 12") ;
#endif
			s_sth.s_bdgt_keys[i] = LV_SHORT ;
			break;
		}

		if(s_sth.s_bdgt_keys[i] == 0) break;

		/* Check whether the given key is already given */
		if(i){	/* 2nd key onwards */
			for(j = 0 ; j <= (i - 1) ; j++)
			    if(s_sth.s_bdgt_keys[i] == s_sth.s_bdgt_keys[j]) {
#ifdef ENGLISH
				fomer("Already Given");
#else
				fomer("Deja donne");
#endif
				s_sth.s_bdgt_keys[i] = LV_SHORT ;
				break;
			    }
		}
		break;
	case CONS_KEY_FLD:
		if(s_sth.s_cons_key < 1 || s_sth.s_cons_key > NO_KEYS) {
#ifdef ENGLISH
			fomer("Should Be Between 1 and 12") ;
#else
			fomer("Devrait etre entre 1 et 12") ;
#endif
			s_sth.s_cons_key = LV_SHORT ;
			break;
		}
		break;
	case CC_KEY_FLD:
		if(s_sth.s_cc_key < 1 || s_sth.s_cc_key > NO_KEYS) {
#ifdef ENGLISH
			fomer("Should Be Between 1 and 12") ;
#else
			fomer("Devrait etre entre 1 et 12") ;
#endif
			s_sth.s_cc_key = LV_SHORT ;
			break;
		}
		break;
	case TB_KEY_FLD:
		if(s_sth.s_tb_key < 0 || s_sth.s_tb_key > NO_KEYS) {
#ifdef ENGLISH
			fomer("Should Be Between 0 and 12") ;
#else
			fomer("Devrait etre entre 0 et 12") ;
#endif
			s_sth.s_tb_key = LV_SHORT ;
			break;
		}
		break;
	case PURLIMIT_FLD:
		if(s_sth.s_purlimit < 0.00) {
#ifdef ENGLISH
			fomer("Purchasing limit cannot be zero");
#else
			fomer("Limite d'achat ne peut pas etre zero");
#endif
			s_sth.s_purlimit = LV_DOUBLE;
			break;
		}
		break;
	case GST_FLD:
		if(s_sth.s_gst_tax[0] == '\0')
			sr.curfld+=100;
		if(s_sth.s_gst_tax[0]!=TAXABLE && s_sth.s_gst_tax[0]!=EXEMPT){
#ifdef	ENGLISH
			fomer("Valid Tax codes are T(axable) or E(xempt)");
#else
			fomer("Codes valides de taxe sont T(axable) ou E(xempte)");
#endif
			s_sth.s_gst_tax[0] = LV_CHAR;
		}
		break;
	case PST_FLD:
		if(s_sth.s_pst_tax[0] == '\0')
			sr.curfld+=100;
		if(s_sth.s_pst_tax[0]!=TAXABLE && s_sth.s_pst_tax[0]!=EXEMPT){
#ifdef	ENGLISH
			fomer("Valid Tax codes are T(axable) or E(xempt)");
#else
			fomer("Codes valides de taxe sont T(axable) ou E(xempte)");
#endif
			s_sth.s_pst_tax[0] = LV_CHAR;
		}
		break;
	default :
#ifdef ENGLISH
		sprintf(e_mesg,"No Validity Check For Field#  %d",sr.curfld);
#else
		sprintf(e_mesg,"Pas de controle de validite pour le Champ# %d",sr.curfld);
#endif
		fomen(e_mesg);
		get();
	}
	sr.nextfld = sr.curfld;
	return(NOERROR);
}	/* Validate() */
/*-----------------------------------------------------------------------*/
/* Display the confirmation message at the bottom of the screen, take the
   option from user and call necessary functions */
ReadOption()
{
	int	err ;

	for( ; ; ) {
#ifdef	ENGLISH
		err = GetOpt("Y(es), E(dit), C(ancel)","YEC");
#else
		err = GetOpt("O(ui), M(odifier), A(nnuler)","OMA");
#endif

		if(err == PROFOM_ERR) return(err) ;

		switch(err) {
			case  YES :
				return(YES) ;
			case  EDIT  :
				err = ReadScreen();
				if(err!=NOERROR) return(ERROR);
				break ;
			case  CANCEL :
#ifdef	ENGLISH
				err = GetOpt("Confirm the Cancel (Y/N)?", "YN") ;
#else
				err=GetOpt("Confirmer l'annulation (O/N)?","ON");
#endif
				if(err == YES) return(CANCEL) ;
				break ;
		}	/* switch err */

		if(err == PROFOM_ERR) return(err) ;
	}	/* for(; ; ) */
}	/* ReadOption() */
/*-----------------------------------------------------------------------*/
/* Display message and get the option */
GetOpt(msg,options)
char	*msg ;
char	*options ;
{
	int	i, j ;

	STRCPY(s_sth.s_mesg,msg);

	sr.nextfld = END_FLD - 100 ;
	sr.endfld = END_FLD ;
	for( ; ; ) {
		s_sth.s_resp[0] = LV_CHAR ;
		fomrd((char*)&s_sth) ;
		ret(err_chk(&sr)) ;

		j = strlen(options) ;
		for( i = 0 ; i < j ; i++)
			if(s_sth.s_resp[0] == options[i]) break ;
		if(i != j) break ;	/* Valid Option Selected */
#ifdef	ENGLISH
		fomer("Invalid Option..");
#else
		fomer("Option invalide..");
#endif
	}
	s_sth.s_mesg[0] = HV_CHAR ;
	s_sth.s_resp[0] = HV_CHAR ;
	sr.nextfld = END_FLD - 100 ;
	sr.endfld = END_FLD ;
	fomwr((char*)&s_sth) ;
	ret(err_chk(&sr)) ;

	return((int)(options[i])) ;
}	/* GetOpt() */
/*-----------------------------------------------------------------------*/
/* Copy the screen info to Param struct and creat Param file */
RiteRecord()
{
	int	code, write_mode ;

	if(pa_exist == 0) {
		write_mode = UPDATE;
		code = ReadParam(write_mode) ;
		if(code == ERROR) {
			roll_back(e_mesg);
			return(ERROR) ;
		}
	}
	else
		write_mode = ADD;
		
	CopyToRecord() ;

	chg_flg = scmp((char *)&pre_rec,(char *)&pa_rec,sizeof(pa_rec));
	if(chg_flg == 0)	/* No changes made */
		return(NOERROR);
		
	code = put_param(&pa_rec, write_mode, 1, e_mesg) ;

	if(code < 0){
#ifdef ENGLISH
		DispError("ERROR in Saving Records"); 
#else
		DispError("ERREUR en conservant les fiches");
#endif
		DispError(e_mesg) ;
		roll_back(e_mesg);
		return(DBH_ERR);
	}

	code=rite_audit((char*)&s_sth,PARAM,write_mode,(char*)&pa_rec,(char*)&pre_rec,e_mesg);
	if(code==LOCKED) {
		DispError(e_mesg);
		roll_back(e_mesg);
		return(LOCKED);
	}

	if(code != NOERROR){
#ifdef ENGLISH
		DispError("ERROR in Saving Records"); 
#else
		DispError("ERREUR en conservant les fiches");
#endif
		DispError(e_mesg) ;
		roll_back(e_mesg);
		return(DBH_ERR);
	}

	if(commit(e_mesg) < 0) {
#ifdef ENGLISH
		DispError("ERROR in Saving Records"); 
#else
		DispError("ERREUR en conservant les fiches");
#endif
		DispError(e_mesg) ;
		return(DBH_ERR);
	}
	return(NOERROR);
}
/*-----------------------------------------------------------------------*/
/* Copy the data record fields to Scrren and display the scrren */
CopyToScreen()
{
	STRCPY(s_sth.s_comp_nm, pa_rec.pa_co_name) ;
	s_sth.s_distccno = pa_rec.pa_distccno ;
	s_sth.s_wareccno = pa_rec.pa_wareccno ;
	s_sth.s_co_dist[0] = pa_rec.pa_co_or_dist[0] ;

	if(pa_rec.pa_aps[0] == YES)
		s_sth.s_aps = 1 ;
	else
		s_sth.s_aps = 0 ;

	if(pa_rec.pa_requisition[0] == YES)
		s_sth.s_requisition = 1 ;
	else
		s_sth.s_requisition = 0 ;

	if(pa_rec.pa_poinv[0] == YES)
		s_sth.s_poinv = 1 ;
	else
		s_sth.s_poinv = 0 ;

	if(pa_rec.pa_stores[0] == YES)
		s_sth.s_stores = 1 ;
	else
		s_sth.s_stores = 0 ;

	if(pa_rec.pa_fa[0] == YES)
		s_sth.s_fa = 1 ;
	else
		s_sth.s_fa = 0 ;

	if(pa_rec.pa_ars[0] == YES)
		s_sth.s_ars = 1 ;
	else
		s_sth.s_ars = 0 ;

	if(pa_rec.pa_tendering[0] == YES)
		s_sth.s_tendering = 1 ;
	else
		s_sth.s_tendering = 0 ;

	if(pa_rec.pa_rotational[0] == YES)
		s_sth.s_rotational = 1 ;
	else
		s_sth.s_rotational = 0 ;

	if(pa_rec.pa_aps[0] == YES && pa_rec.pa_pos[0] == YES)
		s_sth.s_cancel_po = 1 ;
	else
		s_sth.s_cancel_po = 0 ;

	if(pa_rec.pa_budget[0] == YES)
		s_sth.s_budget = 1;
	else
		s_sth.s_budget = 0;

	if(pa_rec.pa_dist_gst[0] == YES)
		s_sth.s_dist_gst = 1;
	else
		s_sth.s_dist_gst = 0;

	if(pa_rec.pa_funds[0] == YES)
		s_sth.s_more_cntl = 1 ;
	else
		s_sth.s_more_cntl = 0 ;

	if(pa_rec.pa_glmast[0] == YES)
		s_sth.s_gl_present = 1 ;
	else
		s_sth.s_gl_present = 0 ;

	if(pa_rec.pa_aps[0] == YES && pa_rec.pa_cheque[0] == YES)
		s_sth.s_grp_chqs = 1 ;
	else
		s_sth.s_grp_chqs = 0 ;

	s_sth.s_no_periods = pa_rec.pa_no_periods ;
	s_sth.s_open_per = pa_rec.pa_open_per ;
	s_sth.s_cur_period = pa_rec.pa_cur_period ;

	s_sth.s_key_hdg[0] = ' ';

	s_sth.s_bdgt_keys[0] = pa_rec.pa_bdgt_key1;
	s_sth.s_bdgt_keys[1] = pa_rec.pa_bdgt_key2;
	s_sth.s_bdgt_keys[2] = pa_rec.pa_bdgt_key3;
	s_sth.s_bdgt_keys[3] = pa_rec.pa_bdgt_key4;
	s_sth.s_bdgt_keys[4] = pa_rec.pa_bdgt_key5;
	s_sth.s_bdgt_keys[5] = pa_rec.pa_bdgt_key6;
	s_sth.s_bdgt_keys[6] = pa_rec.pa_bdgt_key7;

	s_sth.s_cons_key = pa_rec.pa_cons_key;
	s_sth.s_cc_key = pa_rec.pa_cc_key;
	s_sth.s_tb_key = pa_rec.pa_tb_key;

	s_sth.s_purlimit = pa_rec.pa_purlimit;

	s_sth.s_due_days_po = pa_rec.pa_due_days_po;
	s_sth.s_due_days_ap = pa_rec.pa_due_days_ap;
	s_sth.s_due_days_ar = pa_rec.pa_due_days_ar;

	STRCPY(s_sth.s_regist, pa_rec.pa_regist);
	s_sth.s_gst_tax[0] = pa_rec.pa_gst_tax[0];
	s_sth.s_pst_tax[0] = pa_rec.pa_pst_tax[0];


	/* Display the Screen */
	sr.nextfld = 1 ;
	sr.endfld = 0 ;
	fomwr((char*)&s_sth);
	return(NOERROR) ; 
}
/*-----------------------------------------------------------------------*/
/* Copy the Scrren fields to data record */
CopyToRecord()
{
	STRCPY(pa_rec.pa_co_name, s_sth.s_comp_nm) ;
	pa_rec.pa_distccno = s_sth.s_distccno ;
	pa_rec.pa_wareccno = s_sth.s_wareccno ;
	pa_rec.pa_co_or_dist[0] = s_sth.s_co_dist[0] ;

	if(s_sth.s_aps)
		pa_rec.pa_aps[0] = YES ;
	else
		pa_rec.pa_aps[0] = NO ;
	if(s_sth.s_requisition)
		pa_rec.pa_requisition[0] = YES ;
	else
		pa_rec.pa_requisition[0] = NO ;
	if(s_sth.s_poinv)
		pa_rec.pa_poinv[0] = YES ;
	else
		pa_rec.pa_poinv[0] = NO ;
	if(s_sth.s_cancel_po)
		pa_rec.pa_pos[0] = YES ;
	else
		pa_rec.pa_pos[0] = NO ;
	if(s_sth.s_stores)
		pa_rec.pa_stores[0] = YES ;
	else
		pa_rec.pa_stores[0] = NO ;
	if(s_sth.s_fa)
		pa_rec.pa_fa[0] = YES ;
	else
		pa_rec.pa_fa[0] = NO ;
	if(s_sth.s_ars)
		pa_rec.pa_ars[0] = YES ;
	else
		pa_rec.pa_ars[0] = NO ;
	if(s_sth.s_tendering)
		pa_rec.pa_tendering[0] = YES ;
	else
		pa_rec.pa_tendering[0] = NO ;
	if(s_sth.s_rotational)
		pa_rec.pa_rotational[0] = YES ;
	else
		pa_rec.pa_rotational[0] = NO ;
	if(s_sth.s_budget)
		pa_rec.pa_budget[0] = YES ;
	else
		pa_rec.pa_budget[0] = NO ;
	if(s_sth.s_dist_gst)
		pa_rec.pa_dist_gst[0] = YES ;
	else
		pa_rec.pa_dist_gst[0] = NO ;
	if(s_sth.s_more_cntl)
		pa_rec.pa_funds[0] = YES ;
	else
		pa_rec.pa_funds[0] = NO ;
	if(s_sth.s_gl_present != HV_INT && s_sth.s_gl_present)
		pa_rec.pa_glmast[0] = YES ;
	else
		pa_rec.pa_glmast[0] = NO ;
	if(s_sth.s_grp_chqs == 1)
		pa_rec.pa_cheque[0] = YES ;
	else
		pa_rec.pa_cheque[0] = NO ;

	pa_rec.pa_no_periods = s_sth.s_no_periods ;
	pa_rec.pa_open_per = s_sth.s_open_per ;
	pa_rec.pa_cur_period = s_sth.s_cur_period ;

	pa_rec.pa_bdgt_key1 = s_sth.s_bdgt_keys[0];
	pa_rec.pa_bdgt_key2 = s_sth.s_bdgt_keys[1];
	pa_rec.pa_bdgt_key3 = s_sth.s_bdgt_keys[2];
	pa_rec.pa_bdgt_key4 = s_sth.s_bdgt_keys[3];
	pa_rec.pa_bdgt_key5 = s_sth.s_bdgt_keys[4];
	pa_rec.pa_bdgt_key6 = s_sth.s_bdgt_keys[5];
	pa_rec.pa_bdgt_key7 = s_sth.s_bdgt_keys[6];

	pa_rec.pa_cons_key = s_sth.s_cons_key;
	pa_rec.pa_cc_key = s_sth.s_cc_key;
	pa_rec.pa_tb_key = s_sth.s_tb_key;

	pa_rec.pa_purlimit = s_sth.s_purlimit;

	pa_rec.pa_due_days_po = s_sth.s_due_days_po;
	pa_rec.pa_due_days_ap = s_sth.s_due_days_ap;
	pa_rec.pa_due_days_ar = s_sth.s_due_days_ar;
	STRCPY(pa_rec.pa_regist, s_sth.s_regist);
	pa_rec.pa_gst_tax[0] = s_sth.s_gst_tax[0];
	pa_rec.pa_pst_tax[0] = s_sth.s_pst_tax[0];

	pa_rec.pa_date = s_sth.s_rundate ;

}
/*------------------------------------------------------------------------*/
/* Initialize screen data fields with Low Values */
MoveLows()
{
	int	i;

	/* if parameters already exist and not run through menu  */
	/* set dup buffers before moving lows to the remaining fields */
	/* for edit purposes */
	if(pa_exist==0 && SW5==0) {
		for(i = ST_FLD ; i <= END_FLD - 200  ; i += 100)
			fomca1(i,19,2); /* Enable Dup control */

		/* Update Dup Buffers */
		sr.nextfld = ST_FLD ;
		sr.endfld = END_FLD - 200 ;
		fomud((char*)&s_sth);
		ret(err_chk(&sr));
	}

	if(pa_exist == 1 || SW5==0) {
		s_sth.s_rundate = LV_LONG ;

		s_sth.s_comp_nm[0] = LV_CHAR ;
		s_sth.s_distccno = LV_SHORT;
		s_sth.s_wareccno = LV_SHORT;
		s_sth.s_co_dist[0] = LV_CHAR ;
		s_sth.s_aps = LV_INT ;
		s_sth.s_requisition = LV_INT ;
		s_sth.s_poinv = LV_INT ;
		s_sth.s_stores = LV_INT ;
		s_sth.s_fa = LV_INT ;
		s_sth.s_ars = LV_INT ;
		s_sth.s_tendering = LV_INT ;
		s_sth.s_rotational = LV_INT ;
		s_sth.s_cancel_po = LV_INT ;
		s_sth.s_budget = LV_INT;
		s_sth.s_dist_gst = LV_INT;
		s_sth.s_more_cntl = LV_INT ;
		if(SW5==1) 
			s_sth.s_gl_present = HV_INT ;	
		else 
			s_sth.s_gl_present = LV_INT ;	
		/* Don't show above field while adding, copy 'N' to record */
		/* This flag will be updated in glmast program */
		s_sth.s_grp_chqs = LV_INT ;

		s_sth.s_no_periods = LV_SHORT ;
		s_sth.s_open_per = LV_SHORT ;
		s_sth.s_cur_period = LV_SHORT ;
	}
	/* if parameters already exist and run through menu set dup buffers */
	/* before moving lows to the remaining fields for edit purposes */
	if(pa_exist == 0 && SW5==1) {
		for(i = BDGT_KEY_FLD ; i <= END_FLD - 200  ; i += 100)
			fomca1(i,19,2); /* Enable Dup control */

		/* Update Dup Buffers */
		sr.nextfld = BDGT_KEY_FLD ;
		sr.endfld = END_FLD - 200 ;
		fomud((char*)&s_sth);
		ret(err_chk(&sr));
	}

	s_sth.s_key_hdg[0] = ' ' ;

	for(i = 0; i < USER_KEYS; i++)
		s_sth.s_bdgt_keys[i] = LV_SHORT;

	s_sth.s_cons_key = LV_SHORT;
	s_sth.s_cc_key = LV_SHORT;
	s_sth.s_tb_key = LV_SHORT;
	s_sth.s_purlimit = LV_DOUBLE;
	s_sth.s_due_days_po = LV_SHORT;
	s_sth.s_due_days_ap = LV_SHORT;
	s_sth.s_due_days_ar = LV_SHORT;
	s_sth.s_regist[0] = LV_CHAR;
	s_sth.s_gst_tax[0] = LV_CHAR;
	s_sth.s_pst_tax[0] = LV_CHAR;

}	/* MoveLows() */
/*----------------------------------------------------------------*/
static
DispError(s)	/* Display the message */
char	*s ;
{
	STRCPY(s_sth.s_mesg, s) ;
	sr.nextfld = END_FLD - 100;
	fomwf((char*)&s_sth) ;
#ifdef	ENGLISH
	fomen("Press any key to continue");
#else
	fomen("Appuyer sur une touche pour continuer");
#endif
	get();
	s_sth.s_mesg[0] = HV_CHAR;
	sr.nextfld = END_FLD - 100;
	fomwf((char*)&s_sth) ;

	return(ERROR) ;
}

/*-------------------- E n d   O f   P r o g r a m ---------------------*/

