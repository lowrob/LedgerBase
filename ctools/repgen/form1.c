/*
*	File Name  : form.c
*
*	Compilation: cc form.c win.o -lfom -o form	
*	Usage	   : form projcode termname report#
*	Written by : V.SUBRAMANI					  
*		     Started on 14th april 87
*
*		This is a screen program used to define the output report
*	format by the end-user. This gets the `report` number and Common
*	system file as arguments. User can creat several formats(Max. of 9)
*	for one report but recently created/updated one will be used for
*	report generation. This updates the `proj.RPFM` - format file.
*	At the first time it displays the default format(first)and if
*	there are more than one formats for a report already defined,
*	then user can display available formats in a window Field names
*	can also be displayed in a  window.			  
*/

/*
*	Supported Escape characters
*
*	Esc-E	- Exit from the current edit, format not saved.	
*	Esc-P	- Go to previous field.
*	Esc-D 	- Delete the current item.
*	Esc-H	- Display the Help message/window.
*/

/*
*	Default values displayed
*
*	JUSTIFICATION :
*			NUMERIC fields RIGHT justified.
*			CHARACTER fields LEFT justified.
*
*			Optionally can be CENTRE justified.	
*	EDIT-MASKS :
*		Defined in rep.h.
*	LENGTH :
*		Defined in rep.h.
*/

/*
*	COMPUTATIONAL FIELDS
*
*	Are represented as CO for COMPUTE FIELD.
*	Available input fields(only numeric) can be used and referred as i[f#]
*	where f# is field serial number displayed on the help window.
*	Refer comment  alter_rp() routine.
*/

/*
*	FIELD SIZE
*
*	Maximum of Field size specified and length of Edit masks.
*/

/******	
#define DEBUG
*******/

#include <stdio.h>
#include <cfomstrc.h>
#include "rep.h"		/* format def. file */
#include "repname.h"		/* report name def. file */
#include "struct.h"		/* structure def. file */
#include <ctype.h>

#define EXIT		-1
#define CONTINUE	1
#define HELP		2
#define DELETE		3
#define PREV		4	/* field backword */
#define NOTSUPP		5	/* this esc- char not supported */

/** Window selection characters */
#define SELECTED	1 	/* item selected from the window */
#define NOTSELECTED	0	/* No item selected */

#define CHKEXIT(X)	if(X == EXIT) if(Exit_prompt() == EXIT) return(EXIT) ;\
					else continue 
 
#define FORMSCREEN	"repform"


/** Define all field numbers in the screen */
#define START_FIELD	100
#define	PROJECT		300
#define	REP_NO		400
#define	REP_NAME	500
#define FOR_NO		600
#define FOR_NAME	700
#define PG_COLUMNS	800
#define PG_LINES	900
#define LINESPACE 	1000
#define	MAIN_START	1100
#define	MAIN_END	1300
#define	REP_START	1400
#define	REP_END		4300
#define	SEL_FUNCT	4400
#define ATTR_START	4500
#define	CUR_FIELD	4500
#define	CUR_TYPE	4600
#define	CUR_CLASS	4700
#define COMP_EQA	4800
#define REPEATSUPPRESS  4900
#define	CUR_TITLE	5000
#define CUR_WIDTH	5100
#define CUR_TOTFLAG	5200
#define	JUSTIFY		5300
#define	EDIT_MASK	5400
#define MINBOUND	5500
#define MAXBOUND	5600
#define ATTR_END	5600
#define PB_SUPFLD	5700
#define SUB_SUPFLD	5800
#define	PBNO_START	5900
#define	PBNO_END	6000
#define	SBNO_START	6100
#define	SBNO_END	6300
#define PBTO_START	6400
#define	PBTO_END	6500
#define SBTO_START	6600
#define	SBTO_END	6800
#define PBMSG_START	6900
#define PBMSG_END	7000
#define MSG_START	7100
#define MSG_END		7300
#define PBMASK_START 	7400
#define PBMASK_END	7500
#define KEYMASK_START 	7600
#define KEYMASK_END	7800
#define	PROMPT		7900
#define	PMT_YES		8000
#define END_FIELD	8000

/* repform.sth - header for C structure generated by PROFOM EDITOR */

struct	rep_form	{

	char	Proj_name[11] ;	/* Project */
	short	Rep_no ;	/* Report# */
	char	Rep_name[21];	/* Report name */
	short	For_no ;	/* Format# */
	char	For_name[21];	/* Format Name */
	short	Pg_columns ;	/* #of columns per page */
	short	Pg_lines ;	/* #of lines per page */
	short 	Pg_linspace ;	/* between two output lines, space required */ 
	char	Main_head[3][80];/* Report header. */
	char	Rep_field[30][4];/* Reporting fields */
	char 	Sel_funct[2] ;	/* Fuction field, to display select fields */
				/* Next/Previous/write format record allowed*/
				/* field Number */

	char	Cur_field[21];	/* Field Name displayed currently */
	char	Cur_type[5];	/* Current field type 2600 - CHAR/NUM./ACC */
	char	Cur_class[6];	/* Current field class - INPUT/COMPutational */
	char	Comp_eqa[51] ;	/* if CIMPfield, Comp. Equation */
	int	Repeatsuppress; /* if value is repeated, show blank? */	
	char	Cur_title[21] ;	/* field title */
	short 	Cur_width ;	/* width of the string - only for CHAR */
	int	Cur_totflag ;	/* to be totalled? */
	char	Justify[2];	/* Justification - RIGHT/LEFT */
	char	Edit_mask[16];	/* if NUM., Edit masks */
	char	Minbound[11];	/* Mininum valid input value */
	char	Maxbound[11];	/* Maximum valid input value */
	char	Pb_supfld[2] ;	/* Page Break&total prompt suppress field */
	char	Sub_supfld[2] ;	/* sub. total prompt suppress field */
	short	Pb_no[2] ;	/* Page Break field nos.  */
	short	Sub_no[3] ;	/* subtotal field nos.  */
	char	Pb_totflds[2][21];	/* Page Break total fields  */
	char	Sub_totflds[3][21];	/* Sub total fields  */
	char	Pb_text[2][31] ;	/* Page Break Flds Prompts */
	char	Msg_text[3][31] ;	/* Sub-Total Flds Prompts */
	char 	Pbedit_mask[2][16] ;	/* Edit mask for key value, display */
	char 	Keyedit_mask[3][16] ;	/* Edit mask for key value, display */
	char	Prompt[76] ;	/* Confir,m. string */
	int	Pmt_yes ;	/* User input string */
	};

static struct rp_name	Rep_struct ;	/* defined repname.h */
static struct stat_rec	sr ;		/* profom status rec. */
static struct	rep_form screen ;	/* format screen */
static int	retcode ;		/* normally, return value of
					   profom call */

static char	strucbuf[STRBUFSIZE] ;	/* buffer for structure def. rec. */
static FLDINFO	*strfld ;
static INHDR	*strhead ;		/* def. in struct.h */



/* Used to store all the fields under a particular report in a list */
static struct fld_list {
	short	Fldno ;			/* field no. in the record */
	short	Recno ;			/* Index in the record array 0 - 4 */
	char	Fldname[NAME_LEN] ;	/* fld name, given in comment string */
	char 	Fld_typ ;		/* field type, INT,SHORT,LONG.. */
	short 	Fld_size ;		/* field length */
	struct fld_list	*nxtfld ;	/* ptr. to the next element */
	} ; 
static struct fld_list *Fld_lsptr ;

static char Form_name[MAXFORMAT][NAME_LEN] ;	/* all format names under */
						/* a report are stored */

/* Used to Store all the report fields selected for the current format */

static struct rep_fld_list {
	short	Sl_fldserno ;		/* serial no. displayed on the window */
	FIELDNO Sl_fldno ;		/* fld and rec. no */
	char	Sl_fldname[L_NAME] ;	/* field name */
	char 	Sl_type ;		/* field type, INT,SHORT,LONG.. */
	char	Sl_totflag ;		/* To be totalled */
	char	Sl_class ;		/* COMP_FLD / INP_FLD */
	char 	Sl_repeatsuppress ;
	char	Sl_edit_mask[16] ;
	char	Sl_compeqa[51] ;	/* stored as entered in the screen */
	char	Sl_polcomp[50] ;	/* reverse poslish form of comp. */
	char 	Sl_justify ; 		/* verify and reduce the length */
	char	Sl_title[21] ;		/* field title */
	short	Sl_size ;
	char	Sl_minbound[11] ;
	char 	Sl_maxbound[11] ;
	} Sl_fldlst[MAX_REPFLD] ;

static short norepflds ;	/* #of report flds stored in the above array*/
static FIELDNO subtotflds[3] ;	/* store subtotal field nos whose names are *
				/* displayed on the screen */
static FIELDNO pbtotflds[2] ;	/* sub header fields */
	
static short cur_formno ;	/* current format being displayed  */
				/* 0 means new form, > 0 means formno. */

static short cur_repno ;	/* displayed report no., argv[3] */

static union numcharfld {
	int INTfieldno ;	/* Integer value of field no */
	char CHRfieldno[4] ;	/* Character value of field no. */
}	ICfield ;

static char prom_buf[80] ;	/* used to display prompt messave */

static int fds ;		/* file fd for struct. def. file. proj.in */
static int fdr ;		/* file fd for reports file */
static int fdf ;		/* file fd for format def. file */


/** system functions */
char *malloc() ;
long lseek() ;

/*** Define functions and prototype ***/
static int maxltitle(char *);
static int itoa(int, char *);
static int alter_rp(char *, char *); 

main(argc,argv)
int argc ;
char **argv ;
{
	int 	i, j ;
	char	*s_ptr ;
	char	*nfmdir;
	char	*getenv();

	if(argc < 4) {
		printf("Usage : %s proj termname report#\n",argv[0]) ;
		return(0) ;
	}

	/* define the address to the ptrs */
	fldglob = (struct f_global *)frmbuf ;
	fldattri = (struct f_attri *) (fldglob + 1) ;
	
	strhead = (INHDR *)(strucbuf) ;
	strfld = (FLDINFO *)(strhead + 1) ;

	Get_reprec(argv[1],argv[3]) ;	/* open report file&read given report */
	Open_files(argv[1]) ;	/* struct. input and format def. file */

	Cr_frmlist() ;	/* read all format names and store in global array */

	Cr_fldlist() ;	/* read structure def. blocks and form list of names */
			/* Keep the first format in the buffer at the end */
	
	nfmdir = getenv("CTOOLS");/* Added to get the path L.R*/
	if(nfmdir == NULL){
#ifdef ENGLISH
		printf("\"CTOOLS\" environment variable is not exported\n");
#else
		printf("\"CTOOLS\"Variable de l'environnement n'est pas exportee\n");
#endif
		exit(-1) ;
	}
/* NFM_PATH has been commented out in repname.h to avoid hard coding of the path L.R.
	strcpy(sr.scrnam,NFM_PATH) ;*/

	strcpy(sr.scrnam,nfmdir) ; /* Added to replace NFM_PATH L.R. 07/05/93*/
	strcat(sr.scrnam,"/") ;
	strcat(sr.scrnam,FORMSCREEN) ;
	strcpy(sr.termnm,argv[2]) ;


	/*
	*	Copy the program name to PROG_NAME form argv[0]
	*	upto '.'. Supress the path name if it exists.
	*/ 

	j = strlen(argv[1]) ;	/* Length of the program name */

	/* Find out the first slash, in backwards */
	for( j-- ; j > 0 ; j--)
		if(*(argv[1]+j) == '/' || *(argv[1]+j) == '\\'){
			j++ ;	/* Position to 1st char after '/' */
			break ;
		}

	s_ptr = argv[1]+j ;

	/* Copy the program name up to '.' */
	for(i = 0 ; *s_ptr && i < 10 && *s_ptr != '.' ; s_ptr++, i++) 
		*(screen.Proj_name+i) = *s_ptr;

	screen.Proj_name[i] = '\0'; 

/***
	strncpy(screen.Proj_name,argv[1],10) ;	* Copy Project Name *
***/

	fomin(&sr) ;
   	chkerror() ;

	Disp_repname() ;	/* if some format is already present, then
				   display the first format */
	Proc_screen() ;	/* finally returns the selected format no. */

	Close_files() ;
#ifdef DEBUG
	fprintf(stderr,"formrecs :%d\n",Rep_struct.formrecs) ;
#endif
	fomcs() ;
	fomrt() ;
	fprintf(stderr,"RECENTLY SELECTED FORMAT#: %d\n",
		Rep_struct.formoff[cur_formno - 1]) ; 
	exit(Rep_struct.formoff[cur_formno-1]) ; 
		  /* so, all abnormal exits should return negative no. */
	       	  /* to differentiate from format no. returned */
}

/* Open the report file and read the required rec. */

Get_reprec(proj,repno)
char 	*proj,
	*repno ;
{
	char repfile[FILE_NAME_LEN] ;

	strcpy(repfile,proj) ;
	strcat(repfile,REPNAME) ;	/* report file name */

	if((fdr = open(repfile,RWMODE)) < 0) 
		fprintf(stderr,"%s file open error : append\n",repfile) ,
		fprintf(stderr,"Module : form. Func : Get_reprec\n"),
		abexit(OPENERR) ;

	cur_repno = atoi(repno) ;
	if(cur_repno < 1)
		fprintf(stderr,"Report number out of range\n") ,
		fprintf(stderr,"Module : repform. Func : Get_reprec\n"),
		abexit(INTERR) ;

	cur_repno-- ;


#ifdef DEBUG
	fprintf(stderr,"repno : %d\n",cur_repno) ;
#endif

	if(lseek(fdr,(long)(cur_repno * sizeof(struct rp_name)),0) < 0)
		fprintf(stderr,"%s file seek error\n",repfile) ,
		fprintf(stderr,"Module : repform. Func : Get_reprec\n"),
		abexit(SEEKERR) ;

	if(read(fdr,(char *)&Rep_struct,sizeof(struct rp_name)) !=
						sizeof(struct rp_name))
		fprintf(stderr,"%s file read error\n",repfile) ,
		fprintf(stderr,"Module : repform. Func : Get_reprec\n"),
		abexit(READERR) ;

	return(NOERROR) ;
}



/* Open structure and format file  */

Open_files(proj)
char 	*proj ;
{
	char filename[FILE_NAME_LEN] ;
	
	/* make structure input file name */
	
	strcpy(filename,proj) ;
	strcat(filename,STRFILE) ;
#ifdef DEBUG
	fprintf(stderr,"strc. file :%s\n",filename) ;
#endif

	/* open structure file in read mode */
	if((fds = open(filename,RDMODE)) < 0) 
		fprintf(stderr,"%s file open error : read mode\n",filename) ,
		fprintf(stderr,"Module : repform. Func : Open_files\n"),
		abexit(OPENERR) ;
	
	
	strcpy(filename,proj) ;
	strcat(filename,FRMFILE) ;
#ifdef DEBUG
	fprintf(stderr,"format file :%s\n",filename) ;
#endif
	
	/* make format file name */	
	if(access(filename,0) < 0) {
		if((fdf = creat(filename,CRMODE)) < 0) 
			fprintf(stderr,"%s file create error :0664 mode\n",
							filename) ,
			fprintf(stderr,"Module : repform. Func : Open_files\n"),
			abexit(CREATERR) ;
		close(fdf) ;
	}

	/* open format file in append mode */
	if((fdf = open(filename,RWMODE)) < 0) 
		fprintf(stderr,"%s file open error :append mode\n",filename) ,
		fprintf(stderr,"Module : repform. Func : Open_files\n"),
		abexit(OPENERR) ;
	
	return(NOERROR) ;
}


/** Close all the opened files */

Close_files() 
{
	close(fdr) ;
	close(fds) ;
	close(fdf) ;
	return(NOERROR) ;
}


/** Read  format recs one by one and put the format names in an array */

Cr_frmlist() 
{
	int i ;

	for(i = 0; i < Rep_struct.formrecs ; i++) {
		if(lseek(fdf,(long)(Rep_struct.formoff[i] * FRMBUFSIZE),0) < 0)
			fprintf(stderr,"Seek error :formoff : %d\n",
						Rep_struct.formoff[i]) ,
			fprintf(stderr,"Module : repform. Func : Cr_frmlist\n"),
			abexit(SEEKERR) ;

		if(read(fdf,frmbuf,FRMBUFSIZE) < FRMBUFSIZE)
			fprintf(stderr,"format block read error\n"),
			fprintf(stderr,"Module : repform. Func : Cr_frmlist\n"),
			abexit(READERR) ;

		strcpy(Form_name[i],fldglob->formname)  ;
	}

	if(i == 0) {
#ifdef DEBUG
		fprintf(stderr,"No format is defined\n") ;
#endif
		cur_formno = 0 ;
	}
	
	return(NOERROR) ;
}


/** read the format rec. pointed to by `cur_formno` **/

Read_curform()
{
	/* validate the form. no */
	if(cur_formno < 1 || cur_formno > Rep_struct.formrecs)
		fprintf(stderr,"Current format is out of bound : %d\n",
								cur_formno) ,
		fprintf(stderr,"Module : repform. Func : Read_curform\n"),
		abexit(INTERR) ;
		
	if(lseek(fdf,(long)(Rep_struct.formoff[cur_formno - 1] * FRMBUFSIZE),0)
									< 0)
		fprintf(stderr,"Seek error :formoff : %d\n",
					Rep_struct.formoff[cur_formno - 1]) ,
		fprintf(stderr,"Module : repform. Func : Read_curform\n"),
		abexit(SEEKERR) ;

	if(read(fdf,frmbuf,FRMBUFSIZE) < FRMBUFSIZE)
		fprintf(stderr,"format block read error\n"),
		fprintf(stderr,"Module : repform. Func : Read_curform\n"),
		abexit(READERR) ;

	return(NOERROR) ;
}


/* if it is a new format write at the end otherwise rewrite the existing */
/* format - Max of 10 formats per report is supported			 */

Write_curform()
{
	int i ;
	long writeaddress ;

	/** copy structure numbers */
	fldglob->Numrecs = Rep_struct.numstruct ;
	/** check the bound */
	if(fldglob->Numrecs < 1 || fldglob->Numrecs > MAXSTRUCT) {
		fprintf(stderr,"Consistency error : Numbrecs: %d\n",
			fldglob->Numrecs) ;
		fprintf(stderr,"Module:repform; Func: Write_curform\n"),
			abexit(INTERR) ;
	}

	for(i = 0 ; i < fldglob->Numrecs ; i++)
		fldglob->Inrecno[i] = Rep_struct.defstruct[i].strnum ;

	if(cur_formno == 0) {	/* new format */
#ifdef DEBUG
		fprintf(stderr,"New format to be added\n") ;
#endif
		if((writeaddress = lseek(fdf,0L,2)) < 0)
			fprintf(stderr,"Seek error :\n") ,
			fprintf(stderr,"Module: repform. Func:Write_curform\n"),
			abexit(SEEKERR) ;
	}

	else {	/* existing format to be updated */

		/* validate the `cur_formno` and rewrite */
		if(cur_formno < 1 || cur_formno > Rep_struct.formrecs)
			fprintf(stderr,"Current format# is out of bound: %d\n",
				cur_formno) ,
			fprintf(stderr,"Module : form. Func :Write_curform\n"),
			abexit(INTERR) ;

		if(lseek(fdf,(long)(((long)(Rep_struct.formoff[cur_formno - 1])) * FRMBUFSIZE),0) < 0)	
			fprintf(stderr,"Seek error :formoff\n") ,
			fprintf(stderr,"Module : form. Func : Write_curform\n"),
			abexit(SEEKERR) ;
	}

	/* write two format blocks */
	if(write(fdf,frmbuf,FRMBUFSIZE) < FRMBUFSIZE)
		fprintf(stderr,"format block write error\n"),
		fprintf(stderr,"Module : form. Func : Write_curform\n"),
		abexit(WRITEERR) ;

	if(cur_formno == 0) {	/* Newform so update the report record also*/

		/* post in the format name array */
		strcpy(Form_name[Rep_struct.formrecs],screen.For_name) ;		
		Rep_struct.formrecs += 1 ;
		Rep_struct.formoff[Rep_struct.formrecs - 1] =
					writeaddress / FRMBUFSIZE ;
		cur_formno = Rep_struct.formrecs ;
#ifdef DEBUG
		fprintf(stderr,"formrecs :%d\n",Rep_struct.formrecs) ;
#endif	
		if(lseek(fdr,(long)(cur_repno * sizeof(struct rp_name)),0) < 0)
			fprintf(stderr,"%d file seek error\n",cur_repno) ,
			fprintf(stderr,"Module : form. Func : Write_curform\n"),
			abexit(SEEKERR) ;

		if(write(fdr,(char *)&Rep_struct,sizeof(struct rp_name)) !=
							sizeof(struct rp_name))
			fprintf(stderr," file write error\n") ,
			fprintf(stderr,"Module : form. Func : Write_curform\n"),
			abexit(WRITEERR) ;
	}
	else	/* old format updated - format name might have been changed */
		strcpy(Form_name[cur_formno - 1],screen.For_name) ;
	return(NOERROR) ;
}


/* Delete current form being displayed. Validate the cur_formno and update */
/* report record. No need to rewrite format record			   */

Del_curform()
{
	int i ;

	/* validate the `cur_formno` and rewrite */
	if(cur_formno < 1 || cur_formno > Rep_struct.formrecs)
		fprintf(stderr,"Current format no. is out of bound : %d\n",cur_formno) ,
		fprintf(stderr,"Module : form. Func :Del_curform\n"),
		abexit(INTERR) ;

	/* discard the format address */

	for(i = cur_formno - 1; i < Rep_struct.formrecs - 1 ; i++) {
		Rep_struct.formoff[i] = Rep_struct.formoff[i + 1] ;
		strcpy(Form_name[i], Form_name[i+1]) ;
	}
	Rep_struct.formrecs -= 1 ;
	
	if(lseek(fdr,(long)(cur_repno * sizeof(struct rp_name)),0) < 0)
		fprintf(stderr,"%d Report file seek error\n",cur_repno) ,
		fprintf(stderr,"Module : form. Func : Del_curform\n"),
		abexit(SEEKERR) ;

	if(write(fdr,(char *)&Rep_struct,sizeof(struct rp_name)) != sizeof(struct rp_name))
		fprintf(stderr,"%d Report file write error\n",cur_repno) ,
		fprintf(stderr,"Module : form. Func : Del_curform\n"),
		abexit(WRITEERR) ;

	/* write the screen with next format */
	if(cur_formno - 1 == Rep_struct.formrecs)
		cur_formno -= 1 ;

	if(Rep_struct.formrecs == 0) {	/* this is a new format  */
		sr.nextfld = FOR_NO ;
		sr.endfld = FOR_NAME ;
		screen.For_no = 1 ;
		strcpy(screen.For_name,"Format 1") ;
		fomwr((char *)&screen) ;
		chkerror() ;
	} else {
		Read_curform() ;
		cpfrm_to_screen() ;
	}
	return(NOERROR) ;
}
		
	
#define NAMEFOUND	1	/* Duplicated name is found */
#define NAMENOTFOUND	0	/* cur. name is unique	 */

/* Read field info. under all the structures defined for the current report */
/* and create a list. Duplicated fields will be ignored by comparing the    */
/* name.								    */


Cr_fldlist()
{
	int frstfld = 1 ; /* flag to distinguish first and further flds */
	int i, j ;
	struct fld_list *curlstfld = NULL; /* current list field ptr. */
	FLDINFO	*curstrfld = NULL;	/* currently ref. field in the structure */
	Fld_lsptr = NULL ;

	for(i = 0; i < Rep_struct.numstruct ; i++) {

		if(lseek(fds,(long)(Rep_struct.defstruct[i].strnum * STRBUFSIZE),0) < 0)
			fprintf(stderr,"Struc. file lseek error; strnum : %d\n",Rep_struct.defstruct[i].strnum),
			fprintf(stderr,"Module : form, Func : Cr_fldlist\n"),
			abexit(SEEKERR) ;
		
		if(read(fds,strucbuf,STRBUFSIZE) < STRBUFSIZE)
			fprintf(stderr,"Struc. file read error; strnum : %d\n",Rep_struct.defstruct[i].strnum),
			fprintf(stderr,"Module : form, Func : Cr_fldlist\n"),
			abexit(READERR) ;

		
		for(j = 0, curstrfld = strfld; j < strhead->stflds ;
							j++,curstrfld++) {
			if(compnames(curstrfld->fldname) == NAMEFOUND)
				continue ;
			
			if(frstfld) {
				frstfld = 0 ;
				curlstfld = Fld_lsptr = (struct fld_list *)
					(malloc(sizeof(struct fld_list))) ;
				if(Fld_lsptr == NULL)
					fprintf(stderr,
						"Memory allocation error\n") ,
					fprintf(stderr,
						"Func: Cr_fldlist\n"),
					abexit(MEMERR) ;
			}
			else {
				curlstfld->nxtfld = (struct fld_list *)
					(malloc(sizeof(struct fld_list))) ;
				curlstfld = curlstfld->nxtfld ;
			}

			/* now update the list fields */

			strcpy(curlstfld->Fldname,curstrfld->fldname) ;
			curlstfld->Fldno = j ;
			curlstfld->Recno = i ;

			curlstfld->Fld_typ = curstrfld->typf ;
			curlstfld->Fld_size = curstrfld->lenf;

#ifdef DEBUG
			fprintf(stderr,"Name :%20.20s, Fno :%d,Rno:%d\n",curstrfld->fldname, curlstfld->Fldno, curlstfld->Recno) ;
#endif
			curlstfld->nxtfld = NULL ;

		}
	}
	return(NOERROR) ;
}




/** See if the given name is already available in the list */
			
compnames(fldname) 
char *fldname ;

{
	struct fld_list *tmpptr = Fld_lsptr ;
	for(; tmpptr != NULL ; tmpptr = tmpptr->nxtfld)
		if(strcmp(tmpptr->Fldname,fldname) == 0)
			return(NAMEFOUND) ;
	return(NAMENOTFOUND) ;
}





/* move report name on to the screen and display */

Disp_repname() 
{
	screen.Rep_no = cur_repno + 1 ;
	strcpy(screen.Rep_name,Rep_struct.rep_name) ;
	Suppress_fields() ; 
	if(Rep_struct.formrecs == 0) {	/* this is a new format  */
		screen.For_no = 1 ;
		strcpy(screen.For_name,"Format 1") ;
		sr.nextfld = START_FIELD ;
		sr.endfld = END_FIELD ;
		fomwr((char *)&screen) ;
		chkerror() ;
	}
	else {
		cur_formno = 1 ;
		Read_curform() ;
		cpfrm_to_screen() ;
	}

	return(NOERROR) ;
}




/* Clear the duplication buffer contents */

Clear_dup()
{
	int i ;

	screen.Pg_columns = LV_SHORT ;
	screen.Pg_lines = LV_SHORT ;
	screen.Pg_linspace = LV_SHORT ;

	for(i = 0; i < 3; i++)
		screen.Main_head[i][0] = LV_CHAR ;

	for(i = 0; i < 30 ; i++)
		screen.Rep_field[i][0] = LV_CHAR ;

	screen.Sel_funct[0] = LV_CHAR ;
	screen.Cur_field[0] = LV_CHAR ;
	screen.Cur_type[0] = LV_CHAR ;
	screen.Cur_class[0] = LV_CHAR ;
	screen.Cur_title[0] = LV_CHAR ;
	screen.Cur_width = LV_SHORT ;
	screen.Comp_eqa[0] = LV_CHAR ;
	screen.Repeatsuppress = LV_INT   ;	
	screen.Cur_totflag = LV_INT   ;
	screen.Edit_mask[0] = LV_CHAR ;
	screen.Justify[0] = LV_CHAR ;
	screen.Minbound[0] = LV_CHAR ;
	screen.Maxbound[0] = LV_CHAR ;
	screen.Pb_supfld[0] = LV_CHAR ;
	screen.Sub_supfld[0] = LV_CHAR ;

	for(i = 0; i < 2; i++) {
		screen.Pb_no[i] = LV_SHORT ;
		screen.Pb_totflds[i][0] = LV_CHAR ;
		screen.Pb_text[i][0] = LV_CHAR ;
		screen.Pbedit_mask[i][0] = LV_CHAR ;
	}

	for(i = 0; i < 3; i++) {
		screen.Sub_no[i] = LV_SHORT ;
		screen.Sub_totflds[i][0] = LV_CHAR ;
		screen.Msg_text[i][0] = LV_CHAR ;
		screen.Keyedit_mask[i][0] = LV_CHAR ;
	}

	screen.Prompt[0] = HV_CHAR ;
	
	sr.nextfld = START_FIELD ;
	sr.endfld = END_FIELD ;
	fomwr((char *)&screen) ;
	chkerror() ;
	return(NOERROR) ;
}


/* Suppress all the fields except, format name field */

Suppress_fields() 
{
	int i ;
	
	screen.Pg_columns = HV_SHORT ;
	screen.Pg_lines = HV_SHORT ;
	screen.Pg_linspace = HV_SHORT ;

	for(i = 0; i < 3; i++)
		screen.Main_head[i][0] = HV_CHAR ;

	for(i = 0; i < 30 ; i++)
		screen.Rep_field[i][0] = HV_CHAR ;

	for(i = 0 ; i < 30 ; i++)
		fomca1(REP_START + i * 100,9,5) ;

	screen.Sel_funct[0] = HV_CHAR ;
	screen.Cur_field[0] = HV_CHAR ;
	screen.Cur_type[0] = HV_CHAR ;
	screen.Cur_class[0] = HV_CHAR ;
	screen.Cur_title[0] = HV_CHAR ;
	screen.Cur_width = HV_SHORT ;
	screen.Comp_eqa[0] = HV_CHAR ;
	screen.Repeatsuppress = HV_INT   ;
	screen.Cur_totflag = HV_INT   ;
	screen.Edit_mask[0] = HV_CHAR ;
	screen.Justify[0] = HV_CHAR ;
	screen.Minbound[0] = HV_CHAR ;
	screen.Maxbound[0] = HV_CHAR ;

	screen.Pb_supfld[0] = HV_CHAR ;
	screen.Sub_supfld[0] = HV_CHAR ;

	for(i = 0; i < 2; i++) {
		screen.Pb_no[i] = HV_SHORT ;
		screen.Pb_totflds[i][0] = HV_CHAR ;
		screen.Pb_text[i][0] = HV_CHAR ;
		screen.Pbedit_mask[i][0] = HV_CHAR ;	
	}

	for(i = 0; i < 3; i++) {
		screen.Sub_no[i] = HV_SHORT ;
		screen.Sub_totflds[i][0] = HV_CHAR ;
		screen.Msg_text[i][0] = HV_CHAR ;
		screen.Keyedit_mask[i][0] = HV_CHAR ;	
	}
	screen.Prompt[0] = HV_CHAR ;
	screen.Pmt_yes = HV_INT   ;
	sr.nextfld = START_FIELD ;
	sr.endfld = END_FIELD ;
	fomwr((char *)&screen) ;
	chkerror() ;
	return(NOERROR) ;
}



/** Assume that format record has already been read and available in the */
/* buffer. Copy format details on to the screen and display. Build up    */
/* Rep_fields array and update the count				 */

cpfrm_to_screen()
{
	int	i, j;
	struct	f_attri *curfld ;

	screen.For_no = cur_formno ;
	strcpy(screen.For_name,fldglob->formname) ;

#ifdef DEBUF	
	for(i = 0; i < fldglob->mhdnos ; i++) {
		fprintf(stderr,"mhdoff : %d\n",fldglob->mhdoff[i]) ;
		fprintf(stderr,"head %d : %s\n",i,VARADDR+fldglob->mhdoff[i]);
	}
#endif
	
	screen.Pg_columns = fldglob->page_columns ;
	screen.Pg_lines = fldglob->page_lines ;
	screen.Pg_linspace = fldglob->linespace ;

	for(i = 0; i < fldglob->mhdnos ; i++)	
		strcpy(screen.Main_head[i],VARADDR + fldglob->mhdoff[i]) ;

	for(; i < 3 ; i++)
		screen.Main_head[i][0] = LV_CHAR ;
	
	screen.Pb_supfld[0] = ' ' ;
	screen.Sub_supfld[0] = ' ' ;

	for(j = 0; j < fldglob->tot_pghdr ; j++) {
		screen.Pb_no[j] = fldglob->subserno[j] ;
		strcpy(screen.Pb_totflds[j],VARADDR + fldglob->keyoff[j]) ;
		strcpy(screen.Pb_text[j],VARADDR + fldglob->msg_textoff[j]) ;
		strcpy(screen.Pbedit_mask[j],VARADDR+fldglob->keyeditoff[j]) ;	

		pbtotflds[j].inrecno = fldglob->keyno[j].inrecno ;
		pbtotflds[j].infieldno = fldglob->keyno[j].infieldno ;
	}

	for(i = 0; i < fldglob->tot_keys ; i++) {
		screen.Sub_no[i] = fldglob->subserno[i+j] ;
		strcpy(screen.Sub_totflds[i],VARADDR + fldglob->keyoff[i+j]) ;
		strcpy(screen.Msg_text[i],VARADDR + fldglob->msg_textoff[i+j]) ;
		strcpy(screen.Keyedit_mask[i],VARADDR+fldglob->keyeditoff[i+j]);

		subtotflds[i].inrecno = fldglob->keyno[i+j].inrecno ;
		subtotflds[i].infieldno = fldglob->keyno[i+j].infieldno ;
	}

	for(; j < 2 ; j++) {
		screen.Pb_no[j] = LV_SHORT ;
		screen.Pb_totflds[j][0] = LV_CHAR ;
		screen.Pb_text[j][0] = LV_CHAR ;
		screen.Pbedit_mask[j][0] = LV_CHAR ;	

		pbtotflds[j].inrecno = 0 ;
		pbtotflds[j].infieldno = 0;
	}

	for(; i < 3 ; i++) {
		screen.Sub_no[i] = LV_SHORT ;
		screen.Sub_totflds[i][0] = LV_CHAR ;
		screen.Msg_text[i][0] = LV_CHAR ;
		screen.Keyedit_mask[i][0] = LV_CHAR ;	

		subtotflds[i].inrecno = 0 ;
		subtotflds[i].infieldno = 0;
	}

	screen.Sel_funct[0] = ' ' ;
	for(i = 0,curfld = fldattri ; i < fldglob->tot_flds ; i++,curfld++) {

		if(i == 0) {	/* Copy the first field on to the screen */
			strcpy(screen.Cur_field,VARADDR + curfld->fname_off) ;
			if(curfld->fld_type == CHAR_FLD)
				strcpy(screen.Cur_type,"CHAR") ;
			else
				strcpy(screen.Cur_type,"NUME") ;

			if(curfld->fld_class == INP_FLD) {
				screen.Comp_eqa[0] = HV_CHAR ;
				strcpy(screen.Cur_class,"INPUT") ;
			}
			else {
				strcpy(screen.Cur_class,"COMP") ;
				strcpy(screen.Comp_eqa,
					VARADDR+curfld->in_takeno.comp_off[0]);
				strcpy(screen.Cur_field,"COMPUTE FIELD") ;
			}
			if(screen.Cur_type[0] == CHAR_FLD) 
				screen.Cur_totflag = HV_INT   ;
			else
				screen.Cur_totflag = curfld->fld_totflag ;

			screen.Cur_width = curfld->fld_size ;
			strcpy(screen.Edit_mask,VARADDR + curfld->edit_off) ;
			strcpy(screen.Cur_title,VARADDR + curfld->title_off) ;
			screen.Justify[0] = curfld->fld_justify ;
			screen.Repeatsuppress = curfld->repeatsuppress ;
			strcpy(screen.Minbound,VARADDR + curfld->minoff) ;
			strcpy(screen.Maxbound,VARADDR + curfld->maxoff) ;
		}

		Sl_fldlst[i].Sl_fldserno = curfld->fld_serno ;
		strcpy(Sl_fldlst[i].Sl_fldname,VARADDR + curfld->fname_off) ;
		Sl_fldlst[i].Sl_type = curfld->fld_type ;	
		Sl_fldlst[i].Sl_class = curfld->fld_class ;
		Sl_fldlst[i].Sl_totflag = curfld->fld_totflag ;	
		Sl_fldlst[i].Sl_repeatsuppress = curfld->repeatsuppress ;	
		
		strcpy(Sl_fldlst[i].Sl_title,VARADDR + curfld->title_off) ;
		Sl_fldlst[i].Sl_justify = curfld->fld_justify ;
		Sl_fldlst[i].Sl_size = curfld->fld_size ;
		strcpy(Sl_fldlst[i].Sl_edit_mask,VARADDR + curfld->edit_off) ;
		strcpy(Sl_fldlst[i].Sl_minbound,VARADDR + curfld->minoff) ;
		strcpy(Sl_fldlst[i].Sl_maxbound,VARADDR + curfld->maxoff) ;

		if(curfld->fld_class == COMP_FLD) {
			strcpy(screen.Rep_field[i],COMP_CODE) ;
			strcpy(Sl_fldlst[i].Sl_compeqa,
				VARADDR + curfld->in_takeno.comp_off[0]) ;
			strcpy(Sl_fldlst[i].Sl_polcomp,
				VARADDR + curfld->in_takeno.comp_off[1]) ;
#ifdef DEBUG
			fprintf(stderr,"BUFFER TO SCREEN\n") ;
			fprintf(stderr,"COMP : %s , Pol : %s\n",
				Sl_fldlst[i].Sl_compeqa,
				Sl_fldlst[i].Sl_polcomp) ;
#endif 
		}
		else {
			Sl_fldlst[i].Sl_compeqa[0] = '\0' ;
			Sl_fldlst[i].Sl_fldno.inrecno =
					curfld->in_takeno.fieldref.inrecno ;
			Sl_fldlst[i].Sl_fldno.infieldno =
					curfld->in_takeno.fieldref.infieldno ;
			itoa(curfld->fld_serno,screen.Rep_field[i]) ;	
		}
	}

	norepflds = fldglob->tot_flds;
	for(i = norepflds ; i < MAX_REPFLD ; i++) /* suppress unused fid */
		screen.Rep_field[i][0] = LV_CHAR ;

	sr.nextfld = FOR_NO ;	/* update the screen */
	sr.endfld = KEYMASK_END ;
	fomwr((char *)&screen) ;
	chkerror() ;
	for(i = 1; i < MAX_REPFLD ; i++)
		fomca1(REP_START + i * 100,9,5) ;
	fomca1(REP_START,9,3) ;
	return(NOERROR) ;
}


/* format specifications form the screen to record buffer */

cpscreen_to_frm()
{
	int	i, j;
	short	offset = 0;   /* Cur. variable length string address positon */
	struct	f_attri *curfld ;
	
	strcpy(fldglob->formname,screen.For_name) ;

	fldglob->tot_flds = norepflds ;

	for(i = 0; i < 3; i++) 
		if(strlen(screen.Main_head[i]) &&
				screen.Main_head[i][0] != LV_CHAR &&
				screen.Main_head[i][0] != HV_CHAR) {
			fldglob->mhdoff[i] = offset ;
			strcpy(VARADDR + offset,screen.Main_head[i]) ;
			offset += strlen(screen.Main_head[i]) + 1 ;
		}
		else
			break ;

	fldglob->mhdnos = i  ;
#ifdef DEBUG
	for(i = 0; i < fldglob->mhdnos ; i++) {
		fprintf(stderr,"%d, Screen : %s, Frm :%s\n",i + 1,screen.Main_head[i],
			VARADDR + fldglob->mhdoff[i]) ;
		fprintf(stderr,"mhdoff : %d\n",fldglob->mhdoff[i]) ;
	}
#endif
	fldglob->page_columns = screen.Pg_columns ;
	fldglob->page_lines = screen.Pg_lines ;	
	fldglob->linespace = screen.Pg_linspace ;

	/* Copy Page Break fields */
	for(i = 0; i < 2 && (screen.Pb_no[i] > 0) &&
				screen.Pb_no[i] != HV_SHORT; i++) {
		fldglob->keyoff[i] = offset ;
		strcpy(VARADDR + fldglob->keyoff[i],screen.Pb_totflds[i]) ;
		offset += strlen(screen.Pb_totflds[i]) + 1 ;

		fldglob->keyno[i].inrecno = pbtotflds[i].inrecno ;
		fldglob->keyno[i].infieldno = pbtotflds[i].infieldno ;

		fldglob->subserno[i] = screen.Pb_no[i] ;
		fldglob->msg_textoff[i] = offset ;
		strcpy(VARADDR + fldglob->msg_textoff[i],screen.Pb_text[i]) ;
		offset += strlen(screen.Pb_text[i]) + 1 ;
		
		fldglob->keyeditoff[i] = offset ;
		strcpy(VARADDR + fldglob->keyeditoff[i],screen.Pbedit_mask[i]) ;
		offset += strlen(screen.Pbedit_mask[i]) + 1;
	}

	fldglob->tot_pghdr = i ;

	/* Copy Sub-total fields */
	for(j = 0; j < 3 && (screen.Sub_no[j] > 0) &&
				screen.Sub_no[j] != HV_SHORT; j++) {
		fldglob->keyoff[i+j] = offset ;
		strcpy(VARADDR + fldglob->keyoff[i+j],screen.Sub_totflds[j]) ;
		offset += strlen(screen.Sub_totflds[j]) + 1 ;

		fldglob->keyno[i+j].inrecno = subtotflds[j].inrecno ;
		fldglob->keyno[i+j].infieldno = subtotflds[j].infieldno ;

#ifdef DEBUG
		fprintf(stderr,"SUBTOT : recno : %d fldno : %d\n",subtotflds[j].inrecno,subtotflds[j].infieldno) ;
#endif
		fldglob->subserno[i+j] = screen.Sub_no[j] ;
		fldglob->msg_textoff[i+j] = offset ;
		strcpy(VARADDR + fldglob->msg_textoff[i+j],screen.Msg_text[j]) ;
		offset += strlen(screen.Msg_text[j]) + 1 ;
		
		fldglob->keyeditoff[i+j] = offset ;
		strcpy(VARADDR+fldglob->keyeditoff[i+j],screen.Keyedit_mask[j]);
		offset += strlen(screen.Keyedit_mask[j]) + 1;
	}

	fldglob->tot_keys = j ;	

	for(i = 0,curfld = fldattri ; i < fldglob->tot_flds ; i++,curfld++) {

		curfld->fld_serno = Sl_fldlst[i].Sl_fldserno ;

		curfld->fname_off = offset ;
		strcpy(VARADDR + curfld->fname_off,Sl_fldlst[i].Sl_fldname) ;
		offset += strlen(Sl_fldlst[i].Sl_fldname) + 1 ;

		curfld->fld_type = Sl_fldlst[i].Sl_type ;	
		curfld->fld_class = Sl_fldlst[i].Sl_class ;	
		curfld->fld_totflag = Sl_fldlst[i].Sl_totflag ;
		curfld->fld_size = Sl_fldlst[i].Sl_size ;
		curfld->fld_justify = Sl_fldlst[i].Sl_justify ;
		curfld->repeatsuppress = Sl_fldlst[i].Sl_repeatsuppress ;	
		curfld->edit_off = offset ;
		strcpy(VARADDR + curfld->edit_off,Sl_fldlst[i].Sl_edit_mask) ;
		offset += strlen(Sl_fldlst[i].Sl_edit_mask) + 1 ;

		curfld->minoff = offset ;
		strcpy(VARADDR +curfld->minoff,Sl_fldlst[i].Sl_minbound) ;
		offset += strlen(Sl_fldlst[i].Sl_minbound) + 1;
	
		curfld->maxoff = offset ;
		strcpy(VARADDR +curfld->maxoff,Sl_fldlst[i].Sl_maxbound) ;
		offset += strlen(Sl_fldlst[i].Sl_maxbound) + 1 ;

		if(curfld->fld_class == COMP_FLD) {
			curfld->in_takeno.comp_off[0] = offset ;
			strcpy(VARADDR + curfld->in_takeno.comp_off[0], Sl_fldlst[i].Sl_compeqa) ;
			offset += strlen(Sl_fldlst[i].Sl_compeqa) + 1;
			curfld->in_takeno.comp_off[1] = offset ;
			strcpy(VARADDR + curfld->in_takeno.comp_off[1],Sl_fldlst[i].Sl_polcomp) ;
			offset += strlen(Sl_fldlst[i].Sl_polcomp) + 1 ;
#ifdef DEBUG
			fprintf(stderr,"SCREEN TO BUFFER\n") ;
			fprintf(stderr,"COMP : %s , Pol : %s\n",Sl_fldlst[i].Sl_compeqa,Sl_fldlst[i].Sl_polcomp) ;
#endif
		}
		else {
			curfld->in_takeno.fieldref.inrecno = Sl_fldlst[i].Sl_fldno.inrecno ;
			curfld->in_takeno.fieldref.infieldno = Sl_fldlst[i].Sl_fldno.infieldno ;
		}

		curfld->title_off = offset ;
		strcpy(VARADDR + curfld->title_off,Sl_fldlst[i].Sl_title) ;
		offset += strlen(Sl_fldlst[i].Sl_title) + 1 ;

		

	}
	return(NOERROR) ;
}


/* Invariably in all the fields <ESC E> to exit from the current edit  */
/* is allowed.							 */

Proc_screen()
{
	for(;  ;) {
		CHKEXIT(Rd_frmname()) ;	/* Confirmation for exit should
						be done in these routines */
		CHKEXIT(Rd_pagesize()) ;
		CHKEXIT(Rd_linespace()) ;
		CHKEXIT(Rd_headname()) ;
		CHKEXIT(Rd_repflds()) ;
		CHKEXIT(Rd_flddetl()) ;
		CHKEXIT(Rd_pagetotflds()) ;
		CHKEXIT(Rd_subtotflds()) ;

		cpscreen_to_frm() ;
		Write_curform() ;

		/* Check the page width */
		if(CheckWidth() == ERROR) continue ;

		if(Exit_prompt() == EXIT) 
			return(EXIT) ;

	}
}


/* Read/Select format name after displaying the window  */

Rd_frmname()
{
	if(Rep_struct.formrecs == 0) {	/* this is a new format  */
		sr.nextfld = FOR_NO ;
		sr.endfld = FOR_NAME ;
		screen.For_no = 1 ;
		strcpy(screen.For_name,"Format 1") ;
		fomwr((char *)&screen) ;
		chkerror() ;
		Clear_dup() ;
	}
	else 		/* by default display the first format */
		if(cur_formno == 0) { 
			cur_formno = 1 ;
			Read_curform() ;
			cpfrm_to_screen() ;
		}
	
	for( ; ; ) {
		sr.nextfld = FOR_NAME ;
		fomrf((char *)&screen) ;
		retcode = chkerror() ;
		if(sr.retcode == RET_USER_ESC)
		switch(retcode) {
			case EXIT :
				fomen("Exit Pressed ! Update is not done ...") ;
				return(EXIT) ;

			case HELP : 
				Disp_frmwindow() ;
				continue ;

			case DELETE :	/* Delete the current format */
				Del_curform() ;
				continue ;

			case PREV :
				fomen("Field backword not allowed") ;
				continue ;

			default :
				continue ;
		}

		if(strlen(screen.For_name) == 0) {
			fomen("Type Format Name / Esc-E(xit)/H(elp)/D(elete)") ;
			continue ;
		}

		return(CONTINUE) ;
	}
}



/* Format name window boundary */

#define FM_ROW	4
#define FM_COLUMN 42
#define FM_WIDTH 30
#define FM_LINES 12
#define FM_EFFLINES	(FM_LINES - 3)



					
/** display the format names in a window, if user selects any format  */
/* then display that format record if NEW format is selected, create  */
/* default format name						   */
			
Disp_frmwindow()	
{
	int	i ,
		chardisp;	/* #of characters displayed on the window */
	char	*text;
	char	retchar ;

	if(Rep_struct.formrecs < 1) {
		fomen("No Format name is available") ;
		return(NOERROR) ;
	}

	chardisp = 0 ;
	if((text = malloc(FM_WIDTH * FM_LINES)) == NULL) 
		fprintf(stderr,"Memory allocation error\n"), abexit(-20) ;

	/* Include the title string */
	sprintf(text,"%-29.29s\n","Sr#   Format Name") ;
	chardisp += 30 ;

	for(i = 1; i <= Rep_struct.formrecs; i++,chardisp += FM_WIDTH) 
		sprintf(text+FM_WIDTH * i,"%2d.%-26.26s\n",
			i, Form_name[i - 1]) ;
				
	sprintf(text + FM_WIDTH * i,"%-29.29s\n","Type # / N(ew) Format") ;
	chardisp += 30 ;
	padnull(text,chardisp) ;	/* remove in between nulls and append */
					/* null at the end */	
	window(FM_ROW,FM_COLUMN,FM_WIDTH + 5, FM_LINES, text,1) ;

	for(; ;) {
		retchar = get() ;

		switch(retchar) {
		case 'N' :	/** new format to be defined */
		case 'n' :
		    /* check if Max. limit attained */
		    if(Rep_struct.formrecs == MAXFORMAT) {
			fomen("Only 9 formats can be defined under a report") ;
			continue ;
		    }
		    fomer("This a new format") ;
		    redraw() ;
		    Clear_dup() ;
		    for(i = 0; i < MAX_REPFLD; i++)
			Putnull((char*)&Sl_fldlst[i],
				sizeof(struct rep_fld_list)) ;

		    screen.For_no = Rep_struct.formrecs + 1 ;
		    sprintf(screen.For_name,"Format %d",
				Rep_struct.formrecs + 1) ;
		    sr.nextfld = FOR_NO ;
		    sr.endfld = END_FIELD ;
		    fomwr((char *)&screen) ;
		    chkerror() ;

		    cur_formno = 0 ;
		    return(NOERROR) ;
		default : 
		    if(retchar - '0' < 1 || retchar - '0' > i - 1) {
			fomer("Wrong selection !! Try again..") ;
			continue ;
		    }
		    redraw() ;
		    if(cur_formno == retchar - '0') {
			fomen("This format is already displayed") ;
			return(NOERROR) ;
		    }
		    /* read and display the new format */
		    cur_formno = retchar - '0' ;
		    Read_curform() ;
		    cpfrm_to_screen() ;
		    return(NOERROR) ;
		}
	}
}	


/* Read header lines for the report */

Rd_headname()
{
	int i;

	for(sr.nextfld = MAIN_START, i = 0 ; sr.nextfld <= MAIN_END ;
						sr.nextfld += 100, i++) {
		fomrf((char *)&screen) ;
		retcode = chkerror() ;
		if(sr.retcode == RET_USER_ESC)
		switch(retcode) {
		case EXIT :
			fomen("Exit Pressed ! Update is not done ...") ;
			return(EXIT) ;
			
		case HELP :
			fomen("Type Header line in the report") ;
			sr.nextfld -= 100 ; i-- ;
			continue ;

		case PREV : 
			if(sr.nextfld > MAIN_START) {
				sr.nextfld -= 100 ; i-- ;
				sr.endfld = sr.nextfld ;
				fomud((char *)&screen) ;
				chkerror() ;
				continue ;
			}
			fomen("Field Backword not allowed") ;
			sr.nextfld -= 100 ; i-- ;
			continue  ;

		default :
			sr.nextfld -= 100 ; i-- ;
			continue  ;

		}
	
		if(sr.fillcode == FIL_OMITTED || strlen(screen.Main_head[i]) == 0)
			break ;
		if(sr.fillcode == FIL_DUP)
			continue ;
		sr.endfld = sr.nextfld ;
		fomud((char *)&screen) ;
		sr.nextfld -= 100 ; i-- ;
	}

	for(; sr.nextfld <= MAIN_END; sr.nextfld += 100,i++) {
		screen.Main_head[i][0] = LV_CHAR ;
		fomwf((char *)&screen) ;
		chkerror() ;
		screen.Main_head[i][0] = HV_CHAR ;
		fomwf((char *)&screen) ;
		chkerror() ;
	}

	return(NOERROR) ;
}


/** define return value to be put in - INT_FLD/CHR_FLD */
#define INT_FLD	1	/* integer field */
#define CHR_FLD 2	/* character field */


/* Read page size - # of columns and rows */

Rd_pagesize()
{
	int i ;

	if(cur_formno == 0) {	/* Fresh format defined */
				/* Display default values */
		sr.nextfld = PG_COLUMNS ;
		sr.endfld = PG_LINES ;
		screen.Pg_columns = O_COLUMNS ;
		screen.Pg_lines = O_LINES ;
		fomud((char *)&screen) ;
		chkerror() ;
	}

	for(sr.nextfld = PG_COLUMNS,i = 0; sr.nextfld <= PG_LINES;
					sr.nextfld += 100, i++) {
		fomrf((char *)&screen) ;
		retcode = chkerror() ;
		if(sr.retcode == RET_USER_ESC)
		switch(retcode) {
		case EXIT :
			fomen("Exit Pressed ! Update is not done ...") ;
			return(EXIT) ;
			
		case HELP :
			fomen("Type number of lines in the output-page") ;
			sr.nextfld -= 100 ; i-- ;
			continue ;

		case PREV : 
			if(sr.nextfld > PG_COLUMNS) {
				sr.nextfld -= 100 ; i-- ;
				continue ;
			}
			fomen("Field Backword not allowed") ;
			sr.nextfld -= 100 ; i-- ;
			continue  ;

		default :
			sr.nextfld -= 100 ; i-- ;
			continue  ;

		}
	
		switch(i) {
		case 0 :
			if(screen.Pg_columns == 0) {
				sr.nextfld -= 100 ; i-- ;
				continue  ;
			}
		case 1 :
			if(screen.Pg_lines == 0) {
				sr.nextfld -= 100 ; i-- ;
				continue  ;
			}
		}

		if(sr.fillcode == FIL_DUP)
			continue ;
		sr.endfld = sr.nextfld ;
		fomud((char *)&screen) ;
		sr.nextfld -= 100 ; i-- ;
	}

	return(NOERROR) ;
}


/*** Read input for the #of blank lines between two report lines */

Rd_linespace()
{
	sr.nextfld = sr.endfld = LINESPACE ;

	if(cur_formno == 0) {
		screen.Pg_linspace = O_LINESPACE ;
		fomud((char *)&screen) ;
		chkerror() ;
	}

	for(; ;) {
		fomen("No. of blank lines between two report lines") ;	
		fomrf((char *)&screen) ;
		retcode = chkerror() ;
		if(sr.retcode == RET_USER_ESC)
		switch(retcode) {
		case EXIT :
			fomen("Exit Pressed ! Update is not done ...") ;
			return(EXIT) ;
			
		case HELP :
			fomen("No. of blank lines between two report lines") ;
			continue ;

		default :
			continue  ;

		}
	
		if(sr.fillcode == FIL_DUP)
			break ;
	}
	if(screen.Pg_linspace == 0)
		screen.Pg_linspace = 1 ;

	return(NOERROR) ;
}




/* FIELD name window boundary */

#define FD_ROW	4
#define FD_COLUMN 35
#define FD_WIDTH 35
#define FD_LINES 13
#define FD_EFFLINES	(FD_LINES - 4)

static short FLDRnum[FD_EFFLINES] ;

/*
*  display the structure name window and once the selection is made
*  update the screen with the value
*/

/* Create a window and display the first 10 elements */


Show_fldnames(type)	
int type ;
{
	int	i, j, done,
		tempint,
		itemnum,	/* current field scanned */
		chardisp ;	/* #of chars. displayed on the window */
	char	*text ;
	char	retchar ;	/* user typed str. number put here */
	struct	fld_list *strtemp ;

	if((text = malloc(FD_WIDTH * FD_LINES)) == NULL) 
		fprintf(stderr,"Memory allocation error\n"), abexit(-20) ;
	
	strtemp = Fld_lsptr ;
	itemnum = 0 ;

	/* display the header line */
	sprintf(text,"    %-4.4s%-20.20s %-5.5s\n", "NO.","FIELD NAME","TYPE") ;

	for(; ;) {
		chardisp = FD_WIDTH ;

		for(i = 1; (i <= FD_EFFLINES) &&  (strtemp != NULL) ;
			i++, strtemp = strtemp->nxtfld, chardisp += FD_WIDTH) {

			FLDRnum[i - 1] = ++itemnum ;
			/*
			fprintf(stderr,"Serno: %d  Fldname: %s  FLDRnum: %d\n",
				itemnum,strtemp->Fldname,FLDRnum[i - 1]) ;
		 */

			sprintf(text + i*FD_WIDTH,"%1d. %3d. %-20.20s  %4.4s\n",
				i, itemnum, strtemp->Fldname,
				(strtemp->Fld_typ == CHAR) ? "CHAR":"NUME") ;
		}
			
		if(i >= FD_EFFLINES)
			sprintf(text + i * FD_WIDTH,"%-34.34s\n",
				"Type #(Item)/N(ext)/S(kip)") ;
		else
			sprintf(text + i * FD_WIDTH,"%-34.34s\n",
				"Type #(Item)/S(kip)") ;

		chardisp += FD_WIDTH ;

		if(i == 1) {
			fomen("No more field names available") ;
			free(text) ;
			return(NOERROR) ;
		}
		else i-- ;

		padnull(text,chardisp) ; /* remove inbetween nulls and put  */
					/* null at the end */

		window(FD_ROW, FD_COLUMN, FD_WIDTH + 5, FD_LINES,text,1) ;
		done = 0 ;

		while(!done) {
			retchar = get() ;
			/** fprintf(stderr,"retchar : %s\n",retchar ) ; */

			switch(retchar) {
			case 'N' :
			case 'n' :
				done = 1 ;
				continue ;	/* show the next page */

			case 's' :	/* skip the selection */
			case 'S' :
				fomen("Type <Cntl R> to refresh the screen") ;
				return(NOTSELECTED) ;

			default :
				if(retchar - '0' < 1 || retchar - '0' > i) {
					fomer("Wrong selection !! Try again..");
					continue ;
				}
				tempint = FLDRnum[(int)(retchar - '0') - 1] ;
#ifdef DEBUG
				for(j = 0; j < FD_EFFLINES ; j++)
					fprintf(stderr,"FLDR: %d\n",FLDRnum[j]);

				fprintf(stderr, "tempint : %d\n",tempint) ;
				fprintf(stderr,"FLDRnum 0: %d i: %d,i = %d\n",
					FLDRnum[0],FLDRnum[i - 1],i) ;
#endif

				if(tempint < FLDRnum[0] ||
						tempint > FLDRnum[i - 1]) {
					fomen("Wrong selection" ) ;
					continue ;
				}
				
				if(type == CHR_FLD) 
					sprintf(ICfield.CHRfieldno,"%d",
						tempint) ;
				else	
					ICfield.INTfieldno = tempint ;
				free(text) ;
				fomen("Type <Cntl R> to refresh the screen") ;
				return(SELECTED) ;
			}
		}
	}

}


/* read report fields one by one , if comp. field will have CM code */

Rd_repflds() 
{
	int	i, j  ;
	int	retvalue ;
	struct fld_list *fldlptr, *Get_fldelement();

	for(sr.nextfld = REP_START, i = 0 ; sr.nextfld <= REP_END ;
						sr.nextfld += 100, i++) {
		fomrf((char *)&screen) ;
		retvalue = chkerror() ;
		if(sr.retcode == RET_USER_ESC)
		switch(retvalue) {
		case EXIT :
			fomen("Exit pressed! Update is not done") ;
			return(EXIT) ;

		case HELP :
			if(Show_fldnames(CHR_FLD) == NOTSELECTED) {
				sr.nextfld -= 100 ; i-- ;
				continue ;
			}

			strcpy(screen.Rep_field[i],ICfield.CHRfieldno) ;
			fomwf((char *)&screen) ;
			chkerror() ;

			/* Display the field names */
			/* User will select appropriate field number */
			/* Validation has to be done onthe field number */
			/* put the selected fieldnum. in ICfield */

			break ;

		case PREV :
			if(sr.nextfld == REP_START) {
				fomer("Field Backword not allowed") ;
				sr.nextfld -= 100, i-- ;
				continue ;
			}
			sr.nextfld -= 200, i -=2 ;
			continue ;

		case DELETE :

			if(strlen(screen.Rep_field[i]) == 0 ) {
				fomer("No element is available to delete") ;
				sr.nextfld -= 100 ; i-- ;
				continue ;
			}
				
			for(j = i; j < norepflds -1 ; j++) {
				 scpy((char *)&Sl_fldlst[j],(char *)&Sl_fldlst[j + 1],sizeof(struct rep_fld_list)) ;
				strcpy(screen.Rep_field[j],screen.Rep_field[j + 1]) ;
			}
			norepflds -= 1 ;
			screen.Rep_field[norepflds][0] = LV_CHAR ;
			sr.endfld = REP_END ;
			fomwr((char *)&screen) ;
			chkerror() ;
			sr.nextfld -= 100, i-- ;
			continue ;

		default :
			sr.nextfld -= 100, i-- ;
			continue ;
			
		}

		if(i == 0 && strlen(screen.Rep_field[i]) == 0 ) {
			fomen("Type field #/CO(mputational field)/Esc-E(xit),H(elp,D(elete)") ;
			sr.nextfld -= 100 ; i-- ;
			continue ;
		}
	
		if(strlen(screen.Rep_field[i]) == 0)
				break ;		/* No field defined */

		if(strcmp(screen.Rep_field[i], COMP_CODE) == 0){

			if(sr.retcode == RET_NO_ERROR && sr.fillcode == FIL_DUP)
					continue ;
				/* this is already available in the list */

			Sl_fldlst[i].Sl_fldserno = 0 ;	/* on 4-oct-89 amar */
			strcpy(Sl_fldlst[i].Sl_fldname,"COMPUTED" ) ;
			Sl_fldlst[i].Sl_title[0] = '\0' ;
			Sl_fldlst[i].Sl_class = COMP_FLD ;
			Sl_fldlst[i].Sl_justify = RIGHTJUST ;
			Sl_fldlst[i].Sl_type = NUME_FLD ;
			strcpy(Sl_fldlst[i].Sl_edit_mask,FLOATEDIT) ;
			Sl_fldlst[i].Sl_size = sizeof(FLOATEDIT) ;
			Sl_fldlst[i].Sl_totflag = BOOL_YES ;
			Sl_fldlst[i].Sl_repeatsuppress = BOOL_NO ;	
			Sl_fldlst[i].Sl_compeqa[0] = '\0' ;
			Sl_fldlst[i].Sl_polcomp[0] = '\0' ;
			Sl_fldlst[i].Sl_maxbound[0] = '\0' ;
			Sl_fldlst[i].Sl_minbound[0] = '\0' ;
			continue ;
		}

		/* check whether it contains alpha - refer <ctype.h> */
		
		if(isalpha(screen.Rep_field[i][0]) ||
				isalpha(screen.Rep_field[i][1]) ||
				isalpha(screen.Rep_field[i][2])) {
			fomer("Type field #/CO(mputational field)/Esc-E(xit),H(elp,D(elete)") ;
			sr.nextfld -= 100 ; i-- ;
			continue ;
		}


		if((fldlptr = Get_fldelement(atoi(screen.Rep_field[i]))) == NULL) {
			sr.nextfld -= 100 ; i-- ;
			fomen("Field Number not selected properly") ;
			continue ;
		}
		else {	/* display the field name and update the global entr*/
				/* fldattri will have this field info. */

			if(retvalue != HELP && sr.fillcode == FIL_DUP)
				continue ; /* already available in the list */

			Sl_fldlst[i].Sl_fldno.infieldno = fldlptr->Fldno ;
			Sl_fldlst[i].Sl_fldno.inrecno = fldlptr->Recno ;
			Sl_fldlst[i].Sl_fldserno = atoi(screen.Rep_field[i]) ;
			strcpy(Sl_fldlst[i].Sl_fldname,fldlptr->Fldname) ;
            		strcpy(Sl_fldlst[i].Sl_title,fldlptr->Fldname) ;
			Maptoupper(Sl_fldlst[i].Sl_title) ;
			Sl_fldlst[i].Sl_class = INP_FLD ;
			if(fldlptr->Fld_typ == CHAR) {
				Sl_fldlst[i].Sl_justify = LEFTJUST ;
				Sl_fldlst[i].Sl_type  = CHAR_FLD ;
			}
			else {
				Sl_fldlst[i].Sl_justify = RIGHTJUST ;
				Sl_fldlst[i].Sl_type  = NUME_FLD ;
			}

			/* Copy default edit Mask for numeric fields */
			if(fldlptr->Fld_typ != CHAR) {
				Dflt_mask(Sl_fldlst[i].Sl_edit_mask,
					fldlptr->Fld_typ) ;
				Sl_fldlst[i].Sl_size =
					strlen(Sl_fldlst[i].Sl_edit_mask) ;
			}
			else {		/* Char type */
				Sl_fldlst[i].Sl_edit_mask[0] = '\0' ;
				Sl_fldlst[i].Sl_size = fldlptr->Fld_size ;
			}

			if(fldlptr->Fld_typ == CHAR)
				Sl_fldlst[i].Sl_totflag = BOOL_NO ;
			else
				Sl_fldlst[i].Sl_totflag = BOOL_YES ;	/* default value */
			Sl_fldlst[i].Sl_repeatsuppress = BOOL_NO ;
			Sl_fldlst[i].Sl_minbound[0] = '\0' ;
			Sl_fldlst[i].Sl_maxbound[0] = '\0' ;

			/* define the default length also */
			fomce() ;	/* Clear Error line */
			sprintf(prom_buf,"Field Name : %-20.20s",fldlptr->Fldname) ;
			fomen(prom_buf) ;
			
		}
		if(retvalue == HELP) {
			sr.nextfld -= 100 ;
			i-- ; 
					  /* after displaying the item */
					  /* read the same */
		}
			
	}
	norepflds = i ;
	return(NOERROR) ;
}


/* Convert lower case to upper case of the given string */
Maptoupper(s)
char *s;
{
	char	*ptr ;

	for(ptr = s; *ptr != '\0' ; ptr++)
		if(*ptr >= 'a' && *ptr <= 'z')
				*ptr = *ptr - ('a' - 'A') ;
	return(NOERROR) ;
}



/* definitions pertaining to Rd_flddetl() only */
#define PREV_FLD	'P'	/* sel_field mapped to upper case */
#define NEXT_FLD	'N'
#define CHANG_FLD	'C'
#define EXIT_FLD	'E'


/* This routine controls the display and editing of Report fields 	*/
/* There are few options provided for the selection of a particular fld	*/
/* PREV_FLD - display the Previous to current field, if any		*/
/* NEXT_FLD / <CR> - display the Next to current field, if any		*/
/* CHANG_FLD - Change the current field attributes			*/
/* EXIT_SEL - Save and exit to the prompt string			*/
/* <ESC> E - (EXIT)Exit without saving the current changes		*/
/* <ESC> H - (HELP)Display the Help text				*/
/* Actual field elements are stored in global Sl_fldlst[] array		*/


static short Cur_dispfld ;	/* currently displayed field */

Rd_flddetl()	
{
#ifdef DEBUG
	fprintf(stderr,"Rd_flddetl : norepflds : %d\n",norepflds) ;
#endif

	if(norepflds <= 0) {
		fomen("There is no report field available") ;
		return(EXIT) ;
	}

	Cur_dispfld = 1 ;
	fomca1(REP_START,9,3) ;	/* High light the first field */
	Disp_fld() ;	/* Copy the pointed entry from Sl_fldlst[] & display */
			/* this should reverse the currently displayed entry */
			/* in Rep_fields array */
	
	for(; ;) {
		sr.nextfld = SEL_FUNCT ;
		fomwr((char *)&screen) ;
		chkerror() ;

		fomrf((char *)&screen) ;
		retcode = chkerror() ;
		if(sr.retcode == RET_USER_ESC)
		switch(retcode) {

		case EXIT : 
			fomen("Exit pressed ! Update is not done") ;
			return(EXIT) ;

		case HELP :
			fomen("Type <CR>,N(ext)/P(rev)/C(hange)/E(xit-write)/Esc-E(xit)/Esc-H(elp)") ;		
			continue ;

		default :
			continue ;

		}
		if(sr.fillcode == FIL_OMITTED || sr.fillcode == FIL_DUP) {
			Select_fld(NEXT_FLD) ;
			continue ;
		}

		switch(screen.Sel_funct[0]) {

		case NEXT_FLD : 
			Select_fld(NEXT_FLD) ;
			continue ;

		case PREV_FLD :
			Select_fld(PREV_FLD) ;
			continue ;

		case CHANG_FLD :
			if(change_fld() == EXIT)
				return(EXIT) ;
			Up_slfld() ;	/* post the data entered on to buff */
			break ;

		case EXIT_FLD :
			return(NOERROR) ;
		}
	}
}

Dflt_mask(dest, typ)
char	*dest ;
char	typ ;
{
	switch(typ) {
	case SHORT : 
		strcpy(dest,SHORTEDIT) ;
		break;
	case INT : 
		strcpy(dest,INTEDIT) ;
		break;
	case LONG : 
		strcpy(dest,LONGEDIT) ;
		break;
	case FLOAT : 
		strcpy(dest,FLOATEDIT) ;
		break;
	case DOUBLE : 
		strcpy(dest,DOUBLEDIT) ;
		break;
	}
}

/* Calculate the Width of the line and check whether it is exceeding user
   given width */
CheckWidth()
{
	int	n ;
	int	t_len ;
	int	totsiz ;
	char	mesg[80] ;

	totsiz = 0 ;
	for(n = 0 ; n < norepflds ; n++) {
		t_len = maxltitle(Sl_fldlst[n].Sl_title);
		totsiz += (t_len < Sl_fldlst[n].Sl_size) ?
					Sl_fldlst[n].Sl_size : t_len ;
	}

	totsiz += norepflds - 1 ;	/* One balnk between Columns */
	totsiz++ ;			/* New line Character */

	if (totsiz > screen.Pg_columns) {
		sprintf(mesg,"Cur Width: %d  exceeds the Max. #of columns allowed", totsiz) ;
		fomen(mesg) ;
		get() ;
		return(ERROR) ;
	}

	return(NOERROR) ;
}

static int
maxltitle(str)
char *str ;
{
	short	ml= 0, n= 0 ;

	for(; *str!='\0'; str++) {
		if (*str== '\\') {
			if (n > ml) ml= n ;
			n= 0 ;
		}
		else n++ ;
	}
	if (n > ml) ml = n ;
	return(ml) ;
}

#include "form2.c"


